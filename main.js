(function() {
	function r(e, n, t) {
		function o(i, f) {
			if (!n[i]) {
				if (!e[i]) {
					var c = "function" == typeof require && require;
					if (!f && c) return c(i, !0);
					if (u) return u(i, !0);
					var a = new Error("Cannot find module '" + i + "'");
					throw a.code = "MODULE_NOT_FOUND", a
				}
				var p = n[i] = {
					exports: {}
				};
				e[i][0].call(p.exports, function(r) {
					var n = e[i][1][r];
					return o(n || r)
				}, p, p.exports, r, e, n, t)
			}
			return n[i].exports
		}
		for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
		return o
	}
	return r
})()({
	1: [function(require, module, exports) {
		module.exports = {
			"images": [],
			"atlases": [],
			"bitmapFonts": [{
				"key": "7segclock",
				"textureURL": "assets/bitmapfonts/7segclock.png",
				"fontDataURL": "assets/bitmapfonts/7segclock.fnt"
			}, {
				"key": "dp",
				"textureURL": "assets/bitmapfonts/dp.png",
				"fontDataURL": "assets/bitmapfonts/dp.fnt"
			}]
		}

	}, {}],
	2: [function(require, module, exports) {
		"use strict";
		const {
			SvelteComponent: SvelteComponent,
			add_render_callback: add_render_callback,
			add_resize_listener: add_resize_listener,
			append: append,
			attr: attr,
			binding_callbacks: binding_callbacks,
			component_subscribe: component_subscribe,
			create_slot: create_slot,
			detach: detach,
			element: element,
			globals: globals,
			init: init,
			insert: insert,
			is_function: is_function,
			listen: listen,
			run_all: run_all,
			safe_not_equal: safe_not_equal,
			set_data: set_data,
			set_style: set_style,
			space: space,
			stop_propagation: stop_propagation,
			text: text,
			toggle_class: toggle_class,
			transition_in: transition_in,
			transition_out: transition_out,
			update_slot: update_slot
		} = require("svelte/internal"), {
			window: window_1
		} = globals, {
			writable: writable
		} = require("svelte/store"), {
			afterUpdate: afterUpdate,
			onMount: onMount,
			onDestroy: onDestroy
		} = require("svelte");

		function add_css() {
			var e = element("style");
			e.id = "svelte-11zcref-style", e.textContent = ".modal.svelte-11zcref.svelte-11zcref{user-select:none;position:fixed;z-index:9999;top:0;left:0;width:0;height:0}.modal.exclusive.svelte-11zcref.svelte-11zcref{width:100%;height:100%;background:#48426973}.modal-title.svelte-11zcref.svelte-11zcref{background-color:#a80101;margin:0;padding:0;text-align:center;color:white;text-shadow:0 0 1px #0f0f0f, 0 0 3px #1a1a1a;display:flex}.modal-title.svelte-11zcref h2.svelte-11zcref{padding:5px 10px;margin:0;flex:1}.modal-title.svelte-11zcref .close.svelte-11zcref{width:30px;font-size:22px;background:#cf0000;color:white;text-shadow:0 0 1px #0f0f0f, 0 0 3px #1a1a1a;line-height:26px;cursor:pointer;border-left:1px solid #a80101}.modal-content.svelte-11zcref.svelte-11zcref{padding:20px 10px 10px}.modal-inner.svelte-11zcref.svelte-11zcref{width:300px;box-shadow:0 1px 4px #0000006e;border-radius:10px;background:#d7d7d7;overflow:hidden;transition:box-shadow 0.07s}.modal-inner.held.svelte-11zcref.svelte-11zcref{box-shadow:0 2px 8px #00000096}.modal-inner.held.svelte-11zcref .modal-title h2.svelte-11zcref{background:#cf0000}", append(document.head, e)
		}

		function create_if_block(e) {
			let t, n, s;
			return {
				c() {
					(t = element("div")).textContent = "Ã—", attr(t, "class", "close svelte-11zcref")
				},
				m(l, o) {
					insert(l, t, o), n || (s = listen(t, "click", function() {
						is_function(e[3]) && e[3].apply(this, arguments)
					}), n = !0)
				},
				p(t, n) {
					e = t
				},
				d(e) {
					e && detach(t), n = !1, s()
				}
			}
		}

		function create_fragment(e) {
			let t, n, s, l, o, i, a, c, r, d, p, u;
			add_render_callback(e[17]);
			let f = e[3] && create_if_block(e);
			const _ = e[16].default,
				g = create_slot(_, e, e[15], null);
			return {
				c() {
					t = element("div"), n = element("div"), s = element("div"), l = element("h2"), o = text(e[0]), i = space(), f && f.c(), a = space(), c = element("div"), g && g.c(), attr(l, "class", "svelte-11zcref"), attr(s, "class", "modal-title svelte-11zcref"), attr(c, "class", "modal-content svelte-11zcref"), attr(n, "class", "modal-inner svelte-11zcref"), set_style(n, "left", e[9].x + "px"), set_style(n, "top", e[9].y + "px"), set_style(n, "width", e[2] + "px"), add_render_callback(() => e[18].call(n)), toggle_class(n, "held", e[10].dragging), attr(t, "class", "modal svelte-11zcref"), set_style(t, "z-index", e[11]), toggle_class(t, "exclusive", e[1])
				},
				m(_, h) {
					insert(_, t, h), append(t, n), append(n, s), append(s, l), append(l, o), append(s, i), f && f.m(s, null), append(n, a), append(n, c), g && g.m(c, null), r = add_resize_listener(n, e[18].bind(n)), e[19](t), d = !0, p || (u = [listen(window_1, "resize", e[17]), listen(l, "mousedown", e[13]), listen(l, "touchstart", e[13]), listen(t, "mousedown", stop_propagation(e[12])), listen(t, "touchstart", stop_propagation(e[12]), {
						passive: !0
					})], p = !0)
				},
				p(e, [l]) {
					(!d || 1 & l) && set_data(o, e[0]), e[3] ? f ? f.p(e, l) : ((f = create_if_block(e)).c(), f.m(s, null)) : f && (f.d(1), f = null), g && g.p && 32768 & l && update_slot(g, _, e, e[15], l, null, null), (!d || 512 & l) && set_style(n, "left", e[9].x + "px"), (!d || 512 & l) && set_style(n, "top", e[9].y + "px"), (!d || 4 & l) && set_style(n, "width", e[2] + "px"), 1024 & l && toggle_class(n, "held", e[10].dragging), (!d || 2048 & l) && set_style(t, "z-index", e[11]), 2 & l && toggle_class(t, "exclusive", e[1])
				},
				i(e) {
					d || (transition_in(g, e), d = !0)
				},
				o(e) {
					transition_out(g, e), d = !1
				},
				d(n) {
					n && detach(t), f && f.d(), g && g.d(n), r(), e[19](null), p = !1, run_all(u)
				}
			}
		}
		let modals = writable([]);

		function getPos(e) {}

		function getInfo(e) {}

		function instance(e, t, n) {
			let s;
			component_subscribe(e, modals, e => n(20, s = e));
			let l, o, i, a, c, r, {
					$$slots: d = {},
					$$scope: p
				} = t,
				{
					title: u
				} = t,
				{
					exclusive: f = !1
				} = t,
				{
					width: _ = 500
				} = t,
				{
					openAt: g = {
						x: 0,
						y: 0
					}
				} = t,
				{
					cancel: h = !1
				} = t,
				m = {
					x: 100,
					y: 100
				},
				x = {
					dragging: !1,
					fromX: 0,
					fromY: 0,
					anchorX: 0,
					anchorY: 0
				};

			function v() {
				modals.update(e => {
					const t = e.indexOf(c);
					return -1 !== t && e.splice(t, 1), [...e, c]
				})
			}

			function w() {
				m.x + l > i ? n(9, m.x = i - l, m) : m.x < 0 && n(9, m.x = 0, m), m.y + o > a ? n(9, m.y = a - o, m) : m.y < 0 && n(9, m.y = 0, m)
			}

			function b(e) {
				if (!x.dragging) return;
				const t = e.touches && e.touches.length ? e.touches[0] : e;
				n(9, m.x = x.anchorX + (t.clientX - x.fromX), m), n(9, m.y = x.anchorY + (t.clientY - x.fromY), m), w()
			}

			function z(e) {
				const t = e.touches && e.touches.length;
				x.dragging && (t ? (window.removeEventListener("touchend", z), window.removeEventListener("touchmove", b)) : (window.removeEventListener("mouseup", z), window.removeEventListener("mousemove", b))), n(10, x.dragging = !1, x)
			}
			return onMount(() => {
				n(9, m.x = g.x - l / 2, m), n(9, m.y = g.y - 10, m), modals.update(e => [...e, c]), v()
			}), onDestroy(() => {
				modals.update(e => {
					const t = e.indexOf(c);
					if (-1 !== t) return e.splice(t, 1), [...e]
				})
			}), afterUpdate(() => {
				w()
			}), e.$$set = (e => {
				"title" in e && n(0, u = e.title), "exclusive" in e && n(1, f = e.exclusive), "width" in e && n(2, _ = e.width), "openAt" in e && n(14, g = e.openAt), "cancel" in e && n(3, h = e.cancel), "$$scope" in e && n(15, p = e.$$scope)
			}), e.$$.update = (() => {
				1048832 & e.$$.dirty && n(11, r = s.indexOf(c) + 1e3)
			}), [u, f, _, h, l, o, i, a, c, m, x, r, v, function(e) {
				const t = e.touches && e.touches.length,
					s = t ? e.touches[0] : e;
				x.dragging || (t ? (window.addEventListener("touchend", z), window.addEventListener("touchmove", b)) : (window.addEventListener("mouseup", z), window.addEventListener("mousemove", b))), n(10, x.dragging = !0, x), n(10, x.fromX = s.clientX, x), n(10, x.fromY = s.clientY, x), n(10, x.anchorX = m.x, x), n(10, x.anchorY = m.y, x)
			}, g, p, d, function() {
				n(6, i = window_1.innerWidth), n(7, a = window_1.innerHeight)
			}, function() {
				l = this.clientWidth, o = this.clientHeight, n(4, l), n(5, o)
			}, function(e) {
				binding_callbacks[e ? "unshift" : "push"](() => {
					n(8, c = e)
				})
			}]
		}
		class Modal extends SvelteComponent {
			constructor(e) {
				super(), document.getElementById("svelte-11zcref-style") || add_css(), init(this, e, instance, create_fragment, safe_not_equal, {
					title: 0,
					exclusive: 1,
					width: 2,
					openAt: 14,
					cancel: 3
				})
			}
		}
		module.exports = Modal;

	}, {
		"svelte": 57,
		"svelte/internal": 58,
		"svelte/store": 59
	}],
	3: [function(require, module, exports) {
		"use strict";
		const {
			SvelteComponent: SvelteComponent,
			append: append,
			attr: attr,
			create_component: create_component,
			destroy_component: destroy_component,
			destroy_each: destroy_each,
			detach: detach,
			element: element,
			init: init,
			insert: insert,
			listen: listen,
			mount_component: mount_component,
			run_all: run_all,
			safe_not_equal: safe_not_equal,
			set_data: set_data,
			space: space,
			text: text,
			transition_in: transition_in,
			transition_out: transition_out
		} = require("svelte/internal"), {
			createEventDispatcher: createEventDispatcher
		} = require("svelte");

		function add_css() {
			var e = element("style");
			e.id = "svelte-1yqs1lw-style", e.textContent = "th.svelte-1yqs1lw{width:120px}.switch.svelte-1yqs1lw{font-size:30px;cursor:pointer}", append(document.head, e)
		}

		function get_each_context(e, t, n) {
			const s = e.slice();
			return s[11] = t[n], s
		}

		function create_each_block(e) {
			let t, n, s, l, a, o, c = e[11].name + "";

			function i(...t) {
				return e[9](e[11], ...t)
			}
			return {
				c() {
					t = element("li"), n = element("span"), s = text(c), attr(t, "class", l = "sub-menu-tab" + (e[0] == e[11].value ? "-selected" : ""))
				},
				m(e, l) {
					insert(e, t, l), append(t, n), append(n, s), a || (o = listen(t, "click", i), a = !0)
				},
				p(n, a) {
					e = n, 4 & a && c !== (c = e[11].name + "") && set_data(s, c), 5 & a && l !== (l = "sub-menu-tab" + (e[0] == e[11].value ? "-selected" : "")) && attr(t, "class", l)
				},
				d(e) {
					e && detach(t), a = !1, o()
				}
			}
		}

		function create_default_slot(e) {
			let t, n, s, l, a, o, c, i, r, p, u, d, m, _, h, f, g, x, v, b, y = e[2],
				$ = [];
			for (let t = 0; t < y.length; t += 1) $[t] = create_each_block(get_each_context(e, y, t));
			return {
				c() {
					t = element("table"), n = element("tr"), (s = element("th")).textContent = "Fullscreen Mode", l = space(), a = element("td"), o = element("span"), i = space(), r = element("tr"), (p = element("th")).textContent = "Graphics Quality", u = space(), d = element("td"), m = element("ul");
					for (let e = 0; e < $.length; e += 1) $[e].c();
					_ = space(), h = element("div"), (f = element("button")).textContent = "Cancel", g = space(), (x = element("button")).textContent = "Save", attr(s, "class", "svelte-1yqs1lw"), attr(o, "class", c = "switch " + (e[1] ? "ion-toggle-filled settingOn" : "ion-toggle settingOff") + " svelte-1yqs1lw"), attr(p, "class", "svelte-1yqs1lw"), attr(m, "class", "horizontal-spaced pagination-fix margin-top-20 margin-bottom-20 text-center"), attr(f, "class", "button-black button-small"), attr(x, "class", "button-small button-maroon margin-bottom-10"), attr(h, "class", "modal-footer text-center")
				},
				m(c, y) {
					insert(c, t, y), append(t, n), append(n, s), append(n, l), append(n, a), append(a, o), append(t, i), append(t, r), append(r, p), append(r, u), append(r, d), append(d, m);
					for (let e = 0; e < $.length; e += 1) $[e].m(m, null);
					insert(c, _, y), insert(c, h, y), append(h, f), append(h, g), append(h, x), v || (b = [listen(o, "click", e[8]), listen(f, "click", e[6]), listen(x, "click", e[5])], v = !0)
				},
				p(e, t) {
					if (2 & t && c !== (c = "switch " + (e[1] ? "ion-toggle-filled settingOn" : "ion-toggle settingOff") + " svelte-1yqs1lw") && attr(o, "class", c), 5 & t) {
						let n;
						for (y = e[2], n = 0; n < y.length; n += 1) {
							const s = get_each_context(e, y, n);
							$[n] ? $[n].p(s, t) : ($[n] = create_each_block(s), $[n].c(), $[n].m(m, null))
						}
						for (; n < $.length; n += 1) $[n].d(1);
						$.length = y.length
					}
				},
				d(e) {
					e && detach(t), destroy_each($, e), e && detach(_), e && detach(h), v = !1, run_all(b)
				}
			}
		}

		function create_fragment(e) {
			let t, n;
			return t = new e[4]({
				props: {
					title: "Graphics Options",
					openAt: e[3],
					cancel: e[6],
					width: "300",
					$$slots: {
						default: [create_default_slot]
					},
					$$scope: {
						ctx: e
					}
				}
			}), {
				c() {
					create_component(t.$$.fragment)
				},
				m(e, s) {
					mount_component(t, e, s), n = !0
				},
				p(e, [n]) {
					const s = {};
					8 & n && (s.openAt = e[3]), 16391 & n && (s.$$scope = {
						dirty: n,
						ctx: e
					}), t.$set(s)
				},
				i(e) {
					n || (transition_in(t.$$.fragment, e), n = !0)
				},
				o(e) {
					transition_out(t.$$.fragment, e), n = !1
				},
				d(e) {
					destroy_component(t, e)
				}
			}
		}

		function instance(e, t, n) {
			const s = require("./components/modal.svelte");
			let {
				resolutions: l
			} = t, {
				resolutionMaxDim: a
			} = t, {
				embedFullscreen: o
			} = t, {
				openAt: c
			} = t, {
				exclusive: i
			} = t;
			const r = createEventDispatcher();
			return e.$$set = (e => {
				"resolutions" in e && n(2, l = e.resolutions), "resolutionMaxDim" in e && n(0, a = e.resolutionMaxDim), "embedFullscreen" in e && n(1, o = e.embedFullscreen), "openAt" in e && n(3, c = e.openAt), "exclusive" in e && n(7, i = e.exclusive)
			}), [a, o, l, c, s, function() {
				r("save", {
					resolutionMaxDim: a,
					embedFullscreen: o
				})
			}, function() {
				r("cancel")
			}, i, () => n(1, o = !o), e => {
				n(0, a = e.value)
			}]
		}
		class GraphicsSettings extends SvelteComponent {
			constructor(e) {
				super(), document.getElementById("svelte-1yqs1lw-style") || add_css(), init(this, e, instance, create_fragment, safe_not_equal, {
					resolutions: 2,
					resolutionMaxDim: 0,
					embedFullscreen: 1,
					openAt: 3,
					exclusive: 7
				})
			}
		}
		module.exports = GraphicsSettings;

	}, {
		"./components/modal.svelte": 2,
		"svelte": 57,
		"svelte/internal": 58
	}],
	4: [function(require, module, exports) {
		module.exports = {
			GraphicsSettings: require("./graphics-settings.svelte")
		};

	}, {
		"./graphics-settings.svelte": 3
	}],
	5: [function(require, module, exports) {
		const Color = Phaser.Display.Color,
			Linear = Phaser.Math.Linear;

		function lerpGradeColour(t, s, i) {
			return Linear(t.red, s.red, i) << 16 | Linear(t.green, s.green, i) << 8 | Linear(t.blue, s.blue, i)
		}

		function lerpGradeAlpha(t, s, i) {
			return Linear(t.alpha / 255, s.alpha / 255, i)
		}
		class Atmospherics {
			constructor(t) {
				this.worldMap = t, this.scene = t.scene, this.lights1 = this.scene.make.graphics({
					add: !1
				}), this.lights2 = this.scene.make.graphics({
					add: !1
				}), this.darknessLayers = [{
					depth: 120,
					lights: this.lights1
				}, {
					depth: 121,
					lights: this.lights2
				}, {
					depth: 122,
					lights: null
				}].map(t => (t.rect = this.scene.add.rectangle(0, 0, 800, 800, 16777215).setOrigin(0).setDepth(t.depth), t.lights && (t.rect.mask = new Phaser.Display.Masks.GeometryMask(this.scene, t.lights), t.rect.mask.invertAlpha = !0), t))
			}
			setClock(t) {
				this.cycleDurationMs = t.cycleDurationMs, this.serverSyncTime = t.time, this.timeBase = null, this.transitionDurationMs = this.cycleDurationMs / 24, this.transitionDurationPct = this.transitionDurationMs / this.cycleDurationMs, this.darknessGrades = [{
					colours: ["rgba(0,0,136,0.3)", "rgba(0,0,102,0.2)", "rgba(34,34,34,0.15)"],
					start: 0,
					interpolate: !1
				}, {
					colours: ["rgba(82,82,146,0.15)", "rgba(52,52,124,0.15)", "rgba(34,34,34,0.2)"],
					start: .25 * this.cycleDurationMs - this.transitionDurationMs,
					interpolate: !0
				}, {
					colours: ["rgba(68,58,76,0)", "rgba(92,67,62,0)", "rgba(51,42,17,0)"],
					start: .25 * this.cycleDurationMs + this.transitionDurationMs,
					interpolate: !1
				}, {
					colours: ["rgba(53,34,6,0.15)", "rgba(132,81,0,0.1)", "rgba(67,50,0,0.1)"],
					start: .75 * this.cycleDurationMs - this.transitionDurationMs,
					interpolate: !0
				}, {
					colours: ["rgba(0,0,136,0.3)", "rgba(0,0,102,0.2)", "rgba(34,34,34,0.15)"],
					start: .75 * this.cycleDurationMs + this.transitionDurationMs,
					interpolate: !1
				}].map((t, s, i) => (t.colours = t.colours.map(t => Color.RGBStringToColor(t)), t.prev = s > 0 ? i[s - 1] : i[i.length - 1], t.next = s < i.length - 1 ? i[s + 1] : i[0], t.end = s < i.length - 1 ? t.next.start : this.cycleDurationMs, t.duration = t.end - t.start, t))
			}
			update(t, s, i) {
				null === this.timeBase && (this.timeBase = t), this.currentTime = (t - this.timeBase + this.serverSyncTime) % this.cycleDurationMs;
				let r = this.currentTime % this.cycleDurationMs;
				null != this.worldMap.clockTime && (r = this.worldMap.clockTime * this.cycleDurationMs);
				this.cycleDurationMs;
				let e = this.darknessGrades.find(t => r >= t.start && r < t.end);
				for (let t = 0; t < this.darknessLayers.length; t++) {
					const s = this.darknessLayers[t].rect;
					s.width = i.width, s.height = i.height, s.x = i.left, s.y = i.top;
					let l = e.colours[t].color,
						a = e.colours[t].alpha / 255;
					if (e.interpolate) {
						const s = (r - e.start) / e.duration;
						s < .5 ? (l = lerpGradeColour(e.prev.colours[t], e.colours[t], 2 * s), a = lerpGradeAlpha(e.prev.colours[t], e.colours[t], 2 * s)) : (l = lerpGradeColour(e.colours[t], e.next.colours[t], 2 * (s - .5)), a = lerpGradeAlpha(e.colours[t], e.next.colours[t], 2 * (s - .5)))
					}
					s.setFillStyle(l, a)
				}
				if (this.darknessLayers[0].rect.isFilled) {
					this.lights1.clear(), this.lights2.clear();
					let s = 2.5 * Math.sin(t / (5e3 / Math.PI / 2));
					if (this.worldMap.lights)
						for (const t of this.worldMap.lights) t.p ? (t.l1 && (this.lights1.fillStyle(16777215, 1), this.lights1.fillPoints(t.p, !0)), t.l2 && (this.lights2.fillStyle(16777215, 1), this.lights2.fillPoints(t.p, !0))) : (this.lights1.fillStyle(16777215, 1), this.lights1.fillCircle(t.x, t.y, .85 * t.r + s), this.lights2.fillStyle(16777215, 1), this.lights2.fillCircle(t.x, t.y, 1 * t.r + s))
				}
			}
			destroy() {
				this.darknessLayers.forEach(t => {
					t.rect.destroy()
				}), this.lights1.destroy(), this.lights2.destroy(), this.worldMap = null, this.scene = null
			}
		}
		module.exports = Atmospherics;

	}, {}],
	6: [function(require, module, exports) {
		class BaseEntity {
			constructor(t, e) {
				this.obj = t, this.gameObject = t.gameObject, this.id = t.id, this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this.points = t.points, this.props = t.props, this.symbol = Symbol("ENT:" + this.id), this.map = e, this.scene = e.scene, this.gui = e.scene.guiScene, this.net = this.scene.net
			}
			init() {}
			activate(t) {}
			registerTriggerRect({
				x: t,
				y: e,
				width: i,
				height: s
			}) {
				const h = {
					entity: this
				};
				return this.map.createTrigger({
					x: t,
					y: e,
					width: i,
					height: s,
					data: h
				})
			}
			triggerTest(t, e) {
				return !0
			}
			triggerEnter(t, e) {}
			triggerExit(t, e) {}
			deactivate(t) {}
			netActivate(t, e = 0) {
				this.net.send("trainer_entity_activate", {
					id: this.id,
					move: t,
					actionType: e
				})
			}
			getSubobjects(t) {
				let e = t;
				e || (e = this), e.tile && (e = e.tile);
				let i = e && e.objectgroup && e.objectgroup.objects;
				return i && i instanceof Array || (i = []), i
			}
			getSubobjectByName(t, e) {
				return this.getSubobjects(e).find(e => e.name === t)
			}
			getSubobjectByType(t, e) {
				return this.getSubobjects(e).find(e => e.type === t)
			}
			destroy() {
				this.obj = null, this.gameObject = null, this.map = null, this.scene = null, this.gui = null, this.net = null
			}
		}
		module.exports = BaseEntity;

	}, {}],
	7: [function(require, module, exports) {
		const BaseEntity = require("./base"),
			{
				Directions: Directions
			} = require("../../../shared/constants");
		class GymEntity extends BaseEntity {
			init() {
				this.targetProp = this.map.getObjectById(this.props.get("Target")), this.targetGameObject = this.targetProp && this.targetProp.gameObject, this.registerTriggerRect(this)
			}
			activate(t) {}
			triggerTest(t, e) {
				return e.facingDirection === Directions.UP
			}
			triggerEnter(t, e) {
				this.gui.highlightInteractable(this.targetGameObject, () => {
					this.netActivate(e)
				})
			}
			triggerExit(t, e) {
				this.gui.highlightInteractable(null)
			}
		}
		module.exports = GymEntity;

	}, {
		"../../../shared/constants": 60,
		"./base": 6
	}],
	8: [function(require, module, exports) {
		module.exports = {
			transit_slope: require("./transit-slope"),
			pokemart: require("./pokemart"),
			gym: require("./gym"),
			sign: require("./sign"),
			portal: require("./portal")
		};

	}, {
		"./gym": 7,
		"./pokemart": 9,
		"./portal": 10,
		"./sign": 11,
		"./transit-slope": 12
	}],
	9: [function(require, module, exports) {
		const BaseEntity = require("./base"),
			{
				Directions: Directions
			} = require("../../../shared/constants");
		class PokemartEntity extends BaseEntity {
			init() {
				this.targetProp = this.map.getObjectById(this.props.get("Target")), this.targetGameObject = this.targetProp && this.targetProp.gameObject, this.registerTriggerRect(this)
			}
			activate(t) {}
			triggerTest(t, e) {
				return e.facingDirection === Directions.UP
			}
			triggerEnter(t, e) {
				this.gui.highlightInteractable(this.targetGameObject, () => {
					this.netActivate(e)
				})
			}
			triggerExit(t, e) {
				this.gui.highlightInteractable(null)
			}
		}
		module.exports = PokemartEntity;

	}, {
		"../../../shared/constants": 60,
		"./base": 6
	}],
	10: [function(require, module, exports) {
		const BaseEntity = require("./base"),
			{
				Directions: Directions
			} = require("../../../shared/constants"),
			Act = {
				DEFAULT: 1,
				DOORWAY: 2,
				LADDER: 3,
				TELEPORT: 4
			};
		class PortalEntity extends BaseEntity {
			init() {
				this.targetProp = this.map.getObjectById(this.props.get("Target")), this.targetGameObject = this.targetProp && this.targetProp.gameObject, this.facingDirection = this.props.get("FacingDirection"), this.useDoorway = !!this.props.get("UseDoorway"), this.isLadder = !!this.props.get("IsLadder"), this.registerTriggerRect(this), this.maskObj = this.getSubobjectByName("doorwaymask", this.targetProp), this.maskObj && (this.maskPoly = this.scene.add.polygon(this.targetProp.x + this.maskObj.x, this.targetProp.y - this.targetProp.height + this.maskObj.y, this.maskObj.polygon, 0, 0).setOrigin(0), this.mask = new Phaser.Display.Masks.GeometryMask(this.scene, this.maskPoly), this.mask.invertAlpha = !0)
			}
			enterDoorway(t, e) {
				t.lockPhysics();
				const i = this.getSubobjectByName("waypoint1", this.targetProp),
					s = this.getSubobjectByName("waypoint2", this.targetProp),
					r = i.x + this.targetProp.x,
					a = i.y + this.targetProp.y - this.targetProp.height,
					h = t.x - r,
					n = t.y - a,
					o = s.x + this.targetProp.x,
					c = s.y + this.targetProp.y - this.targetProp.height,
					g = r - o,
					l = a - c,
					p = this.scene.tweens.createTimeline();
				return t.sprite.mask = this.mask, p.add({
					targets: t,
					x: r,
					y: a,
					interpolateVisualsMultiplier: .5,
					ease: Phaser.Math.Easing.Linear,
					duration: t.calcTravelTime(Math.sqrt(h * h + n * n)),
					onComplete: () => {
						t.shadow.setVisible(!1), this.isLadder && this.facingDirection === Directions.DOWN && (t.facingDirection = Directions.UP), this.facingDirection === Directions.UP && (t.minDepth = this.targetGameObject.depth + 1e-5)
					}
				}), p.add({
					targets: t,
					x: o,
					y: c,
					interpolateVisualsMultiplier: 0,
					ease: Phaser.Math.Easing.Linear,
					duration: t.calcTravelTime(Math.sqrt(g * g + l * l))
				}), p.once(Phaser.Tweens.Events.TIMELINE_COMPLETE, () => {
					t.sprite.clearMask(), t.sprite.setVisible(!1), t.facingDirection = this.facingDirection, e && e()
				}), p.play(), !0
			}
			async enterLadder() {
				return !0
			}
			async enterTeleporter() {
				return !0
			}
			activate(t, e) {
				switch (e) {
					default:
					case Act.DEFAULT:
						return !0;
					case Act.DOORWAY:
						return this.enterDoorway(t);
					case Act.LADDER:
						return this.enterLadder(t);
					case Act.TELEPORT:
						return this.enterTeleporter(t)
				}
			}
			triggerTest(t, e) {
				return void 0 === this.facingDirection || e.facingDirection === this.facingDirection
			}
			triggerEnter(t, e) {
				if (this.useDoorway) return this.netActivate(e, Act.DOORWAY), void this.enterDoorway(e, () => {
					this.netActivate(e, Act.DEFAULT)
				});
				this.targetGameObject ? this.gui.highlightInteractable(this.targetGameObject, () => {
					this.netActivate(e, Act.DEFAULT)
				}) : this.netActivate(e, Act.DEFAULT)
			}
			triggerExit(t, e) {
				this.gui.highlightInteractable(null)
			}
			destroy() {
				this.mask && (this.mask.destroy(), this.mask = null), this.maskPoly && (this.maskPoly.destroy(), this.maskPoly = null), super.destroy()
			}
		}
		module.exports = PortalEntity;

	}, {
		"../../../shared/constants": 60,
		"./base": 6
	}],
	11: [function(require, module, exports) {
		const BaseEntity = require("./base"),
			{
				Directions: Directions
			} = require("../../../shared/constants");
		class SignEntity extends BaseEntity {
			init() {
				this.text = this.props.get("Text") || "", this.textBg = this.props.get("TextBg") || 0;
				let t = {
					x: this.x,
					y: this.y,
					width: this.width,
					height: this.height
				};
				if (this.obj.tile) {
					t.width -= 20, t.x += 10, t.height = 60, t.y -= t.height / 2 + 10;
					const i = this.getSubobjectByType("origin");
					i && (t.y = this.y - this.height + i.y - t.height / 2)
				}
				this.registerTriggerRect(t), this.centerY = t.y + t.height / 2
			}
			activate(t) {}
			triggerTest(t, i) {
				return i.y <= this.centerY && i.facingDirection === Directions.DOWN || i.y >= this.centerY && i.facingDirection === Directions.UP || i.facingDirection === Directions.LEFT || i.facingDirection === Directions.RIGHT
			}
			triggerEnter(t, i) {
				this.gui.highlightInteractable(this.gameObject, () => {
					this.gui.textFrame.next()
				}), this.gui.textFrame.show({
					text: this.text,
					background: this.textBg
				})
			}
			triggerExit(t, i) {
				this.gui.textFrame.hide(), this.gui.highlightInteractable(null)
			}
		}
		module.exports = SignEntity;

	}, {
		"../../../shared/constants": 60,
		"./base": 6
	}],
	12: [function(require, module, exports) {
		const BaseEntity = require("./base"),
			{
				Directions: Directions
			} = require("../../../shared/constants");
		class TransitSlopeEntity extends BaseEntity {
			init() {
				this.slopeDirection = this.props.get("FacingDirection"), this.registerTriggerRect(this)
			}
			activate(t) {
				if (t[this.symbol]) return;
				t[this.symbol] = !0, t.lockPhysics();
				const i = this.props.get("MoveX"),
					e = this.props.get("MoveY"),
					s = (this.x, this.width, this.y, this.height, this.slopeDirection === Directions.DOWN ? this.y + this.height : this.y),
					r = this.slopeDirection === Directions.RIGHT ? this.x + this.width : this.x;
				let n;
				const h = [];
				switch (this.slopeDirection) {
					case Directions.DOWN:
					case Directions.UP:
						n = t.y - s, h.push({
							x: t.x,
							y: s
						}), h.push({
							x: t.x,
							y: s + e
						}), h.push({
							x: t.x,
							y: s + e - n
						});
						break;
					case Directions.RIGHT:
					case Directions.LEFT:
						n = t.x - r, h.push({
							x: r,
							y: t.y
						}), h.push({
							x: r + i,
							y: t.y + e
						}), h.push({
							x: r + i - n,
							y: t.y + e
						})
				}
				const o = !!this.props.get("RockClimb"),
					a = this.scene.tweens.createTimeline();
				o && t.mount("rock");
				const c = o ? 300 : t.calcTravelTime(n);
				return a.add({
					targets: t,
					x: h[0].x,
					y: h[0].y,
					interpolateVisualsMultiplier: o ? 0 : .5,
					ease: Phaser.Math.Easing.Linear,
					duration: c
				}), a.add({
					targets: t,
					x: h[1].x,
					y: h[1].y,
					ease: Phaser.Math.Easing.Linear,
					duration: t.calcTravelTime(Math.sqrt(i * i + e * e)),
					onComplete: () => {
						o && t.dismount("rock")
					}
				}), a.add({
					targets: t,
					x: h[2].x,
					y: h[2].y,
					interpolateVisualsMultiplier: 1,
					ease: Phaser.Math.Easing.Linear,
					duration: c
				}), a.once(Phaser.Tweens.Events.TIMELINE_COMPLETE, () => {
					t.unlockPhysics(), t[this.symbol] = !1
				}), a.play(), !0
			}
			triggerTest(t, i) {
				if (i.facingDirection === this.slopeDirection) {
					switch (this.slopeDirection) {
						case Directions.DOWN:
						case Directions.UP:
							if (i.getLeftEdge() < this.x || i.getRightEdge() > this.x + this.width) return;
							break;
						case Directions.RIGHT:
						case Directions.LEFT:
							if (i.getTopEdge() < this.y || i.getBottomEdge() > this.y + this.height) return
					}
					return !0
				}
			}
			triggerEnter(t, i) {
				this.activate(i) && this.netActivate(i)
			}
		}
		module.exports = TransitSlopeEntity;

	}, {
		"../../../shared/constants": 60,
		"./base": 6
	}],
	13: [function(require, module, exports) {
		const {
			Directions: Directions,
			Tiles: Tiles
		} = require("../../../shared/constants"), PHYSICS_LOCK = Symbol("PHYSICS_LOCK"), VIS_INTERP_SIZE = 300;

		function isPointInBox(i, t, s) {
			return i >= s.x && i <= s.x + s.width && t >= s.y && t <= s.y + s.height
		}

		function countCornersWithinBox(i, t) {
			const s = i.x - i.width * i.originX,
				e = i.y - i.height * i.originY;
			let h = 0;
			return isPointInBox(s, e, t) && h++, isPointInBox(s + i.width, e, t) && h++, isPointInBox(s, e + i.height, t) && h++, isPointInBox(s + i.width, e + i.height, t) && h++, h
		}
		class Mobile extends Phaser.GameObjects.Rectangle {
			constructor(i, t, s, e) {
				super(i, t, s, 24, 20, 16711680, 0), this._x = t, this._y = s, this.facingDirection = Directions.DOWN, this.interpolateVisualsMultiplier = 1, this.maxSpeed = 2, this[PHYSICS_LOCK] = 0, this.vis = {
					x: t,
					y: s,
					px1: t,
					py1: s,
					px2: t,
					py2: s
				}, this.scene.add.existing(this), this.scene.physics.add.existing(this), this.body.useDamping = !0, this.activeTriggers = new Map, this.currentMount = null, this.setInterpolateVisuals(!0)
			}
			getLeftEdge() {
				return this.x - this.width / 2
			}
			getRightEdge() {
				return this.x + this.width / 2
			}
			getTopEdge() {
				return this.y - this.height / 2
			}
			getBottomEdge() {
				return this.y + this.height / 2
			}
			calcTravelTime(i) {
				return Math.abs(430 * i / 32 / this.getTopSpeed())
			}
			getTopSpeed() {
				let i = this.maxSpeed;
				return this.currentMount && (i *= this.currentMount.speedMultiplier), i
			}
			teleportTo(i, t) {
				this.x = this.vis.x = this.vis.px1 = this.vis.px2 = i, this.y = this.vis.y = this.vis.py1 = this.vis.py2 = t
			}
			get tileX() {
				return Math.floor(this.vis.x / 32)
			}
			get tileY() {
				return Math.floor(this.vis.y / 32)
			}
			onTileCollision(i) {
				if (this.currentCollisionTile !== i.collisionTile) {
					const t = {
						prevCollisionTile: this.currentCollisionTile,
						...i
					};
					this.onLeaveTileType(t), this.currentCollisionTile = i.collisionTile, this.onEnterTileType(t)
				}
			}
			onEnterTileType(i) {}
			onLeaveTileType(i) {}
			setInterpolateVisuals(i) {
				this.interpolateVisuals = !!i
			}
			updateVisualInterpolation(i, t, s) {
				if (this.vis.px2 = this.vis.px1, this.vis.py2 = this.vis.py1, this.vis.px1 = this.vis.x, this.vis.py1 = this.vis.y, this.interpolateVisuals) {
					const e = i - this.vis.x,
						h = t - this.vis.y,
						n = Math.max(1 / s * VIS_INTERP_SIZE * this.interpolateVisualsMultiplier, 1);
					this.vis.x += e / n, this.vis.y += h / n
				} else this.vis.x = i, this.vis.y = t
			}
			updateAnimations(i) {}
			updateVis(i, t) {
				const s = this.x,
					e = this.y;
				this.updateVisualInterpolation(s, e, t);
				const h = this.tileX,
					n = this.tileY;
				let o = this.vis.x,
					r = this.vis.y;
				this.currentMount && (r += this.currentMount.z), this.sprite.x = this.shadow.x = o, this.sprite.y = this.shadow.y = r, this.sprite.setDepth(Math.max(6 - 1 / this.vis.y, this.minDepth || 0)), this.shadow.setDepth(this.sprite.depth - 1), this.currentMount && this.currentMount.updateVis(i, t), this.sprite.y += this.hopZ, this.updateAnimations(t), h === this.prevTileX && n === this.prevTileY || this.emit("tile", {
					x: h,
					y: n
				}), this.prevTileX = h, this.prevTileY = n
			}
			lockPhysics() {
				return this[PHYSICS_LOCK]++, this[PHYSICS_LOCK] >= 1 && this.scene.physics.world.disable(this), this
			}
			unlockPhysics() {
				if (!this[PHYSICS_LOCK]) throw Error("Cannot unlock physics as no lock in place");
				if (this[PHYSICS_LOCK]--, this.scene) return 0 === this[PHYSICS_LOCK] && this.scene.physics.world.enable(this), this
			}
			getPhysicsLocked() {
				return !!this[PHYSICS_LOCK]
			}
			setMovementInput(i, t, s) {
				if (!s && !this.drag) return void this.body.setDrag(this.interpolateVisuals ? 0 : .8);
				if (this.body.setDrag(0), this.getPhysicsLocked()) return;
				let e, h, n = Math.max(0, Math.min(Math.abs(s), 1));
				if (n > 0) {
					const s = Math.sqrt(i * i + t * t);
					e = i / s || 0, h = t / s || 0
				}
				let o = e * n * this.maxSpeed * 100,
					r = h * n * this.maxSpeed * 100;
				this.body.setVelocity(o, r), Math.abs(o) >= Math.abs(r) ? this.facingDirection = o > 0 ? Directions.RIGHT : Directions.LEFT : this.facingDirection = r > 0 ? Directions.DOWN : Directions.UP
			}
		}
		module.exports = Mobile;

	}, {
		"../../../shared/constants": 60
	}],
	14: [function(require, module, exports) {
		module.exports = {
			rock: require("./rock"),
			surf: require("./surf")
		};

	}, {
		"./rock": 15,
		"./surf": 16
	}],
	15: [function(require, module, exports) {
		const {
			Directions: Directions
		} = require("../../../../shared/constants");
		class MountRock {
			constructor(t) {
				this.trainer = t, this.scene = t.scene, this.z = 0, this.speedMultiplier = 2, this.sprite = t.scene.add.image(0, 0, "mobs_mounts", 0), this.sprite.setAlpha(0).setScale(0), this.tween = this.scene.tweens.add({
					targets: this.sprite,
					alpha: 1,
					scale: 1,
					duration: 200
				}), this.dustParticles = this.scene.add.particles("particles_8x8"), this.dustParticlesEmitter = this.dustParticles.createEmitter({
					on: !1,
					frame: [5, 6, 7],
					lifespan: 1e3,
					speed: {
						min: 90,
						max: 100
					},
					angle: {
						min: 250,
						max: 290
					},
					rotate: {
						min: 0,
						max: 360
					},
					gravityY: 200,
					frequency: 50,
					follow: this.sprite,
					emitZone: {
						source: new Phaser.Geom.Rectangle(-10, -24, 40, 32),
						type: "random"
					}
				}), this.dustParticlesEmitter.start(), this.trainer.once("destroy", this.destroy, this), this.emitCloud()
			}
			emitCloud() {
				const t = this.scene.add.sprite(this.trainer.vis.x, this.trainer.vis.y, "particles_48x48", Math.floor(7 * Math.random())).setDepth(this.sprite.depth + 1).setAlpha(1).setScale(.5);
				this.scene.tweens.add({
					targets: t,
					scale: 1,
					ease: Phaser.Math.Easing.Sine.Out,
					duration: 500
				}), this.scene.tweens.add({
					targets: t,
					alpha: 0,
					ease: Phaser.Math.Easing.Quintic.In,
					duration: 1e3,
					onComplete: () => {
						t.destroy()
					}
				})
			}
			destroy() {
				this.trainer.off("destroy", this.destroy, this), this.dustParticlesEmitter.stop(), this.tween.stop(), this.tween = this.scene.tweens.add({
					targets: this.sprite,
					alpha: 0,
					ease: Phaser.Math.Easing.Quartic.In,
					duration: 200,
					onComplete: this.sprite.destroy.bind(this.sprite)
				})
			}
			updateVis(t, e) {
				(!this.lastCloudTime || t - this.lastCloudTime > 100) && (this.emitCloud(), this.lastCloudTime = t), this.sprite.x = this.trainer.vis.x, this.sprite.y = this.trainer.vis.y, this.dustParticles.setDepth(this.sprite.depth + 1);
				let s = 0;
				switch (this.sprite.setFlipX(!1), this.trainer.facingDirection) {
					case Directions.DOWN:
						s = 6;
						break;
					case Directions.UP:
						s = 7;
						break;
					case Directions.LEFT:
						s = 8;
						break;
					case Directions.RIGHT:
						this.sprite.setFlipX(!0), s = 8
				}
				this.sprite.setFrame(s), this.sprite.depth = this.trainer.sprite.depth - 1e-8
			}
		}
		module.exports = MountRock;

	}, {
		"../../../../shared/constants": 60
	}],
	16: [function(require, module, exports) {
		const {
			Directions: Directions
		} = require("../../../../shared/constants"), BOB_FREQUENCY = 2e3, SPLASH_FREQUENCY = 100;
		class MountSurf {
			constructor(t) {
				this.trainer = t, this.scene = t.scene, this.bobAccumulatedMs = 0, this.z = 0, this.speedMultiplier = 1, this.sprite = t.scene.add.image(0, 0, "mobs_mounts", 0), this.sprite.setAlpha(0).setScale(0), this.tween = this.scene.tweens.add({
					targets: this.sprite,
					alpha: 1,
					scale: 1,
					duration: 200
				}), this.trainer.once("destroy", this.destroy, this)
			}
			destroy() {
				this.trainer.off("destroy", this.destroy, this), this.tween.stop(), this.tween = this.scene.tweens.add({
					targets: this.sprite,
					alpha: 0,
					ease: Phaser.Math.Easing.Quartic.In,
					duration: 200,
					onComplete: this.sprite.destroy.bind(this.sprite)
				})
			}
			updateVis(t, s) {
				this.bobAccumulatedMs = (this.bobAccumulatedMs + s) % BOB_FREQUENCY, this.z = 5 * Math.sin(this.bobAccumulatedMs / BOB_FREQUENCY * Math.PI * 2), this.sprite.x = this.trainer.sprite.x, this.sprite.y = this.trainer.sprite.y;
				let e = 0;
				switch (this.sprite.setFlipX(!1), this.trainer.facingDirection) {
					case Directions.DOWN:
						e = 0;
						break;
					case Directions.UP:
						e = 1;
						break;
					case Directions.LEFT:
						e = 2;
						break;
					case Directions.RIGHT:
						this.sprite.setFlipX(!0), e = 2
				}
				this.sprite.setFrame(e), this.sprite.depth = this.trainer.sprite.depth - 1e-8
			}
		}
		module.exports = MountSurf;

	}, {
		"../../../../shared/constants": 60
	}],
	17: [function(require, module, exports) {
		const Mobile = require("./mobile"),
			{
				Directions: Directions,
				Tiles: Tiles
			} = require("../../../shared/constants"),
			Mounts = require("./mounts"),
			FOOTPRINT_TILES = [Tiles.SAND, Tiles.DIRT, Tiles.SNOW];
		class Trainer extends Mobile {
			constructor(t, s) {
				super(t, s.x, s.y), this.id, this.spriteIdx = 1, this.maxSpeed = 2, this.setData(s), this.footprint = {
					prevX: this.x,
					prevY: this.y
				}, this.hopZ = 0, this.hopTween = null, this.masked = !1, this.sprite = this.scene.add.sprite(this.x, this.y).setOrigin(.5, .9), this.sprite.play(`trainer${this.spriteIdx}.stand.down`), this.shadow = this.scene.add.ellipse(this.x, this.y, 32, 16, 0).setAlpha(.2)
			}
			mount(t) {
				this.dismount(), this.currentMount = new Mounts[t](this), this.hop()
			}
			dismount(t) {
				this.currentMount && (!t || this.currentMount instanceof Mounts[t]) && (this.currentMount.destroy(), this.currentMount = null, this.hop())
			}
			hop() {
				this.hopTween && this.hopTween.stop(), this.hopTween = this.scene.tweens.createTimeline(), this.hopTween.add({
					targets: this,
					hopZ: -15,
					ease: Phaser.Math.Easing.Quadratic.Out,
					duration: 180
				}), this.hopTween.add({
					targets: this,
					hopZ: 0,
					ease: Phaser.Math.Easing.Quadratic.Out,
					duration: 180
				}), this.hopTween.once(Phaser.Tweens.Events.TIMELINE_COMPLETE, () => {
					if (!this.scene) return;
					if ([Tiles.WATER].includes(this.currentCollisionTile)) return;
					this.createFootprint(2);
					const t = this.scene.add.sprite(this.vis.x - 15, this.vis.y - 7).play("effect_dustmote").setDepth(this.sprite.depth).setFlipX(!0),
						s = this.scene.add.sprite(this.vis.x + 15, this.vis.y - 7).play("effect_dustmote").setDepth(this.sprite.depth);
					this.scene.tweens.add({
						targets: t,
						x: t.x - 10,
						duration: 400,
						onComplete: t.destroy.bind(t)
					}), this.scene.tweens.add({
						targets: s,
						x: s.x + 10,
						duration: 400,
						onComplete: s.destroy.bind(s)
					})
				}), this.hopTween.play()
			}
			onEnterTileType(t) {
				switch (t.collisionTile) {
					case Tiles.GRASS:
						this.shadow.setVisible(!1), this.masked = !0;
						break;
					case Tiles.WATER:
						this.shadow.setVisible(!1), this.mount("surf")
				}
			}
			onLeaveTileType(t) {
				switch (t.prevCollisionTile) {
					case Tiles.GRASS:
						this.shadow.setVisible(!0), this.masked = !1;
						break;
					case Tiles.WATER:
						this.shadow.setVisible(!0), this.dismount("surf")
				}
			}
			setData(t) {
				Object.assign(this, t), this.emit("update", t)
			}
			createFootprint(t) {
				const s = this.vis.x - this.footprint.prevX,
					e = this.vis.y - this.footprint.prevY;
				if (this.footprint.prevX = this.vis.x, this.footprint.prevY = this.vis.y, !isNaN(s) && !isNaN(e) && FOOTPRINT_TILES.includes(this.currentCollisionTile))
					for (let i = 0; i < t; i++) {
						this.footprint.flop = !this.footprint.flop;
						const t = Phaser.Math.Angle.Between(0, 0, s, e),
							i = this.scene.add.sprite(5, 0, "particles_8x8", 3).setDepth(5).setRotation(t).setFlipY(this.footprint.flop).setBlendMode(Phaser.BlendModes.MULTIPLY);
						Phaser.Math.Rotate(i, 1.5708 * (this.footprint.flop ? 1 : -1) + t), i.x += this.vis.x, i.y += this.vis.y - 3, this.scene.tweens.add({
							targets: i,
							scale: 0,
							duration: 2e3,
							ease: Phaser.Math.Easing.Quintic.In,
							onComplete: i.destroy.bind(i)
						})
					}
			}
			onAnimationFrameChange(t) {
				this.hopZ || this.currentMount || this.createFootprint(1)
			}
			updateAnimations(t) {
				super.updateAnimations(t);
				let s = "stand";
				const e = this.vis.x - this.vis.px2,
					i = this.vis.y - this.vis.py2,
					n = Math.abs(Math.sqrt(e * e + i * i));
				!this.currentMount && n > .02 && (s = "walk", this.sprite.anims.setTimeScale(n * (1 / t) * 5));
				let h = "down";
				switch (this.sprite.setFlipX(!1), this.facingDirection) {
					case Directions.DOWN:
						h = "down";
						break;
					case Directions.UP:
						h = "up";
						break;
					case Directions.LEFT:
						h = "left";
						break;
					case Directions.RIGHT:
						this.sprite.setFlipX(!0), h = "left"
				}
				const r = this.sprite.anims.currentFrame.index;
				this.prevFrameIdx !== r && (this.prevFrameIdx = r, this.onAnimationFrameChange(r)), this.sprite.play(`trainer${this.spriteIdx}${this.masked?"masked":""}.${s}.${h}`, !0)
			}
			destroyWithEffect() {
				this.scene.tweens.add({
					targets: this.sprite,
					alpha: 0,
					duration: 200,
					onComplete: this.destroy.bind(this)
				})
			}
			destroy() {
				this.scene && (this.sprite.destroy(), this.shadow.destroy(), this.currentMount && (this.currentMount.destroy(), this.currentMount = null), super.destroy())
			}
		}
		module.exports = Trainer;

	}, {
		"../../../shared/constants": 60,
		"./mobile": 13,
		"./mounts": 14
	}],
	18: [function(require, module, exports) {
		const {
			Tiles: Tiles
		} = require("../../shared/constants");
		class ParticleEffects {
			constructor(s) {
				this.scene = s, this.grassParticles = this.scene.add.particles("particles_4x4"), this.grassParticles.setDepth(6), this.grassParticlesEmitter = this.grassParticles.createEmitter({
					frame: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
					lifespan: 1e3,
					speed: {
						min: 90,
						max: 100
					},
					angle: {
						min: 250,
						max: 290
					},
					gravityY: 200,
					frequency: -1,
					emitZone: {
						source: new Phaser.Geom.Rectangle(0, 0, 32, 24),
						type: "random"
					}
				}), this.splashAngle = {
					min: 0,
					max: 360
				}, this.splashParticles = this.scene.add.particles("particles_4x4"), this.splashParticles.setDepth(5), this.splashParticlesEmitter = this.splashParticles.createEmitter({
					frame: [15, 16],
					lifespan: 2e3,
					alpha: {
						start: 1,
						end: 0
					},
					speed: {
						min: 4,
						max: 8
					},
					angle: this.splashAngle,
					frequency: -1,
					emitZone: {
						source: new Phaser.Geom.Circle(0, 0, 24),
						type: "random"
					}
				}), this.scene.events.on("trainerTileCollision", this.onTrainerTile, this)
			}
			onTrainerTile({
				tileX: s,
				tileY: e,
				trainer: t,
				map: i,
				collisionTile: a
			}) {
				a === Tiles.GRASS && this.grass(s, e)
			}
			grass(s, e) {
				this.grassParticlesEmitter.explode(8, 32 * s, 32 * e)
			}
			splash(s, e, t) {
				void 0 !== t ? (this.splashAngle.min = t - 1, this.splashAngle.max = t + 1) : (this.splashAngle.min = 0, this.splashAngle.max = 360), this.splashParticlesEmitter.setAngle(this.splashAngle), this.splashParticlesEmitter.explode(3, s, e)
			}
			clear() {}
		}
		module.exports = ParticleEffects;

	}, {
		"../../shared/constants": 60
	}],
	19: [function(require, module, exports) {
		const MOVEMENTS = {
				ooze: (e, t) => {
					t.tilePositionY = -.002 * e + 3 * Math.sin(.0012 * e % (2 * Math.PI))
				},
				ocean: (e, t) => {
					t.tilePositionX = .008 * e, t.tilePositionY = -.008 * e
				},
				river: (e, t) => {
					t.tilePositionY = -.015 * e
				},
				waterfall: (e, t) => {
					t.tilePositionY = -.09 * e
				}
			},
			ANIMATIONS = {
				stillwater: {
					frames: [0],
					frameRate: 0,
					movement: MOVEMENTS.ooze
				},
				ocean: {
					frames: [0],
					frameRate: 0,
					movement: MOVEMENTS.ocean
				},
				river: {
					frames: [0],
					frameRate: 0,
					movement: MOVEMENTS.river
				},
				swamp: {
					frames: [1],
					frameRate: 0,
					movement: MOVEMENTS.ooze
				},
				magma: {
					frames: [2, 3, 4, 5],
					frameRate: 4,
					movement: MOVEMENTS.ooze
				},
				waterfall: {
					frames: [8],
					frameRate: 0,
					movement: MOVEMENTS.waterfall
				},
				watersplash: {
					frames: [9, 10],
					frameRate: 6,
					movement: null
				}
			};
		class TiledBackground extends Phaser.GameObjects.TileSprite {
			constructor(e, t) {
				super(e, t.x, t.y, t.width, t.height, "backgrounds", 0), this.obj = t, this.animation = ANIMATIONS[t.props.get("Key")] || ANIMATIONS.stillwater, this.frameTotal = this.animation.frames.length, this.setFrame(this.animation.frames[0]), this.setOrigin(0).setDepth(t.depth - .001), this.scene.add.existing(this)
			}
			updateVis(e, t, a) {
				if (this.frameTotal > 0) {
					const t = Math.floor(e / 1e3 * this.animation.frameRate % this.frameTotal);
					this.setFrame(this.animation.frames[t])
				}
				this.animation.movement && this.animation.movement(e, this)
			}
			destroy() {
				super.destroy()
			}
		}
		module.exports = TiledBackground;

	}, {}],
	20: [function(require, module, exports) {
		class UIClock extends Phaser.GameObjects.Container {
			constructor(t, e, s) {
				super(t, e, s), this.cycleDurationMs = null, this.serverSyncTime = null, this.timeBase = null, this.background = this.scene.add.image(0, 0, "ui_clock", 0).setOrigin(0), this.icon = this.scene.add.image(0, 0, "ui_clock", 1).setOrigin(0), this.clockHours = this.scene.add.bitmapText(40, 6, "dp", "", 27).setText("00").setOrigin(0), this.clockMins = this.scene.add.bitmapText(80, 6, "dp", "", 27).setText("00").setOrigin(0), this.add([this.background, this.icon, this.clockHours, this.clockMins]), this.scene.add.existing(this)
			}
			get width() {
				return 124 * this.scale
			}
			get height() {
				return 47 * this.scale
			}
			preUpdate(t) {
				null === this.timeBase && (this.timeBase = t), this.currentTime = (t - this.timeBase + this.serverSyncTime) % this.cycleDurationMs;
				let e = this.currentTime / this.cycleDurationMs;
				if (!isNaN(e)) {
					let t = 24 * e,
						s = t % 1 * 60;
					t = Math.floor(t).toFixed(0).padStart(2, "0"), s = Math.floor(s).toFixed(0).padStart(2, "0"), this.clockHours.setText(t), this.clockMins.setText(s);
					const i = e >= .25 && e < .75;
					this.icon.setFrame(i ? 1 : 2)
				}
			}
			setClock(t) {
				this.cycleDurationMs = t.cycleDurationMs, this.serverSyncTime = t.time, this.timeBase = null
			}
		}
		module.exports = UIClock;

	}, {}],
	21: [function(require, module, exports) {
		const STATIC_URL = "https://static.pokemon-vortex.com/v4/images/pokemon_front/",
			FRAME_POKEBALL = 2,
			FRAME_SEASONBALL = 3;
		class EncounterProfile extends Phaser.GameObjects.Container {
			constructor(t) {
				super(t, 0, 0), this.scene = t, this.platform = this.scene.add.image(0, 20, "ui_platforms", 0).setAlpha(0), this.pokeImg = this.scene.add.image(0, 0).setAlpha(0), this.pokeName = this.scene.add.bitmapText(0, 66, "dp", "", 17).setCenterAlign(), this.pokeLvl = this.scene.add.bitmapText(0, 0, "dp", "", 17).setCenterAlign(), this.battleButton = this.scene.add.image(0, 0, "ui_battle-button", 0).setAlpha(0), this.genderImg = this.scene.add.image(0, 0, "ui_gender", 0).setAlpha(0), this.caughtImg = this.scene.add.image(0, 0, "ui_gender", FRAME_POKEBALL), this.battleButton.setInteractive({
					cursor: "pointer"
				}), this.battleButton.on("pointerover", t => {
					this.battleButton.setFrame(1)
				}), this.battleButton.on("pointerout", t => {
					this.battleButton.setFrame(0)
				}), this.battleButton.on("pointerdown", this.startBattle, this), this.add(this.platform), this.add(this.pokeImg), this.add(this.pokeName), this.add(this.pokeLvl), this.add(this.genderImg), this.add(this.caughtImg), this.add(this.battleButton), this.scene.input.keyboard.on("keydown-SPACE", this.startBattle, this), this.scene.input.gamepad.on(Phaser.Input.Gamepad.Events.BUTTON_DOWN, this.onGamepadDown, this)
			}
			onGamepadDown(t, e, s) {
				1 === s && 0 === e.index && this.startBattle()
			}
			startBattle(t) {
				this.encounter && this.encounter.startBattle()
			}
			setEncounter(t) {
				if (this.encounter = t, !t) return;
				switch (this.platform.setFrame(t.platform), this.pokeName.setText(t.fullname).setOrigin(.5), this.pokeImg.setY(t.pokemon.yoffset), this.pokeImg.setAlpha(0), t.gender) {
					default:
					case "None":
						this.genderImg.setAlpha(0);
						break;
					case "Male":
						this.genderImg.setFrame(1).setAlpha(1);
						break;
					case "Female":
						this.genderImg.setFrame(0).setAlpha(1)
				}
				this.genderImg.setPosition(this.pokeName.x + this.pokeName.width / 2 + 10, this.pokeName.y + this.pokeName.height / 2 - 5), this.caughtImg.setPosition(this.pokeName.x - this.pokeName.width / 2 - 10, this.pokeName.y + this.pokeName.height / 2 - 5), this.caughtImg.setFrame(2 === t.caught ? FRAME_SEASONBALL : FRAME_POKEBALL), this.caughtImg.setAlpha(t.caught ? 1 : 0), this.pokeLvl.setPosition(this.pokeName.x, this.pokeName.y + 15).setText("Level: " + t.level).setOrigin(.5), this.platform.setAlpha(1), this.battleButton.setAlpha(1), this.battleButton.setY(this.pokeLvl.y + this.pokeLvl.height + 20), this.pokeImgTween && this.pokeImgTween.stop();
				const e = "poke_" + t.fullname;
				this.scene.dynamicLoader.load({
					type: "image",
					key: e,
					url: STATIC_URL + encodeURIComponent(t.fullname) + ".png"
				}).then(() => {
					if (this.encounter.id === t.id) return this.pokeImg.setTexture(e), new Promise(t => {
						this.pokeImgTween = this.scene.tweens.add({
							targets: this.pokeImg,
							alpha: 1,
							duration: 500,
							ease: Phaser.Math.Easing.Cubic.Out,
							onComplete: t
						})
					});
					console.log("invalid encounter")
				}).catch(t => {
					console.error("Error loading encounter:", t)
				})
			}
			destroy() {
				super.destroy()
			}
		}
		module.exports = EncounterProfile;

	}, {}],
	22: [function(require, module, exports) {
		const EventEmitter = require("eventemitter3");
		class InteractionHighlight extends EventEmitter {
			constructor(t) {
				super(), this.scene = t, this.targetGameObject = null, this.clickable = null, this.rt = this.scene.add.renderTexture(0, 0, 100, 100).setOrigin(0, 1).setVisible(!1).setTintFill(), this.scene.input.keyboard.on("keydown-SPACE", this.interact, this), this.scene.input.gamepad.on(Phaser.Input.Gamepad.Events.BUTTON_DOWN, this.onGamepadDown, this)
			}
			onGamepadDown(t, e, i) {
				1 === i && 0 === e.index && this.interact()
			}
			interact() {
				this.interactCallback && this.interactCallback()
			}
			setDepth(t) {
				return this.rt.setDepth(t), this
			}
			show(t, e) {
				this.hide(), this.targetGameObject = t, this.interactCallback = e, this.rt.clear();
				let i = this.targetGameObject.frame;
				this.rt.setSize(i.width, i.height), this.rt.draw(i), this.rt.setVisible(!0), this.clickable = this.scene.add.rectangle(0, 0, i.width, i.height, 16776960, 0).setOrigin(0, 1).setInteractive({
					cursor: "pointer"
				}), this.clickable.on(Phaser.Input.Events.POINTER_DOWN, this.interact, this)
			}
			hide() {
				this.rt.setVisible(!1), this.clickable && this.clickable.destroy(), this.targetGameObject = null, this.interactCallback = null
			}
			update(t, e, i) {
				if (this.targetGameObject) {
					t.fromWorldCoordsScaled(this.targetGameObject.x, this.targetGameObject.y, this.rt), this.clickable && t.fromWorldCoordsScaled(this.targetGameObject.x, this.targetGameObject.y, this.clickable);
					const i = 2 * Math.PI,
						s = e % 1500 / 1500;
					this.rt.setAlpha(.25 * (Math.sin(i * s) / 2 + .5) + .1)
				}
			}
			destroy() {
				this.scene.input.keyboard.off("keydown-SPACE", this.interact, this)
			}
		}
		module.exports = InteractionHighlight;

	}, {
		"eventemitter3": 47
	}],
	23: [function(require, module, exports) {
		const MAX_LINES = 5;
		class SystemMessages extends Phaser.GameObjects.Container {
			constructor(e, t, s) {
				super(e, t, s), this.width = 1, this.height = 1, this.lines = [], this.background = this.scene.add.rectangle(0, 0, 1, 1, 0, .5).setOrigin(0), this.add(this.background), this.scene.add.existing(this)
			}
			clear() {
				for (; this.lines.length > 0;) this.removeLine(this.lines[0]);
				this.reflow()
			}
			display(e) {
				const t = this.scene.add.bitmapText(0, 0, "dp", e.message);
				this.add(t);
				const s = {
					text: t,
					tween: this.scene.tweens.add({
						targets: t,
						alpha: 0,
						delay: 8e3,
						duration: 200,
						onComplete: () => {
							this.removeLine(s)
						}
					})
				};
				for (this.lines.push(s); this.lines.length > MAX_LINES;) this.removeLine(this.lines[0]);
				this.reflow()
			}
			removeLine(e) {
				const t = this.lines.indexOf(e); - 1 !== t && (this.lines.splice(t, 1), console.log(e.tween), e.tween.stop(), e.text.destroy(), this.reflow())
			}
			reflow() {
				if (this.setVisible(this.lines.length > 0), !this.lines.length) return;
				let e = 10,
					t = this.width - 20;
				for (const s of this.lines) {
					s.text.setMaxWidth(t);
					let i = s.text.height;
					s.text.y = e, s.text.x = 10, s.text.setOrigin(0), e += i + 10
				}
				this.height = e + 5, this.background.setSize(this.width, this.height), this.y = this.scene.cameras.main.height - this.height - 50
			}
			setWidth(e) {
				this.width = e, this.reflow()
			}
			destroy() {
				this.background.destroy(), this.lines.forEach(e => {
					e.text.destroy()
				}), super.destroy()
			}
		}
		module.exports = SystemMessages;

	}, {}],
	24: [function(require, module, exports) {
		const STANDARD_ICONS = {
			South: 2,
			North: 3,
			West: 4,
			East: 5,
			SouthWest: 6,
			SouthEast: 7,
			NorthWest: 8,
			NorthEast: 9,
			WestSouth: 10,
			WestNorth: 11,
			EastSouth: 12,
			EastNorth: 13
		};
		class TextFrame extends Phaser.GameObjects.Container {
			constructor(t, i, s, e) {
				super(t, i, s), this.pages = [], this.frameTouch = !1, this.cursorPosition = 0, this.line1TextLength = 0, this.line2TextLength = 0, this.background = this.scene.add.image(0, 0, "ui_text-frames", 4), this.arrow = this.scene.add.image(118, 9, "ui_text-frames-icons", 1), this.arrowBobY = 0, this.icon = this.scene.add.image(-88, 0, "ui_text-frames-icons", 0), this.line1 = this.scene.add.dynamicBitmapText(-112, -17, "dp", e || "", 18).setOrigin(0).setLeftAlign().setScale(.7692), this.line2 = this.scene.add.dynamicBitmapText(-112, -1, "dp", e || "", 18).setOrigin(0).setLeftAlign().setScale(.7692), this.add([this.background, this.line1, this.line2, this.arrow, this.icon]), this.scene.add.existing(this), this.hide(), this.background.setInteractive({
					cursor: "pointer"
				}), this.background.on("pointerdown", t => {
					this.next()
				}), this.line1.setDisplayCallback(this.onLine1Display.bind(this)), this.line2.setDisplayCallback(this.onLine2Display.bind(this)), this.scene.input.keyboard.on("keydown-SPACE", this.next, this), this.scene.input.gamepad.on(Phaser.Input.Gamepad.Events.BUTTON_DOWN, this.onGamepadDown, this)
			}
			onGamepadDown(t, i, s) {
				1 === s && 0 === i.index && this.next()
			}
			onLine1Display(t) {
				return this.cursorPosition < t.index && (t.scale = 0), t
			}
			onLine2Display(t) {
				return this.cursorPosition - this.line1TextLength < t.index && (t.scale = 0), t
			}
			get isFullyDisplayed() {
				return this.cursorPosition >= this.line1TextLength + this.line2TextLength
			}
			show({
				text: t,
				background: i
			}) {
				this.pages = t.split("\n-\n").map(t => {
					const i = t.split("\n");
					let s = null;
					const e = i[0].match(/^<(.*)>$/);
					return e && (i.shift(), s = +e[1] == e[1] ? +e[1] : STANDARD_ICONS[e[1]]), {
						icon: s,
						line1: i[0] || "",
						line2: i[1] || ""
					}
				}), this.background.setFrame(i), this.pagePosition = -1, this.next()
			}
			preUpdate(t, i) {
				this.cursorPosition += .05 * i, this.arrowBobY = 2 * Math.sin(t % 400 / 400 * Math.PI * 2), this.arrow.y = 9 + this.arrowBobY, this.frameTouch = !1
			}
			next() {
				if (this.frameTouch) return;
				if (this.frameTouch = !0, !this.pages.length) return this.hide();
				if (this.cursorPosition > 0 && !this.isFullyDisplayed && this.visible) return void(this.cursorPosition = this.line1TextLength + this.line2TextLength);
				this.pagePosition++, this.pagePosition >= this.pages.length && (this.pagePosition = -1);
				const t = this.pages[this.pagePosition];
				this.setVisible(!!t), t && (this.cursorPosition = 0, this.arrow.setVisible(this.pagePosition !== this.pages.length - 1), this.line1.setText(t.line1), this.line1TextLength = t.line1.length, this.line2.setText(t.line2), this.line2TextLength = t.line2.length, this.icon.setVisible(!!t.icon).setFrame(t.icon), t.icon ? this.line1.x = this.line2.x = -57 : this.line1.x = this.line2.x = -112)
			}
			hide() {
				this.setVisible(!1), this.pages = []
			}
			setBackground(t) {
				return this.background.setFrame(t), this
			}
			destroy() {
				this.scene.input.keyboard.off("keydown-SPACE", this.next, this)
			}
		}
		module.exports = TextFrame;

	}, {}],
	25: [function(require, module, exports) {
		class ZoneLabel extends Phaser.GameObjects.Container {
			constructor(t, e, s, i) {
				super(t, e, s), this.nativeWidth = 136, this.nativeHeight = 32, this.setScale(1), this.background = this.scene.add.image(0, 0, "ui_zone-labels", 0), this.text = this.scene.add.bitmapText(0, -3, "dp", i || "", 13).setOrigin(.5).setCenterAlign(), this.add([this.background, this.text]), this.scene.add.existing(this), this.totalTime = 0, this.showTime = 0
			}
			setScale(t) {
				return super.setScale(t), this.width = this.nativeWidth * t, this.height = this.nativeHeight * t, this
			}
			preUpdate(t) {
				this.totalTime = t
			}
			getProgress(t) {
				const e = this.totalTime - this.showTime;
				return Math.min(e / t, 1)
			}
			show({
				text: t,
				background: e,
				tween: s
			}) {
				return this.tween && (this.tween.stop(), this.tween = null), s && (this.tween = this.scene.tweens.addCounter(s)), this.showTime = this.totalTime, this.setText(t), this.setBackground(e), this
			}
			getTweenProgress() {
				return this.tween ? this.tween.getValue() : 0
			}
			setText(t) {
				return this.text.setText(t), this
			}
			setBackground(t) {
				return this.background.setFrame(t), this
			}
		}
		module.exports = ZoneLabel;

	}, {}],
	26: [function(require, module, exports) {
		const path = require("path"),
			cloneDeep = require("lodash.clonedeep"),
			Atmospherics = require("./atmospherics"),
			{
				Directions: Directions
			} = require("../../shared/constants"),
			Entities = require("./entities"),
			TiledBackground = require("./tiled-background"),
			EventEmitter = require("eventemitter3"),
			DEBUG_DEPTH = 2e3;

		function indexBy(e, t, i) {
			return (t || []).reduce((t, s) => (t.set(s[e], i ? s[i] : s), t), new Map)
		}

		function coerceArray(e) {
			return e instanceof Array || (e = []), e
		}
		class WorldMap extends EventEmitter {
			constructor(e, {
				key: t,
				debug: i
			}) {
				super(), this.scene = e, this.key = `${t}_worldmap`, this.atlasKey = `${t}_atlas`, this.tilesKey = `${t}_tiles`, this.collisions = e.add.group({
					name: "collisions"
				}), this.triggers = e.add.group({
					name: "triggers"
				}), this.props = e.add.group({
					name: "props"
				}), this.lights = [], this.allObjects = [], this.allObjectsById = new Map, this.allProps = [], this.entitiesById = new Map, this.tiledBackgrounds = [], this.setDebug(i)
			}
			init(e) {
				this.initTilemap(), this.initObjects(), this.initAtmospherics(), this.setClock(e), this.scene.physics.world.enable(this.triggers, Phaser.Physics.Arcade.STATIC_BODY)
			}
			setDebug(e) {
				e ? (!this._debugCollisionGfx && this.collisions && (this._debugCollisionGfx = this.scene.add.graphics(0, 0).setDepth(DEBUG_DEPTH + 1), this.tilemap.renderDebug(this._debugCollisionGfx, {
					tileColor: null
				}, "collisions")), Phaser.Actions.SetAlpha(this.triggers.children.entries, .6)) : (this._debugCollisionGfx && (this._debugCollisionGfx.destroy(), this._debugCollisionGfx = null), Phaser.Actions.SetAlpha(this.triggers.children.entries, 0))
			}
			createTrigger({
				x: e,
				y: t,
				width: i,
				height: s,
				data: r
			}) {
				const a = this.scene.add.rectangle(e, t, i, s, 6711039).setOrigin(0).setAlpha(0).setDepth(DEBUG_DEPTH + 2);
				return a.setData(r), this.triggers.add(a), a
			}
			initAtmospherics() {
				this.tilemapProps.get("AlwaysNight") ? this.clockTime = 0 : this.tilemapProps.get("AlwaysDay") ? this.clockTime = .5 : this.tilemapProps.get("ClockTime") && (this.clockTime = this.tilemapProps.get("ClockTime")), this.atmospherics = new Atmospherics(this)
			}
			setClock(e) {
				this.atmospherics.setClock(e)
			}
			update(e, t, i) {
				this.atmospherics.update(e, t, i);
				for (let s = 0; s < this.tiledBackgrounds.length; s++) this.tiledBackgrounds[s].updateVis(e, t, i)
			}
			getObjectById(e) {
				return this.allObjectsById.get(e)
			}
			createEntity(e) {
				const t = new Entities[e.type](e, this);
				this.entitiesById.set(e.id, t), this.emit("entityLoaded", t)
			}
			getEntity(e) {
				return this.entitiesById.get(e)
			}
			destroyEntity(e) {
				const t = this.getEntity(e);
				t && (this.entitiesById.delete(e), t.destroy())
			}
			createBackground(e) {
				const t = new TiledBackground(this.scene, e);
				this.tiledBackgrounds.push(t)
			}
			initObjects() {
				for (const e of this.tilemap.objects) {
					const t = indexBy("name", e.properties, "value").get("depth") || 0;
					for (const i of e.objects) i.props = indexBy("name", i.properties, "value"), i.depth = t, this.allObjects.push(i), this.allObjectsById.set(i.id, i), i.gid && (i.tile = this.findTileByGid(i.gid), this.allProps.push(i))
				}
				for (const e of this.allProps) this.createProp(e);
				for (const e of this.allObjects) switch (e.type) {
					case "background":
						this.createBackground(e);
						break;
					case "block":
						this.createBlock(e);
						break;
					case "light":
						this.createLight(e);
						break;
					case "env_anim_simple":
						this.createSimpleAnimation(e, 6 - 1 / e.y + 10 * e.depth);
						break;
					default:
						e.type in Entities && this.createEntity(e)
				}
				this.entitiesById.forEach(e => e.init())
			}
			findTileByGid(e) {
				try {
					const t = this.tilemapRaw.tilesets.find(t => e >= t.firstgid && e <= t.lastgid),
						i = t.tiles.find(i => e === i.id + t.firstgid);
					return i.imageFrame = path.basename(i.image), i.imageKey = path.basename(path.dirname(i.image)), i
				} catch (e) {
					return console.error(e), {
						imageKey: "error"
					}
				}
			}
			createLight(e) {
				if (e.polygon && e.polygon.length) {
					const t = e.props.get("Layer1"),
						i = e.props.get("Layer2");
					this.lights.push({
						p: e.polygon.map(({
							x: t,
							y: i
						}) => ({
							x: t + e.x,
							y: i + e.y
						})),
						l1: t || void 0 === t,
						l2: i || void 0 === i
					})
				} else this.lights.push({
					x: e.x + e.width / 2,
					y: e.y + e.height / 2,
					r: e.width / 2
				})
			}
			createProp(e) {
				try {
					let t;
					if (0 !== e.rotation && e.rotation % 180 == 0 && (e.rotation / 180 % 2 && (e.flippedHorizontal = !e.flippedHorizontal, e.flippedVertical = !e.flippedVertical, e.x -= e.width, e.y += e.height), e.rotation = 0), e.tile) {
						const i = e.props.get("Animation");
						t = i ? this.scene.add.sprite(0, 0, this.atlasKey, e.tile.imageFrame).play(i) : this.scene.add.image(0, 0, this.atlasKey, e.tile.imageFrame)
					} else t = this.scene.add.image(0, 0, "");
					if (t.setPosition(e.x, e.y).setOrigin(0, 1).setDepth(6 - 1 / e.y + 10 * e.depth), e.flippedHorizontal && t.setFlipX(!0), e.flippedVertical && t.setFlipY(!0), this.props.add(t), e.tile && e.tile.objectgroup && e.tile.objectgroup.objects)
						for (const i of e.tile.objectgroup.objects) {
							const s = cloneDeep(i);
							switch (s.props = indexBy("name", s.properties, "value"), e.flippedHorizontal && (s.x = e.width - s.width - s.x), e.flippedVertical && (s.y = e.height - s.height - s.y), s.x += e.x, s.y += e.y - e.height, s.depth = e.depth, i.type) {
								case "block":
									this.createBlock(s);
									break;
								case "origin":
									t.setDepth(6 - 1 / s.y + 10 * e.depth);
									break;
								case "light":
									this.createLight(s);
									break;
								case "env_anim_simple":
									this.createSimpleAnimation(s, t.depth)
							}
						}
					e.gameObject = t
				} catch (e) {
					console.error("Failed to create prop", e)
				}
			}
			createSimpleAnimation(e, t) {
				const i = this.scene.add.sprite(e.x, e.y).setOrigin(.5, 1).setDepth(t).play(e.props.get("Animation"));
				this.props.add(i)
			}
			createBlock(e) {
				if (e.depth > 0) return;
				const t = this.scene.add.rectangle(e.x, e.y, e.width, e.height, 16711680).setAlpha(0).setOrigin(0, 0);
				if (this.scene.physics.world.enable(t, Phaser.Physics.Arcade.STATIC_BODY), this.collisions.add(t), e.props && e.props.get("HopDown")) {
					const t = this.scene.add.rectangle(e.x, e.y, e.width, 3, 6711039).setOrigin(0, 1).setAlpha(1).setDepth(DEBUG_DEPTH + 2);
					t.setData("type", "ledge"), t.setData("direction", Directions.DOWN), this.triggers.add(t)
				}
			}
			initTilemap() {
				this.tilemap = this.scene.make.tilemap({
					key: this.key
				}), this.tilemapRaw = this.scene.cache.tilemap.get(this.key).data, this.tilemapProps = indexBy("name", coerceArray(this.tilemap.properties), "value"), this.tilesets = indexBy("name", this.tilemap.tilesets), this.collisionsTileset = this.tilesets.get("collisions"), this.tilemap.addTilesetImage(this.tilesKey, this.tilesKey, 32, 32, 1, 2);
				for (const e of this.tilemap.layers) {
					const t = indexBy("name", e.properties, "value");
					if (t.get("collisions")) this.tilemap.createStaticLayer(e.name, null, 0, 0), this.tilemap.setCollision(this.collisionsTileset.firstgid, !0, !0, e.name), this.collisions.add(e.tilemapLayer), this.collisionsLayer = e;
					else {
						this.tilemap.createStaticLayer(e.name, [this.tilesKey], 0, 0).setDepth(t.get("depth") || 0)
					}
				}
			}
			getCollisionAt(e, t) {
				if (!this.collisionsLayer || !this.collisionsTileset) return;
				if (!this.collisionsLayer.data[t] || !this.collisionsLayer.data[t][e]) return;
				const i = this.collisionsLayer.data[t][e];
				return i ? i.index - this.collisionsTileset.firstgid : void 0
			}
			destroy() {
				for (this.allObjects = [], this.allObjectsById.clear(), this.props.destroy(!0), this.collisions.destroy(!0), this.triggers.destroy(!0), this.atmospherics.destroy(), this.tilemap.destroy(), this.entitiesById.forEach(e => e.destroy()); this.tiledBackgrounds.length;) this.tiledBackgrounds.pop().destroy()
			}
		}
		module.exports = WorldMap;

	}, {
		"../../shared/constants": 60,
		"./atmospherics": 5,
		"./entities": 8,
		"./tiled-background": 19,
		"eventemitter3": 47,
		"lodash.clonedeep": 50,
		"path": 53
	}],
	27: [function(require, module, exports) {
		"use strict";
		const meta = require("./meta.json"),
			Phaser = require("phaser/dist/phaser-arcade-physics.min.js"),
			NetPlugin = require("./plugins/net"),
			VortexEmbedPlugin = require("./plugins/vortex-embed"),
			AutoscalerPlugin = require("./plugins/autoscaler"),
			DynamicLoaderPlugin = require("./plugins/dynamic-loader"),
			PrefsPlugin = require("./plugins/prefs");
		VortexEmbedPlugin.addCss(window);
		const game = new Phaser.Game({
			version: meta.version,
			type: Phaser.WEBGL,
			render: {
				batchSize: 4096
			},
			banner: !1,
			scale: {
				mode: Phaser.Scale.FIT,
				parent: "mapapp",
				autoRound: !0
			},
			input: {
				gamepad: !0
			},
			loader: {
				baseURL: meta.staticUrl || window._livemap.assetUrl
			},
			physics: {
				default: "arcade"
			},
			fps: {
				target: 60,
				min: 1,
				panicMax: 10
			}
		});
		game.plugins.install("net", NetPlugin, !0, "net", {
			url: window._livemap.wsUrl,
			id: window._livemap.id,
			token: window._livemap.token,
			version: meta.version,
			document: window.document,
			debug: !1
		}), game.plugins.install("prefs", PrefsPlugin, !0, "prefs", {
			storage: window.localStorage,
			key: "_livemaps_prefs_",
			definitions: require("./prefs-defs")
		}), game.plugins.install("autoscaler", AutoscalerPlugin, !0, "autoscaler", {
			window: window
		}), game.plugins.install("vortex", VortexEmbedPlugin, !0, "vortex", {
			window: window
		}), game.plugins.installScenePlugin("DynamicLoader", DynamicLoaderPlugin, "dynamicLoader"), game.scene.add("BootstrapScene", require("./scenes/bootstrap")), game.scene.add("LoadingScene", require("./scenes/loading")), game.scene.add("MenuScene", require("./scenes/menu")), game.scene.add("WorldScene", require("./scenes/world")), game.scene.add("DebugScene", require("./scenes/debug")), game.scene.add("ControlsUIScene", require("./scenes/controlsui")), game.scene.add("GUIScene", require("./scenes/gui")), game.scene.add("DisconnectScene", require("./scenes/disconnect")), game.scene.start("BootstrapScene");

	}, {
		"./meta.json": 28,
		"./plugins/autoscaler": 29,
		"./plugins/dynamic-loader": 30,
		"./plugins/net": 31,
		"./plugins/prefs": 32,
		"./plugins/vortex-embed": 33,
		"./prefs-defs": 34,
		"./scenes/bootstrap": 35,
		"./scenes/controlsui": 36,
		"./scenes/debug": 37,
		"./scenes/disconnect": 38,
		"./scenes/gui": 39,
		"./scenes/loading": 40,
		"./scenes/menu": 41,
		"./scenes/world": 42,
		"phaser/dist/phaser-arcade-physics.min.js": 55
	}],
	28: [function(require, module, exports) {
		module.exports = {
			"version": "v1608671173230",
			"staticUrl": "https://storage.googleapis.com/livemaps-assets/v1608671173230"
		}

	}, {}],
	29: [function(require, module, exports) {
		const debounce = require("lodash.debounce"),
			MAX_DIM = 1920,
			MAX_DIM_CLASSIC = 1006;
		class AutoscalerPlugin extends Phaser.Plugins.BasePlugin {
			init({
				window: e
			}) {
				this.prefs = this.game.plugins.get("prefs"), this.window = e, this.resizeGameDebounced = debounce(() => this.resizeGame(), 50), e.addEventListener("resize", this.resizeGameDebounced, !0), e.addEventListener("orientationchange", this.resizeGameDebounced, !0)
			}
			getScale() {
				return Math.min(this.getResolutionMaxDim() / MAX_DIM, 1)
			}
			getResolutionMaxDim() {
				return this.prefs.get("resolutionMaxDim")
			}
			resizeGame() {
				if (this.prefs.get("embedFullscreen")) {
					let e = this.window.innerWidth / this.window.devicePixelRatio,
						i = this.window.innerHeight / (1 / this.window.devicePixelRatio),
						t = this.getResolutionMaxDim() / Math.max(this.window.devicePixelRatio, 1),
						s = this.window.innerWidth / this.window.innerHeight,
						n = this.window.innerHeight / this.window.innerWidth;
					const h = this.window.document.getElementById(this.game.config.parent);
					h && (e = h.offsetWidth / this.window.devicePixelRatio, i = h.offsetHeight / (1 / this.window.devicePixelRatio), s = h.offsetWidth / h.offsetHeight, n = h.offsetHeight / h.offsetWidth);
					let o, a, d = Math.min(Math.max(e, i), t);
					if (s > n ? (o = d, a = d * n) : (o = d * s, a = d), o <= 0 || a <= 0) return;
					this.game.scale.scaleMode = Phaser.Scale.FIT, this.game.scale.setGameSize(o, a)
				} else this.game.scale.setGameSize(MAX_DIM_CLASSIC * this.getScale(), MAX_DIM_CLASSIC / 2 * this.getScale());
				this.game.scale.refresh()
			}
		}
		module.exports = AutoscalerPlugin;

	}, {
		"lodash.debounce": 51
	}],
	30: [function(require, module, exports) {
		class DynamicLoader extends Phaser.Plugins.ScenePlugin {
			constructor(e, s) {
				super(e, s), this.retries = 3, this.loadCache = DynamicLoader.loadCache
			}
			async _loadAsset(e) {
				return new Promise((s, a) => {
					let t = 0;

					function r() {
						t++
					}
					switch (this.scene.load.on(Phaser.Loader.Events.ADD, r), e.type) {
						case "tilemapJSON":
							this.scene.load.tilemapTiledJSON(e);
							break;
						default:
							this.scene.load[e.type](e)
					}
					if (this.scene.load.off(Phaser.Loader.Events.ADD, r), !t) return s(e.key);
					this.scene.load.on(Phaser.Loader.Events.FILE_LOAD_ERROR, i), this.scene.load.on(Phaser.Loader.Events.FILE_COMPLETE, n), this.scene.load.start();
					const o = () => {
						this.scene.load.off(Phaser.Loader.Events.FILE_LOAD_ERROR, i), this.scene.load.off(Phaser.Loader.Events.FILE_COMPLETE, n)
					};

					function n(a, t) {
						a === e.key && (o(), s(e.key))
					}

					function i(s) {
						s.key === e.key && (o(), a(Error(`Asset load error: ${e.type}/${e.key} : ${s.src}`)))
					}
				})
			}
			async loadAsset(e) {
				const s = `${e.type};${e.key}`;
				let a = this.loadCache.get(s);
				return a || (a = new Promise(async (t, r) => {
					let o;
					for (let r = 0; r < this.retries; r++) try {
						const r = await this._loadAsset(e);
						return this.loadCache.delete(s, a), t(r)
					} catch (e) {
						o = e
					}
					this.loadCache.delete(s, a), r(o)
				}), this.loadCache.set(s, a)), a
			}
			async load(e) {
				return Array.isArray(e) || (e = [e]), Promise.all(e.map(e => this.loadAsset(e)))
			}
			async loadZone(e) {
				const s = `${e}_worldmap`,
					a = `${e}_tiles`,
					t = `${e}_atlas`,
					r = [];
				return this.scene.cache.tilemap.has(s) || r.push({
					type: "tilemapJSON",
					key: s,
					url: `maps/${e}/${e}.json`
				}), this.scene.textures.list[a] || r.push({
					type: "image",
					key: a,
					url: `maps/${e}/${e}_tiles.png`
				}), this.scene.cache.json.has(t) || r.push({
					type: "atlas",
					key: t,
					atlasURL: `maps/${e}/${e}_atlas.json`,
					textureURL: `maps/${e}/${e}_atlas.png`
				}), this.load(r)
			}
		}
		DynamicLoader.loadCache = new Map, DynamicLoader.register = function(e) {
			e.register("DynamicLoader", DynamicLoader, "dynamicLoader")
		}, module.exports = DynamicLoader;

	}, {}],
	31: [function(require, module, exports) {
		(function(Buffer) {
			const netMessages = require("../../shared/net-messages"),
				eventStapler = require("eventstapler"),
				EventEmitter = require("eventemitter3"),
				RECONNECT_MS = 1e3,
				DESYNC_MS = 3e3;
			class NetPlugin extends Phaser.Plugins.BasePlugin {
				constructor(...e) {
					super(...e), EventEmitter.call(this), this.resetQueues()
				}
				get isWindowHidden() {
					return this.document.hidden
				}
				get isConnecting() {
					return this.ws && this.ws.readyState === WebSocket.CONNECTING
				}
				get isConnected() {
					return this.ws && this.ws.readyState === WebSocket.OPEN
				}
				get isClosing() {
					return this.ws && this.ws.readyState === WebSocket.CLOSING
				}
				get isClosed() {
					return !this.ws || this.ws.readyState === WebSocket.CLOSED
				}
				init({
					id: e,
					token: t,
					url: s,
					version: n,
					document: i,
					debug: o
				}) {
					this.url = s, this.id = e, this.token = t, this.version = n, this.debug = !!o, this.document = i, this.connectionFailures = 0, this.connect()
				}
				resetQueues() {
					this.inboundQueue = [], this.outboundQueue = []
				}
				connect() {
					if (this.isConnecting || this.isConnected) return;
					this.autoReconnect = !0, this.wsEvents && (this.wsEvents.release(), this.wsEvents = null);
					const e = new URL(this.url);
					e.searchParams.set("version", this.version), this.id && this.token && (e.searchParams.set("id", this.id), e.searchParams.set("token", this.token)), this.ws = new WebSocket(e.href), this.ws.binaryType = "arraybuffer", this.wsEvents = eventStapler(this.ws).on("open", this.onWsOpen, this).on("close", this.onWsClose, this).on("error", this.onWsError, this).on("message", this.onWsMessage, this).releaseAfter("close")
				}
				close(e, t) {
					this.autoReconnect = !1, this.reconnectTimeout && clearTimeout(this.reconnectTimeout), this.ws && this.ws.close(e, t)
				}
				send(e, t) {
					this.debug && console.log(">>", e, t);
					const s = netMessages.encode(e, t);
					this.isConnected ? this.ws.send(s) : this.outboundQueue.push(s)
				}
				readInboundQueue(e) {
					if (this.isWindowHidden) return;
					let t = !1;
					if (this.lastInboundQueueRead) {
						e - this.lastInboundQueueRead > DESYNC_MS && (t = !0)
					}
					for (this.lastInboundQueueRead = e; this.inboundQueue.length > 0;) {
						const [e, s, n] = this.inboundQueue.shift();
						t && !e || (this.debug && console.log("<<", s, n), this.emit(s, n), s === NetPlugin.DISCONNECT && this.autoReconnect && (this.reconnectTimeout = setTimeout(() => {
							this.autoReconnect && this.connect()
						}, RECONNECT_MS)))
					}
					t && (console.error("Network desync"), this.resetQueues(), this.emit(NetPlugin.DESYNC))
				}
				onWsOpen(e) {
					for (this.connectionFailures = 0; this.outboundQueue.length;) this.ws.send(this.outboundQueue.shift());
					this.inboundQueue.push([!0, NetPlugin.CONNECT, e])
				}
				onWsClose(e) {
					const t = {
						code: e.code,
						failures: ++this.connectionFailures
					};
					this.inboundQueue.push([!0, NetPlugin.DISCONNECT, t])
				}
				onWsError(e) {
					this.inboundQueue.push([!0, NetPlugin.ERROR, e])
				}
				onWsMessage(e) {
					try {
						const {
							key: t,
							data: s
						} = netMessages.decode(Buffer.from(e.data));
						this.inboundQueue.push([!1, t, s])
					} catch (e) {
						this.onWsError(e)
					}
				}
			}
			NetPlugin.CONNECT = Symbol("CONNECT"), NetPlugin.DISCONNECT = Symbol("DISCONNECT"), NetPlugin.ERROR = Symbol("ERROR"), NetPlugin.DESYNC = Symbol("DESYNC"), Object.assign(NetPlugin.prototype, EventEmitter.prototype), module.exports = NetPlugin;

		}).call(this, require("buffer").Buffer)
	}, {
		"../../shared/net-messages": 61,
		"buffer": 46,
		"eventemitter3": 47,
		"eventstapler": 48
	}],
	32: [function(require, module, exports) {
		class PrefsPlugin extends Phaser.Plugins.BasePlugin {
			init({
				storage: e,
				key: t,
				definitions: s
			}) {
				this.storage = e, this.key = t, this.data = {}, this.defs = new Map;
				for (const e of s) this.defs.set(e.key, e), this.set(e.key, e.defaultValue, !1);
				try {
					const e = JSON.parse(this.storage[this.key]);
					if ("object" != typeof e) throw Error("Saved data is not an object");
					for (const [t, s] of Object.entries(e)) this.set(t, s, !1)
				} catch (e) {}
			}
			get(e) {
				return this.data[e]
			}
			set(e, t, s = !0) {
				const a = this.defs.get(e);
				a ? typeof t === a.type ? a.fixedSet && -1 === a.fixedSet.indexOf(t) ? console.warn("Cannot set preference outside of fixed set", {
					key: e,
					value: t,
					def: a
				}) : "number" === a.type && (void 0 !== a.max && (t = Math.min(t, a.max)), void 0 !== a.min && (t = Math.max(t, a.min)), Number.isNaN(t) || t === 1 / 0) ? console.warn("Cannot set unserialisable value", {
					key: e,
					value: t
				}) : (this.data[e] = t, s && this.save()) : console.warn("Cannot set preference of invalid type", {
					key: e,
					value: t,
					def: a
				}) : console.warn("Cannot set undefined preference", {
					key: e,
					value: t
				})
			}
			save() {
				this.storage[this.key] = JSON.stringify(this.data)
			}
		}
		module.exports = PrefsPlugin;

	}, {}],
	33: [function(require, module, exports) {
		class VortexEmbedPlugin extends Phaser.Plugins.BasePlugin {
			init({
				window: n
			}) {
				this.prefs = this.game.plugins.get("prefs"), this.window = n, this.document = n.document, this.registerHandlers(), this.setEmbedFullscreen(this.prefs.get("embedFullscreen"))
			}
			registerHandlers() {
				this.game.canvas.addEventListener("contextmenu", n => n.preventDefault()), this.document.addEventListener("click", n => {
					const e = n.target === this.game.canvas;
					this.game.input.keyboard.enabled = e
				}), this.window.addEventListener("mousewheel", n => {
					n.target === this.game.canvas && n.preventDefault()
				}, {
					passive: !1
				})
			}
			setEmbedFullscreen(n) {
				const e = this.document.querySelector("html");
				n ? (e.classList.remove("lm-classic"), e.classList.add("lm-fullscreen")) : (e.classList.remove("lm-fullscreen"), e.classList.add("lm-classic"))
			}
			static addCss(n) {
				const e = n.document.createElement("style");
				e.appendChild(n.document.createTextNode("\n            #content {\n                padding: 168px 0 0 0;\n                margin: 0;\n                width: 100%;\n            }\n            #mapapp {\n                height: 503px;\n                height: min(503px, 100% - 163px) !important;\n                width: 1006px;\n                background: black;\n                position: relative;\n            }\n\n            html.lm-fullscreen {\n                height: 100%;\n            }\n            body {\n                overflow: initial;\n            }\n            html.lm-fullscreen body {\n                overflow: hidden;\n            }\n            html.lm-fullscreen body {\n                height: 100%;\n                width: initial;\n                min-width: 1006px;\n            }\n            html.lm-fullscreen #top {\n                position: absolute;\n                max-width: none;\n                height: initial;\n                top: 0;\n            }\n            html.lm-fullscreen #content {\n                width: 100%;\n                max-width: 100%;\n                height: 100%;\n                margin: 0;\n                padding: 168px 0 0;\n                position: absolute;\n                top: 0;\n                bottom: 0;\n                left: 0;\n                right: 0;\n            }\n            html.lm-fullscreen #mapapp {\n                height: 100% !important;\n                width: 100%;\n            }\n            html.lm-fullscreen #disclaimer-container {\n                display: none;\n            }\n            html.lm-fullscreen #logo {\n                float: initial;\n                position: absolute;\n                left: 55px;\n            }\n            html.lm-fullscreen .navbar-top-container-inner {\n                margin: 0 auto;\n                position: relative;\n            }\n            html.lm-fullscreen .leftCol {\n                left: 50px;\n            }\n        ")), n.document.body.appendChild(e)
			}
		}
		module.exports = VortexEmbedPlugin;

	}, {}],
	34: [function(require, module, exports) {
		module.exports = [{
			key: "embedFullscreen",
			type: "boolean",
			defaultValue: !0
		}, {
			key: "resolutionMaxDim",
			type: "number",
			fixedSet: [1920, 1463, 1006],
			defaultValue: 1920
		}, {
			key: "targetZoom",
			type: "number",
			max: 2,
			min: 1,
			defaultValue: 1.2
		}];

	}, {}],
	35: [function(require, module, exports) {
		class BootstrapScene extends Phaser.Scene {
			create() {
				this.autoscaler.resizeGame();
				try {
					window.addEventListener("vortex_session_expired", () => {
						this.net.setAutoReconnect(!1), this.net.disconnect(), this.scene.start("DisconnectScene", {
							title: "Session Expired",
							description: "Please log back in",
							code: DisconnectCodes.SESSION_EXPIRED
						})
					})
				} catch (e) {}
				this.load.spritesheet({
					key: "throbber",
					url: "assets/images/misc/throbber.png",
					frameConfig: {
						frameWidth: 44,
						frameHeight: 44
					}
				}), this.load.on(Phaser.Loader.Events.COMPLETE, this.onLoadComplete, this), this.load.on(Phaser.Loader.Events.FILE_LOAD_ERROR, this.onFileLoadError, this), this.load.start()
			}
			onFileLoadError(e) {
				console.log("File load error:", e.src), alert("File load error: " + e.src)
			}
			onLoadComplete() {
				this.anims.create({
					key: "throbberAnim",
					frames: this.anims.generateFrameNumbers("throbber", {
						start: 0,
						end: 7
					}),
					frameRate: 16,
					repeat: -1
				}), this.scene.stop(), this.scene.start("LoadingScene")
			}
		}
		module.exports = BootstrapScene;

	}, {}],
	36: [function(require, module, exports) {
		const VPAD_SIZE = 70;
		class ControlsUIScene extends Phaser.Scene {
			create({
				controls: t
			}) {
				this.controls = t, this.vpadScale = 1, this.vpad = {
					back: this.add.circle(0, 0, 1.5 * VPAD_SIZE, 0).setAlpha(0),
					stick: this.add.circle(0, 0, .7 * VPAD_SIZE, 0).setAlpha(0),
					x: 0,
					y: 0,
					active: !1
				}, this.input.on(Phaser.Input.Events.POINTER_DOWN, this.showVPad, this), this.input.on(Phaser.Input.Events.POINTER_UP, this.hideVPad, this), this.input.on(Phaser.Input.Events.POINTER_UP_OUTSIDE, this.hideVPad, this)
			}
			update() {
				const t = this.controls.ctrl.pointer;
				if (t.x = 0, t.y = 0, t.m = 0, !this.vpad.active) return;
				const s = this.input.activePointer;
				if (s.isDown) {
					const i = s.x - this.vpad.x,
						a = s.y - this.vpad.y,
						e = Math.sqrt(i * i + a * a),
						h = i / e || 0,
						c = a / e || 0;
					Math.sqrt(h * h + c * c);
					t.x = h, t.y = c, t.m = Math.min(e / VPAD_SIZE / this.vpadScale, 1), this.vpad.stick.setPosition(this.vpad.x + h * t.m * VPAD_SIZE * this.vpadScale, this.vpad.y + c * t.m * VPAD_SIZE * this.vpadScale)
				} else this.hideVPad()
			}
			showVPad(t) {
				this.vpadScale = this.autoscaler.getScale(), this.vpad.active || (this.vpad.active = !0, this.vpad.x = t.x, this.vpad.y = t.y, this.vpad.back.setScale(this.vpadScale).setAlpha(.2).setPosition(t.x, t.y), this.vpad.stick.setScale(this.vpadScale).setAlpha(.2).setPosition(t.x, t.y))
			}
			hideVPad(t) {
				this.vpad.active && (this.vpad.active = !1, this.vpad.back.setAlpha(0), this.vpad.stick.setAlpha(0))
			}
		}
		module.exports = ControlsUIScene;

	}, {}],
	37: [function(require, module, exports) {
		class DebugScene extends Phaser.Scene {
			init() {}
			create() {}
			update(e, c) {}
		}
		module.exports = DebugScene;

	}, {}],
	38: [function(require, module, exports) {
		const {
			DisconnectCodes: DisconnectCodes,
			DisconnectLookup: DisconnectLookup
		} = require("../../shared/constants");
		class DisconnectScene extends Phaser.Scene {
			create(t) {
				t && t.code || (t = DisconnectLookup(DisconnectCodes.GENERIC)), this.txtTitle = this.add.text(0, 0, t.title, {
					color: "#fff",
					align: "center",
					fontSize: "28px",
					fontFamily: "Impact, Arial"
				}).setOrigin(.5, 0), this.txtDesc = this.add.text(0, 0, t.description, {
					color: "#fff",
					align: "center",
					fontSize: "18px",
					fontFamily: "Arial"
				}).setOrigin(.5, 0), this.scale.on(Phaser.Scale.Events.RESIZE, this.onResize, this), this.onResize(), t.autoReload && setTimeout(() => {
					window.location.reload()
				}, 2e3)
			}
			onResize() {
				const t = this.cameras.main;
				this.txtTitle.x = t.width / 2, this.txtTitle.y = t.height / 3, this.txtTitle.setWordWrapWidth(.8 * t.width, !0), this.txtDesc.x = t.width / 2, this.txtDesc.y = this.txtTitle.y + this.txtTitle.height + 20, this.txtDesc.setWordWrapWidth(.8 * t.width, !0)
			}
		}
		module.exports = DisconnectScene;

	}, {
		"../../shared/constants": 60
	}],
	39: [function(require, module, exports) {
		const EncounterProfile = require("../gameobjects/ui/encounter-profile"),
			ZoneLabel = require("../gameobjects/ui/zone-label"),
			TextFrame = require("../gameobjects/ui/text-frame"),
			UIClock = require("../gameobjects/ui/clock"),
			SystemMessages = require("../gameobjects/ui/system-messages"),
			InteractionHighlight = require("../gameobjects/ui/interaction-highlight"),
			eventStapler = require("eventstapler"),
			ExtUI = require("../extui"),
			NAMETAG = Symbol("NAMETAG"),
			TEXT = Symbol("TEXT"),
			BG = Symbol("BG"),
			GUIDepth = ["InteractionHighlight", "SystemMessages", "TextFrame", "ZoneLabel", "Clock", "SettingsButton", "EncounterProfile"].reduce((e, t, s) => (e[t] = s, e), {});
		class GUIScene extends Phaser.Scene {
			init() {}
			create() {
				this._uiSingletons = new Map, this.trainers = new Set, this.worldScene = this.scene.get("WorldScene"), this.worldCam = this.worldScene.cameras.main, this.worldScene.events.on("trainerLoaded", this.onTrainerLoaded, this), this.worldScene.events.on("trainerUnloaded", this.onTrainerUnloaded, this), this.worldScene.events.on("wildEncounter", this.onWildEncounter, this), this.worldScene.events.on(Phaser.Scenes.Events.SHUTDOWN, this.worldShutdown, this), this.scale.on(Phaser.Scale.Events.RESIZE, this.onResize, this), this.encounterProfile = new EncounterProfile(this), this.add.existing(this.encounterProfile), this.encounterProfile.setAlpha(0).setDepth(3), this.clock = new UIClock(this, 0, 0), this.clock.setDepth(GUIDepth.Clock), this.worldScene.events.on("clock", this.clock.setClock, this.clock), this.settingsButton = this.add.image(0, 0, "ui_icons", 2), this.settingsButton.setDepth(GUIDepth.SettingsButton).setOrigin(1, 0), this.settingsButton.setInteractive({
					cursor: "pointer"
				}), this.settingsButton.setAlpha(.75), this.settingsButton.on("pointerdown", this.openGraphicsSettings, this), this.fpsCounter = this.add.bitmapText(50, 50, "dp", "FPS:", 25).setOrigin(0).setVisible(!1), this.settingsButton.on("pointerover", e => {
					this.settingsButton.setFrame(3), this.settingsButton.setAlpha(1), this.fpsCounter.setVisible(!0)
				}), this.settingsButton.on("pointerout", e => {
					this.settingsButton.setFrame(2), this.settingsButton.setAlpha(.75), this.fpsCounter.setVisible(!1)
				}), this.zoneLabel = new ZoneLabel(this, 0, 0), this.zoneLabel.setDepth(GUIDepth.ZoneLabel), this.worldScene.events.on("zoneInit", this.onZoneInit, this), this.textFrame = new TextFrame(this, 0, 0), this.textFrame.setDepth(GUIDepth.TextFrame), this.interactionHighlight = new InteractionHighlight(this, 0, 0), this.interactionHighlight.setDepth(GUIDepth.InteractionHighlight), this.systemMessages = new SystemMessages(this, 0, 0), this.systemMessages.setDepth(GUIDepth.SystemMessages), this.onResize()
			}
			getPointerEventCoords(e) {
				const t = e.touches && e.touches.length ? e.touches[0] : e;
				return {
					x: t.clientX,
					y: t.clientY
				}
			}
			openSingletonUI(e, t) {
				let s = this._uiSingletons.get(e);
				return s || (s = this.openUI(e, t, () => {
					this._uiSingletons.delete(e)
				}), this._uiSingletons.set(e, s)), s
			}
			openUI(e, t, s) {
				if (!(e in ExtUI)) throw Error(`${e} template not found in ExtUI`);
				const i = new ExtUI[e]({
					target: window.document.body,
					props: t
				});
				let n = {
					modal: i,
					on: (e, t) => (i.$on(e, e => t(e, n)), n),
					close: () => {
						i.$destroy(), s && s()
					}
				};
				return n.on("cancel", (e, t) => t.close()), n
			}
			openGraphicsSettings(e, t, s) {
				return this.openSingletonUI("GraphicsSettings", {
					openAt: this.getPointerEventCoords(e.event),
					resolutions: [{
						name: "High",
						value: 1920
					}, {
						name: "Medium",
						value: 1463
					}, {
						name: "Low",
						value: 1006
					}],
					embedFullscreen: this.prefs.get("embedFullscreen"),
					resolutionMaxDim: this.prefs.get("resolutionMaxDim")
				}).on("save", (e, t) => {
					this.prefs.set("embedFullscreen", e.detail.embedFullscreen), this.prefs.set("resolutionMaxDim", e.detail.resolutionMaxDim), t.close(), window.location.reload()
				})
			}
			highlightInteractable(e, t) {
				e ? this.interactionHighlight.show(e, t) : this.interactionHighlight.hide()
			}
			onZoneInit(e) {
				const t = e.tilemapProps.get("Name");
				"" !== t && this.zoneLabel.show({
					text: t || e.key,
					background: e.tilemapProps.get("NameBg") || 0,
					tween: {
						from: 0,
						to: 1,
						yoyo: !0,
						duration: 500,
						hold: 2e3
					}
				})
			}
			resizeEncounter(e, t) {
				this.isPortrait = t;
				let s = e.height / 600;
				s <= 1 && !t ? (s = Math.max(e.height / 300, 1), this.encounterProfile.setPosition(e.width / 4, e.height / 3)) : this.encounterProfile.setPosition(e.width / 2, e.height / 10), this.encounterProfile.setScale(s)
			}
			resizeSettingsButton(e, t) {
				this.settingsButton.setScale(.5 * this.clock.scale), this.settingsButton.setPosition(e.width, this.clock.y + this.clock.height), this.fpsCounter.setScale(.8 * this.clock.scale).setPosition(this.clock.x + 7, this.settingsButton.y)
			}
			resizeClock(e, t) {
				this.clock.setScale(Math.max(e.width / 1200, 1)), this.clock.setPosition(e.width - this.clock.width, 0)
			}
			resizeZoneLabel(e, t) {
				let s = Math.min(e.width / this.zoneLabel.nativeWidth, e.height / 200, 2.5);
				this.zoneLabel.setScale(s), this.zoneLabel.x = e.width / 2
			}
			resizeTextFrame(e, t) {
				let s = Math.min(e.width / 256, e.height / 200, 2.5);
				this.textFrame.setPosition(e.width / 2, .7 * e.height).setScale(s)
			}
			resizeSystemMessages(e, t) {
				this.systemMessages.setWidth(e.width)
			}
			onResize() {
				const e = this.cameras.main,
					t = e.height > e.width;
				this.resizeEncounter(e, t), this.resizeClock(e, t), this.resizeSettingsButton(e, t), this.resizeZoneLabel(e, t), this.resizeTextFrame(e, t), this.resizeSystemMessages(e, t)
			}
			tweenEncounterUI(e) {
				this.encounterVisTween && this.encounterVisTween.stop(), this.encounterVisTween = this.tweens.add({
					targets: this.encounterProfile,
					alpha: e,
					duration: 200
				})
			}
			onWildEncounter(e) {
				e ? (this.tweenEncounterUI(1), this.encounterProfile.setEncounter(e), this.onResize()) : (this.tweenEncounterUI(0), this.encounterProfile.setEncounter(null))
			}
			onTrainerLoaded(e) {
				const t = this.add.container(0, 0);
				t[TEXT] = this.add.bitmapText(0, 0, "dp", "", 18), t[BG] = this.add.rectangle(0, 4, 0, 0, 16777215, .5), t.add(t[BG]), t.add(t[TEXT]), e[NAMETAG] = t, this.trainers.add(e), e.on("update", t => this.onTrainerUpdate({
					trainer: e,
					trainerData: t
				}))
			}
			onTrainerUpdate({
				trainer: e,
				trainerData: t
			}) {
				const s = e[NAMETAG];
				s[TEXT].setText(e.playerData.username).setCenterAlign().setOrigin(.5), s[BG].setSize(s[TEXT].width + 10, s[TEXT].height + 7).setOrigin(.5, .5)
			}
			onTrainerUnloaded(e) {
				this.trainers.delete(e);
				const t = e[NAMETAG];
				t && (t.destroy(), e[NAMETAG] = null)
			}
			updateViewport(e, t, s) {
				for (const t of this.trainers) e.fromWorldCoords(t.vis.x, t.vis.y - 50, t[NAMETAG]);
				this.zoneLabel.y = this.zoneLabel.getTweenProgress() * this.zoneLabel.height - this.zoneLabel.height / 2, this.interactionHighlight.update(e, t, s)
			}
			update() {
				this.fpsCounter.visible && this.fpsCounter.setText("FPS: " + this.game.loop.actualFps.toFixed(2))
			}
			worldShutdown() {
				this.scene.stop()
			}
			displaySysMessage(e) {
				this.systemMessages.display(e)
			}
			shutdown() {
				console.log("GUI shutdown")
			}
		}
		module.exports = GUIScene;

	}, {
		"../extui": 4,
		"../gameobjects/ui/clock": 20,
		"../gameobjects/ui/encounter-profile": 21,
		"../gameobjects/ui/interaction-highlight": 22,
		"../gameobjects/ui/system-messages": 23,
		"../gameobjects/ui/text-frame": 24,
		"../gameobjects/ui/zone-label": 25,
		"eventstapler": 48
	}],
	40: [function(require, module, exports) {
		const assetIndex = require("../assets.json"),
			assets = {
				bitmapFonts: [],
				spritesheets: [{
					key: "particles_4x4",
					url: "assets/images/effects/particles-4x4.png",
					frameConfig: {
						frameWidth: 8,
						frameHeight: 8,
						margin: 1,
						spacing: 2
					}
				}, {
					key: "particles_8x8",
					url: "assets/images/effects/particles-8x8.png",
					frameConfig: {
						frameWidth: 16,
						frameHeight: 16,
						margin: 1,
						spacing: 2
					}
				}, {
					key: "particles_32x32",
					url: "assets/images/effects/particles-32x32.png",
					frameConfig: {
						frameWidth: 64,
						frameHeight: 64,
						margin: 1,
						spacing: 2
					}
				}, {
					key: "particles_48x48",
					url: "assets/images/effects/particles-48x48.png",
					frameConfig: {
						frameWidth: 96,
						frameHeight: 96,
						margin: 1,
						spacing: 2
					}
				}, {
					key: "misc_64x64",
					url: "assets/images/effects/misc-64x64.png",
					frameConfig: {
						frameWidth: 128,
						frameHeight: 128,
						margin: 1,
						spacing: 2
					}
				}, {
					key: "mobs_trainers1",
					url: "assets/images/mobs/trainers1.png",
					frameConfig: {
						frameWidth: 48,
						frameHeight: 48,
						margin: 1,
						spacing: 2
					}
				}, {
					key: "mobs_trainers2",
					url: "assets/images/mobs/trainers2.png",
					frameConfig: {
						frameWidth: 48,
						frameHeight: 48,
						margin: 1,
						spacing: 2
					}
				}, {
					key: "mobs_trainers1_masked",
					url: "assets/images/mobs/trainers1_masked.png",
					frameConfig: {
						frameWidth: 48,
						frameHeight: 48,
						margin: 1,
						spacing: 2
					}
				}, {
					key: "mobs_trainers2_masked",
					url: "assets/images/mobs/trainers2_masked.png",
					frameConfig: {
						frameWidth: 48,
						frameHeight: 48,
						margin: 1,
						spacing: 2
					}
				}, {
					key: "mobs_mounts",
					url: "assets/images/mobs/mounts.png",
					frameConfig: {
						frameWidth: 64,
						frameHeight: 64,
						margin: 1,
						spacing: 2
					}
				}, {
					key: "ui_battle-button",
					url: "assets/images/ui/battle-button.png",
					frameConfig: {
						frameWidth: 115,
						frameHeight: 35
					}
				}, {
					key: "ui_platforms",
					url: "assets/images/ui/platforms.png",
					frameConfig: {
						frameWidth: 128,
						frameHeight: 64
					}
				}, {
					key: "ui_gender",
					url: "assets/images/ui/gender.png",
					frameConfig: {
						frameWidth: 16,
						frameHeight: 16
					}
				}, {
					key: "ui_clock",
					url: "assets/images/ui/clock.png",
					frameConfig: {
						frameWidth: 128,
						frameHeight: 48
					}
				}, {
					key: "ui_zone-labels",
					url: "assets/images/ui/zone-labels.png",
					frameConfig: {
						frameWidth: 136,
						frameHeight: 32
					}
				}, {
					key: "ui_text-frames",
					url: "assets/images/ui/text-frames.png",
					frameConfig: {
						frameWidth: 256,
						frameHeight: 48
					}
				}, {
					key: "ui_text-frames-icons",
					url: "assets/images/ui/text-frames-icons.png",
					frameConfig: {
						frameWidth: 48,
						frameHeight: 36
					}
				}, {
					key: "ui_icons",
					url: "assets/images/ui/ui-icons.png",
					frameConfig: {
						frameWidth: 48,
						frameHeight: 48,
						margin: 0,
						spacing: 0
					}
				}, {
					key: "backgrounds",
					url: "assets/images/tilesets/backgrounds.png",
					frameConfig: {
						frameWidth: 32,
						frameHeight: 32,
						margin: 1,
						spacing: 2
					}
				}],
				images: [{
					key: "error",
					url: "assets/images/misc/error.png"
				}, {
					key: "encounter-alert",
					url: "assets/images/misc/encounter-alert.png"
				}, {
					key: "mask_tallgrass",
					url: "assets/images/masks/tallgrass.png"
				}],
				audio: [],
				tilemaps: [],
				atlases: []
			};
		assets.images.push(...assetIndex.images), assets.atlases.push(...assetIndex.atlases), assets.bitmapFonts.push(...assetIndex.bitmapFonts);
		class LoadingScene extends Phaser.Scene {
			create() {
				const e = this.cameras.main,
					a = e.width / 2,
					s = e.height / 2;
				this.add.text(a, s + 25, "LOADING", {
					fontFamily: "Arial",
					fontSize: "12px"
				}).setOrigin(.5, 0), this.add.sprite(a, s, "throbber").play("throbberAnim"), this.add.rectangle(a, s + 56, 70, 12, 16777215), this.add.rectangle(a, s + 56, 68, 10, 0);
				let t = this.add.rectangle(a - 33, s + 56, 1, 8, 16777215).setOrigin(0, .5);
				this.load.on(Phaser.Loader.Events.PROGRESS, e => {
					t.width = 66 * e
				}), this.load.on(Phaser.Loader.Events.COMPLETE, this.loaded, this);
				for (const e of assets.bitmapFonts) this.load.bitmapFont(e);
				for (const e of assets.spritesheets) this.load.spritesheet(e);
				for (const e of assets.images) this.load.image(e);
				for (const e of assets.audio) this.load.audio(e);
				for (const e of assets.tilemaps) this.load.tilemapTiledJSON(e);
				for (const e of assets.atlases) this.load.atlas(e);
				this.load.start(), this.cameras.main.setZoom(Math.max(this.cameras.main.height / 448, this.cameras.main.width / 2560))
			}
			loaded() {
				const e = [{
					key: "walk.down",
					frames: [1, 0, 2, 0],
					frameRate: 6,
					repeat: -1
				}, {
					key: "walk.up",
					frames: [4, 3, 5, 3],
					frameRate: 6,
					repeat: -1
				}, {
					key: "walk.left",
					frames: [7, 6, 8, 6],
					frameRate: 6,
					repeat: -1
				}, {
					key: "stand.down",
					frames: [0],
					frameRate: 1,
					repeat: 0
				}, {
					key: "stand.up",
					frames: [3],
					frameRate: 1,
					repeat: 0
				}, {
					key: "stand.left",
					frames: [6],
					frameRate: 1,
					repeat: 0
				}];
				for (let a = 0; a < 80; a++)
					for (let s of e) {
						const e = a % 40 * 9,
							t = s.frames.map(a => a + e);
						this.anims.create({
							key: `trainer${a+1}.${s.key}`,
							frames: this.anims.generateFrameNames("mobs_trainers" + (Math.floor(a / 40) + 1), {
								frames: t
							}),
							frameRate: s.frameRate || 1,
							repeat: s.repeat || 0
						}), this.anims.create({
							key: `trainer${a+1}masked.${s.key}`,
							frames: this.anims.generateFrameNames("mobs_trainers" + (Math.floor(a / 40) + 1) + "_masked", {
								frames: t
							}),
							frameRate: s.frameRate || 1,
							repeat: s.repeat || 0
						})
					}
				this.anims.create({
					key: "effect_dustmote",
					frames: this.anims.generateFrameNames("particles_8x8", {
						frames: [0, 1, 2]
					}),
					frameRate: 8,
					repeat: 0
				}), this.anims.create({
					key: "effect_flame_candle",
					frames: this.anims.generateFrameNames("particles_8x8", {
						frames: [12, 13, 14, 15]
					}),
					frameRate: 4,
					repeat: -1
				}), this.anims.create({
					key: "effect_flame_brazier",
					frames: this.anims.generateFrameNames("particles_32x32", {
						frames: [0, 1, 2, 3, 4]
					}),
					frameRate: 7,
					repeat: -1
				}), this.anims.create({
					key: "prop_fountain",
					frames: this.anims.generateFrameNames("misc_64x64", {
						frames: [0, 1, 2, 3, 4]
					}),
					frameRate: 10,
					repeat: -1
				}), this.scene.stop(), this.scene.start("WorldScene")
			}
		}
		module.exports = LoadingScene;

	}, {
		"../assets.json": 1
	}],
	41: [function(require, module, exports) {
		class MenuScene extends Phaser.Scene {
			init() {}
			create() {}
		}
		module.exports = MenuScene;

	}, {}],
	42: [function(require, module, exports) {
		const Trainer = require("../gameobjects/mobiles/trainer"),
			WorldMap = require("../gameobjects/world-map"),
			ParticleEffects = require("../gameobjects/particle-effects"),
			Controls = require("../util/controls"),
			Viewport = require("../util/viewport"),
			{
				DisconnectCodes: DisconnectCodes,
				DisconnectLookup: DisconnectLookup
			} = require("../../shared/constants"),
			PortalEntity = require("../gameobjects/entities/portal"),
			eventStapler = require("eventstapler"),
			NetPlugin = require("../plugins/net"),
			FADE_INTERVAL = 150,
			TRIGGER_OVERLAP = Symbol("TRIGGER_OVERLAP"),
			PHYS_DELTA_MINIMUM = 1 / 60 * 1e3,
			FOV_TILE_SIZE = 32,
			FOV_MAX_HEIGHT = 544,
			FOV_MAX_WIDTH = 1360;
		class WorldScene extends Phaser.Scene {
			create() {
				this.initZoom(), this.scene.launch("DebugScene"), this.scene.launch("GUIScene"), this.guiScene = this.scene.get("GUIScene"), this.physics.world.setFPS(0), this.viewport = new Viewport(this.cameras.main), this.particleEffects = new ParticleEffects(this), this.trainers = new Map, this.trainersGroup = this.add.group([], {
					name: "trainers"
				}), this.controls = new Controls(this), this.scale.on(Phaser.Scale.Events.RESIZE, this.fixCameraZoom, this), this.events.once(Phaser.Scenes.Events.SHUTDOWN, this.shutdown, this), this.fixCameraZoom(), eventStapler(this.net).on(NetPlugin.DISCONNECT, this.onDisconnect, this).on(NetPlugin.DESYNC, this.resync, this).on(NetPlugin.CONNECT, this.resync, this).on("trainer_move", this.trainerMove, this).on("trainer_join", this.trainerJoin, this).on("trainer_leave", this.trainerLeave, this).on("trainer_entity_activate", this.trainerEntityActivate, this).on("zone_world_load", this.zoneWorldPreload, this).on("zone_init", this.zoneInit, this).on("session_init", this.sessionInit, this).on("wild_encounter", this.wildEncounter, this).on("wild_encounter_reset", this.wildEncounterReset, this).on("form_submit", this.formSubmit, this).on("spectate", this.onSpectate, this).on("sys_message", this.onSysMessage, this)
			}
			onDisconnect(t) {
				this.reset();
				const e = DisconnectLookup(t.code);
				(!e || !e.autoReconnect || t.failures >= 3) && (this.net.close(), this.scene.start("DisconnectScene", e))
			}
			resync() {
				this.reset(), this.net.send("resync_request")
			}
			sessionInit({
				manifest: t,
				playerData: e
			}) {
				this.manifest = t, this.playerData = e, this.playerId = e.id, this.zoom.min = e.isAdmin ? .2 : 1
			}
			initZoom() {
				this.zoom = {
					target: 1.2,
					max: 2,
					min: 1,
					real: 1
				}, this.setTargetZoom(this.prefs.get("targetZoom"), !1), this.zoom.real = this.zoom.target
			}
			setTargetZoom(t, e = !0) {
				this.zoom.target = Math.min(this.zoom.max, Math.max(this.zoom.min, t)), e && this.prefs.set("targetZoom", this.zoom.target)
			}
			onInteract({
				id: t,
				trigger: e
			}) {
				this.cameraTarget && this.net.send("interact", {
					x: this.cameraTarget.x,
					y: this.cameraTarget.y,
					id: t
				})
			}
			setCameraTarget(t) {
				this.cameraTarget !== t && (this.cameraTarget = t, this.cameras.main.flash(300, 0, 0, 0, !0))
			}
			fixCameraZoom(t) {
				const e = this.zoom.target - this.zoom.real;
				if (t && Math.abs(e) > 1e-8) {
					const i = Math.max(1 / t * 100, 1);
					this.zoom.real += e / i
				} else this.zoom.real = this.zoom.target;
				const i = Math.max(this.cameras.main.height / FOV_MAX_HEIGHT, this.cameras.main.width / FOV_MAX_WIDTH) * this.zoom.real;
				this.cameras.main.setZoom(i)
			}
			update(t, e) {
				this.controls.update(t, e), this.net.readInboundQueue(t);
				let i = e;
				for (; i >= 0;) this.physics.world.step(.001 * Math.min(i, PHYS_DELTA_MINIMUM)), this.map && (this.physics.world.overlap(this.map.triggers, this.controls.target, this.controls.triggerOverlapCallback, this.controls.triggerProcessCallback, this.controls), this.controls.triggersUpdate(), this.physics.world.collide(this.map.collisions, this.trainersGroup)), i -= PHYS_DELTA_MINIMUM;
				this.fixCameraZoom(e);
				for (const i of this.trainers.values()) i.updateVis(t, e);
				this.cameraTarget && this.cameras.main.centerOn(this.cameraTarget.x, this.cameraTarget.y), this.viewport.update(), this.map && this.map.update(t, e, this.viewport), this.guiScene && this.guiScene.updateViewport(this.viewport, t, e)
			}
			reset() {
				this.trainers.forEach((t, e) => {
					this.unloadTrainer(e)
				}), this.map && (this.map.destroy(), this.map = null), this.events.emit("wildEncounter", null)
			}
			shutdown() {
				this.scale.off(Phaser.Scale.Events.RESIZE, this.fixCameraZoom, this)
			}
			async zoneWorldPreload(t) {
				try {
					const e = new Promise(t => setTimeout(t, FADE_INTERVAL));
					this.cameras.main.fadeOut(FADE_INTERVAL), await Promise.all([this.dynamicLoader.loadZone(t.key), e]), this.net.send("zone_world_loaded", t)
				} catch (t) {
					this.scene.start("DisconnectScene", {
						title: "Loading failed",
						description: t.message
					})
				}
			}
			zoneInit({
				key: t,
				trainers: e,
				clock: i
			}) {
				this.reset(), this.map = new WorldMap(this, {
					key: t,
					debug: !1
				}), this.map.on("entityLoaded", t => {
					if (t instanceof PortalEntity) {
						const e = t.props.get("ToZone");
						e && this.dynamicLoader.loadZone(e).catch(t => {
							console.error("Zone preload failed", t)
						})
					}
				}), this.map.init(i), this.events.emit("clock", i), this.events.emit("zoneInit", this.map), e.forEach(this.loadTrainer.bind(this)), this.cameras.main.fadeIn(FADE_INTERVAL);
				try {
					window.dispatchEvent(new CustomEvent("livemap_zone_init", {
						key: t
					}))
				} catch (t) {}
			}
			trainerJoin(t) {
				this.loadTrainer(t)
			}
			trainerLeave({
				id: t
			}) {
				this.unloadTrainer(t)
			}
			formSubmit(t) {
				t.sceneEnd && this.scene.start("PleaseWaitScene"), this.net.close(DisconnectCodes.LEAVING_PAGE);
				const e = (t.absolute ? "" : this.manifest.siteUrl) + t.action;
				if ("get" !== t.method || t.inputs.length) {
					const i = window.document;
					let s = i.createElement("form");
					s.style.display = "none", i.body.appendChild(s), s.action = e, s.method = t.method;
					for (let e of t.inputs) {
						let t = i.createElement("input");
						t.name = e.name, t.value = e.value, s.appendChild(t)
					}
					s.submit()
				} else window.location.href = e
			}
			wildEncounter(t) {
				if (this.net.send("wild_encounter_conf", t), t.startBattle = (() => {
						this.net.send("wild_encounter_start", t)
					}), this.events.emit("wildEncounter", t), t.tilePos) {
					const e = this.add.image(32 * t.tilePos.x + 16, 32 * t.tilePos.y - 16, "encounter-alert").setDepth(1e3),
						i = this.tweens.createTimeline();
					i.add({
						targets: e,
						y: e.y - 16,
						duration: 500,
						ease: Phaser.Math.Easing.Cubic.Out
					}), i.add({
						targets: e,
						alpha: 0,
						duration: 500,
						ease: Phaser.Math.Easing.Cubic.In
					}), i.play()
				}
			}
			wildEncounterReset() {
				this.events.emit("wildEncounter", null)
			}
			loadTrainer(t) {
				let e = this.trainers.get(t.id);
				return e || ((e = new Trainer(this, t)).on("tile", ({
					x: t,
					y: i
				}) => {
					if (!this.map) return;
					const s = {
						tileX: t,
						tileY: i,
						trainer: e,
						map: this.map,
						collisionTile: this.map.getCollisionAt(t, i)
					};
					this.events.emit("trainerTileCollision", s), e.onTileCollision(s)
				}), this.trainersGroup.add(e), this.trainers.set(t.id, e), this.events.emit("trainerLoaded", e)), e.setData(t), e.id === this.playerId && this.grantTrainerControl(e), e
			}
			unloadTrainer(t) {
				const e = this.trainers.get(t);
				e && (this.trainers.delete(t), this.trainersGroup.remove(e), e === this.controls.target && this.controls.setTarget(null, !1), e.destroyWithEffect(), this.events.emit("trainerUnloaded", e))
			}
			grantTrainerControl(t) {
				this.setCameraTarget(t), t.setInterpolateVisuals(!1), this.controls.setTarget(t, !0), this.events.emit("controlTrainerGrant", t)
			}
			revokeTrainerControl() {
				const t = this.cameraTarget;
				this.controls.setTarget(null, !1), t && (t.setInterpolateVisuals(!1), this.events.emit("controlTrainerRevoke", t))
			}
			trainerMove(t) {
				const e = this.trainers.get(t.id);
				e && e !== this.cameraTarget && (e.x = t.x, e.y = t.y, e.facingDirection = t.facingDirection, e.body.setVelocity(t.vx, t.vy))
			}
			trainerEntityActivate({
				id: t,
				move: e,
				actionType: i
			}) {
				if (!this.map) return;
				const s = this.trainers.get(e.id);
				if (!s) return;
				const n = this.map.getEntity(t);
				n && (this.trainerMove(e), n.activate(s, i))
			}
			onSpectate({
				x1: t,
				y1: e,
				x2: i,
				y2: s,
				secs: n
			}) {
				const a = {
					x: t,
					y: e
				};
				this.setCameraTarget(a), this.tweens.add({
					targets: a,
					x: i,
					y: s,
					duration: 1e3 * n
				})
			}
			onSysMessage(t) {
				this.guiScene && this.guiScene.displaySysMessage(t)
			}
			onNetPing(t) {
				this.net.pong(t)
			}
		}
		module.exports = WorldScene;

	}, {
		"../../shared/constants": 60,
		"../gameobjects/entities/portal": 10,
		"../gameobjects/mobiles/trainer": 17,
		"../gameobjects/particle-effects": 18,
		"../gameobjects/world-map": 26,
		"../plugins/net": 31,
		"../util/controls": 43,
		"../util/viewport": 44,
		"eventstapler": 48
	}],
	43: [function(require, module, exports) {
		const throttle = require("lodash.throttle"),
			EventEmitter = Phaser.Events.EventEmitter,
			{
				Directions: Directions
			} = require("../../shared/constants"),
			UPDATES_PER_SECOND = 5,
			GAMEPAD_MAGNITUDE_DEADZONE = .25;
		class Controls extends EventEmitter {
			constructor(t) {
				super(), this.target = null, this.targetPrevVals = null, this.enabled = !1, this.keyboardEnabled = !1, this.triggerState = new Map, this.scene = t, this.net = t.net, this.ctrl = {
					gamepad: {
						x: 0,
						y: 0,
						m: 0
					},
					keyboard: {
						x: 0,
						y: 0,
						m: 0
					},
					pointer: {
						x: 0,
						y: 0,
						m: 0
					}
				}, this.scene.sys.events.on(Phaser.Scenes.Events.SHUTDOWN, this.destroy, this), this.keys = ["W", "A", "S", "D", "UP", "LEFT", "DOWN", "RIGHT", "SHIFT"].reduce((t, e) => (t[e] = this.scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes[e]), t), {}), this.scene.input.on(Phaser.Input.Events.POINTER_WHEEL, this.onMouseWheel, this), this.scene.scene.launch("ControlsUIScene", {
					controls: this
				}), this.scene.events.on(Phaser.Scenes.Events.POST_UPDATE, this.postUpdate, this), this.emitBodyChange = throttle(t => {
					if (!this.target || !this.target.body || this.target.getPhysicsLocked()) return;
					const e = this.targetPrevVals;
					e.x = this.target.x, e.y = this.target.y, e.vx = this.target.body.velocity.x, e.vy = this.target.body.velocity.y, e.facingDirection = this.target.facingDirection, e.lastChange = t, this.net.send("trainer_move", e)
				}, 1e3 / UPDATES_PER_SECOND)
			}
			onMouseWheel(t, e, s, i, r) {
				if (0 === i) return;
				const a = i > 0 ? -.2 : .2;
				this.scene.setTargetZoom(this.scene.zoom.target + a)
			}
			setTarget(t, e) {
				return this.target && this.triggersErase(), this.targetPrevVals = {
					x: 0,
					y: 0,
					vx: 0,
					vy: 0,
					lastChange: 0,
					facingDirection: Directions.DOWN
				}, this.target = t, void 0 !== e && this.setEnabled(e), t && (this.targetPrevVals.id = t.id), this
			}
			setEnabled(t) {
				return this.enabled = t, this
			}
			update() {
				if (!this.enabled) return;
				this.updateKeyboard(), this.updateGamepad();
				const t = this.ctrl.gamepad.x + this.ctrl.keyboard.x + this.ctrl.pointer.x,
					e = this.ctrl.gamepad.y + this.ctrl.keyboard.y + this.ctrl.pointer.y,
					s = Math.max(this.ctrl.gamepad.m, this.ctrl.keyboard.m, this.ctrl.pointer.m);
				this.target.setMovementInput(t, e, s)
			}
			postUpdate(t) {
				this.bodyChangeCheck(t)
			}
			bodyChangeCheck(t) {
				if (!this.target || !this.target.body || this.target.getPhysicsLocked()) return;
				const e = this.target,
					s = this.targetPrevVals;
				s.lastChange;
				(e.x !== s.x || e.y !== s.y || e.facingDirection !== s.facingDirection) && this.emitBodyChange(t)
			}
			updateGamepad() {
				const t = this.ctrl.gamepad;
				if (t.x = 0, t.y = 0, t.m = 0, this.scene.input.gamepad.total > 0) {
					const e = this.scene.input.gamepad.getPad(0);
					e && e.axes && e.axes.length >= 2 && (t.x = e.axes[0].getValue(), t.y = e.axes[1].getValue(), t.m = this.hyp(t.x, t.y), t.m < GAMEPAD_MAGNITUDE_DEADZONE ? t.m = 0 : t.m = (t.m - GAMEPAD_MAGNITUDE_DEADZONE) * (1 / (1 - GAMEPAD_MAGNITUDE_DEADZONE)))
				}
			}
			updatePointer() {
				const t = this.ctrl.pointer;
				t.x = 0, t.y = 0, t.m = 0;
				const e = this.scene.input.activePointer;
				e.isDown && (t.x = e.worldX - this.target.x, t.y = e.worldY - this.target.y, t.m = this.hyp(t.x, t.y) / 80)
			}
			updateKeyboard() {
				!this.keyboardEnabled && this.scene.game.input.keyboard.enabled ? (this.scene.input.keyboard.resetKeys(), this.keyboardEnabled = !0) : this.scene.game.input.keyboard.enabled || (this.keyboardEnabled = !1);
				const t = this.ctrl.keyboard;
				t.x = 0, t.y = 0, t.m = 0, this.keyboardEnabled && ((this.keys.UP.isDown || this.keys.W.isDown) && (t.y = -1), (this.keys.DOWN.isDown || this.keys.S.isDown) && (t.y = 1), (this.keys.LEFT.isDown || this.keys.A.isDown) && (t.x = -1), (this.keys.RIGHT.isDown || this.keys.D.isDown) && (t.x = 1));
				const e = this.keys.SHIFT.isDown ? .5 : 1;
				t.m = t.x || t.y ? e : 0
			}
			hyp(t, e) {
				return Math.sqrt(t * t + e * e)
			}
			triggersErase(t = !0) {
				t && this.triggerState.forEach((t, e) => {
					t.active && t.ent.triggerExit(e, t.trainer)
				}), this.triggerState.clear()
			}
			triggerOverlapCallback(t, e) {
				const s = t.getData("entity");
				if (!s) return;
				let i = this.triggerState.get(t);
				i || (i = {
					active: !1,
					overlapping: !1,
					ent: s,
					trainer: e
				}, this.triggerState.set(t, i)), i.overlapping = !0, i.trainer = e
			}
			triggerProcessCallback(t, e) {
				const s = t.getData("entity");
				return !(!s || !s.triggerTest(t, e))
			}
			triggersUpdate() {
				this.triggerState.forEach((t, e) => {
					t.overlapping && !t.active ? (t.active = !0, t.ent.triggerEnter(e, t.trainer)) : !t.overlapping && t.active && (t.active = !1, t.ent.triggerExit(e, t.trainer)), t.overlapping = !1
				})
			}
			destroy() {
				this.scene && (this.triggersErase(), this.scene.scene.stop("ControlsUIScene")), this.enabled = !1, this.scene = null, this.target = null
			}
		}
		module.exports = Controls;

	}, {
		"../../shared/constants": 60,
		"lodash.throttle": 52
	}],
	44: [function(require, module, exports) {
		class Viewport extends Phaser.Geom.Rectangle {
			constructor(o) {
				super(0, 0, 0, 0), this.camera = o
			}
			update() {
				let o = this.camera.width,
					t = this.camera.height,
					s = .5 * o,
					e = .5 * t;
				this.zoom = this.camera.zoom;
				let i = this.camera.scrollX + s,
					r = this.camera.scrollY + e,
					h = o / this.zoom,
					m = t / this.zoom;
				this.setTo(i - h / 2, r - m / 2, h, m)
			}
			fromWorldCoords(o, t, s) {
				const e = (o - this.x) * this.zoom,
					i = (t - this.y) * this.zoom;
				if (!s) return {
					x: e,
					y: i
				};
				s.x = e, s.y = i
			}
			fromWorldCoordsScaled(o, t, s) {
				const e = (o - this.x) * this.zoom,
					i = (t - this.y) * this.zoom;
				if (!s) return {
					x: e,
					y: i,
					scale: this.zoom
				};
				s.x = e, s.y = i, s.scale = this.zoom
			}
		}
		module.exports = Viewport;

	}, {}],
	45: [function(require, module, exports) {
		"use strict";
		exports.byteLength = byteLength, exports.toByteArray = toByteArray, exports.fromByteArray = fromByteArray;
		for (var lookup = [], revLookup = [], Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; i < len; ++i) lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;

		function getLens(o) {
			var r = o.length;
			if (r % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
			var e = o.indexOf("=");
			return -1 === e && (e = r), [e, e === r ? 0 : 4 - e % 4]
		}

		function byteLength(o) {
			var r = getLens(o),
				e = r[0],
				t = r[1];
			return 3 * (e + t) / 4 - t
		}

		function _byteLength(o, r, e) {
			return 3 * (r + e) / 4 - e
		}

		function toByteArray(o) {
			var r, e, t = getLens(o),
				n = t[0],
				u = t[1],
				p = new Arr(_byteLength(o, n, u)),
				a = 0,
				h = u > 0 ? n - 4 : n;
			for (e = 0; e < h; e += 4) r = revLookup[o.charCodeAt(e)] << 18 | revLookup[o.charCodeAt(e + 1)] << 12 | revLookup[o.charCodeAt(e + 2)] << 6 | revLookup[o.charCodeAt(e + 3)], p[a++] = r >> 16 & 255, p[a++] = r >> 8 & 255, p[a++] = 255 & r;
			return 2 === u && (r = revLookup[o.charCodeAt(e)] << 2 | revLookup[o.charCodeAt(e + 1)] >> 4, p[a++] = 255 & r), 1 === u && (r = revLookup[o.charCodeAt(e)] << 10 | revLookup[o.charCodeAt(e + 1)] << 4 | revLookup[o.charCodeAt(e + 2)] >> 2, p[a++] = r >> 8 & 255, p[a++] = 255 & r), p
		}

		function tripletToBase64(o) {
			return lookup[o >> 18 & 63] + lookup[o >> 12 & 63] + lookup[o >> 6 & 63] + lookup[63 & o]
		}

		function encodeChunk(o, r, e) {
			for (var t, n = [], u = r; u < e; u += 3) t = (o[u] << 16 & 16711680) + (o[u + 1] << 8 & 65280) + (255 & o[u + 2]), n.push(tripletToBase64(t));
			return n.join("")
		}

		function fromByteArray(o) {
			for (var r, e = o.length, t = e % 3, n = [], u = 0, p = e - t; u < p; u += 16383) n.push(encodeChunk(o, u, u + 16383 > p ? p : u + 16383));
			return 1 === t ? (r = o[e - 1], n.push(lookup[r >> 2] + lookup[r << 4 & 63] + "==")) : 2 === t && (r = (o[e - 2] << 8) + o[e - 1], n.push(lookup[r >> 10] + lookup[r >> 4 & 63] + lookup[r << 2 & 63] + "=")), n.join("")
		}
		revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;

	}, {}],
	46: [function(require, module, exports) {
		(function(Buffer) {
			"use strict";
			var base64 = require("base64-js"),
				ieee754 = require("ieee754");
			exports.Buffer = Buffer, exports.SlowBuffer = SlowBuffer, exports.INSPECT_MAX_BYTES = 50;
			var K_MAX_LENGTH = 2147483647;

			function typedArraySupport() {
				try {
					var e = new Uint8Array(1);
					return e.__proto__ = {
						__proto__: Uint8Array.prototype,
						foo: function() {
							return 42
						}
					}, 42 === e.foo()
				} catch (e) {
					return !1
				}
			}

			function createBuffer(e) {
				if (e > K_MAX_LENGTH) throw new RangeError('The value "' + e + '" is invalid for option "size"');
				var t = new Uint8Array(e);
				return t.__proto__ = Buffer.prototype, t
			}

			function Buffer(e, t, r) {
				if ("number" == typeof e) {
					if ("string" == typeof t) throw new TypeError('The "string" argument must be of type string. Received type number');
					return allocUnsafe(e)
				}
				return from(e, t, r)
			}

			function from(e, t, r) {
				if ("string" == typeof e) return fromString(e, t);
				if (ArrayBuffer.isView(e)) return fromArrayLike(e);
				if (null == e) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
				if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) return fromArrayBuffer(e, t, r);
				if ("number" == typeof e) throw new TypeError('The "value" argument must not be of type number. Received type number');
				var n = e.valueOf && e.valueOf();
				if (null != n && n !== e) return Buffer.from(n, t, r);
				var f = fromObject(e);
				if (f) return f;
				if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e[Symbol.toPrimitive]) return Buffer.from(e[Symbol.toPrimitive]("string"), t, r);
				throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e)
			}

			function assertSize(e) {
				if ("number" != typeof e) throw new TypeError('"size" argument must be of type number');
				if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"')
			}

			function alloc(e, t, r) {
				return assertSize(e), e <= 0 ? createBuffer(e) : void 0 !== t ? "string" == typeof r ? createBuffer(e).fill(t, r) : createBuffer(e).fill(t) : createBuffer(e)
			}

			function allocUnsafe(e) {
				return assertSize(e), createBuffer(e < 0 ? 0 : 0 | checked(e))
			}

			function fromString(e, t) {
				if ("string" == typeof t && "" !== t || (t = "utf8"), !Buffer.isEncoding(t)) throw new TypeError("Unknown encoding: " + t);
				var r = 0 | byteLength(e, t),
					n = createBuffer(r),
					f = n.write(e, t);
				return f !== r && (n = n.slice(0, f)), n
			}

			function fromArrayLike(e) {
				for (var t = e.length < 0 ? 0 : 0 | checked(e.length), r = createBuffer(t), n = 0; n < t; n += 1) r[n] = 255 & e[n];
				return r
			}

			function fromArrayBuffer(e, t, r) {
				if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
				if (e.byteLength < t + (r || 0)) throw new RangeError('"length" is outside of buffer bounds');
				var n;
				return (n = void 0 === t && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, t) : new Uint8Array(e, t, r)).__proto__ = Buffer.prototype, n
			}

			function fromObject(e) {
				if (Buffer.isBuffer(e)) {
					var t = 0 | checked(e.length),
						r = createBuffer(t);
					return 0 === r.length ? r : (e.copy(r, 0, 0, t), r)
				}
				return void 0 !== e.length ? "number" != typeof e.length || numberIsNaN(e.length) ? createBuffer(0) : fromArrayLike(e) : "Buffer" === e.type && Array.isArray(e.data) ? fromArrayLike(e.data) : void 0
			}

			function checked(e) {
				if (e >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
				return 0 | e
			}

			function SlowBuffer(e) {
				return +e != e && (e = 0), Buffer.alloc(+e)
			}

			function byteLength(e, t) {
				if (Buffer.isBuffer(e)) return e.length;
				if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) return e.byteLength;
				if ("string" != typeof e) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
				var r = e.length,
					n = arguments.length > 2 && !0 === arguments[2];
				if (!n && 0 === r) return 0;
				for (var f = !1;;) switch (t) {
					case "ascii":
					case "latin1":
					case "binary":
						return r;
					case "utf8":
					case "utf-8":
						return utf8ToBytes(e).length;
					case "ucs2":
					case "ucs-2":
					case "utf16le":
					case "utf-16le":
						return 2 * r;
					case "hex":
						return r >>> 1;
					case "base64":
						return base64ToBytes(e).length;
					default:
						if (f) return n ? -1 : utf8ToBytes(e).length;
						t = ("" + t).toLowerCase(), f = !0
				}
			}

			function slowToString(e, t, r) {
				var n = !1;
				if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
				if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return "";
				if ((r >>>= 0) <= (t >>>= 0)) return "";
				for (e || (e = "utf8");;) switch (e) {
					case "hex":
						return hexSlice(this, t, r);
					case "utf8":
					case "utf-8":
						return utf8Slice(this, t, r);
					case "ascii":
						return asciiSlice(this, t, r);
					case "latin1":
					case "binary":
						return latin1Slice(this, t, r);
					case "base64":
						return base64Slice(this, t, r);
					case "ucs2":
					case "ucs-2":
					case "utf16le":
					case "utf-16le":
						return utf16leSlice(this, t, r);
					default:
						if (n) throw new TypeError("Unknown encoding: " + e);
						e = (e + "").toLowerCase(), n = !0
				}
			}

			function swap(e, t, r) {
				var n = e[t];
				e[t] = e[r], e[r] = n
			}

			function bidirectionalIndexOf(e, t, r, n, f) {
				if (0 === e.length) return -1;
				if ("string" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), numberIsNaN(r = +r) && (r = f ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
					if (f) return -1;
					r = e.length - 1
				} else if (r < 0) {
					if (!f) return -1;
					r = 0
				}
				if ("string" == typeof t && (t = Buffer.from(t, n)), Buffer.isBuffer(t)) return 0 === t.length ? -1 : arrayIndexOf(e, t, r, n, f);
				if ("number" == typeof t) return t &= 255, "function" == typeof Uint8Array.prototype.indexOf ? f ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : arrayIndexOf(e, [t], r, n, f);
				throw new TypeError("val must be string, number or Buffer")
			}

			function arrayIndexOf(e, t, r, n, f) {
				var i, o = 1,
					u = e.length,
					s = t.length;
				if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
					if (e.length < 2 || t.length < 2) return -1;
					o = 2, u /= 2, s /= 2, r /= 2
				}

				function a(e, t) {
					return 1 === o ? e[t] : e.readUInt16BE(t * o)
				}
				if (f) {
					var h = -1;
					for (i = r; i < u; i++)
						if (a(e, i) === a(t, -1 === h ? 0 : i - h)) {
							if (-1 === h && (h = i), i - h + 1 === s) return h * o
						} else -1 !== h && (i -= i - h), h = -1
				} else
					for (r + s > u && (r = u - s), i = r; i >= 0; i--) {
						for (var c = !0, l = 0; l < s; l++)
							if (a(e, i + l) !== a(t, l)) {
								c = !1;
								break
							} if (c) return i
					}
				return -1
			}

			function hexWrite(e, t, r, n) {
				r = Number(r) || 0;
				var f = e.length - r;
				n ? (n = Number(n)) > f && (n = f) : n = f;
				var i = t.length;
				n > i / 2 && (n = i / 2);
				for (var o = 0; o < n; ++o) {
					var u = parseInt(t.substr(2 * o, 2), 16);
					if (numberIsNaN(u)) return o;
					e[r + o] = u
				}
				return o
			}

			function utf8Write(e, t, r, n) {
				return blitBuffer(utf8ToBytes(t, e.length - r), e, r, n)
			}

			function asciiWrite(e, t, r, n) {
				return blitBuffer(asciiToBytes(t), e, r, n)
			}

			function latin1Write(e, t, r, n) {
				return asciiWrite(e, t, r, n)
			}

			function base64Write(e, t, r, n) {
				return blitBuffer(base64ToBytes(t), e, r, n)
			}

			function ucs2Write(e, t, r, n) {
				return blitBuffer(utf16leToBytes(t, e.length - r), e, r, n)
			}

			function base64Slice(e, t, r) {
				return 0 === t && r === e.length ? base64.fromByteArray(e) : base64.fromByteArray(e.slice(t, r))
			}

			function utf8Slice(e, t, r) {
				r = Math.min(e.length, r);
				for (var n = [], f = t; f < r;) {
					var i, o, u, s, a = e[f],
						h = null,
						c = a > 239 ? 4 : a > 223 ? 3 : a > 191 ? 2 : 1;
					if (f + c <= r) switch (c) {
						case 1:
							a < 128 && (h = a);
							break;
						case 2:
							128 == (192 & (i = e[f + 1])) && (s = (31 & a) << 6 | 63 & i) > 127 && (h = s);
							break;
						case 3:
							i = e[f + 1], o = e[f + 2], 128 == (192 & i) && 128 == (192 & o) && (s = (15 & a) << 12 | (63 & i) << 6 | 63 & o) > 2047 && (s < 55296 || s > 57343) && (h = s);
							break;
						case 4:
							i = e[f + 1], o = e[f + 2], u = e[f + 3], 128 == (192 & i) && 128 == (192 & o) && 128 == (192 & u) && (s = (15 & a) << 18 | (63 & i) << 12 | (63 & o) << 6 | 63 & u) > 65535 && s < 1114112 && (h = s)
					}
					null === h ? (h = 65533, c = 1) : h > 65535 && (h -= 65536, n.push(h >>> 10 & 1023 | 55296), h = 56320 | 1023 & h), n.push(h), f += c
				}
				return decodeCodePointsArray(n)
			}
			exports.kMaxLength = K_MAX_LENGTH, Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport(), Buffer.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(Buffer.prototype, "parent", {
				enumerable: !0,
				get: function() {
					if (Buffer.isBuffer(this)) return this.buffer
				}
			}), Object.defineProperty(Buffer.prototype, "offset", {
				enumerable: !0,
				get: function() {
					if (Buffer.isBuffer(this)) return this.byteOffset
				}
			}), "undefined" != typeof Symbol && null != Symbol.species && Buffer[Symbol.species] === Buffer && Object.defineProperty(Buffer, Symbol.species, {
				value: null,
				configurable: !0,
				enumerable: !1,
				writable: !1
			}), Buffer.poolSize = 8192, Buffer.from = function(e, t, r) {
				return from(e, t, r)
			}, Buffer.prototype.__proto__ = Uint8Array.prototype, Buffer.__proto__ = Uint8Array, Buffer.alloc = function(e, t, r) {
				return alloc(e, t, r)
			}, Buffer.allocUnsafe = function(e) {
				return allocUnsafe(e)
			}, Buffer.allocUnsafeSlow = function(e) {
				return allocUnsafe(e)
			}, Buffer.isBuffer = function(e) {
				return null != e && !0 === e._isBuffer && e !== Buffer.prototype
			}, Buffer.compare = function(e, t) {
				if (isInstance(e, Uint8Array) && (e = Buffer.from(e, e.offset, e.byteLength)), isInstance(t, Uint8Array) && (t = Buffer.from(t, t.offset, t.byteLength)), !Buffer.isBuffer(e) || !Buffer.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
				if (e === t) return 0;
				for (var r = e.length, n = t.length, f = 0, i = Math.min(r, n); f < i; ++f)
					if (e[f] !== t[f]) {
						r = e[f], n = t[f];
						break
					} return r < n ? -1 : n < r ? 1 : 0
			}, Buffer.isEncoding = function(e) {
				switch (String(e).toLowerCase()) {
					case "hex":
					case "utf8":
					case "utf-8":
					case "ascii":
					case "latin1":
					case "binary":
					case "base64":
					case "ucs2":
					case "ucs-2":
					case "utf16le":
					case "utf-16le":
						return !0;
					default:
						return !1
				}
			}, Buffer.concat = function(e, t) {
				if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
				if (0 === e.length) return Buffer.alloc(0);
				var r;
				if (void 0 === t)
					for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
				var n = Buffer.allocUnsafe(t),
					f = 0;
				for (r = 0; r < e.length; ++r) {
					var i = e[r];
					if (isInstance(i, Uint8Array) && (i = Buffer.from(i)), !Buffer.isBuffer(i)) throw new TypeError('"list" argument must be an Array of Buffers');
					i.copy(n, f), f += i.length
				}
				return n
			}, Buffer.byteLength = byteLength, Buffer.prototype._isBuffer = !0, Buffer.prototype.swap16 = function() {
				var e = this.length;
				if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
				for (var t = 0; t < e; t += 2) swap(this, t, t + 1);
				return this
			}, Buffer.prototype.swap32 = function() {
				var e = this.length;
				if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
				for (var t = 0; t < e; t += 4) swap(this, t, t + 3), swap(this, t + 1, t + 2);
				return this
			}, Buffer.prototype.swap64 = function() {
				var e = this.length;
				if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
				for (var t = 0; t < e; t += 8) swap(this, t, t + 7), swap(this, t + 1, t + 6), swap(this, t + 2, t + 5), swap(this, t + 3, t + 4);
				return this
			}, Buffer.prototype.toString = function() {
				var e = this.length;
				return 0 === e ? "" : 0 === arguments.length ? utf8Slice(this, 0, e) : slowToString.apply(this, arguments)
			}, Buffer.prototype.toLocaleString = Buffer.prototype.toString, Buffer.prototype.equals = function(e) {
				if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
				return this === e || 0 === Buffer.compare(this, e)
			}, Buffer.prototype.inspect = function() {
				var e = "",
					t = exports.INSPECT_MAX_BYTES;
				return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">"
			}, Buffer.prototype.compare = function(e, t, r, n, f) {
				if (isInstance(e, Uint8Array) && (e = Buffer.from(e, e.offset, e.byteLength)), !Buffer.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
				if (void 0 === t && (t = 0), void 0 === r && (r = e ? e.length : 0), void 0 === n && (n = 0), void 0 === f && (f = this.length), t < 0 || r > e.length || n < 0 || f > this.length) throw new RangeError("out of range index");
				if (n >= f && t >= r) return 0;
				if (n >= f) return -1;
				if (t >= r) return 1;
				if (this === e) return 0;
				for (var i = (f >>>= 0) - (n >>>= 0), o = (r >>>= 0) - (t >>>= 0), u = Math.min(i, o), s = this.slice(n, f), a = e.slice(t, r), h = 0; h < u; ++h)
					if (s[h] !== a[h]) {
						i = s[h], o = a[h];
						break
					} return i < o ? -1 : o < i ? 1 : 0
			}, Buffer.prototype.includes = function(e, t, r) {
				return -1 !== this.indexOf(e, t, r)
			}, Buffer.prototype.indexOf = function(e, t, r) {
				return bidirectionalIndexOf(this, e, t, r, !0)
			}, Buffer.prototype.lastIndexOf = function(e, t, r) {
				return bidirectionalIndexOf(this, e, t, r, !1)
			}, Buffer.prototype.write = function(e, t, r, n) {
				if (void 0 === t) n = "utf8", r = this.length, t = 0;
				else if (void 0 === r && "string" == typeof t) n = t, r = this.length, t = 0;
				else {
					if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
					t >>>= 0, isFinite(r) ? (r >>>= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0)
				}
				var f = this.length - t;
				if ((void 0 === r || r > f) && (r = f), e.length > 0 && (r < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
				n || (n = "utf8");
				for (var i = !1;;) switch (n) {
					case "hex":
						return hexWrite(this, e, t, r);
					case "utf8":
					case "utf-8":
						return utf8Write(this, e, t, r);
					case "ascii":
						return asciiWrite(this, e, t, r);
					case "latin1":
					case "binary":
						return latin1Write(this, e, t, r);
					case "base64":
						return base64Write(this, e, t, r);
					case "ucs2":
					case "ucs-2":
					case "utf16le":
					case "utf-16le":
						return ucs2Write(this, e, t, r);
					default:
						if (i) throw new TypeError("Unknown encoding: " + n);
						n = ("" + n).toLowerCase(), i = !0
				}
			}, Buffer.prototype.toJSON = function() {
				return {
					type: "Buffer",
					data: Array.prototype.slice.call(this._arr || this, 0)
				}
			};
			var MAX_ARGUMENTS_LENGTH = 4096;

			function decodeCodePointsArray(e) {
				var t = e.length;
				if (t <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, e);
				for (var r = "", n = 0; n < t;) r += String.fromCharCode.apply(String, e.slice(n, n += MAX_ARGUMENTS_LENGTH));
				return r
			}

			function asciiSlice(e, t, r) {
				var n = "";
				r = Math.min(e.length, r);
				for (var f = t; f < r; ++f) n += String.fromCharCode(127 & e[f]);
				return n
			}

			function latin1Slice(e, t, r) {
				var n = "";
				r = Math.min(e.length, r);
				for (var f = t; f < r; ++f) n += String.fromCharCode(e[f]);
				return n
			}

			function hexSlice(e, t, r) {
				var n = e.length;
				(!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
				for (var f = "", i = t; i < r; ++i) f += toHex(e[i]);
				return f
			}

			function utf16leSlice(e, t, r) {
				for (var n = e.slice(t, r), f = "", i = 0; i < n.length; i += 2) f += String.fromCharCode(n[i] + 256 * n[i + 1]);
				return f
			}

			function checkOffset(e, t, r) {
				if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
				if (e + t > r) throw new RangeError("Trying to access beyond buffer length")
			}

			function checkInt(e, t, r, n, f, i) {
				if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
				if (t > f || t < i) throw new RangeError('"value" argument is out of bounds');
				if (r + n > e.length) throw new RangeError("Index out of range")
			}

			function checkIEEE754(e, t, r, n, f, i) {
				if (r + n > e.length) throw new RangeError("Index out of range");
				if (r < 0) throw new RangeError("Index out of range")
			}

			function writeFloat(e, t, r, n, f) {
				return t = +t, r >>>= 0, f || checkIEEE754(e, t, r, 4, 3.4028234663852886e38, -3.4028234663852886e38), ieee754.write(e, t, r, n, 23, 4), r + 4
			}

			function writeDouble(e, t, r, n, f) {
				return t = +t, r >>>= 0, f || checkIEEE754(e, t, r, 8, 1.7976931348623157e308, -1.7976931348623157e308), ieee754.write(e, t, r, n, 52, 8), r + 8
			}
			Buffer.prototype.slice = function(e, t) {
				var r = this.length;
				(e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e && (t = e);
				var n = this.subarray(e, t);
				return n.__proto__ = Buffer.prototype, n
			}, Buffer.prototype.readUIntLE = function(e, t, r) {
				e >>>= 0, t >>>= 0, r || checkOffset(e, t, this.length);
				for (var n = this[e], f = 1, i = 0; ++i < t && (f *= 256);) n += this[e + i] * f;
				return n
			}, Buffer.prototype.readUIntBE = function(e, t, r) {
				e >>>= 0, t >>>= 0, r || checkOffset(e, t, this.length);
				for (var n = this[e + --t], f = 1; t > 0 && (f *= 256);) n += this[e + --t] * f;
				return n
			}, Buffer.prototype.readUInt8 = function(e, t) {
				return e >>>= 0, t || checkOffset(e, 1, this.length), this[e]
			}, Buffer.prototype.readUInt16LE = function(e, t) {
				return e >>>= 0, t || checkOffset(e, 2, this.length), this[e] | this[e + 1] << 8
			}, Buffer.prototype.readUInt16BE = function(e, t) {
				return e >>>= 0, t || checkOffset(e, 2, this.length), this[e] << 8 | this[e + 1]
			}, Buffer.prototype.readUInt32LE = function(e, t) {
				return e >>>= 0, t || checkOffset(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
			}, Buffer.prototype.readUInt32BE = function(e, t) {
				return e >>>= 0, t || checkOffset(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
			}, Buffer.prototype.readIntLE = function(e, t, r) {
				e >>>= 0, t >>>= 0, r || checkOffset(e, t, this.length);
				for (var n = this[e], f = 1, i = 0; ++i < t && (f *= 256);) n += this[e + i] * f;
				return n >= (f *= 128) && (n -= Math.pow(2, 8 * t)), n
			}, Buffer.prototype.readIntBE = function(e, t, r) {
				e >>>= 0, t >>>= 0, r || checkOffset(e, t, this.length);
				for (var n = t, f = 1, i = this[e + --n]; n > 0 && (f *= 256);) i += this[e + --n] * f;
				return i >= (f *= 128) && (i -= Math.pow(2, 8 * t)), i
			}, Buffer.prototype.readInt8 = function(e, t) {
				return e >>>= 0, t || checkOffset(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
			}, Buffer.prototype.readInt16LE = function(e, t) {
				e >>>= 0, t || checkOffset(e, 2, this.length);
				var r = this[e] | this[e + 1] << 8;
				return 32768 & r ? 4294901760 | r : r
			}, Buffer.prototype.readInt16BE = function(e, t) {
				e >>>= 0, t || checkOffset(e, 2, this.length);
				var r = this[e + 1] | this[e] << 8;
				return 32768 & r ? 4294901760 | r : r
			}, Buffer.prototype.readInt32LE = function(e, t) {
				return e >>>= 0, t || checkOffset(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
			}, Buffer.prototype.readInt32BE = function(e, t) {
				return e >>>= 0, t || checkOffset(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
			}, Buffer.prototype.readFloatLE = function(e, t) {
				return e >>>= 0, t || checkOffset(e, 4, this.length), ieee754.read(this, e, !0, 23, 4)
			}, Buffer.prototype.readFloatBE = function(e, t) {
				return e >>>= 0, t || checkOffset(e, 4, this.length), ieee754.read(this, e, !1, 23, 4)
			}, Buffer.prototype.readDoubleLE = function(e, t) {
				return e >>>= 0, t || checkOffset(e, 8, this.length), ieee754.read(this, e, !0, 52, 8)
			}, Buffer.prototype.readDoubleBE = function(e, t) {
				return e >>>= 0, t || checkOffset(e, 8, this.length), ieee754.read(this, e, !1, 52, 8)
			}, Buffer.prototype.writeUIntLE = function(e, t, r, n) {
				(e = +e, t >>>= 0, r >>>= 0, n) || checkInt(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
				var f = 1,
					i = 0;
				for (this[t] = 255 & e; ++i < r && (f *= 256);) this[t + i] = e / f & 255;
				return t + r
			}, Buffer.prototype.writeUIntBE = function(e, t, r, n) {
				(e = +e, t >>>= 0, r >>>= 0, n) || checkInt(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
				var f = r - 1,
					i = 1;
				for (this[t + f] = 255 & e; --f >= 0 && (i *= 256);) this[t + f] = e / i & 255;
				return t + r
			}, Buffer.prototype.writeUInt8 = function(e, t, r) {
				return e = +e, t >>>= 0, r || checkInt(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1
			}, Buffer.prototype.writeUInt16LE = function(e, t, r) {
				return e = +e, t >>>= 0, r || checkInt(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
			}, Buffer.prototype.writeUInt16BE = function(e, t, r) {
				return e = +e, t >>>= 0, r || checkInt(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
			}, Buffer.prototype.writeUInt32LE = function(e, t, r) {
				return e = +e, t >>>= 0, r || checkInt(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4
			}, Buffer.prototype.writeUInt32BE = function(e, t, r) {
				return e = +e, t >>>= 0, r || checkInt(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
			}, Buffer.prototype.writeIntLE = function(e, t, r, n) {
				if (e = +e, t >>>= 0, !n) {
					var f = Math.pow(2, 8 * r - 1);
					checkInt(this, e, t, r, f - 1, -f)
				}
				var i = 0,
					o = 1,
					u = 0;
				for (this[t] = 255 & e; ++i < r && (o *= 256);) e < 0 && 0 === u && 0 !== this[t + i - 1] && (u = 1), this[t + i] = (e / o >> 0) - u & 255;
				return t + r
			}, Buffer.prototype.writeIntBE = function(e, t, r, n) {
				if (e = +e, t >>>= 0, !n) {
					var f = Math.pow(2, 8 * r - 1);
					checkInt(this, e, t, r, f - 1, -f)
				}
				var i = r - 1,
					o = 1,
					u = 0;
				for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);) e < 0 && 0 === u && 0 !== this[t + i + 1] && (u = 1), this[t + i] = (e / o >> 0) - u & 255;
				return t + r
			}, Buffer.prototype.writeInt8 = function(e, t, r) {
				return e = +e, t >>>= 0, r || checkInt(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1
			}, Buffer.prototype.writeInt16LE = function(e, t, r) {
				return e = +e, t >>>= 0, r || checkInt(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
			}, Buffer.prototype.writeInt16BE = function(e, t, r) {
				return e = +e, t >>>= 0, r || checkInt(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
			}, Buffer.prototype.writeInt32LE = function(e, t, r) {
				return e = +e, t >>>= 0, r || checkInt(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
			}, Buffer.prototype.writeInt32BE = function(e, t, r) {
				return e = +e, t >>>= 0, r || checkInt(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
			}, Buffer.prototype.writeFloatLE = function(e, t, r) {
				return writeFloat(this, e, t, !0, r)
			}, Buffer.prototype.writeFloatBE = function(e, t, r) {
				return writeFloat(this, e, t, !1, r)
			}, Buffer.prototype.writeDoubleLE = function(e, t, r) {
				return writeDouble(this, e, t, !0, r)
			}, Buffer.prototype.writeDoubleBE = function(e, t, r) {
				return writeDouble(this, e, t, !1, r)
			}, Buffer.prototype.copy = function(e, t, r, n) {
				if (!Buffer.isBuffer(e)) throw new TypeError("argument should be a Buffer");
				if (r || (r = 0), n || 0 === n || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < r && (n = r), n === r) return 0;
				if (0 === e.length || 0 === this.length) return 0;
				if (t < 0) throw new RangeError("targetStart out of bounds");
				if (r < 0 || r >= this.length) throw new RangeError("Index out of range");
				if (n < 0) throw new RangeError("sourceEnd out of bounds");
				n > this.length && (n = this.length), e.length - t < n - r && (n = e.length - t + r);
				var f = n - r;
				if (this === e && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(t, r, n);
				else if (this === e && r < t && t < n)
					for (var i = f - 1; i >= 0; --i) e[i + t] = this[i + r];
				else Uint8Array.prototype.set.call(e, this.subarray(r, n), t);
				return f
			}, Buffer.prototype.fill = function(e, t, r, n) {
				if ("string" == typeof e) {
					if ("string" == typeof t ? (n = t, t = 0, r = this.length) : "string" == typeof r && (n = r, r = this.length), void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
					if ("string" == typeof n && !Buffer.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
					if (1 === e.length) {
						var f = e.charCodeAt(0);
						("utf8" === n && f < 128 || "latin1" === n) && (e = f)
					}
				} else "number" == typeof e && (e &= 255);
				if (t < 0 || this.length < t || this.length < r) throw new RangeError("Out of range index");
				if (r <= t) return this;
				var i;
				if (t >>>= 0, r = void 0 === r ? this.length : r >>> 0, e || (e = 0), "number" == typeof e)
					for (i = t; i < r; ++i) this[i] = e;
				else {
					var o = Buffer.isBuffer(e) ? e : Buffer.from(e, n),
						u = o.length;
					if (0 === u) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
					for (i = 0; i < r - t; ++i) this[i + t] = o[i % u]
				}
				return this
			};
			var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

			function base64clean(e) {
				if ((e = (e = e.split("=")[0]).trim().replace(INVALID_BASE64_RE, "")).length < 2) return "";
				for (; e.length % 4 != 0;) e += "=";
				return e
			}

			function toHex(e) {
				return e < 16 ? "0" + e.toString(16) : e.toString(16)
			}

			function utf8ToBytes(e, t) {
				var r;
				t = t || 1 / 0;
				for (var n = e.length, f = null, i = [], o = 0; o < n; ++o) {
					if ((r = e.charCodeAt(o)) > 55295 && r < 57344) {
						if (!f) {
							if (r > 56319) {
								(t -= 3) > -1 && i.push(239, 191, 189);
								continue
							}
							if (o + 1 === n) {
								(t -= 3) > -1 && i.push(239, 191, 189);
								continue
							}
							f = r;
							continue
						}
						if (r < 56320) {
							(t -= 3) > -1 && i.push(239, 191, 189), f = r;
							continue
						}
						r = 65536 + (f - 55296 << 10 | r - 56320)
					} else f && (t -= 3) > -1 && i.push(239, 191, 189);
					if (f = null, r < 128) {
						if ((t -= 1) < 0) break;
						i.push(r)
					} else if (r < 2048) {
						if ((t -= 2) < 0) break;
						i.push(r >> 6 | 192, 63 & r | 128)
					} else if (r < 65536) {
						if ((t -= 3) < 0) break;
						i.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128)
					} else {
						if (!(r < 1114112)) throw new Error("Invalid code point");
						if ((t -= 4) < 0) break;
						i.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128)
					}
				}
				return i
			}

			function asciiToBytes(e) {
				for (var t = [], r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));
				return t
			}

			function utf16leToBytes(e, t) {
				for (var r, n, f, i = [], o = 0; o < e.length && !((t -= 2) < 0); ++o) n = (r = e.charCodeAt(o)) >> 8, f = r % 256, i.push(f), i.push(n);
				return i
			}

			function base64ToBytes(e) {
				return base64.toByteArray(base64clean(e))
			}

			function blitBuffer(e, t, r, n) {
				for (var f = 0; f < n && !(f + r >= t.length || f >= e.length); ++f) t[f + r] = e[f];
				return f
			}

			function isInstance(e, t) {
				return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name
			}

			function numberIsNaN(e) {
				return e != e
			}

		}).call(this, require("buffer").Buffer)
	}, {
		"base64-js": 45,
		"buffer": 46,
		"ieee754": 49
	}],
	47: [function(require, module, exports) {
		"use strict";
		var has = Object.prototype.hasOwnProperty,
			prefix = "~";

		function Events() {}

		function EE(e, t, n) {
			this.fn = e, this.context = t, this.once = n || !1
		}

		function addListener(e, t, n, r, i) {
			if ("function" != typeof n) throw new TypeError("The listener must be a function");
			var o = new EE(n, r || e, i),
				s = prefix ? prefix + t : t;
			return e._events[s] ? e._events[s].fn ? e._events[s] = [e._events[s], o] : e._events[s].push(o) : (e._events[s] = o, e._eventsCount++), e
		}

		function clearEvent(e, t) {
			0 == --e._eventsCount ? e._events = new Events : delete e._events[t]
		}

		function EventEmitter() {
			this._events = new Events, this._eventsCount = 0
		}
		Object.create && (Events.prototype = Object.create(null), (new Events).__proto__ || (prefix = !1)), EventEmitter.prototype.eventNames = function() {
			var e, t, n = [];
			if (0 === this._eventsCount) return n;
			for (t in e = this._events) has.call(e, t) && n.push(prefix ? t.slice(1) : t);
			return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(e)) : n
		}, EventEmitter.prototype.listeners = function(e) {
			var t = prefix ? prefix + e : e,
				n = this._events[t];
			if (!n) return [];
			if (n.fn) return [n.fn];
			for (var r = 0, i = n.length, o = new Array(i); r < i; r++) o[r] = n[r].fn;
			return o
		}, EventEmitter.prototype.listenerCount = function(e) {
			var t = prefix ? prefix + e : e,
				n = this._events[t];
			return n ? n.fn ? 1 : n.length : 0
		}, EventEmitter.prototype.emit = function(e, t, n, r, i, o) {
			var s = prefix ? prefix + e : e;
			if (!this._events[s]) return !1;
			var f, c, v = this._events[s],
				a = arguments.length;
			if (v.fn) {
				switch (v.once && this.removeListener(e, v.fn, void 0, !0), a) {
					case 1:
						return v.fn.call(v.context), !0;
					case 2:
						return v.fn.call(v.context, t), !0;
					case 3:
						return v.fn.call(v.context, t, n), !0;
					case 4:
						return v.fn.call(v.context, t, n, r), !0;
					case 5:
						return v.fn.call(v.context, t, n, r, i), !0;
					case 6:
						return v.fn.call(v.context, t, n, r, i, o), !0
				}
				for (c = 1, f = new Array(a - 1); c < a; c++) f[c - 1] = arguments[c];
				v.fn.apply(v.context, f)
			} else {
				var p, l = v.length;
				for (c = 0; c < l; c++) switch (v[c].once && this.removeListener(e, v[c].fn, void 0, !0), a) {
					case 1:
						v[c].fn.call(v[c].context);
						break;
					case 2:
						v[c].fn.call(v[c].context, t);
						break;
					case 3:
						v[c].fn.call(v[c].context, t, n);
						break;
					case 4:
						v[c].fn.call(v[c].context, t, n, r);
						break;
					default:
						if (!f)
							for (p = 1, f = new Array(a - 1); p < a; p++) f[p - 1] = arguments[p];
						v[c].fn.apply(v[c].context, f)
				}
			}
			return !0
		}, EventEmitter.prototype.on = function(e, t, n) {
			return addListener(this, e, t, n, !1)
		}, EventEmitter.prototype.once = function(e, t, n) {
			return addListener(this, e, t, n, !0)
		}, EventEmitter.prototype.removeListener = function(e, t, n, r) {
			var i = prefix ? prefix + e : e;
			if (!this._events[i]) return this;
			if (!t) return clearEvent(this, i), this;
			var o = this._events[i];
			if (o.fn) o.fn !== t || r && !o.once || n && o.context !== n || clearEvent(this, i);
			else {
				for (var s = 0, f = [], c = o.length; s < c; s++)(o[s].fn !== t || r && !o[s].once || n && o[s].context !== n) && f.push(o[s]);
				f.length ? this._events[i] = 1 === f.length ? f[0] : f : clearEvent(this, i)
			}
			return this
		}, EventEmitter.prototype.removeAllListeners = function(e) {
			var t;
			return e ? (t = prefix ? prefix + e : e, this._events[t] && clearEvent(this, t)) : (this._events = new Events, this._eventsCount = 0), this
		}, EventEmitter.prototype.off = EventEmitter.prototype.removeListener, EventEmitter.prototype.addListener = EventEmitter.prototype.on, EventEmitter.prefixed = prefix, EventEmitter.EventEmitter = EventEmitter, "undefined" != typeof module && (module.exports = EventEmitter);

	}, {}],
	48: [function(require, module, exports) {
		class StapledEmitter {
			constructor(e) {
				this._isReleased = !1, this._emitter = e, this._eventHandlers = []
			}
			_add(e, t, r, s, ...n) {
				if (this._isReleased) throw Error("Staple is released");
				if (-1 === ["string", "symbol"].indexOf(typeof t)) throw Error("Event name must be a string or a symbol");
				if (!(r instanceof Function)) throw Error("Event handler must be a function");
				const i = r.bind(s, ...n);
				let o = this._emitter.on ? "on" : "addEventListener";
				if (e && (o = "once"), !this._emitter[o]) throw Error(`EventEmitter doesn't support method .${o}()`);
				return this._emitter[o](t, i), this._eventHandlers.push({
					event: t,
					boundHandler: i
				}), this
			}
			on(...e) {
				return this._add(!1, ...e)
			}
			once(...e) {
				return this._add(!0, ...e)
			}
			releaseAfter(e) {
				return this.on(e, this.release, this)
			}
			release() {
				if (this._isReleased) return this;
				for (const e of this._eventHandlers) {
					let t = this._emitter.removeListener ? "removeListener" : "removeEventListener";
					this._emitter[t](e.event, e.boundHandler)
				}
				return this
			}
		}
		module.exports = function(e) {
			return new StapledEmitter(e)
		};

	}, {}],
	49: [function(require, module, exports) {
		exports.read = function(a, o, t, r, h) {
			var M, p, w = 8 * h - r - 1,
				f = (1 << w) - 1,
				e = f >> 1,
				i = -7,
				N = t ? h - 1 : 0,
				n = t ? -1 : 1,
				s = a[o + N];
			for (N += n, M = s & (1 << -i) - 1, s >>= -i, i += w; i > 0; M = 256 * M + a[o + N], N += n, i -= 8);
			for (p = M & (1 << -i) - 1, M >>= -i, i += r; i > 0; p = 256 * p + a[o + N], N += n, i -= 8);
			if (0 === M) M = 1 - e;
			else {
				if (M === f) return p ? NaN : 1 / 0 * (s ? -1 : 1);
				p += Math.pow(2, r), M -= e
			}
			return (s ? -1 : 1) * p * Math.pow(2, M - r)
		}, exports.write = function(a, o, t, r, h, M) {
			var p, w, f, e = 8 * M - h - 1,
				i = (1 << e) - 1,
				N = i >> 1,
				n = 23 === h ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
				s = r ? 0 : M - 1,
				u = r ? 1 : -1,
				l = o < 0 || 0 === o && 1 / o < 0 ? 1 : 0;
			for (o = Math.abs(o), isNaN(o) || o === 1 / 0 ? (w = isNaN(o) ? 1 : 0, p = i) : (p = Math.floor(Math.log(o) / Math.LN2), o * (f = Math.pow(2, -p)) < 1 && (p--, f *= 2), (o += p + N >= 1 ? n / f : n * Math.pow(2, 1 - N)) * f >= 2 && (p++, f /= 2), p + N >= i ? (w = 0, p = i) : p + N >= 1 ? (w = (o * f - 1) * Math.pow(2, h), p += N) : (w = o * Math.pow(2, N - 1) * Math.pow(2, h), p = 0)); h >= 8; a[t + s] = 255 & w, s += u, w /= 256, h -= 8);
			for (p = p << h | w, e += h; e > 0; a[t + s] = 255 & p, s += u, p /= 256, e -= 8);
			a[t + s - u] |= 128 * l
		};

	}, {}],
	50: [function(require, module, exports) {
		(function(global) {
			var LARGE_ARRAY_SIZE = 200,
				HASH_UNDEFINED = "__lodash_hash_undefined__",
				MAX_SAFE_INTEGER = 9007199254740991,
				argsTag = "[object Arguments]",
				arrayTag = "[object Array]",
				boolTag = "[object Boolean]",
				dateTag = "[object Date]",
				errorTag = "[object Error]",
				funcTag = "[object Function]",
				genTag = "[object GeneratorFunction]",
				mapTag = "[object Map]",
				numberTag = "[object Number]",
				objectTag = "[object Object]",
				promiseTag = "[object Promise]",
				regexpTag = "[object RegExp]",
				setTag = "[object Set]",
				stringTag = "[object String]",
				symbolTag = "[object Symbol]",
				weakMapTag = "[object WeakMap]",
				arrayBufferTag = "[object ArrayBuffer]",
				dataViewTag = "[object DataView]",
				float32Tag = "[object Float32Array]",
				float64Tag = "[object Float64Array]",
				int8Tag = "[object Int8Array]",
				int16Tag = "[object Int16Array]",
				int32Tag = "[object Int32Array]",
				uint8Tag = "[object Uint8Array]",
				uint8ClampedTag = "[object Uint8ClampedArray]",
				uint16Tag = "[object Uint16Array]",
				uint32Tag = "[object Uint32Array]",
				reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
				reFlags = /\w*$/,
				reIsHostCtor = /^\[object .+?Constructor\]$/,
				reIsUint = /^(?:0|[1-9]\d*)$/,
				cloneableTags = {};
			cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
			var freeGlobal = "object" == typeof global && global && global.Object === Object && global,
				freeSelf = "object" == typeof self && self && self.Object === Object && self,
				root = freeGlobal || freeSelf || Function("return this")(),
				freeExports = "object" == typeof exports && exports && !exports.nodeType && exports,
				freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module,
				moduleExports = freeModule && freeModule.exports === freeExports;

			function addMapEntry(e, t) {
				return e.set(t[0], t[1]), e
			}

			function addSetEntry(e, t) {
				return e.add(t), e
			}

			function arrayEach(e, t) {
				for (var a = -1, r = e ? e.length : 0; ++a < r && !1 !== t(e[a], a, e););
				return e
			}

			function arrayPush(e, t) {
				for (var a = -1, r = t.length, n = e.length; ++a < r;) e[n + a] = t[a];
				return e
			}

			function arrayReduce(e, t, a, r) {
				var n = -1,
					o = e ? e.length : 0;
				for (r && o && (a = e[++n]); ++n < o;) a = t(a, e[n], n, e);
				return a
			}

			function baseTimes(e, t) {
				for (var a = -1, r = Array(e); ++a < e;) r[a] = t(a);
				return r
			}

			function getValue(e, t) {
				return null == e ? void 0 : e[t]
			}

			function isHostObject(e) {
				var t = !1;
				if (null != e && "function" != typeof e.toString) try {
					t = !!(e + "")
				} catch (e) {}
				return t
			}

			function mapToArray(e) {
				var t = -1,
					a = Array(e.size);
				return e.forEach(function(e, r) {
					a[++t] = [r, e]
				}), a
			}

			function overArg(e, t) {
				return function(a) {
					return e(t(a))
				}
			}

			function setToArray(e) {
				var t = -1,
					a = Array(e.size);
				return e.forEach(function(e) {
					a[++t] = e
				}), a
			}
			var arrayProto = Array.prototype,
				funcProto = Function.prototype,
				objectProto = Object.prototype,
				coreJsData = root["__core-js_shared__"],
				maskSrcKey = function() {
					var e = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
					return e ? "Symbol(src)_1." + e : ""
				}(),
				funcToString = funcProto.toString,
				hasOwnProperty = objectProto.hasOwnProperty,
				objectToString = objectProto.toString,
				reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
				Buffer = moduleExports ? root.Buffer : void 0,
				Symbol = root.Symbol,
				Uint8Array = root.Uint8Array,
				getPrototype = overArg(Object.getPrototypeOf, Object),
				objectCreate = Object.create,
				propertyIsEnumerable = objectProto.propertyIsEnumerable,
				splice = arrayProto.splice,
				nativeGetSymbols = Object.getOwnPropertySymbols,
				nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0,
				nativeKeys = overArg(Object.keys, Object),
				DataView = getNative(root, "DataView"),
				Map = getNative(root, "Map"),
				Promise = getNative(root, "Promise"),
				Set = getNative(root, "Set"),
				WeakMap = getNative(root, "WeakMap"),
				nativeCreate = getNative(Object, "create"),
				dataViewCtorString = toSource(DataView),
				mapCtorString = toSource(Map),
				promiseCtorString = toSource(Promise),
				setCtorString = toSource(Set),
				weakMapCtorString = toSource(WeakMap),
				symbolProto = Symbol ? Symbol.prototype : void 0,
				symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;

			function Hash(e) {
				var t = -1,
					a = e ? e.length : 0;
				for (this.clear(); ++t < a;) {
					var r = e[t];
					this.set(r[0], r[1])
				}
			}

			function hashClear() {
				this.__data__ = nativeCreate ? nativeCreate(null) : {}
			}

			function hashDelete(e) {
				return this.has(e) && delete this.__data__[e]
			}

			function hashGet(e) {
				var t = this.__data__;
				if (nativeCreate) {
					var a = t[e];
					return a === HASH_UNDEFINED ? void 0 : a
				}
				return hasOwnProperty.call(t, e) ? t[e] : void 0
			}

			function hashHas(e) {
				var t = this.__data__;
				return nativeCreate ? void 0 !== t[e] : hasOwnProperty.call(t, e)
			}

			function hashSet(e, t) {
				return this.__data__[e] = nativeCreate && void 0 === t ? HASH_UNDEFINED : t, this
			}

			function ListCache(e) {
				var t = -1,
					a = e ? e.length : 0;
				for (this.clear(); ++t < a;) {
					var r = e[t];
					this.set(r[0], r[1])
				}
			}

			function listCacheClear() {
				this.__data__ = []
			}

			function listCacheDelete(e) {
				var t = this.__data__,
					a = assocIndexOf(t, e);
				return !(a < 0) && (a == t.length - 1 ? t.pop() : splice.call(t, a, 1), !0)
			}

			function listCacheGet(e) {
				var t = this.__data__,
					a = assocIndexOf(t, e);
				return a < 0 ? void 0 : t[a][1]
			}

			function listCacheHas(e) {
				return assocIndexOf(this.__data__, e) > -1
			}

			function listCacheSet(e, t) {
				var a = this.__data__,
					r = assocIndexOf(a, e);
				return r < 0 ? a.push([e, t]) : a[r][1] = t, this
			}

			function MapCache(e) {
				var t = -1,
					a = e ? e.length : 0;
				for (this.clear(); ++t < a;) {
					var r = e[t];
					this.set(r[0], r[1])
				}
			}

			function mapCacheClear() {
				this.__data__ = {
					hash: new Hash,
					map: new(Map || ListCache),
					string: new Hash
				}
			}

			function mapCacheDelete(e) {
				return getMapData(this, e).delete(e)
			}

			function mapCacheGet(e) {
				return getMapData(this, e).get(e)
			}

			function mapCacheHas(e) {
				return getMapData(this, e).has(e)
			}

			function mapCacheSet(e, t) {
				return getMapData(this, e).set(e, t), this
			}

			function Stack(e) {
				this.__data__ = new ListCache(e)
			}

			function stackClear() {
				this.__data__ = new ListCache
			}

			function stackDelete(e) {
				return this.__data__.delete(e)
			}

			function stackGet(e) {
				return this.__data__.get(e)
			}

			function stackHas(e) {
				return this.__data__.has(e)
			}

			function stackSet(e, t) {
				var a = this.__data__;
				if (a instanceof ListCache) {
					var r = a.__data__;
					if (!Map || r.length < LARGE_ARRAY_SIZE - 1) return r.push([e, t]), this;
					a = this.__data__ = new MapCache(r)
				}
				return a.set(e, t), this
			}

			function arrayLikeKeys(e, t) {
				var a = isArray(e) || isArguments(e) ? baseTimes(e.length, String) : [],
					r = a.length,
					n = !!r;
				for (var o in e) !t && !hasOwnProperty.call(e, o) || n && ("length" == o || isIndex(o, r)) || a.push(o);
				return a
			}

			function assignValue(e, t, a) {
				var r = e[t];
				hasOwnProperty.call(e, t) && eq(r, a) && (void 0 !== a || t in e) || (e[t] = a)
			}

			function assocIndexOf(e, t) {
				for (var a = e.length; a--;)
					if (eq(e[a][0], t)) return a;
				return -1
			}

			function baseAssign(e, t) {
				return e && copyObject(t, keys(t), e)
			}

			function baseClone(e, t, a, r, n, o, c) {
				var s;
				if (r && (s = o ? r(e, n, o, c) : r(e)), void 0 !== s) return s;
				if (!isObject(e)) return e;
				var i = isArray(e);
				if (i) {
					if (s = initCloneArray(e), !t) return copyArray(e, s)
				} else {
					var u = getTag(e),
						l = u == funcTag || u == genTag;
					if (isBuffer(e)) return cloneBuffer(e, t);
					if (u == objectTag || u == argsTag || l && !o) {
						if (isHostObject(e)) return o ? e : {};
						if (s = initCloneObject(l ? {} : e), !t) return copySymbols(e, baseAssign(s, e))
					} else {
						if (!cloneableTags[u]) return o ? e : {};
						s = initCloneByTag(e, u, baseClone, t)
					}
				}
				c || (c = new Stack);
				var g = c.get(e);
				if (g) return g;
				if (c.set(e, s), !i) var f = a ? getAllKeys(e) : keys(e);
				return arrayEach(f || e, function(n, o) {
					f && (n = e[o = n]), assignValue(s, o, baseClone(n, t, a, r, o, e, c))
				}), s
			}

			function baseCreate(e) {
				return isObject(e) ? objectCreate(e) : {}
			}

			function baseGetAllKeys(e, t, a) {
				var r = t(e);
				return isArray(e) ? r : arrayPush(r, a(e))
			}

			function baseGetTag(e) {
				return objectToString.call(e)
			}

			function baseIsNative(e) {
				return !(!isObject(e) || isMasked(e)) && (isFunction(e) || isHostObject(e) ? reIsNative : reIsHostCtor).test(toSource(e))
			}

			function baseKeys(e) {
				if (!isPrototype(e)) return nativeKeys(e);
				var t = [];
				for (var a in Object(e)) hasOwnProperty.call(e, a) && "constructor" != a && t.push(a);
				return t
			}

			function cloneBuffer(e, t) {
				if (t) return e.slice();
				var a = new e.constructor(e.length);
				return e.copy(a), a
			}

			function cloneArrayBuffer(e) {
				var t = new e.constructor(e.byteLength);
				return new Uint8Array(t).set(new Uint8Array(e)), t
			}

			function cloneDataView(e, t) {
				var a = t ? cloneArrayBuffer(e.buffer) : e.buffer;
				return new e.constructor(a, e.byteOffset, e.byteLength)
			}

			function cloneMap(e, t, a) {
				return arrayReduce(t ? a(mapToArray(e), !0) : mapToArray(e), addMapEntry, new e.constructor)
			}

			function cloneRegExp(e) {
				var t = new e.constructor(e.source, reFlags.exec(e));
				return t.lastIndex = e.lastIndex, t
			}

			function cloneSet(e, t, a) {
				return arrayReduce(t ? a(setToArray(e), !0) : setToArray(e), addSetEntry, new e.constructor)
			}

			function cloneSymbol(e) {
				return symbolValueOf ? Object(symbolValueOf.call(e)) : {}
			}

			function cloneTypedArray(e, t) {
				var a = t ? cloneArrayBuffer(e.buffer) : e.buffer;
				return new e.constructor(a, e.byteOffset, e.length)
			}

			function copyArray(e, t) {
				var a = -1,
					r = e.length;
				for (t || (t = Array(r)); ++a < r;) t[a] = e[a];
				return t
			}

			function copyObject(e, t, a, r) {
				a || (a = {});
				for (var n = -1, o = t.length; ++n < o;) {
					var c = t[n],
						s = r ? r(a[c], e[c], c, a, e) : void 0;
					assignValue(a, c, void 0 === s ? e[c] : s)
				}
				return a
			}

			function copySymbols(e, t) {
				return copyObject(e, getSymbols(e), t)
			}

			function getAllKeys(e) {
				return baseGetAllKeys(e, keys, getSymbols)
			}

			function getMapData(e, t) {
				var a = e.__data__;
				return isKeyable(t) ? a["string" == typeof t ? "string" : "hash"] : a.map
			}

			function getNative(e, t) {
				var a = getValue(e, t);
				return baseIsNative(a) ? a : void 0
			}
			Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, Hash.prototype.has = hashHas, Hash.prototype.set = hashSet, ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet, MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet, Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, Stack.prototype.has = stackHas, Stack.prototype.set = stackSet;
			var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray,
				getTag = baseGetTag;

			function initCloneArray(e) {
				var t = e.length,
					a = e.constructor(t);
				return t && "string" == typeof e[0] && hasOwnProperty.call(e, "index") && (a.index = e.index, a.input = e.input), a
			}

			function initCloneObject(e) {
				return "function" != typeof e.constructor || isPrototype(e) ? {} : baseCreate(getPrototype(e))
			}

			function initCloneByTag(e, t, a, r) {
				var n = e.constructor;
				switch (t) {
					case arrayBufferTag:
						return cloneArrayBuffer(e);
					case boolTag:
					case dateTag:
						return new n(+e);
					case dataViewTag:
						return cloneDataView(e, r);
					case float32Tag:
					case float64Tag:
					case int8Tag:
					case int16Tag:
					case int32Tag:
					case uint8Tag:
					case uint8ClampedTag:
					case uint16Tag:
					case uint32Tag:
						return cloneTypedArray(e, r);
					case mapTag:
						return cloneMap(e, r, a);
					case numberTag:
					case stringTag:
						return new n(e);
					case regexpTag:
						return cloneRegExp(e);
					case setTag:
						return cloneSet(e, r, a);
					case symbolTag:
						return cloneSymbol(e)
				}
			}

			function isIndex(e, t) {
				return !!(t = null == t ? MAX_SAFE_INTEGER : t) && ("number" == typeof e || reIsUint.test(e)) && e > -1 && e % 1 == 0 && e < t
			}

			function isKeyable(e) {
				var t = typeof e;
				return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== e : null === e
			}

			function isMasked(e) {
				return !!maskSrcKey && maskSrcKey in e
			}

			function isPrototype(e) {
				var t = e && e.constructor;
				return e === ("function" == typeof t && t.prototype || objectProto)
			}

			function toSource(e) {
				if (null != e) {
					try {
						return funcToString.call(e)
					} catch (e) {}
					try {
						return e + ""
					} catch (e) {}
				}
				return ""
			}

			function cloneDeep(e) {
				return baseClone(e, !0, !0)
			}

			function eq(e, t) {
				return e === t || e != e && t != t
			}

			function isArguments(e) {
				return isArrayLikeObject(e) && hasOwnProperty.call(e, "callee") && (!propertyIsEnumerable.call(e, "callee") || objectToString.call(e) == argsTag)
			}(DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) && (getTag = function(e) {
				var t = objectToString.call(e),
					a = t == objectTag ? e.constructor : void 0,
					r = a ? toSource(a) : void 0;
				if (r) switch (r) {
					case dataViewCtorString:
						return dataViewTag;
					case mapCtorString:
						return mapTag;
					case promiseCtorString:
						return promiseTag;
					case setCtorString:
						return setTag;
					case weakMapCtorString:
						return weakMapTag
				}
				return t
			});
			var isArray = Array.isArray;

			function isArrayLike(e) {
				return null != e && isLength(e.length) && !isFunction(e)
			}

			function isArrayLikeObject(e) {
				return isObjectLike(e) && isArrayLike(e)
			}
			var isBuffer = nativeIsBuffer || stubFalse;

			function isFunction(e) {
				var t = isObject(e) ? objectToString.call(e) : "";
				return t == funcTag || t == genTag
			}

			function isLength(e) {
				return "number" == typeof e && e > -1 && e % 1 == 0 && e <= MAX_SAFE_INTEGER
			}

			function isObject(e) {
				var t = typeof e;
				return !!e && ("object" == t || "function" == t)
			}

			function isObjectLike(e) {
				return !!e && "object" == typeof e
			}

			function keys(e) {
				return isArrayLike(e) ? arrayLikeKeys(e) : baseKeys(e)
			}

			function stubArray() {
				return []
			}

			function stubFalse() {
				return !1
			}
			module.exports = cloneDeep;

		}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	}, {}],
	51: [function(require, module, exports) {
		(function(global) {
			var FUNC_ERROR_TEXT = "Expected a function",
				NAN = NaN,
				symbolTag = "[object Symbol]",
				reTrim = /^\s+|\s+$/g,
				reIsBadHex = /^[-+]0x[0-9a-f]+$/i,
				reIsBinary = /^0b[01]+$/i,
				reIsOctal = /^0o[0-7]+$/i,
				freeParseInt = parseInt,
				freeGlobal = "object" == typeof global && global && global.Object === Object && global,
				freeSelf = "object" == typeof self && self && self.Object === Object && self,
				root = freeGlobal || freeSelf || Function("return this")(),
				objectProto = Object.prototype,
				objectToString = objectProto.toString,
				nativeMax = Math.max,
				nativeMin = Math.min,
				now = function() {
					return root.Date.now()
				};

			function debounce(e, t, r) {
				var o, n, i, u, a, f, c = 0,
					l = !1,
					b = !1,
					s = !0;
				if ("function" != typeof e) throw new TypeError(FUNC_ERROR_TEXT);

				function v(t) {
					var r = o,
						i = n;
					return o = n = void 0, c = t, u = e.apply(i, r)
				}

				function m(e) {
					var r = e - f;
					return void 0 === f || r >= t || r < 0 || b && e - c >= i
				}

				function j() {
					var e = now();
					if (m(e)) return y(e);
					a = setTimeout(j, function(e) {
						var r = t - (e - f);
						return b ? nativeMin(r, i - (e - c)) : r
					}(e))
				}

				function y(e) {
					return a = void 0, s && o ? v(e) : (o = n = void 0, u)
				}

				function p() {
					var e = now(),
						r = m(e);
					if (o = arguments, n = this, f = e, r) {
						if (void 0 === a) return function(e) {
							return c = e, a = setTimeout(j, t), l ? v(e) : u
						}(f);
						if (b) return a = setTimeout(j, t), v(f)
					}
					return void 0 === a && (a = setTimeout(j, t)), u
				}
				return t = toNumber(t) || 0, isObject(r) && (l = !!r.leading, i = (b = "maxWait" in r) ? nativeMax(toNumber(r.maxWait) || 0, t) : i, s = "trailing" in r ? !!r.trailing : s), p.cancel = function() {
					void 0 !== a && clearTimeout(a), c = 0, o = f = n = a = void 0
				}, p.flush = function() {
					return void 0 === a ? u : y(now())
				}, p
			}

			function isObject(e) {
				var t = typeof e;
				return !!e && ("object" == t || "function" == t)
			}

			function isObjectLike(e) {
				return !!e && "object" == typeof e
			}

			function isSymbol(e) {
				return "symbol" == typeof e || isObjectLike(e) && objectToString.call(e) == symbolTag
			}

			function toNumber(e) {
				if ("number" == typeof e) return e;
				if (isSymbol(e)) return NAN;
				if (isObject(e)) {
					var t = "function" == typeof e.valueOf ? e.valueOf() : e;
					e = isObject(t) ? t + "" : t
				}
				if ("string" != typeof e) return 0 === e ? e : +e;
				e = e.replace(reTrim, "");
				var r = reIsBinary.test(e);
				return r || reIsOctal.test(e) ? freeParseInt(e.slice(2), r ? 2 : 8) : reIsBadHex.test(e) ? NAN : +e
			}
			module.exports = debounce;

		}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	}, {}],
	52: [function(require, module, exports) {
		(function(global) {
			var FUNC_ERROR_TEXT = "Expected a function",
				NAN = NaN,
				symbolTag = "[object Symbol]",
				reTrim = /^\s+|\s+$/g,
				reIsBadHex = /^[-+]0x[0-9a-f]+$/i,
				reIsBinary = /^0b[01]+$/i,
				reIsOctal = /^0o[0-7]+$/i,
				freeParseInt = parseInt,
				freeGlobal = "object" == typeof global && global && global.Object === Object && global,
				freeSelf = "object" == typeof self && self && self.Object === Object && self,
				root = freeGlobal || freeSelf || Function("return this")(),
				objectProto = Object.prototype,
				objectToString = objectProto.toString,
				nativeMax = Math.max,
				nativeMin = Math.min,
				now = function() {
					return root.Date.now()
				};

			function debounce(t, e, n) {
				var r, i, o, a, u, f, c = 0,
					l = !1,
					b = !1,
					s = !0;
				if ("function" != typeof t) throw new TypeError(FUNC_ERROR_TEXT);

				function v(e) {
					var n = r,
						o = i;
					return r = i = void 0, c = e, a = t.apply(o, n)
				}

				function m(t) {
					var n = t - f;
					return void 0 === f || n >= e || n < 0 || b && t - c >= o
				}

				function y() {
					var t = now();
					if (m(t)) return j(t);
					u = setTimeout(y, function(t) {
						var n = e - (t - f);
						return b ? nativeMin(n, o - (t - c)) : n
					}(t))
				}

				function j(t) {
					return u = void 0, s && r ? v(t) : (r = i = void 0, a)
				}

				function g() {
					var t = now(),
						n = m(t);
					if (r = arguments, i = this, f = t, n) {
						if (void 0 === u) return function(t) {
							return c = t, u = setTimeout(y, e), l ? v(t) : a
						}(f);
						if (b) return u = setTimeout(y, e), v(f)
					}
					return void 0 === u && (u = setTimeout(y, e)), a
				}
				return e = toNumber(e) || 0, isObject(n) && (l = !!n.leading, o = (b = "maxWait" in n) ? nativeMax(toNumber(n.maxWait) || 0, e) : o, s = "trailing" in n ? !!n.trailing : s), g.cancel = function() {
					void 0 !== u && clearTimeout(u), c = 0, r = f = i = u = void 0
				}, g.flush = function() {
					return void 0 === u ? a : j(now())
				}, g
			}

			function throttle(t, e, n) {
				var r = !0,
					i = !0;
				if ("function" != typeof t) throw new TypeError(FUNC_ERROR_TEXT);
				return isObject(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), debounce(t, e, {
					leading: r,
					maxWait: e,
					trailing: i
				})
			}

			function isObject(t) {
				var e = typeof t;
				return !!t && ("object" == e || "function" == e)
			}

			function isObjectLike(t) {
				return !!t && "object" == typeof t
			}

			function isSymbol(t) {
				return "symbol" == typeof t || isObjectLike(t) && objectToString.call(t) == symbolTag
			}

			function toNumber(t) {
				if ("number" == typeof t) return t;
				if (isSymbol(t)) return NAN;
				if (isObject(t)) {
					var e = "function" == typeof t.valueOf ? t.valueOf() : t;
					t = isObject(e) ? e + "" : e
				}
				if ("string" != typeof t) return 0 === t ? t : +t;
				t = t.replace(reTrim, "");
				var n = reIsBinary.test(t);
				return n || reIsOctal.test(t) ? freeParseInt(t.slice(2), n ? 2 : 8) : reIsBadHex.test(t) ? NAN : +t
			}
			module.exports = throttle;

		}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	}, {}],
	53: [function(require, module, exports) {
		(function(process) {
			function normalizeArray(r, t) {
				for (var e = 0, n = r.length - 1; n >= 0; n--) {
					var o = r[n];
					"." === o ? r.splice(n, 1) : ".." === o ? (r.splice(n, 1), e++) : e && (r.splice(n, 1), e--)
				}
				if (t)
					for (; e--; e) r.unshift("..");
				return r
			}

			function basename(r) {
				"string" != typeof r && (r += "");
				var t, e = 0,
					n = -1,
					o = !0;
				for (t = r.length - 1; t >= 0; --t)
					if (47 === r.charCodeAt(t)) {
						if (!o) {
							e = t + 1;
							break
						}
					} else -1 === n && (o = !1, n = t + 1);
				return -1 === n ? "" : r.slice(e, n)
			}

			function filter(r, t) {
				if (r.filter) return r.filter(t);
				for (var e = [], n = 0; n < r.length; n++) t(r[n], n, r) && e.push(r[n]);
				return e
			}
			exports.resolve = function() {
				for (var r = "", t = !1, e = arguments.length - 1; e >= -1 && !t; e--) {
					var n = e >= 0 ? arguments[e] : process.cwd();
					if ("string" != typeof n) throw new TypeError("Arguments to path.resolve must be strings");
					n && (r = n + "/" + r, t = "/" === n.charAt(0))
				}
				return (t ? "/" : "") + (r = normalizeArray(filter(r.split("/"), function(r) {
					return !!r
				}), !t).join("/")) || "."
			}, exports.normalize = function(r) {
				var t = exports.isAbsolute(r),
					e = "/" === substr(r, -1);
				return (r = normalizeArray(filter(r.split("/"), function(r) {
					return !!r
				}), !t).join("/")) || t || (r = "."), r && e && (r += "/"), (t ? "/" : "") + r
			}, exports.isAbsolute = function(r) {
				return "/" === r.charAt(0)
			}, exports.join = function() {
				var r = Array.prototype.slice.call(arguments, 0);
				return exports.normalize(filter(r, function(r, t) {
					if ("string" != typeof r) throw new TypeError("Arguments to path.join must be strings");
					return r
				}).join("/"))
			}, exports.relative = function(r, t) {
				function e(r) {
					for (var t = 0; t < r.length && "" === r[t]; t++);
					for (var e = r.length - 1; e >= 0 && "" === r[e]; e--);
					return t > e ? [] : r.slice(t, e - t + 1)
				}
				r = exports.resolve(r).substr(1), t = exports.resolve(t).substr(1);
				for (var n = e(r.split("/")), o = e(t.split("/")), s = Math.min(n.length, o.length), i = s, u = 0; u < s; u++)
					if (n[u] !== o[u]) {
						i = u;
						break
					} var l = [];
				for (u = i; u < n.length; u++) l.push("..");
				return (l = l.concat(o.slice(i))).join("/")
			}, exports.sep = "/", exports.delimiter = ":", exports.dirname = function(r) {
				if ("string" != typeof r && (r += ""), 0 === r.length) return ".";
				for (var t = r.charCodeAt(0), e = 47 === t, n = -1, o = !0, s = r.length - 1; s >= 1; --s)
					if (47 === (t = r.charCodeAt(s))) {
						if (!o) {
							n = s;
							break
						}
					} else o = !1;
				return -1 === n ? e ? "/" : "." : e && 1 === n ? "/" : r.slice(0, n)
			}, exports.basename = function(r, t) {
				var e = basename(r);
				return t && e.substr(-1 * t.length) === t && (e = e.substr(0, e.length - t.length)), e
			}, exports.extname = function(r) {
				"string" != typeof r && (r += "");
				for (var t = -1, e = 0, n = -1, o = !0, s = 0, i = r.length - 1; i >= 0; --i) {
					var u = r.charCodeAt(i);
					if (47 !== u) - 1 === n && (o = !1, n = i + 1), 46 === u ? -1 === t ? t = i : 1 !== s && (s = 1) : -1 !== t && (s = -1);
					else if (!o) {
						e = i + 1;
						break
					}
				}
				return -1 === t || -1 === n || 0 === s || 1 === s && t === n - 1 && t === e + 1 ? "" : r.slice(t, n)
			};
			var substr = "b" === "ab".substr(-1) ? function(r, t, e) {
				return r.substr(t, e)
			} : function(r, t, e) {
				return t < 0 && (t = r.length + t), r.substr(t, e)
			};

		}).call(this, require('_process'))
	}, {
		"_process": 56
	}],
	54: [function(require, module, exports) {
		"use strict";
		module.exports = Pbf;
		var ieee754 = require("ieee754");

		function Pbf(t) {
			this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length
		}
		Pbf.Varint = 0, Pbf.Fixed64 = 1, Pbf.Bytes = 2, Pbf.Fixed32 = 5;
		var SHIFT_LEFT_32 = 4294967296,
			SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,
			TEXT_DECODER_MIN_LENGTH = 12,
			utf8TextDecoder = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");

		function readVarintRemainder(t, i, e) {
			var r, s, n = e.buf;
			if (r = (112 & (s = n[e.pos++])) >> 4, s < 128) return toNum(t, r, i);
			if (r |= (127 & (s = n[e.pos++])) << 3, s < 128) return toNum(t, r, i);
			if (r |= (127 & (s = n[e.pos++])) << 10, s < 128) return toNum(t, r, i);
			if (r |= (127 & (s = n[e.pos++])) << 17, s < 128) return toNum(t, r, i);
			if (r |= (127 & (s = n[e.pos++])) << 24, s < 128) return toNum(t, r, i);
			if (r |= (1 & (s = n[e.pos++])) << 31, s < 128) return toNum(t, r, i);
			throw new Error("Expected varint not more than 10 bytes")
		}

		function readPackedEnd(t) {
			return t.type === Pbf.Bytes ? t.readVarint() + t.pos : t.pos + 1
		}

		function toNum(t, i, e) {
			return e ? 4294967296 * i + (t >>> 0) : 4294967296 * (i >>> 0) + (t >>> 0)
		}

		function writeBigVarint(t, i) {
			var e, r;
			if (t >= 0 ? (e = t % 4294967296 | 0, r = t / 4294967296 | 0) : (r = ~(-t / 4294967296), 4294967295 ^ (e = ~(-t % 4294967296)) ? e = e + 1 | 0 : (e = 0, r = r + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");
			i.realloc(10), writeBigVarintLow(e, r, i), writeBigVarintHigh(r, i)
		}

		function writeBigVarintLow(t, i, e) {
			e.buf[e.pos++] = 127 & t | 128, t >>>= 7, e.buf[e.pos++] = 127 & t | 128, t >>>= 7, e.buf[e.pos++] = 127 & t | 128, t >>>= 7, e.buf[e.pos++] = 127 & t | 128, t >>>= 7, e.buf[e.pos] = 127 & t
		}

		function writeBigVarintHigh(t, i) {
			var e = (7 & t) << 4;
			i.buf[i.pos++] |= e | ((t >>>= 3) ? 128 : 0), t && (i.buf[i.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (i.buf[i.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (i.buf[i.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (i.buf[i.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (i.buf[i.pos++] = 127 & t)))))
		}

		function makeRoomForExtraLength(t, i, e) {
			var r = i <= 16383 ? 1 : i <= 2097151 ? 2 : i <= 268435455 ? 3 : Math.floor(Math.log(i) / (7 * Math.LN2));
			e.realloc(r);
			for (var s = e.pos - 1; s >= t; s--) e.buf[s + r] = e.buf[s]
		}

		function writePackedVarint(t, i) {
			for (var e = 0; e < t.length; e++) i.writeVarint(t[e])
		}

		function writePackedSVarint(t, i) {
			for (var e = 0; e < t.length; e++) i.writeSVarint(t[e])
		}

		function writePackedFloat(t, i) {
			for (var e = 0; e < t.length; e++) i.writeFloat(t[e])
		}

		function writePackedDouble(t, i) {
			for (var e = 0; e < t.length; e++) i.writeDouble(t[e])
		}

		function writePackedBoolean(t, i) {
			for (var e = 0; e < t.length; e++) i.writeBoolean(t[e])
		}

		function writePackedFixed32(t, i) {
			for (var e = 0; e < t.length; e++) i.writeFixed32(t[e])
		}

		function writePackedSFixed32(t, i) {
			for (var e = 0; e < t.length; e++) i.writeSFixed32(t[e])
		}

		function writePackedFixed64(t, i) {
			for (var e = 0; e < t.length; e++) i.writeFixed64(t[e])
		}

		function writePackedSFixed64(t, i) {
			for (var e = 0; e < t.length; e++) i.writeSFixed64(t[e])
		}

		function readUInt32(t, i) {
			return (t[i] | t[i + 1] << 8 | t[i + 2] << 16) + 16777216 * t[i + 3]
		}

		function writeInt32(t, i, e) {
			t[e] = i, t[e + 1] = i >>> 8, t[e + 2] = i >>> 16, t[e + 3] = i >>> 24
		}

		function readInt32(t, i) {
			return (t[i] | t[i + 1] << 8 | t[i + 2] << 16) + (t[i + 3] << 24)
		}

		function readUtf8(t, i, e) {
			for (var r = "", s = i; s < e;) {
				var n, o, a, h = t[s],
					u = null,
					f = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
				if (s + f > e) break;
				1 === f ? h < 128 && (u = h) : 2 === f ? 128 == (192 & (n = t[s + 1])) && (u = (31 & h) << 6 | 63 & n) <= 127 && (u = null) : 3 === f ? (n = t[s + 1], o = t[s + 2], 128 == (192 & n) && 128 == (192 & o) && ((u = (15 & h) << 12 | (63 & n) << 6 | 63 & o) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === f && (n = t[s + 1], o = t[s + 2], a = t[s + 3], 128 == (192 & n) && 128 == (192 & o) && 128 == (192 & a) && ((u = (15 & h) << 18 | (63 & n) << 12 | (63 & o) << 6 | 63 & a) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, f = 1) : u > 65535 && (u -= 65536, r += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), r += String.fromCharCode(u), s += f
			}
			return r
		}

		function readUtf8TextDecoder(t, i, e) {
			return utf8TextDecoder.decode(t.subarray(i, e))
		}

		function writeUtf8(t, i, e) {
			for (var r, s, n = 0; n < i.length; n++) {
				if ((r = i.charCodeAt(n)) > 55295 && r < 57344) {
					if (!s) {
						r > 56319 || n + 1 === i.length ? (t[e++] = 239, t[e++] = 191, t[e++] = 189) : s = r;
						continue
					}
					if (r < 56320) {
						t[e++] = 239, t[e++] = 191, t[e++] = 189, s = r;
						continue
					}
					r = s - 55296 << 10 | r - 56320 | 65536, s = null
				} else s && (t[e++] = 239, t[e++] = 191, t[e++] = 189, s = null);
				r < 128 ? t[e++] = r : (r < 2048 ? t[e++] = r >> 6 | 192 : (r < 65536 ? t[e++] = r >> 12 | 224 : (t[e++] = r >> 18 | 240, t[e++] = r >> 12 & 63 | 128), t[e++] = r >> 6 & 63 | 128), t[e++] = 63 & r | 128)
			}
			return e
		}
		Pbf.prototype = {
			destroy: function() {
				this.buf = null
			},
			readFields: function(t, i, e) {
				for (e = e || this.length; this.pos < e;) {
					var r = this.readVarint(),
						s = r >> 3,
						n = this.pos;
					this.type = 7 & r, t(s, i, this), this.pos === n && this.skip(r)
				}
				return i
			},
			readMessage: function(t, i) {
				return this.readFields(t, i, this.readVarint() + this.pos)
			},
			readFixed32: function() {
				var t = readUInt32(this.buf, this.pos);
				return this.pos += 4, t
			},
			readSFixed32: function() {
				var t = readInt32(this.buf, this.pos);
				return this.pos += 4, t
			},
			readFixed64: function() {
				var t = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
				return this.pos += 8, t
			},
			readSFixed64: function() {
				var t = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
				return this.pos += 8, t
			},
			readFloat: function() {
				var t = ieee754.read(this.buf, this.pos, !0, 23, 4);
				return this.pos += 4, t
			},
			readDouble: function() {
				var t = ieee754.read(this.buf, this.pos, !0, 52, 8);
				return this.pos += 8, t
			},
			readVarint: function(t) {
				var i, e, r = this.buf;
				return i = 127 & (e = r[this.pos++]), e < 128 ? i : (i |= (127 & (e = r[this.pos++])) << 7, e < 128 ? i : (i |= (127 & (e = r[this.pos++])) << 14, e < 128 ? i : (i |= (127 & (e = r[this.pos++])) << 21, e < 128 ? i : readVarintRemainder(i |= (15 & (e = r[this.pos])) << 28, t, this))))
			},
			readVarint64: function() {
				return this.readVarint(!0)
			},
			readSVarint: function() {
				var t = this.readVarint();
				return t % 2 == 1 ? (t + 1) / -2 : t / 2
			},
			readBoolean: function() {
				return Boolean(this.readVarint())
			},
			readString: function() {
				var t = this.readVarint() + this.pos,
					i = this.pos;
				return this.pos = t, t - i >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder ? readUtf8TextDecoder(this.buf, i, t) : readUtf8(this.buf, i, t)
			},
			readBytes: function() {
				var t = this.readVarint() + this.pos,
					i = this.buf.subarray(this.pos, t);
				return this.pos = t, i
			},
			readPackedVarint: function(t, i) {
				if (this.type !== Pbf.Bytes) return t.push(this.readVarint(i));
				var e = readPackedEnd(this);
				for (t = t || []; this.pos < e;) t.push(this.readVarint(i));
				return t
			},
			readPackedSVarint: function(t) {
				if (this.type !== Pbf.Bytes) return t.push(this.readSVarint());
				var i = readPackedEnd(this);
				for (t = t || []; this.pos < i;) t.push(this.readSVarint());
				return t
			},
			readPackedBoolean: function(t) {
				if (this.type !== Pbf.Bytes) return t.push(this.readBoolean());
				var i = readPackedEnd(this);
				for (t = t || []; this.pos < i;) t.push(this.readBoolean());
				return t
			},
			readPackedFloat: function(t) {
				if (this.type !== Pbf.Bytes) return t.push(this.readFloat());
				var i = readPackedEnd(this);
				for (t = t || []; this.pos < i;) t.push(this.readFloat());
				return t
			},
			readPackedDouble: function(t) {
				if (this.type !== Pbf.Bytes) return t.push(this.readDouble());
				var i = readPackedEnd(this);
				for (t = t || []; this.pos < i;) t.push(this.readDouble());
				return t
			},
			readPackedFixed32: function(t) {
				if (this.type !== Pbf.Bytes) return t.push(this.readFixed32());
				var i = readPackedEnd(this);
				for (t = t || []; this.pos < i;) t.push(this.readFixed32());
				return t
			},
			readPackedSFixed32: function(t) {
				if (this.type !== Pbf.Bytes) return t.push(this.readSFixed32());
				var i = readPackedEnd(this);
				for (t = t || []; this.pos < i;) t.push(this.readSFixed32());
				return t
			},
			readPackedFixed64: function(t) {
				if (this.type !== Pbf.Bytes) return t.push(this.readFixed64());
				var i = readPackedEnd(this);
				for (t = t || []; this.pos < i;) t.push(this.readFixed64());
				return t
			},
			readPackedSFixed64: function(t) {
				if (this.type !== Pbf.Bytes) return t.push(this.readSFixed64());
				var i = readPackedEnd(this);
				for (t = t || []; this.pos < i;) t.push(this.readSFixed64());
				return t
			},
			skip: function(t) {
				var i = 7 & t;
				if (i === Pbf.Varint)
					for (; this.buf[this.pos++] > 127;);
				else if (i === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
				else if (i === Pbf.Fixed32) this.pos += 4;
				else {
					if (i !== Pbf.Fixed64) throw new Error("Unimplemented type: " + i);
					this.pos += 8
				}
			},
			writeTag: function(t, i) {
				this.writeVarint(t << 3 | i)
			},
			realloc: function(t) {
				for (var i = this.length || 16; i < this.pos + t;) i *= 2;
				if (i !== this.length) {
					var e = new Uint8Array(i);
					e.set(this.buf), this.buf = e, this.length = i
				}
			},
			finish: function() {
				return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
			},
			writeFixed32: function(t) {
				this.realloc(4), writeInt32(this.buf, t, this.pos), this.pos += 4
			},
			writeSFixed32: function(t) {
				this.realloc(4), writeInt32(this.buf, t, this.pos), this.pos += 4
			},
			writeFixed64: function(t) {
				this.realloc(8), writeInt32(this.buf, -1 & t, this.pos), writeInt32(this.buf, Math.floor(t * SHIFT_RIGHT_32), this.pos + 4), this.pos += 8
			},
			writeSFixed64: function(t) {
				this.realloc(8), writeInt32(this.buf, -1 & t, this.pos), writeInt32(this.buf, Math.floor(t * SHIFT_RIGHT_32), this.pos + 4), this.pos += 8
			},
			writeVarint: function(t) {
				(t = +t || 0) > 268435455 || t < 0 ? writeBigVarint(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))))
			},
			writeSVarint: function(t) {
				this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t)
			},
			writeBoolean: function(t) {
				this.writeVarint(Boolean(t))
			},
			writeString: function(t) {
				t = String(t), this.realloc(4 * t.length), this.pos++;
				var i = this.pos;
				this.pos = writeUtf8(this.buf, t, this.pos);
				var e = this.pos - i;
				e >= 128 && makeRoomForExtraLength(i, e, this), this.pos = i - 1, this.writeVarint(e), this.pos += e
			},
			writeFloat: function(t) {
				this.realloc(4), ieee754.write(this.buf, t, this.pos, !0, 23, 4), this.pos += 4
			},
			writeDouble: function(t) {
				this.realloc(8), ieee754.write(this.buf, t, this.pos, !0, 52, 8), this.pos += 8
			},
			writeBytes: function(t) {
				var i = t.length;
				this.writeVarint(i), this.realloc(i);
				for (var e = 0; e < i; e++) this.buf[this.pos++] = t[e]
			},
			writeRawMessage: function(t, i) {
				this.pos++;
				var e = this.pos;
				t(i, this);
				var r = this.pos - e;
				r >= 128 && makeRoomForExtraLength(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r
			},
			writeMessage: function(t, i, e) {
				this.writeTag(t, Pbf.Bytes), this.writeRawMessage(i, e)
			},
			writePackedVarint: function(t, i) {
				i.length && this.writeMessage(t, writePackedVarint, i)
			},
			writePackedSVarint: function(t, i) {
				i.length && this.writeMessage(t, writePackedSVarint, i)
			},
			writePackedBoolean: function(t, i) {
				i.length && this.writeMessage(t, writePackedBoolean, i)
			},
			writePackedFloat: function(t, i) {
				i.length && this.writeMessage(t, writePackedFloat, i)
			},
			writePackedDouble: function(t, i) {
				i.length && this.writeMessage(t, writePackedDouble, i)
			},
			writePackedFixed32: function(t, i) {
				i.length && this.writeMessage(t, writePackedFixed32, i)
			},
			writePackedSFixed32: function(t, i) {
				i.length && this.writeMessage(t, writePackedSFixed32, i)
			},
			writePackedFixed64: function(t, i) {
				i.length && this.writeMessage(t, writePackedFixed64, i)
			},
			writePackedSFixed64: function(t, i) {
				i.length && this.writeMessage(t, writePackedSFixed64, i)
			},
			writeBytesField: function(t, i) {
				this.writeTag(t, Pbf.Bytes), this.writeBytes(i)
			},
			writeFixed32Field: function(t, i) {
				this.writeTag(t, Pbf.Fixed32), this.writeFixed32(i)
			},
			writeSFixed32Field: function(t, i) {
				this.writeTag(t, Pbf.Fixed32), this.writeSFixed32(i)
			},
			writeFixed64Field: function(t, i) {
				this.writeTag(t, Pbf.Fixed64), this.writeFixed64(i)
			},
			writeSFixed64Field: function(t, i) {
				this.writeTag(t, Pbf.Fixed64), this.writeSFixed64(i)
			},
			writeVarintField: function(t, i) {
				this.writeTag(t, Pbf.Varint), this.writeVarint(i)
			},
			writeSVarintField: function(t, i) {
				this.writeTag(t, Pbf.Varint), this.writeSVarint(i)
			},
			writeStringField: function(t, i) {
				this.writeTag(t, Pbf.Bytes), this.writeString(i)
			},
			writeFloatField: function(t, i) {
				this.writeTag(t, Pbf.Fixed32), this.writeFloat(i)
			},
			writeDoubleField: function(t, i) {
				this.writeTag(t, Pbf.Fixed64), this.writeDouble(i)
			},
			writeBooleanField: function(t, i) {
				this.writeVarintField(t, Boolean(i))
			}
		};

	}, {
		"ieee754": 49
	}],
	55: [function(require, module, exports) {
		! function(t, e) {
			"object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define("Phaser", [], e) : "object" == typeof exports ? exports.Phaser = e() : t.Phaser = e()
		}(window, function() {
			return i = {}, t.m = e = [function(t, e) {
				function i(t, e, i, n) {
					for (var r in e)
						if (e.hasOwnProperty(r)) {
							var o = (l = e, c = r, p = f = void 0, p = (d = i) ? l[c] : Object.getOwnPropertyDescriptor(l, c), !d && p.value && "object" == typeof p.value && (p = p.value), !(!p || !((f = p).get && "function" == typeof f.get || f.set && "function" == typeof f.set)) && (void 0 === p.enumerable && (p.enumerable = !0), void 0 === p.configurable && (p.configurable = !0), p));
							if (!1 !== o) {
								if (a = (n || t).prototype, h = r, u = void 0, (u = Object.getOwnPropertyDescriptor(a, h)) && (u.value && "object" == typeof u.value && (u = u.value), !1 === u.configurable)) {
									if (s.ignoreFinals) continue;
									throw new Error("cannot override final property '" + r + "', set Class.ignoreFinals = true to skip")
								}
								Object.defineProperty(t.prototype, r, o)
							} else t.prototype[r] = e[r]
						} var a, h, u, l, c, d, f, p
				}

				function n(t, e) {
					if (e) {
						Array.isArray(e) || (e = [e]);
						for (var n = 0; n < e.length; n++) i(t, e[n].prototype || e[n])
					}
				}

				function s(t) {
					var e, s, r;
					if ((t = t || {}).initialize) {
						if ("function" != typeof t.initialize) throw new Error("initialize must be a function");
						r = t.initialize, delete t.initialize
					} else r = t.Extends ? (s = t.Extends, function() {
						s.apply(this, arguments)
					}) : function() {};
					t.Extends ? (r.prototype = Object.create(t.Extends.prototype), r.prototype.constructor = r, e = t.Extends, delete t.Extends) : r.prototype.constructor = r;
					var o = null;
					return t.Mixins && (o = t.Mixins, delete t.Mixins), n(r, o), i(r, t, !0, e), r
				}
				s.extend = i, s.mixin = n, s.ignoreFinals = !1, t.exports = s
			}, function(t, e) {
				t.exports = function() {}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					var n = typeof t;
					return t && "number" != n && "string" != n && t.hasOwnProperty(e) && void 0 !== t[e] ? t[e] : i
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(106),
					r = new n({
						initialize: function(t, e) {
							this.x = 0, this.y = 0, "object" == typeof t ? (this.x = t.x || 0, this.y = t.y || 0) : (void 0 === e && (e = t), this.x = t || 0, this.y = e || 0)
						},
						clone: function() {
							return new r(this.x, this.y)
						},
						copy: function(t) {
							return this.x = t.x || 0, this.y = t.y || 0, this
						},
						setFromObject: function(t) {
							return this.x = t.x || 0, this.y = t.y || 0, this
						},
						set: function(t, e) {
							return void 0 === e && (e = t), this.x = t, this.y = e, this
						},
						setTo: function(t, e) {
							return this.set(t, e)
						},
						setToPolar: function(t, e) {
							return null == e && (e = 1), this.x = Math.cos(t) * e, this.y = Math.sin(t) * e, this
						},
						equals: function(t) {
							return this.x === t.x && this.y === t.y
						},
						fuzzyEquals: function(t, e) {
							return s(this.x, t.x, e) && s(this.y, t.y, e)
						},
						angle: function() {
							var t = Math.atan2(this.y, this.x);
							return t < 0 && (t += 2 * Math.PI), t
						},
						setAngle: function(t) {
							return this.setToPolar(t, this.length())
						},
						add: function(t) {
							return this.x += t.x, this.y += t.y, this
						},
						subtract: function(t) {
							return this.x -= t.x, this.y -= t.y, this
						},
						multiply: function(t) {
							return this.x *= t.x, this.y *= t.y, this
						},
						scale: function(t) {
							return isFinite(t) ? (this.x *= t, this.y *= t) : (this.x = 0, this.y = 0), this
						},
						divide: function(t) {
							return this.x /= t.x, this.y /= t.y, this
						},
						negate: function() {
							return this.x = -this.x, this.y = -this.y, this
						},
						distance: function(t) {
							var e = t.x - this.x,
								i = t.y - this.y;
							return Math.sqrt(e * e + i * i)
						},
						distanceSq: function(t) {
							var e = t.x - this.x,
								i = t.y - this.y;
							return e * e + i * i
						},
						length: function() {
							var t = this.x,
								e = this.y;
							return Math.sqrt(t * t + e * e)
						},
						setLength: function(t) {
							return this.normalize().scale(t)
						},
						lengthSq: function() {
							var t = this.x,
								e = this.y;
							return t * t + e * e
						},
						normalize: function() {
							var t = this.x,
								e = this.y,
								i = t * t + e * e;
							return 0 < i && (i = 1 / Math.sqrt(i), this.x = t * i, this.y = e * i), this
						},
						normalizeRightHand: function() {
							var t = this.x;
							return this.x = -1 * this.y, this.y = t, this
						},
						normalizeLeftHand: function() {
							var t = this.x;
							return this.x = this.y, this.y = -1 * t, this
						},
						dot: function(t) {
							return this.x * t.x + this.y * t.y
						},
						cross: function(t) {
							return this.x * t.y - this.y * t.x
						},
						lerp: function(t, e) {
							void 0 === e && (e = 0);
							var i = this.x,
								n = this.y;
							return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this
						},
						transformMat3: function(t) {
							var e = this.x,
								i = this.y,
								n = t.val;
							return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this
						},
						transformMat4: function(t) {
							var e = this.x,
								i = this.y,
								n = t.val;
							return this.x = n[0] * e + n[4] * i + n[12], this.y = n[1] * e + n[5] * i + n[13], this
						},
						reset: function() {
							return this.x = 0, this.y = 0, this
						},
						limit: function(t) {
							var e = this.length();
							return e && t < e && this.scale(t / e), this
						},
						reflect: function(t) {
							return t = t.clone().normalize(), this.subtract(t.scale(2 * this.dot(t)))
						},
						mirror: function(t) {
							return this.reflect(t).negate()
						},
						rotate: function(t) {
							var e = Math.cos(t),
								i = Math.sin(t);
							return this.set(e * this.x - i * this.y, i * this.x + e * this.y)
						}
					});
				r.ZERO = new r, r.RIGHT = new r(1, 0), r.LEFT = new r(-1, 0), r.UP = new r(0, -1), r.DOWN = new r(0, 1), r.ONE = new r(1, 1), t.exports = r
			}, function(t, e, i) {
				var n = i(0),
					s = i(47),
					r = new n({
						initialize: function(t, e) {
							void 0 === t && (t = 0), void 0 === e && (e = t), this.type = s.POINT, this.x = t, this.y = e
						},
						setTo: function(t, e) {
							return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = i(0),
					s = i(23),
					r = i(22),
					o = new n({
						initialize: function(t) {
							this.scene = t, this.systems = t.sys, this.displayList, this.updateList, t.sys.events.once(r.BOOT, this.boot, this), t.sys.events.on(r.START, this.start, this)
						},
						boot: function() {
							this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.systems.events.once(r.DESTROY, this.destroy, this)
						},
						start: function() {
							this.systems.events.once(r.SHUTDOWN, this.shutdown, this)
						},
						existing: function(t) {
							return (t.renderCanvas || t.renderWebGL) && this.displayList.add(t), t.preUpdate && this.updateList.add(t), t
						},
						shutdown: function() {
							this.systems.events.off(r.SHUTDOWN, this.shutdown, this)
						},
						destroy: function() {
							this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null, this.displayList = null, this.updateList = null
						}
					});
				o.register = function(t, e) {
					o.prototype.hasOwnProperty(t) || (o.prototype[t] = e)
				}, o.remove = function(t) {
					o.prototype.hasOwnProperty(t) && delete o.prototype[t]
				}, s.register("GameObjectFactory", o, "add"), t.exports = o
			}, function(t, e) {
				t.exports = function(t, e, i) {
					if (t && "number" != typeof t) {
						if (t.hasOwnProperty(e)) return t[e];
						if (-1 === e.indexOf(".")) return i;
						for (var n = e.split("."), s = t, r = i, o = 0; o < n.length; o++) {
							if (!s.hasOwnProperty(n[o])) {
								r = i;
								break
							}
							r = s[n[o]], s = s[n[o]]
						}
						return r
					}
					return i
				}
			}, function(t, e) {
				t.exports = function(t) {
					if ("object" != typeof t || t.nodeType || t === t.window) return !1;
					try {
						if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1
					} catch (t) {
						return !1
					}
					return !0
				}
			}, function(t, e) {
				var i = {},
					n = {
						install: function(t) {
							for (var e in i) t[e] = i[e]
						},
						register: function(t, e) {
							i[t] = e
						},
						destroy: function() {
							i = {}
						}
					};
				t.exports = n
			}, function(t, e) {
				t.exports = {
					getTintFromFloats: function(t, e, i, n) {
						return ((255 & (255 * n | 0)) << 24 | (255 & (255 * t | 0)) << 16 | (255 & (255 * e | 0)) << 8 | 255 & (255 * i | 0)) >>> 0
					},
					getTintAppendFloatAlpha: function(t, e) {
						return ((255 & (255 * e | 0)) << 24 | t) >>> 0
					},
					getTintAppendFloatAlphaAndSwap: function(t, e) {
						return ((255 & (255 * e | 0)) << 24 | (255 & (0 | t)) << 16 | (255 & (t >> 8 | 0)) << 8 | 255 & (t >> 16 | 0)) >>> 0
					},
					getFloatsFromUintRGB: function(t) {
						return [(255 & (t >> 16 | 0)) / 255, (255 & (t >> 8 | 0)) / 255, (255 & (0 | t)) / 255]
					},
					getComponentCount: function(t, e) {
						for (var i = 0, n = 0; n < t.length; ++n) {
							var s = t[n];
							s.type === e.FLOAT ? i += s.size : i += 1
						}
						return i
					}
				}
			}, function(t, e, i) {
				"use strict";
				var n = Object.prototype.hasOwnProperty,
					s = "~";

				function r() {}

				function o(t, e, i) {
					this.fn = t, this.context = e, this.once = i || !1
				}

				function a(t, e, i, n, r) {
					if ("function" != typeof i) throw new TypeError("The listener must be a function");
					var a = new o(i, n || t, r),
						h = s ? s + e : e;
					return t._events[h] ? t._events[h].fn ? t._events[h] = [t._events[h], a] : t._events[h].push(a) : (t._events[h] = a, t._eventsCount++), t
				}

				function h(t, e) {
					0 == --t._eventsCount ? t._events = new r : delete t._events[e]
				}

				function u() {
					this._events = new r, this._eventsCount = 0
				}
				Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (s = !1)), u.prototype.eventNames = function() {
					var t, e, i = [];
					if (0 === this._eventsCount) return i;
					for (e in t = this._events) n.call(t, e) && i.push(s ? e.slice(1) : e);
					return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i
				}, u.prototype.listeners = function(t) {
					var e = s ? s + t : t,
						i = this._events[e];
					if (!i) return [];
					if (i.fn) return [i.fn];
					for (var n = 0, r = i.length, o = new Array(r); n < r; n++) o[n] = i[n].fn;
					return o
				}, u.prototype.listenerCount = function(t) {
					var e = s ? s + t : t,
						i = this._events[e];
					return i ? i.fn ? 1 : i.length : 0
				}, u.prototype.emit = function(t, e, i, n, r, o) {
					var a = s ? s + t : t;
					if (!this._events[a]) return !1;
					var h, u = this._events[a],
						l = arguments.length;
					if (u.fn) {
						switch (u.once && this.removeListener(t, u.fn, void 0, !0), l) {
							case 1:
								return u.fn.call(u.context), !0;
							case 2:
								return u.fn.call(u.context, e), !0;
							case 3:
								return u.fn.call(u.context, e, i), !0;
							case 4:
								return u.fn.call(u.context, e, i, n), !0;
							case 5:
								return u.fn.call(u.context, e, i, n, r), !0;
							case 6:
								return u.fn.call(u.context, e, i, n, r, o), !0
						}
						for (f = 1, h = new Array(l - 1); f < l; f++) h[f - 1] = arguments[f];
						u.fn.apply(u.context, h)
					} else
						for (var c, d = u.length, f = 0; f < d; f++) switch (u[f].once && this.removeListener(t, u[f].fn, void 0, !0), l) {
							case 1:
								u[f].fn.call(u[f].context);
								break;
							case 2:
								u[f].fn.call(u[f].context, e);
								break;
							case 3:
								u[f].fn.call(u[f].context, e, i);
								break;
							case 4:
								u[f].fn.call(u[f].context, e, i, n);
								break;
							default:
								if (!h)
									for (c = 1, h = new Array(l - 1); c < l; c++) h[c - 1] = arguments[c];
								u[f].fn.apply(u[f].context, h)
						}
					return !0
				}, u.prototype.on = function(t, e, i) {
					return a(this, t, e, i, !1)
				}, u.prototype.once = function(t, e, i) {
					return a(this, t, e, i, !0)
				}, u.prototype.removeListener = function(t, e, i, n) {
					var r = s ? s + t : t;
					if (!this._events[r]) return this;
					if (!e) return h(this, r), this;
					var o = this._events[r];
					if (o.fn) o.fn !== e || n && !o.once || i && o.context !== i || h(this, r);
					else {
						for (var a = 0, u = [], l = o.length; a < l; a++)(o[a].fn !== e || n && !o[a].once || i && o[a].context !== i) && u.push(o[a]);
						u.length ? this._events[r] = 1 === u.length ? u[0] : u : h(this, r)
					}
					return this
				}, u.prototype.removeAllListeners = function(t) {
					var e;
					return t ? (e = s ? s + t : t, this._events[e] && h(this, e)) : (this._events = new r, this._eventsCount = 0), this
				}, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = s, u.EventEmitter = u, t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(48),
					r = i(152),
					o = i(274),
					a = i(47),
					h = i(56),
					u = i(155),
					l = new n({
						initialize: function(t, e, i, n) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.type = a.RECTANGLE, this.x = t, this.y = e, this.width = i, this.height = n
						},
						contains: function(t, e) {
							return s(this, t, e)
						},
						getPoint: function(t, e) {
							return r(this, t, e)
						},
						getPoints: function(t, e, i) {
							return o(this, t, e, i)
						},
						getRandomPoint: function(t) {
							return u(this, t)
						},
						setTo: function(t, e, i, n) {
							return this.x = t, this.y = e, this.width = i, this.height = n, this
						},
						setEmpty: function() {
							return this.setTo(0, 0, 0, 0)
						},
						setPosition: function(t, e) {
							return void 0 === e && (e = t), this.x = t, this.y = e, this
						},
						setSize: function(t, e) {
							return void 0 === e && (e = t), this.width = t, this.height = e, this
						},
						isEmpty: function() {
							return this.width <= 0 || this.height <= 0
						},
						getLineA: function(t) {
							return void 0 === t && (t = new h), t.setTo(this.x, this.y, this.right, this.y), t
						},
						getLineB: function(t) {
							return void 0 === t && (t = new h), t.setTo(this.right, this.y, this.right, this.bottom), t
						},
						getLineC: function(t) {
							return void 0 === t && (t = new h), t.setTo(this.right, this.bottom, this.x, this.bottom), t
						},
						getLineD: function(t) {
							return void 0 === t && (t = new h), t.setTo(this.x, this.bottom, this.x, this.y), t
						},
						left: {
							get: function() {
								return this.x
							},
							set: function(t) {
								t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t
							}
						},
						right: {
							get: function() {
								return this.x + this.width
							},
							set: function(t) {
								t <= this.x ? this.width = 0 : this.width = t - this.x
							}
						},
						top: {
							get: function() {
								return this.y
							},
							set: function(t) {
								t >= this.bottom ? this.height = 0 : this.height = this.bottom - t, this.y = t
							}
						},
						bottom: {
							get: function() {
								return this.y + this.height
							},
							set: function(t) {
								t <= this.y ? this.height = 0 : this.height = t - this.y
							}
						},
						centerX: {
							get: function() {
								return this.x + this.width / 2
							},
							set: function(t) {
								this.x = t - this.width / 2
							}
						},
						centerY: {
							get: function() {
								return this.y + this.height / 2
							},
							set: function(t) {
								this.y = t - this.height / 2
							}
						}
					});
				t.exports = l
			}, function(t, e, i) {
				t.exports = {
					Alpha: i(533),
					AlphaSingle: i(269),
					Animation: i(504),
					BlendMode: i(272),
					ComputedSize: i(552),
					Crop: i(553),
					Depth: i(273),
					Flip: i(554),
					GetBounds: i(555),
					Mask: i(277),
					Origin: i(572),
					PathFollower: i(573),
					Pipeline: i(156),
					ScrollFactor: i(280),
					Size: i(574),
					Texture: i(575),
					TextureCrop: i(576),
					Tint: i(577),
					ToJSON: i(281),
					Transform: i(282),
					TransformMatrix: i(29),
					Visible: i(283)
				}
			}, function(t, e) {
				var i = {
					PI2: 2 * Math.PI,
					TAU: .5 * Math.PI,
					EPSILON: 1e-6,
					DEG_TO_RAD: Math.PI / 180,
					RAD_TO_DEG: 180 / Math.PI,
					RND: null,
					MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,
					MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991
				};
				t.exports = i
			}, function(t, e, i) {
				var n = i(0),
					s = i(281),
					r = i(113),
					o = i(10),
					a = i(90),
					h = new n({
						Extends: o,
						initialize: function(t, e) {
							o.call(this), this.scene = t, this.type = e, this.state = 0, this.parentContainer = null, this.name = "", this.active = !0, this.tabIndex = -1, this.data = null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.ignoreDestroy = !1, t.sys.queueDepthSort()
						},
						setActive: function(t) {
							return this.active = t, this
						},
						setName: function(t) {
							return this.name = t, this
						},
						setState: function(t) {
							return this.state = t, this
						},
						setDataEnabled: function() {
							return this.data || (this.data = new r(this)), this
						},
						setData: function(t, e) {
							return this.data || (this.data = new r(this)), this.data.set(t, e), this
						},
						incData: function(t, e) {
							return this.data || (this.data = new r(this)), this.data.inc(t, e), this
						},
						toggleData: function(t) {
							return this.data || (this.data = new r(this)), this.data.toggle(t), this
						},
						getData: function(t) {
							return this.data || (this.data = new r(this)), this.data.get(t)
						},
						setInteractive: function(t, e, i) {
							return this.scene.sys.input.enable(this, t, e, i), this
						},
						disableInteractive: function() {
							return this.input && (this.input.enabled = !1), this
						},
						removeInteractive: function() {
							return this.scene.sys.input.clear(this), this.input = void 0, this
						},
						update: function() {},
						toJSON: function() {
							return s(this)
						},
						willRender: function(t) {
							return !(h.RENDER_MASK !== this.renderFlags || 0 !== this.cameraFilter && this.cameraFilter & t.id)
						},
						getIndexList: function() {
							for (var t = this, e = this.parentContainer, i = []; e && (i.unshift(e.getIndex(t)), (t = e).parentContainer);) e = e.parentContainer;
							return i.unshift(this.scene.sys.displayList.getIndex(t)), i
						},
						destroy: function(t) {
							var e;
							void 0 === t && (t = !1), this.scene && !this.ignoreDestroy && (this.preDestroy && this.preDestroy.call(this), this.emit(a.DESTROY, this), e = this.scene.sys, t || (e.displayList.remove(this), e.updateList.remove(this)), this.input && (e.input.clear(this), this.input = void 0), this.data && (this.data.destroy(), this.data = void 0), this.body && (this.body.destroy(), this.body = void 0), t || e.queueDepthSort(), this.active = !1, this.visible = !1, this.scene = void 0, this.parentContainer = void 0, this.removeAllListeners())
						}
					});
				h.RENDER_MASK = 15, t.exports = h
			}, function(t, e, i) {
				var n = i(170),
					s = i(6);
				t.exports = function(t, e, i) {
					var r = s(t, e, null);
					if (null === r) return i;
					if (Array.isArray(r)) return n.RND.pick(r);
					if ("object" == typeof r) {
						if (r.hasOwnProperty("randInt")) return n.RND.integerInRange(r.randInt[0], r.randInt[1]);
						if (r.hasOwnProperty("randFloat")) return n.RND.realInRange(r.randFloat[0], r.randFloat[1])
					} else if ("function" == typeof r) return r(e);
					return r
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(23),
					r = i(22),
					o = new n({
						initialize: function(t) {
							this.scene = t, this.systems = t.sys, this.displayList, this.updateList, t.sys.events.once(r.BOOT, this.boot, this), t.sys.events.on(r.START, this.start, this)
						},
						boot: function() {
							this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.systems.events.once(r.DESTROY, this.destroy, this)
						},
						start: function() {
							this.systems.events.once(r.SHUTDOWN, this.shutdown, this)
						},
						shutdown: function() {
							this.systems.events.off(r.SHUTDOWN, this.shutdown, this)
						},
						destroy: function() {
							this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null, this.displayList = null, this.updateList = null
						}
					});
				o.register = function(t, e) {
					o.prototype.hasOwnProperty(t) || (o.prototype[t] = e)
				}, o.remove = function(t) {
					o.prototype.hasOwnProperty(t) && delete o.prototype[t]
				}, s.register("GameObjectCreator", o, "make"), t.exports = o
			}, function(t, e) {
				t.exports = {
					LOADER_IDLE: 0,
					LOADER_LOADING: 1,
					LOADER_PROCESSING: 2,
					LOADER_COMPLETE: 3,
					LOADER_SHUTDOWN: 4,
					LOADER_DESTROYED: 5,
					FILE_PENDING: 10,
					FILE_LOADING: 11,
					FILE_LOADED: 12,
					FILE_FAILED: 13,
					FILE_PROCESSING: 14,
					FILE_ERRORED: 16,
					FILE_COMPLETE: 17,
					FILE_DESTROYED: 18,
					FILE_POPULATED: 19
				}
			}, function(t, e, i) {
				var n = i(7),
					s = function() {
						var t, e, i, r, o, a, h = arguments[0] || {},
							u = 1,
							l = arguments.length,
							c = !1;
						for ("boolean" == typeof h && (c = h, h = arguments[1] || {}, u = 2), l === u && (h = this, --u); u < l; u++)
							if (null != (t = arguments[u]))
								for (e in t) i = h[e], h !== (r = t[e]) && (c && r && (n(r) || (o = Array.isArray(r))) ? (a = o ? (o = !1, i && Array.isArray(i) ? i : []) : i && n(i) ? i : {}, h[e] = s(c, a, r)) : void 0 !== r && (h[e] = r));
						return h
					};
				t.exports = s
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return Math.max(e, Math.min(i, t))
				}
			}, function(t, e, i) {
				t.exports = {
					BLUR: i(556),
					BOOT: i(557),
					CONTEXT_LOST: i(558),
					CONTEXT_RESTORED: i(559),
					DESTROY: i(560),
					FOCUS: i(561),
					HIDDEN: i(562),
					PAUSE: i(563),
					POST_RENDER: i(564),
					POST_STEP: i(565),
					PRE_RENDER: i(566),
					PRE_STEP: i(567),
					READY: i(568),
					RESUME: i(569),
					STEP: i(570),
					VISIBLE: i(571)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(82),
					o = i(2),
					a = i(138),
					h = i(215),
					u = i(455),
					l = i(139),
					c = new n({
						initialize: function(t, e) {
							this.loader = t, this.cache = o(e, "cache", !1), this.type = o(e, "type", !1), this.key = o(e, "key", !1);
							var i = this.key;
							if (t.prefix && "" !== t.prefix && (this.key = t.prefix + i), !this.type || !this.key) throw new Error("Error calling 'Loader." + this.type + "' invalid key provided.");
							this.url = o(e, "url"), void 0 === this.url ? this.url = t.path + i + "." + o(e, "extension", "") : "string" == typeof this.url && 0 !== this.url.indexOf("blob:") && 0 !== this.url.indexOf("data:") && (this.url = t.path + this.url), this.src = "", this.xhrSettings = l(o(e, "responseType", void 0)), o(e, "xhrSettings", !1) && (this.xhrSettings = h(this.xhrSettings, o(e, "xhrSettings", {}))), this.xhrLoader = null, this.state = "function" == typeof this.url ? s.FILE_POPULATED : s.FILE_PENDING, this.bytesTotal = 0, this.bytesLoaded = -1, this.percentComplete = -1, this.crossOrigin = void 0, this.data = void 0, this.config = o(e, "config", {}), this.multiFile, this.linkFile
						},
						setLink: function(t) {
							(this.linkFile = t).linkFile = this
						},
						resetXHR: function() {
							this.xhrLoader && (this.xhrLoader.onload = void 0, this.xhrLoader.onerror = void 0, this.xhrLoader.onprogress = void 0)
						},
						load: function() {
							this.state === s.FILE_POPULATED ? this.loader.nextFile(this, !0) : (this.state = s.FILE_LOADING, this.src = a(this, this.loader.baseURL), 0 === this.src.indexOf("data:") ? console.warn("Local data URIs are not supported: " + this.key) : this.xhrLoader = u(this, this.loader.xhr))
						},
						onLoad: function(t, e) {
							var i = t.responseURL && 0 === t.responseURL.indexOf("file://") && 0 === e.target.status,
								n = !(e.target && 200 !== e.target.status) || i;
							4 === t.readyState && 400 <= t.status && t.status <= 599 && (n = !1), this.state = s.FILE_LOADED, this.resetXHR(), this.loader.nextFile(this, n)
						},
						onError: function() {
							this.resetXHR(), this.loader.nextFile(this, !1)
						},
						onProgress: function(t) {
							t.lengthComputable && (this.bytesLoaded = t.loaded, this.bytesTotal = t.total, this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1), this.loader.emit(r.FILE_PROGRESS, this, this.percentComplete))
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING, this.onProcessComplete()
						},
						onProcessComplete: function() {
							this.state = s.FILE_COMPLETE, this.multiFile && this.multiFile.onFileComplete(this), this.loader.fileProcessComplete(this)
						},
						onProcessError: function() {
							this.state = s.FILE_ERRORED, this.multiFile && this.multiFile.onFileFailed(this), this.loader.fileProcessComplete(this)
						},
						hasCacheConflict: function() {
							return this.cache && this.cache.exists(this.key)
						},
						addToCache: function() {
							this.cache && this.cache.add(this.key, this.data), this.pendingDestroy()
						},
						pendingDestroy: function(t) {
							void 0 === t && (t = this.data);
							var e = this.key,
								i = this.type;
							this.loader.emit(r.FILE_COMPLETE, e, i, t), this.loader.emit(r.FILE_KEY_COMPLETE + i + "-" + e, e, i, t), this.loader.flagForRemoval(this)
						},
						destroy: function() {
							this.loader = null, this.cache = null, this.xhrSettings = null, this.multiFile = null, this.linkFile = null, this.data = null
						}
					});
				c.createObjectURL = function(t, e, i) {
					var n;
					"function" == typeof URL ? t.src = URL.createObjectURL(e) : ((n = new FileReader).onload = function() {
						t.removeAttribute("crossOrigin"), t.src = "data:" + (e.type || i) + ";base64," + n.result.split(",")[1]
					}, n.onerror = t.onerror, n.readAsDataURL(e))
				}, c.revokeObjectURL = function(t) {
					"function" == typeof URL && URL.revokeObjectURL(t.src)
				}, t.exports = c
			}, function(t, e, i) {
				t.exports = {
					BOOT: i(709),
					CREATE: i(710),
					DESTROY: i(711),
					PAUSE: i(712),
					POST_UPDATE: i(713),
					PRE_UPDATE: i(714),
					READY: i(715),
					RENDER: i(716),
					RESUME: i(717),
					SHUTDOWN: i(718),
					SLEEP: i(719),
					START: i(720),
					TRANSITION_COMPLETE: i(721),
					TRANSITION_INIT: i(722),
					TRANSITION_OUT: i(723),
					TRANSITION_START: i(724),
					TRANSITION_WAKE: i(725),
					UPDATE: i(726),
					WAKE: i(727)
				}
			}, function(t, e) {
				var i = {},
					n = {},
					s = {
						register: function(t, e, n, s) {
							void 0 === s && (s = !1), i[t] = {
								plugin: e,
								mapping: n,
								custom: s
							}
						},
						registerCustom: function(t, e, i, s) {
							n[t] = {
								plugin: e,
								mapping: i,
								data: s
							}
						},
						hasCore: function(t) {
							return i.hasOwnProperty(t)
						},
						hasCustom: function(t) {
							return n.hasOwnProperty(t)
						},
						getCore: function(t) {
							return i[t]
						},
						getCustom: function(t) {
							return n[t]
						},
						getCustomClass: function(t) {
							return n.hasOwnProperty(t) ? n[t].plugin : null
						},
						remove: function(t) {
							i.hasOwnProperty(t) && delete i[t]
						},
						removeCustom: function(t) {
							n.hasOwnProperty(t) && delete n[t]
						},
						destroyCorePlugins: function() {
							for (var t in i) i.hasOwnProperty(t) && delete i[t]
						},
						destroyCustomPlugins: function() {
							for (var t in n) n.hasOwnProperty(t) && delete n[t]
						}
					};
				t.exports = s
			}, function(t, e, i) {
				var n = i(2);
				t.exports = function(t, e, i, s, r, o) {
					void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = o.width), void 0 === s && (s = o.height);
					var a = n(r, "isNotEmpty", !1),
						h = n(r, "isColliding", !1),
						u = n(r, "hasInterestingFace", !1);
					t < 0 && (i += t, t = 0), e < 0 && (s += e, e = 0), t + i > o.width && (i = Math.max(o.width - t, 0)), e + s > o.height && (s = Math.max(o.height - e, 0));
					for (var l = [], c = e; c < e + s; c++)
						for (var d = t; d < t + i; d++) {
							var f = o.data[c][d];
							if (null !== f) {
								if (a && -1 === f.index) continue;
								if (h && !f.collides) continue;
								if (u && !f.hasInterestingFace) continue;
								l.push(f)
							}
						}
					return l
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s, r) {
					var o;
					void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 1);
					var a = 0,
						h = t.length;
					if (1 === r)
						for (o = s; o < h; o++) t[o][e] = i + a * n, a++;
					else
						for (o = s; 0 <= o; o--) t[o][e] = i + a * n, a++;
					return t
				}
			}, function(t, e, i) {
				var n, s = i(33),
					r = i(167),
					o = [],
					a = !1;

				function h(t, e, i, h, u) {
					void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === h && (h = s.CANVAS), void 0 === u && (u = !1);
					var l = n(h),
						c = (null === l ? (l = {
							parent: t,
							canvas: document.createElement("canvas"),
							type: h
						}, h === s.CANVAS && o.push(l)) : l.parent = t, l.canvas);
					return u && (l.parent = c), c.width = e, c.height = i, a && h === s.CANVAS && r.disable(c.getContext("2d")), c
				}

				function u() {
					var t = 0;
					return o.forEach(function(e) {
						e.parent && t++
					}), t
				}
				t.exports = {
					create2D: function(t, e, i) {
						return h(t, e, i, s.CANVAS)
					},
					create: h,
					createWebGL: function(t, e, i) {
						return h(t, e, i, s.WEBGL)
					},
					disableSmoothing: function() {
						a = !0
					},
					enableSmoothing: function() {
						a = !1
					},
					first: n = function(t) {
						if (void 0 === t && (t = s.CANVAS), t === s.WEBGL) return null;
						for (var e = 0; e < o.length; e++) {
							var i = o[e];
							if (!i.parent && i.type === t) return i
						}
						return null
					},
					free: function() {
						return o.length - u()
					},
					pool: o,
					remove: function(t) {
						var e = t instanceof HTMLCanvasElement;
						o.forEach(function(i) {
							(e && i.canvas === t || !e && i.parent === t) && (i.parent = null, i.canvas.width = 1, i.canvas.height = 1)
						})
					},
					total: u
				}
			}, function(t, e, i) {
				var n = i(52),
					s = i(15);
				t.exports = function(t, e, i) {
					e.x = s(i, "x", 0), e.y = s(i, "y", 0), e.depth = s(i, "depth", 0), e.flipX = s(i, "flipX", !1), e.flipY = s(i, "flipY", !1);
					var r = s(i, "scale", null);
					"number" == typeof r ? e.setScale(r) : null !== r && (e.scaleX = s(r, "x", 1), e.scaleY = s(r, "y", 1));
					var o = s(i, "scrollFactor", null);
					"number" == typeof o ? e.setScrollFactor(o) : null !== o && (e.scrollFactorX = s(o, "x", 1), e.scrollFactorY = s(o, "y", 1)), e.rotation = s(i, "rotation", 0);
					var a = s(i, "angle", null);
					null !== a && (e.angle = a), e.alpha = s(i, "alpha", 1);
					var h, u, l = s(i, "origin", null);
					return "number" == typeof l ? e.setOrigin(l) : null !== l && (h = s(l, "x", .5), u = s(l, "y", .5), e.setOrigin(h, u)), e.blendMode = s(i, "blendMode", n.NORMAL), e.visible = s(i, "visible", !0), s(i, "add", !0) && t.sys.displayList.add(e), e.preUpdate && t.sys.updateList.add(e), e
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					var r = n.alpha * i.alpha;
					if (r <= 0) return !1;
					var o = t._tempMatrix1.copyFromArray(n.matrix.matrix),
						a = t._tempMatrix2.applyITRS(i.x, i.y, i.rotation, i.scaleX, i.scaleY),
						h = t._tempMatrix3;
					return s ? (o.multiplyWithOffset(s, -n.scrollX * i.scrollFactorX, -n.scrollY * i.scrollFactorY), a.e = i.x, a.f = i.y) : (a.e -= n.scrollX * i.scrollFactorX, a.f -= n.scrollY * i.scrollFactorY), o.multiply(a, h), e.globalCompositeOperation = t.blendModes[i.blendMode], e.globalAlpha = r, e.save(), h.setToContext(e), e.imageSmoothingEnabled = !(!t.antialias || i.frame && i.frame.source.scaleMode), !0
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(13),
					r = i(3),
					o = new n({
						initialize: function(t, e, i, n, s, r) {
							void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), void 0 === s && (s = 0), void 0 === r && (r = 0), this.matrix = new Float32Array([t, e, i, n, s, r, 0, 0, 1]), this.decomposedMatrix = {
								translateX: 0,
								translateY: 0,
								scaleX: 1,
								scaleY: 1,
								rotation: 0
							}
						},
						a: {
							get: function() {
								return this.matrix[0]
							},
							set: function(t) {
								this.matrix[0] = t
							}
						},
						b: {
							get: function() {
								return this.matrix[1]
							},
							set: function(t) {
								this.matrix[1] = t
							}
						},
						c: {
							get: function() {
								return this.matrix[2]
							},
							set: function(t) {
								this.matrix[2] = t
							}
						},
						d: {
							get: function() {
								return this.matrix[3]
							},
							set: function(t) {
								this.matrix[3] = t
							}
						},
						e: {
							get: function() {
								return this.matrix[4]
							},
							set: function(t) {
								this.matrix[4] = t
							}
						},
						f: {
							get: function() {
								return this.matrix[5]
							},
							set: function(t) {
								this.matrix[5] = t
							}
						},
						tx: {
							get: function() {
								return this.matrix[4]
							},
							set: function(t) {
								this.matrix[4] = t
							}
						},
						ty: {
							get: function() {
								return this.matrix[5]
							},
							set: function(t) {
								this.matrix[5] = t
							}
						},
						rotation: {
							get: function() {
								return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1)
							}
						},
						rotationNormalized: {
							get: function() {
								var t = this.matrix,
									e = t[0],
									i = t[1],
									n = t[2],
									r = t[3];
								return e || i ? 0 < i ? Math.acos(e / this.scaleX) : -Math.acos(e / this.scaleX) : n || r ? s.TAU - (0 < r ? Math.acos(-n / this.scaleY) : -Math.acos(n / this.scaleY)) : 0
							}
						},
						scaleX: {
							get: function() {
								return Math.sqrt(this.a * this.a + this.b * this.b)
							}
						},
						scaleY: {
							get: function() {
								return Math.sqrt(this.c * this.c + this.d * this.d)
							}
						},
						loadIdentity: function() {
							var t = this.matrix;
							return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, this
						},
						translate: function(t, e) {
							var i = this.matrix;
							return i[4] = i[0] * t + i[2] * e + i[4], i[5] = i[1] * t + i[3] * e + i[5], this
						},
						scale: function(t, e) {
							var i = this.matrix;
							return i[0] *= t, i[1] *= t, i[2] *= e, i[3] *= e, this
						},
						rotate: function(t) {
							var e = Math.sin(t),
								i = Math.cos(t),
								n = this.matrix,
								s = n[0],
								r = n[1],
								o = n[2],
								a = n[3];
							return n[0] = s * i + o * e, n[1] = r * i + a * e, n[2] = s * -e + o * i, n[3] = r * -e + a * i, this
						},
						multiply: function(t, e) {
							var i = this.matrix,
								n = t.matrix,
								s = i[0],
								r = i[1],
								o = i[2],
								a = i[3],
								h = i[4],
								u = i[5],
								l = n[0],
								c = n[1],
								d = n[2],
								f = n[3],
								p = n[4],
								g = n[5],
								v = void 0 === e ? this : e;
							return v.a = l * s + c * o, v.b = l * r + c * a, v.c = d * s + f * o, v.d = d * r + f * a, v.e = p * s + g * o + h, v.f = p * r + g * a + u, v
						},
						multiplyWithOffset: function(t, e, i) {
							var n = this.matrix,
								s = t.matrix,
								r = n[0],
								o = n[1],
								a = n[2],
								h = n[3],
								u = e * r + i * a + n[4],
								l = e * o + i * h + n[5],
								c = s[0],
								d = s[1],
								f = s[2],
								p = s[3],
								g = s[4],
								v = s[5];
							return n[0] = c * r + d * a, n[1] = c * o + d * h, n[2] = f * r + p * a, n[3] = f * o + p * h, n[4] = g * r + v * a + u, n[5] = g * o + v * h + l, this
						},
						transform: function(t, e, i, n, s, r) {
							var o = this.matrix,
								a = o[0],
								h = o[1],
								u = o[2],
								l = o[3],
								c = o[4],
								d = o[5];
							return o[0] = t * a + e * u, o[1] = t * h + e * l, o[2] = i * a + n * u, o[3] = i * h + n * l, o[4] = s * a + r * u + c, o[5] = s * h + r * l + d, this
						},
						transformPoint: function(t, e, i) {
							void 0 === i && (i = {
								x: 0,
								y: 0
							});
							var n = this.matrix,
								s = n[0],
								r = n[1],
								o = n[2],
								a = n[3],
								h = n[4],
								u = n[5];
							return i.x = t * s + e * o + h, i.y = t * r + e * a + u, i
						},
						invert: function() {
							var t = this.matrix,
								e = t[0],
								i = t[1],
								n = t[2],
								s = t[3],
								r = t[4],
								o = t[5],
								a = e * s - i * n;
							return t[0] = s / a, t[1] = -i / a, t[2] = -n / a, t[3] = e / a, t[4] = (n * o - s * r) / a, t[5] = -(e * o - i * r) / a, this
						},
						copyFrom: function(t) {
							var e = this.matrix;
							return e[0] = t.a, e[1] = t.b, e[2] = t.c, e[3] = t.d, e[4] = t.e, e[5] = t.f, this
						},
						copyFromArray: function(t) {
							var e = this.matrix;
							return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], this
						},
						copyToContext: function(t) {
							var e = this.matrix;
							return t.transform(e[0], e[1], e[2], e[3], e[4], e[5]), t
						},
						setToContext: function(t) {
							var e = this.matrix;
							return t.setTransform(e[0], e[1], e[2], e[3], e[4], e[5]), t
						},
						copyToArray: function(t) {
							var e = this.matrix;
							return void 0 === t ? t = [e[0], e[1], e[2], e[3], e[4], e[5]] : (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5]), t
						},
						setTransform: function(t, e, i, n, s, r) {
							var o = this.matrix;
							return o[0] = t, o[1] = e, o[2] = i, o[3] = n, o[4] = s, o[5] = r, this
						},
						decomposeMatrix: function() {
							var t, e, i = this.decomposedMatrix,
								n = this.matrix,
								s = n[0],
								r = n[1],
								o = n[2],
								a = n[3],
								h = s * a - r * o;
							return i.translateX = n[4], i.translateY = n[5], s || r ? (t = Math.sqrt(s * s + r * r), i.rotation = 0 < r ? Math.acos(s / t) : -Math.acos(s / t), i.scaleX = t, i.scaleY = h / t) : o || a ? (e = Math.sqrt(o * o + a * a), i.rotation = .5 * Math.PI - (0 < a ? Math.acos(-o / e) : -Math.acos(o / e)), i.scaleX = h / e, i.scaleY = e) : (i.rotation = 0, i.scaleX = 0, i.scaleY = 0), i
						},
						applyITRS: function(t, e, i, n, s) {
							var r = this.matrix,
								o = Math.sin(i),
								a = Math.cos(i);
							return r[4] = t, r[5] = e, r[0] = a * n, r[1] = o * n, r[2] = -o * s, r[3] = a * s, this
						},
						applyInverse: function(t, e, i) {
							void 0 === i && (i = new r);
							var n = this.matrix,
								s = n[0],
								o = n[1],
								a = n[2],
								h = n[3],
								u = n[4],
								l = n[5],
								c = 1 / (s * h + a * -o);
							return i.x = h * c * t + -a * c * e + (l * a - u * h) * c, i.y = s * c * e + -o * c * t + (-l * s + u * o) * c, i
						},
						getX: function(t, e) {
							return t * this.a + e * this.c + this.e
						},
						getY: function(t, e) {
							return t * this.b + e * this.d + this.f
						},
						getCSSMatrix: function() {
							var t = this.matrix;
							return "matrix(" + t[0] + "," + t[1] + "," + t[2] + "," + t[3] + "," + t[4] + "," + t[5] + ")"
						},
						destroy: function() {
							this.matrix = null, this.decomposedMatrix = null
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(14),
					o = i(56),
					a = new n({
						Extends: r,
						Mixins: [s.AlphaSingle, s.BlendMode, s.ComputedSize, s.Depth, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Transform, s.Visible],
						initialize: function(t, e, i) {
							void 0 === e && (e = "Shape"), r.call(this, t, e), this.geom = i, this.pathData = [], this.pathIndexes = [], this.fillColor = 16777215, this.fillAlpha = 1, this.strokeColor = 16777215, this.strokeAlpha = 1, this.lineWidth = 1, this.isFilled = !1, this.isStroked = !1, this.closePath = !0, this._tempLine = new o, this.initPipeline()
						},
						setFillStyle: function(t, e) {
							return void 0 === e && (e = 1), void 0 === t ? this.isFilled = !1 : (this.fillColor = t, this.fillAlpha = e, this.isFilled = !0), this
						},
						setStrokeStyle: function(t, e, i) {
							return void 0 === i && (i = 1), void 0 === t ? this.isStroked = !1 : (this.lineWidth = t, this.strokeColor = e, this.strokeAlpha = i, this.isStroked = !0), this
						},
						setClosePath: function(t) {
							return this.closePath = t, this
						},
						preDestroy: function() {
							this.geom = null, this._tempLine = null, this.pathData = [], this.pathIndexes = []
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(0),
					s = i(165),
					r = i(295),
					o = i(166),
					a = i(296),
					h = new n({
						initialize: function(t, e, i, n) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 255), this.r = 0, this.g = 0, this.b = 0, this.a = 255, this._h = 0, this._s = 0, this._v = 0, this._locked = !1, this.gl = [0, 0, 0, 1], this._color = 0, this._color32 = 0, this._rgba = "", this.setTo(t, e, i, n)
						},
						transparent: function() {
							return this._locked = !0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this._locked = !1, this.update(!0)
						},
						setTo: function(t, e, i, n, s) {
							return void 0 === n && (n = 255), void 0 === s && (s = !0), this._locked = !0, this.red = t, this.green = e, this.blue = i, this.alpha = n, this._locked = !1, this.update(s)
						},
						setGLTo: function(t, e, i, n) {
							return void 0 === n && (n = 1), this._locked = !0, this.redGL = t, this.greenGL = e, this.blueGL = i, this.alphaGL = n, this._locked = !1, this.update(!0)
						},
						setFromRGB: function(t) {
							return this._locked = !0, this.red = t.r, this.green = t.g, this.blue = t.b, t.hasOwnProperty("a") && (this.alpha = t.a), this._locked = !1, this.update(!0)
						},
						setFromHSV: function(t, e, i) {
							return o(t, e, i, this)
						},
						update: function(t) {
							if (void 0 === t && (t = !1), this._locked) return this;
							var e = this.r,
								i = this.g,
								n = this.b,
								o = this.a;
							return this._color = s(e, i, n), this._color32 = r(e, i, n, o), this._rgba = "rgba(" + e + "," + i + "," + n + "," + o / 255 + ")", t && a(e, i, n, this), this
						},
						updateHSV: function() {
							var t = this.r,
								e = this.g,
								i = this.b;
							return a(t, e, i, this), this
						},
						clone: function() {
							return new h(this.r, this.g, this.b, this.a)
						},
						gray: function(t) {
							return this.setTo(t, t, t)
						},
						random: function(t, e) {
							void 0 === t && (t = 0), void 0 === e && (e = 255);
							var i = Math.floor(t + Math.random() * (e - t)),
								n = Math.floor(t + Math.random() * (e - t)),
								s = Math.floor(t + Math.random() * (e - t));
							return this.setTo(i, n, s)
						},
						randomGray: function(t, e) {
							void 0 === t && (t = 0), void 0 === e && (e = 255);
							var i = Math.floor(t + Math.random() * (e - t));
							return this.setTo(i, i, i)
						},
						saturate: function(t) {
							return this.s += t / 100, this
						},
						desaturate: function(t) {
							return this.s -= t / 100, this
						},
						lighten: function(t) {
							return this.v += t / 100, this
						},
						darken: function(t) {
							return this.v -= t / 100, this
						},
						brighten: function(t) {
							var e = this.r,
								i = this.g,
								n = this.b;
							e = Math.max(0, Math.min(255, e - Math.round(-t / 100 * 255))), i = Math.max(0, Math.min(255, i - Math.round(-t / 100 * 255))), n = Math.max(0, Math.min(255, n - Math.round(-t / 100 * 255)));
							return this.setTo(e, i, n)
						},
						color: {
							get: function() {
								return this._color
							}
						},
						color32: {
							get: function() {
								return this._color32
							}
						},
						rgba: {
							get: function() {
								return this._rgba
							}
						},
						redGL: {
							get: function() {
								return this.gl[0]
							},
							set: function(t) {
								this.gl[0] = Math.min(Math.abs(t), 1), this.r = Math.floor(255 * this.gl[0]), this.update(!0)
							}
						},
						greenGL: {
							get: function() {
								return this.gl[1]
							},
							set: function(t) {
								this.gl[1] = Math.min(Math.abs(t), 1), this.g = Math.floor(255 * this.gl[1]), this.update(!0)
							}
						},
						blueGL: {
							get: function() {
								return this.gl[2]
							},
							set: function(t) {
								this.gl[2] = Math.min(Math.abs(t), 1), this.b = Math.floor(255 * this.gl[2]), this.update(!0)
							}
						},
						alphaGL: {
							get: function() {
								return this.gl[3]
							},
							set: function(t) {
								this.gl[3] = Math.min(Math.abs(t), 1), this.a = Math.floor(255 * this.gl[3]), this.update()
							}
						},
						red: {
							get: function() {
								return this.r
							},
							set: function(t) {
								t = Math.floor(Math.abs(t)), this.r = Math.min(t, 255), this.gl[0] = t / 255, this.update(!0)
							}
						},
						green: {
							get: function() {
								return this.g
							},
							set: function(t) {
								t = Math.floor(Math.abs(t)), this.g = Math.min(t, 255), this.gl[1] = t / 255, this.update(!0)
							}
						},
						blue: {
							get: function() {
								return this.b
							},
							set: function(t) {
								t = Math.floor(Math.abs(t)), this.b = Math.min(t, 255), this.gl[2] = t / 255, this.update(!0)
							}
						},
						alpha: {
							get: function() {
								return this.a
							},
							set: function(t) {
								t = Math.floor(Math.abs(t)), this.a = Math.min(t, 255), this.gl[3] = t / 255, this.update()
							}
						},
						h: {
							get: function() {
								return this._h
							},
							set: function(t) {
								this._h = t, o(t, this._s, this._v, this)
							}
						},
						s: {
							get: function() {
								return this._s
							},
							set: function(t) {
								this._s = t, o(this._h, t, this._v, this)
							}
						},
						v: {
							get: function() {
								return this._v
							},
							set: function(t) {
								this._v = t, o(this._h, this._s, t, this)
							}
						}
					});
				t.exports = h
			}, function(t, e) {
				t.exports = {
					CSV: 0,
					TILED_JSON: 1,
					ARRAY_2D: 2,
					WELTMEISTER: 3
				}
			}, function(t, e, i) {
				var n = {
					VERSION: "3.24.1",
					BlendModes: i(52),
					ScaleModes: i(234),
					AUTO: 0,
					CANVAS: 1,
					WEBGL: 2,
					HEADLESS: 3,
					FOREVER: -1,
					NONE: 4,
					UP: 5,
					DOWN: 6,
					LEFT: 7,
					RIGHT: 8
				};
				t.exports = n
			}, function(t, e) {
				t.exports = function(t) {
					return t.y + t.height - t.height * t.originY
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.x - t.width * t.originX
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.x + t.width - t.width * t.originX
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.y - t.height * t.originY
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s, r) {
					var o;
					void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 1);
					var a = 0,
						h = t.length;
					if (1 === r)
						for (o = s; o < h; o++) t[o][e] += i + a * n, a++;
					else
						for (o = s; 0 <= o; o--) t[o][e] += i + a * n, a++;
					return t
				}
			}, function(t, e, i) {
				var n = i(13);
				t.exports = function(t) {
					return t * n.DEG_TO_RAD
				}
			}, function(t, e, i) {
				t.exports = {
					DESTROY: i(647),
					FADE_IN_COMPLETE: i(648),
					FADE_IN_START: i(649),
					FADE_OUT_COMPLETE: i(650),
					FADE_OUT_START: i(651),
					FLASH_COMPLETE: i(652),
					FLASH_START: i(653),
					PAN_COMPLETE: i(654),
					PAN_START: i(655),
					POST_RENDER: i(656),
					PRE_RENDER: i(657),
					ROTATE_COMPLETE: i(658),
					ROTATE_START: i(659),
					SHAKE_COMPLETE: i(660),
					SHAKE_START: i(661),
					ZOOM_COMPLETE: i(662),
					ZOOM_START: i(663)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					var s = i || e.fillColor,
						r = n || e.fillAlpha,
						o = (16711680 & s) >>> 16,
						a = (65280 & s) >>> 8,
						h = 255 & s;
					t.fillStyle = "rgba(" + o + "," + a + "," + h + "," + r + ")"
				}
			}, , function(t, e) {
				t.exports = function(t, e) {
					return t.y = e + t.height * t.originY, t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.x = e + t.width * t.originX, t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.x = e - t.width + t.width * t.originX, t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.y = e - t.height + t.height * t.originY, t
				}
			}, function(t, e) {
				t.exports = {
					CIRCLE: 0,
					ELLIPSE: 1,
					LINE: 2,
					POINT: 3,
					POLYGON: 4,
					RECTANGLE: 5,
					TRIANGLE: 6
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return !(t.width <= 0 || t.height <= 0) && t.x <= e && t.x + t.width >= e && t.y <= i && t.y + t.height >= i
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					var s = i || e.strokeColor,
						r = n || e.strokeAlpha,
						o = (16711680 & s) >>> 16,
						a = (65280 & s) >>> 8,
						h = 255 & s;
					t.strokeStyle = "rgba(" + o + "," + a + "," + h + "," + r + ")", t.lineWidth = e.lineWidth
				}
			}, function(t, e) {
				t.exports = {
					DYNAMIC_BODY: 0,
					STATIC_BODY: 1,
					GROUP: 2,
					TILEMAPLAYER: 3,
					FACING_NONE: 10,
					FACING_UP: 11,
					FACING_DOWN: 12,
					FACING_LEFT: 13,
					FACING_RIGHT: 14
				}
			}, function(t, e, i) {
				var n = i(142),
					s = i(24);
				t.exports = function(t, e, i, r, o) {
					for (var a, h, u, l, c = s(t, e, i, r, null, o), d = 0; d < c.length; d++) {
						var f = c[d];
						f && (f.collides ? (a = n(f.x, f.y - 1, !0, o), h = n(f.x, f.y + 1, !0, o), u = n(f.x - 1, f.y, !0, o), l = n(f.x + 1, f.y, !0, o), f.faceTop = !a || !a.collides, f.faceBottom = !h || !h.collides, f.faceLeft = !u || !u.collides, f.faceRight = !l || !l.collides) : f.resetFaces())
					}
				}
			}, function(t, e) {
				t.exports = {
					SKIP_CHECK: -1,
					NORMAL: 0,
					ADD: 1,
					MULTIPLY: 2,
					SCREEN: 3,
					OVERLAY: 4,
					DARKEN: 5,
					LIGHTEN: 6,
					COLOR_DODGE: 7,
					COLOR_BURN: 8,
					HARD_LIGHT: 9,
					SOFT_LIGHT: 10,
					DIFFERENCE: 11,
					EXCLUSION: 12,
					HUE: 13,
					SATURATION: 14,
					COLOR: 15,
					LUMINOSITY: 16,
					ERASE: 17,
					SOURCE_IN: 18,
					SOURCE_OUT: 19,
					SOURCE_ATOP: 20,
					DESTINATION_OVER: 21,
					DESTINATION_IN: 22,
					DESTINATION_OUT: 23,
					DESTINATION_ATOP: 24,
					LIGHTER: 25,
					COPY: 26,
					XOR: 27
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					var s = t - i,
						r = e - n;
					return Math.sqrt(s * s + r * r)
				}
			}, function(t, e, i) {
				t.exports = {
					BOOT: i(823),
					DESTROY: i(824),
					DRAG_END: i(825),
					DRAG_ENTER: i(826),
					DRAG: i(827),
					DRAG_LEAVE: i(828),
					DRAG_OVER: i(829),
					DRAG_START: i(830),
					DROP: i(831),
					GAME_OUT: i(832),
					GAME_OVER: i(833),
					GAMEOBJECT_DOWN: i(834),
					GAMEOBJECT_DRAG_END: i(835),
					GAMEOBJECT_DRAG_ENTER: i(836),
					GAMEOBJECT_DRAG: i(837),
					GAMEOBJECT_DRAG_LEAVE: i(838),
					GAMEOBJECT_DRAG_OVER: i(839),
					GAMEOBJECT_DRAG_START: i(840),
					GAMEOBJECT_DROP: i(841),
					GAMEOBJECT_MOVE: i(842),
					GAMEOBJECT_OUT: i(843),
					GAMEOBJECT_OVER: i(844),
					GAMEOBJECT_POINTER_DOWN: i(845),
					GAMEOBJECT_POINTER_MOVE: i(846),
					GAMEOBJECT_POINTER_OUT: i(847),
					GAMEOBJECT_POINTER_OVER: i(848),
					GAMEOBJECT_POINTER_UP: i(849),
					GAMEOBJECT_POINTER_WHEEL: i(850),
					GAMEOBJECT_UP: i(851),
					GAMEOBJECT_WHEEL: i(852),
					MANAGER_BOOT: i(853),
					MANAGER_PROCESS: i(854),
					MANAGER_UPDATE: i(855),
					POINTER_DOWN: i(856),
					POINTER_DOWN_OUTSIDE: i(857),
					POINTER_MOVE: i(858),
					POINTER_OUT: i(859),
					POINTER_OVER: i(860),
					POINTER_UP: i(861),
					POINTER_UP_OUTSIDE: i(862),
					POINTER_WHEEL: i(863),
					POINTERLOCK_CHANGE: i(864),
					PRE_UPDATE: i(865),
					SHUTDOWN: i(866),
					START: i(867),
					UPDATE: i(868)
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return 0 < t.radius && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(275),
					r = i(153),
					o = i(47),
					a = i(154),
					h = i(3),
					u = new n({
						initialize: function(t, e, i, n) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.type = o.LINE, this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n
						},
						getPoint: function(t, e) {
							return s(this, t, e)
						},
						getPoints: function(t, e, i) {
							return r(this, t, e, i)
						},
						getRandomPoint: function(t) {
							return a(this, t)
						},
						setTo: function(t, e, i, n) {
							return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this
						},
						getPointA: function(t) {
							return void 0 === t && (t = new h), t.set(this.x1, this.y1), t
						},
						getPointB: function(t) {
							return void 0 === t && (t = new h), t.set(this.x2, this.y2), t
						},
						left: {
							get: function() {
								return Math.min(this.x1, this.x2)
							},
							set: function(t) {
								this.x1 <= this.x2 ? this.x1 = t : this.x2 = t
							}
						},
						right: {
							get: function() {
								return Math.max(this.x1, this.x2)
							},
							set: function(t) {
								this.x1 > this.x2 ? this.x1 = t : this.x2 = t
							}
						},
						top: {
							get: function() {
								return Math.min(this.y1, this.y2)
							},
							set: function(t) {
								this.y1 <= this.y2 ? this.y1 = t : this.y2 = t
							}
						},
						bottom: {
							get: function() {
								return Math.max(this.y1, this.y2)
							},
							set: function(t) {
								this.y1 > this.y2 ? this.y1 = t : this.y2 = t
							}
						}
					});
				t.exports = u
			}, function(t, e) {
				t.exports = function(t) {
					return Math.sqrt((t.x2 - t.x1) * (t.x2 - t.x1) + (t.y2 - t.y1) * (t.y2 - t.y1))
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					var n = i - e;
					return e + ((t - e) % n + n) % n
				}
			}, function(t, e, i) {
				t.exports = {
					COMPLETE: i(891),
					DECODED: i(892),
					DECODED_ALL: i(893),
					DESTROY: i(894),
					DETUNE: i(895),
					GLOBAL_DETUNE: i(896),
					GLOBAL_MUTE: i(897),
					GLOBAL_RATE: i(898),
					GLOBAL_VOLUME: i(899),
					LOOP: i(900),
					LOOPED: i(901),
					MUTE: i(902),
					PAUSE_ALL: i(903),
					PAUSE: i(904),
					PLAY: i(905),
					RATE: i(906),
					RESUME_ALL: i(907),
					RESUME: i(908),
					SEEK: i(909),
					STOP_ALL: i(910),
					STOP: i(911),
					UNLOCKED: i(912),
					VOLUME: i(913)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(6),
					u = i(7),
					l = new n({
						Extends: r,
						initialize: function(t, e, i, n, o) {
							var l, c = "json";
							u(e) && (e = a(l = e, "key"), i = a(l, "url"), n = a(l, "xhrSettings"), c = a(l, "extension", c), o = a(l, "dataKey", o));
							var d = {
								type: "json",
								cache: t.cacheManager.json,
								extension: c,
								responseType: "text",
								key: e,
								url: i,
								xhrSettings: n,
								config: o
							};
							r.call(this, t, d), u(i) && (this.data = o ? h(i, o) : i, this.state = s.FILE_POPULATED)
						},
						onProcess: function() {
							var t, e;
							this.state !== s.FILE_POPULATED && (this.state = s.FILE_PROCESSING, t = JSON.parse(this.xhrLoader.responseText), e = this.config, this.data = "string" == typeof e ? h(t, e, t) : t), this.onProcessComplete()
						}
					});
				o.register("json", function(t, e, i, n) {
					if (Array.isArray(t))
						for (var s = 0; s < t.length; s++) this.addFile(new l(this, t[s]));
					else this.addFile(new l(this, t, e, n, i));
					return this
				}), t.exports = l
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t, e, i, n) {
						this.loader = t, this.type = e, this.key = i, this.multiKeyIndex = t.multiKeyIndex++, this.files = n, this.complete = !1, this.pending = n.length, this.failed = 0, this.config = {}, this.baseURL = t.baseURL, this.path = t.path, this.prefix = t.prefix;
						for (var s = 0; s < n.length; s++) n[s].multiFile = this
					},
					isReadyToProcess: function() {
						return 0 === this.pending && 0 === this.failed && !this.complete
					},
					addToMultiFile: function(t) {
						return this.files.push(t), (t.multiFile = this).pending++, this.complete = !1, this
					},
					onFileComplete: function(t) {
						-1 !== this.files.indexOf(t) && this.pending--
					},
					onFileFailed: function(t) {
						-1 !== this.files.indexOf(t) && this.failed++
					}
				});
				t.exports = n
			}, , function(t, e) {
				t.exports = function(t, e, i, n) {
					void 0 === e && (e = !0);
					var s = n.baseTileWidth,
						r = n.tilemapLayer;
					return r && (void 0 === i && (i = r.scene.cameras.main), t -= r.x + i.scrollX * (1 - r.scrollFactorX), s *= r.scaleX), e ? Math.floor(t / s) : t / s
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					void 0 === e && (e = !0);
					var s = n.baseTileHeight,
						r = n.tilemapLayer;
					return r && (void 0 === i && (i = r.scene.cameras.main), t -= r.y + i.scrollY * (1 - r.scrollFactorY), s *= r.scaleY), e ? Math.floor(t / s) : t / s
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(55),
					r = i(266),
					o = i(267),
					a = i(47),
					h = i(150),
					u = new n({
						initialize: function(t, e, i) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.type = a.CIRCLE, this.x = t, this.y = e, this._radius = i, this._diameter = 2 * i
						},
						contains: function(t, e) {
							return s(this, t, e)
						},
						getPoint: function(t, e) {
							return r(this, t, e)
						},
						getPoints: function(t, e, i) {
							return o(this, t, e, i)
						},
						getRandomPoint: function(t) {
							return h(this, t)
						},
						setTo: function(t, e, i) {
							return this.x = t, this.y = e, this._radius = i, this._diameter = 2 * i, this
						},
						setEmpty: function() {
							return this._radius = 0, this._diameter = 0, this
						},
						setPosition: function(t, e) {
							return void 0 === e && (e = t), this.x = t, this.y = e, this
						},
						isEmpty: function() {
							return this._radius <= 0
						},
						radius: {
							get: function() {
								return this._radius
							},
							set: function(t) {
								this._radius = t, this._diameter = 2 * t
							}
						},
						diameter: {
							get: function() {
								return this._diameter
							},
							set: function(t) {
								this._diameter = t, this._radius = .5 * t
							}
						},
						left: {
							get: function() {
								return this.x - this._radius
							},
							set: function(t) {
								this.x = t + this._radius
							}
						},
						right: {
							get: function() {
								return this.x + this._radius
							},
							set: function(t) {
								this.x = t - this._radius
							}
						},
						top: {
							get: function() {
								return this.y - this._radius
							},
							set: function(t) {
								this.y = t + this._radius
							}
						},
						bottom: {
							get: function() {
								return this.y + this._radius
							},
							set: function(t) {
								this.y = t - this._radius
							}
						}
					});
				t.exports = u
			}, function(t, e, i) {
				"use strict";

				function n(t, e, i) {
					i = i || 2;
					var n, h, l, c, d, g, v, m = e && e.length,
						y = m ? e[0] * i : t.length,
						x = s(t, 0, y, i, !0),
						T = [];
					if (!x || x.next === x.prev) return T;
					if (m && (x = function(t, e, i, n) {
							var o, h, l, c = [];
							for (o = 0, h = e.length; o < h; o++)(l = s(t, e[o] * n, o < h - 1 ? e[o + 1] * n : t.length, n, !1)) === l.next && (l.steiner = !0), c.push(function(t) {
								for (var e = t, i = t; e.x < i.x && (i = e), (e = e.next) !== t;);
								return i
							}(l));
							for (c.sort(a), o = 0; o < c.length; o++) ! function(t, e) {
								var i;
								(e = function(t, e) {
									var i, n = e,
										s = t.x,
										r = t.y,
										o = -1 / 0;
									do {
										if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
											var a = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
											if (a <= s && o < a) {
												if ((o = a) === s) {
													if (r === n.y) return n;
													if (r === n.next.y) return n.next
												}
												i = n.x < n.next.x ? n : n.next
											}
										}
										n = n.next
									} while (n !== e);
									if (!i) return null;
									if (s === o) return i.prev;
									var h, l = i,
										c = i.x,
										d = i.y,
										p = 1 / 0;
									for (n = i.next; n !== l;) s >= n.x && n.x >= c && s !== n.x && u(r < d ? s : o, r, c, d, r < d ? o : s, r, n.x, n.y) && ((h = Math.abs(r - n.y) / (s - n.x)) < p || h === p && n.x > i.x) && f(n, t) && (i = n, p = h), n = n.next;
									return i
								}(t, e)) && r(i = p(e, t), i.next)
							}(c[o], i), i = r(i, i.next);
							return i
						}(t, e, x, i)), t.length > 80 * i) {
						n = l = t[0], h = c = t[1];
						for (var w = i; w < y; w += i)(d = t[w]) < n && (n = d), (g = t[w + 1]) < h && (h = g), l < d && (l = d), c < g && (c = g);
						v = 0 !== (v = Math.max(l - n, c - h)) ? 1 / v : 0
					}
					return o(x, T, i, n, h, v), T
				}

				function s(t, e, i, n, s) {
					var r, o;
					if (s === 0 < y(t, e, i, n))
						for (r = e; r < i; r += n) o = g(r, t[r], t[r + 1], o);
					else
						for (r = i - n; e <= r; r -= n) o = g(r, t[r], t[r + 1], o);
					return o && c(o, o.next) && (v(o), o = o.next), o
				}

				function r(t, e) {
					if (!t) return t;
					e = e || t;
					var i, n = t;
					do {
						if (i = !1, n.steiner || !c(n, n.next) && 0 !== l(n.prev, n, n.next)) n = n.next;
						else {
							if (v(n), (n = e = n.prev) === n.next) break;
							i = !0
						}
					} while (i || n !== e);
					return e
				}

				function o(t, e, i, n, s, a, g) {
					if (t) {
						!g && a && function(t, e, i, n) {
							for (var s = t; null === s.z && (s.z = h(s.x, s.y, e, i, n)), s.prevZ = s.prev, s.nextZ = s.next, (s = s.next) !== t;);
							s.prevZ.nextZ = null, s.prevZ = null,
								function(t) {
									var e, i, n, s, r, o, a, h, u = 1;
									do {
										for (i = t, r = t = null, o = 0; i;) {
											for (o++, n = i, e = a = 0; e < u && (a++, n = n.nextZ); e++);
											for (h = u; 0 < a || 0 < h && n;) 0 !== a && (0 === h || !n || i.z <= n.z) ? (i = (s = i).nextZ, a--) : (n = (s = n).nextZ, h--), r ? r.nextZ = s : t = s, s.prevZ = r, r = s;
											i = n
										}
										r.nextZ = null, u *= 2
									} while (1 < o)
								}(s)
						}(t, n, s, a);
						for (var m, y, x = t; t.prev !== t.next;)
							if (m = t.prev, y = t.next, a ? function(t, e, i, n) {
									var s = t.prev,
										r = t,
										o = t.next;
									if (0 <= l(s, r, o)) return !1;
									for (var a = s.x < r.x ? s.x < o.x ? s.x : o.x : r.x < o.x ? r.x : o.x, c = s.y < r.y ? s.y < o.y ? s.y : o.y : r.y < o.y ? r.y : o.y, d = s.x > r.x ? s.x > o.x ? s.x : o.x : r.x > o.x ? r.x : o.x, f = s.y > r.y ? s.y > o.y ? s.y : o.y : r.y > o.y ? r.y : o.y, p = h(a, c, e, i, n), g = h(d, f, e, i, n), v = t.prevZ, m = t.nextZ; v && v.z >= p && m && m.z <= g;) {
										if (v !== t.prev && v !== t.next && u(s.x, s.y, r.x, r.y, o.x, o.y, v.x, v.y) && 0 <= l(v.prev, v, v.next)) return !1;
										if (v = v.prevZ, m !== t.prev && m !== t.next && u(s.x, s.y, r.x, r.y, o.x, o.y, m.x, m.y) && 0 <= l(m.prev, m, m.next)) return !1;
										m = m.nextZ
									}
									for (; v && v.z >= p;) {
										if (v !== t.prev && v !== t.next && u(s.x, s.y, r.x, r.y, o.x, o.y, v.x, v.y) && 0 <= l(v.prev, v, v.next)) return !1;
										v = v.prevZ
									}
									for (; m && m.z <= g;) {
										if (m !== t.prev && m !== t.next && u(s.x, s.y, r.x, r.y, o.x, o.y, m.x, m.y) && 0 <= l(m.prev, m, m.next)) return !1;
										m = m.nextZ
									}
									return !0
								}(t, n, s, a) : function(t) {
									var e = t.prev,
										i = t,
										n = t.next;
									if (0 <= l(e, i, n)) return !1;
									for (var s = t.next.next; s !== t.prev;) {
										if (u(e.x, e.y, i.x, i.y, n.x, n.y, s.x, s.y) && 0 <= l(s.prev, s, s.next)) return !1;
										s = s.next
									}
									return !0
								}(t)) e.push(m.i / i), e.push(t.i / i), e.push(y.i / i), v(t), t = y.next, x = y.next;
							else if ((t = y) === x) {
							g ? 1 === g ? o(t = function(t, e, i) {
								var n = t;
								do {
									var s = n.prev,
										r = n.next.next;
									!c(s, r) && d(s, n, n.next, r) && f(s, r) && f(r, s) && (e.push(s.i / i), e.push(n.i / i), e.push(r.i / i), v(n), v(n.next), n = t = r), n = n.next
								} while (n !== t);
								return n
							}(t, e, i), e, i, n, s, a, 2) : 2 === g && function(t, e, i, n, s, a) {
								var h = t;
								do {
									for (var u = h.next.next; u !== h.prev;) {
										if (h.i !== u.i && function(t, e) {
												return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
													var i = t;
													do {
														if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && d(i, i.next, t, e)) return !0;
														i = i.next
													} while (i !== t);
													return !1
												}(t, e) && f(t, e) && f(e, t) && function(t, e) {
													for (var i = t, n = !1, s = (t.x + e.x) / 2, r = (t.y + e.y) / 2; i.y > r != i.next.y > r && i.next.y !== i.y && s < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (n = !n), (i = i.next) !== t;);
													return n
												}(t, e)
											}(h, u)) {
											var l = p(h, u);
											return h = r(h, h.next), l = r(l, l.next), o(h, e, i, n, s, a), o(l, e, i, n, s, a)
										}
										u = u.next
									}
									h = h.next
								} while (h !== t)
							}(t, e, i, n, s, a) : o(r(t), e, i, n, s, a, 1);
							break
						}
					}
				}

				function a(t, e) {
					return t.x - e.x
				}

				function h(t, e, i, n, s) {
					return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * s) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * s) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
				}

				function u(t, e, i, n, s, r, o, a) {
					return 0 <= (s - o) * (e - a) - (t - o) * (r - a) && 0 <= (t - o) * (n - a) - (i - o) * (e - a) && 0 <= (i - o) * (r - a) - (s - o) * (n - a)
				}

				function l(t, e, i) {
					return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
				}

				function c(t, e) {
					return t.x === e.x && t.y === e.y
				}

				function d(t, e, i, n) {
					return c(t, e) && c(i, n) || c(t, n) && c(i, e) || 0 < l(t, e, i) != 0 < l(t, e, n) && 0 < l(i, n, t) != 0 < l(i, n, e)
				}

				function f(t, e) {
					return l(t.prev, t, t.next) < 0 ? 0 <= l(t, e, t.next) && 0 <= l(t, t.prev, e) : l(t, e, t.prev) < 0 || l(t, t.next, e) < 0
				}

				function p(t, e) {
					var i = new m(t.i, t.x, t.y),
						n = new m(e.i, e.x, e.y),
						s = t.next,
						r = e.prev;
					return (t.next = e).prev = t, (i.next = s).prev = i, (n.next = i).prev = n, (r.next = n).prev = r, n
				}

				function g(t, e, i, n) {
					var s = new m(t, e, i);
					return n ? (s.next = n.next, (s.prev = n).next.prev = s, n.next = s) : (s.prev = s).next = s, s
				}

				function v(t) {
					t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
				}

				function m(t, e, i) {
					this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
				}

				function y(t, e, i, n) {
					for (var s = 0, r = e, o = i - n; r < i; r += n) s += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r;
					return s
				}(t.exports = n).deviation = function(t, e, i, n) {
					var s = e && e.length,
						r = s ? e[0] * i : t.length,
						o = Math.abs(y(t, 0, r, i));
					if (s)
						for (var a = 0, h = e.length; a < h; a++) {
							var u = e[a] * i,
								l = a < h - 1 ? e[a + 1] * i : t.length;
							o -= Math.abs(y(t, u, l, i))
						}
					var c = 0;
					for (a = 0; a < n.length; a += 3) {
						var d = n[a] * i,
							f = n[a + 1] * i,
							p = n[a + 2] * i;
						c += Math.abs((t[d] - t[p]) * (t[1 + f] - t[1 + d]) - (t[d] - t[f]) * (t[1 + p] - t[1 + d]))
					}
					return 0 === o && 0 === c ? 0 : Math.abs((c - o) / o)
				}, n.flatten = function(t) {
					for (var e = t[0][0].length, i = {
							vertices: [],
							holes: [],
							dimensions: e
						}, n = 0, s = 0; s < t.length; s++) {
						for (var r = 0; r < t[s].length; r++)
							for (var o = 0; o < e; o++) i.vertices.push(t[s][r][o]);
						0 < s && (n += t[s - 1].length, i.holes.push(n))
					}
					return i
				}
			}, function(t, e) {
				t.exports = function(t) {
					var e = {};
					for (var i in t) Array.isArray(t[i]) ? e[i] = t[i].slice(0) : e[i] = t[i];
					return e
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					var s = t.length;
					if (e < 0 || s < e || i <= e || s < i || s < e + i) {
						if (n) throw new Error("Range Error: Values outside acceptable range");
						return !1
					}
					return !0
				}
			}, function(t, e, i) {
				var n = i(115),
					s = i(181);
				t.exports = function(t, e) {
					var i, r = n.Power0;
					if ("string" == typeof t ? n.hasOwnProperty(t) ? r = n[t] : (i = "", t.indexOf(".") && ("in" === (i = t.substr(t.indexOf(".") + 1)).toLowerCase() ? i = "easeIn" : "out" === i.toLowerCase() ? i = "easeOut" : "inout" === i.toLowerCase() && (i = "easeInOut")), t = s(t.substr(0, t.indexOf(".") + 1) + i), n.hasOwnProperty(t) && (r = n[t])) : "function" == typeof t ? r = t : Array.isArray(t) && t.length, !e) return r;
					var o = e.slice(0);
					return o.unshift(0),
						function(t) {
							return o[0] = t, r.apply(this, o)
						}
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					var o = t.strokeTint,
						a = n.getTintAppendFloatAlphaAndSwap(e.strokeColor, e.strokeAlpha * i);
					o.TL = a, o.TR = a, o.BL = a, o.BR = a;
					var h = e.pathData,
						u = h.length - 1,
						l = e.lineWidth,
						c = l / 2,
						d = h[0] - s,
						f = h[1] - r;
					e.closePath || (u -= 2);
					for (var p = 2; p < u; p += 2) {
						var g = h[p] - s,
							v = h[p + 1] - r;
						t.setTexture2D(), t.batchLine(d, f, g, v, c, c, l, p - 2, !!e.closePath && p === u - 1), d = g, f = v
					}
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(83),
					r = i(425),
					o = i(426),
					a = i(47),
					h = i(56),
					u = i(158),
					l = new n({
						initialize: function(t, e, i, n, s, r) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), this.type = a.TRIANGLE, this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this.x3 = s, this.y3 = r
						},
						contains: function(t, e) {
							return s(this, t, e)
						},
						getPoint: function(t, e) {
							return r(this, t, e)
						},
						getPoints: function(t, e, i) {
							return o(this, t, e, i)
						},
						getRandomPoint: function(t) {
							return u(this, t)
						},
						setTo: function(t, e, i, n, s, r) {
							return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this.x3 = s, this.y3 = r, this
						},
						getLineA: function(t) {
							return void 0 === t && (t = new h), t.setTo(this.x1, this.y1, this.x2, this.y2), t
						},
						getLineB: function(t) {
							return void 0 === t && (t = new h), t.setTo(this.x2, this.y2, this.x3, this.y3), t
						},
						getLineC: function(t) {
							return void 0 === t && (t = new h), t.setTo(this.x3, this.y3, this.x1, this.y1), t
						},
						left: {
							get: function() {
								return Math.min(this.x1, this.x2, this.x3)
							},
							set: function(t) {
								var e = this.x1 <= this.x2 && this.x1 <= this.x3 ? this.x1 - t : this.x2 <= this.x1 && this.x2 <= this.x3 ? this.x2 - t : this.x3 - t;
								this.x1 -= e, this.x2 -= e, this.x3 -= e
							}
						},
						right: {
							get: function() {
								return Math.max(this.x1, this.x2, this.x3)
							},
							set: function(t) {
								var e = this.x1 >= this.x2 && this.x1 >= this.x3 ? this.x1 - t : this.x2 >= this.x1 && this.x2 >= this.x3 ? this.x2 - t : this.x3 - t;
								this.x1 -= e, this.x2 -= e, this.x3 -= e
							}
						},
						top: {
							get: function() {
								return Math.min(this.y1, this.y2, this.y3)
							},
							set: function(t) {
								var e = this.y1 <= this.y2 && this.y1 <= this.y3 ? this.y1 - t : this.y2 <= this.y1 && this.y2 <= this.y3 ? this.y2 - t : this.y3 - t;
								this.y1 -= e, this.y2 -= e, this.y3 -= e
							}
						},
						bottom: {
							get: function() {
								return Math.max(this.y1, this.y2, this.y3)
							},
							set: function(t) {
								var e = this.y1 >= this.y2 && this.y1 >= this.y3 ? this.y1 - t : this.y2 >= this.y1 && this.y2 >= this.y3 ? this.y2 - t : this.y3 - t;
								this.y1 -= e, this.y2 -= e, this.y3 -= e
							}
						}
					});
				t.exports = l
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = new n({
						Extends: r,
						initialize: function t(e, i, n, s, o) {
							var u, l, c = "png";
							h(i) && (i = a(l = i, "key"), n = a(l, "url"), u = a(l, "normalMap"), s = a(l, "xhrSettings"), c = a(l, "extension", c), o = a(l, "frameConfig")), Array.isArray(n) && (u = n[1], n = n[0]);
							var d, f = {
								type: "image",
								cache: e.textureManager,
								extension: c,
								responseType: "blob",
								key: i,
								url: n,
								xhrSettings: s,
								config: o
							};
							r.call(this, e, f), u && ((d = new t(e, this.key, u, s, o)).type = "normalMap", this.setLink(d), e.addFile(d))
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING, this.data = new Image, this.data.crossOrigin = this.crossOrigin;
							var t = this;
							this.data.onload = function() {
								r.revokeObjectURL(t.data), t.onProcessComplete()
							}, this.data.onerror = function() {
								r.revokeObjectURL(t.data), t.onProcessError()
							}, r.createObjectURL(this.data, this.xhrLoader.response, "image/png")
						},
						addToCache: function() {
							var t, e = this.linkFile;
							e && e.state === s.FILE_COMPLETE ? (t = "image" === this.type ? this.cache.addImage(this.key, this.data, e.data) : this.cache.addImage(e.key, e.data, this.data), this.pendingDestroy(t), e.pendingDestroy(t)) : e || (t = this.cache.addImage(this.key, this.data), this.pendingDestroy(t))
						}
					});
				o.register("image", function(t, e, i) {
					if (Array.isArray(t))
						for (var n = 0; n < t.length; n++) this.addFile(new u(this, t[n]));
					else this.addFile(new u(this, t, e, i));
					return this
				}), t.exports = u
			}, function(t, e) {
				t.exports = function(t, e) {
					e ? t.setCollision(!0, !0, !0, !0, !1) : t.resetCollision(!1)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(444),
					o = new n({
						Mixins: [s.Alpha, s.Flip, s.Visible],
						initialize: function(t, e, i, n, s, r, o, a) {
							this.layer = t, this.index = e, this.x = i, this.y = n, this.width = s, this.height = r, this.baseWidth = void 0 !== o ? o : s, this.baseHeight = void 0 !== a ? a : r, this.pixelX = 0, this.pixelY = 0, this.updatePixelXY(), this.properties = {}, this.rotation = 0, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceLeft = !1, this.faceRight = !1, this.faceTop = !1, this.faceBottom = !1, this.collisionCallback = null, (this.collisionCallbackContext = this).tint = 16777215, this.physics = {}
						},
						containsPoint: function(t, e) {
							return !(t < this.pixelX || e < this.pixelY || t > this.right || e > this.bottom)
						},
						copy: function(t) {
							return this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.visible = t.visible, this.setFlip(t.flipX, t.flipY), this.tint = t.tint, this.rotation = t.rotation, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext, this
						},
						getCollisionGroup: function() {
							return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null
						},
						getTileData: function() {
							return this.tileset ? this.tileset.getTileData(this.index) : null
						},
						getLeft: function(t) {
							var e = this.tilemapLayer;
							return e ? e.tileToWorldX(this.x, t) : this.x * this.baseWidth
						},
						getRight: function(t) {
							var e = this.tilemapLayer;
							return e ? this.getLeft(t) + this.width * e.scaleX : this.getLeft(t) + this.width
						},
						getTop: function(t) {
							var e = this.tilemapLayer;
							return e ? e.tileToWorldY(this.y, t) - (this.height - this.baseHeight) * e.scaleY : this.y * this.baseHeight - (this.height - this.baseHeight)
						},
						getBottom: function(t) {
							var e = this.tilemapLayer;
							return e ? this.getTop(t) + this.height * e.scaleY : this.getTop(t) + this.height
						},
						getBounds: function(t, e) {
							return void 0 === e && (e = new r), e.x = this.getLeft(), e.y = this.getTop(), e.width = this.getRight() - e.x, e.height = this.getBottom() - e.y, e
						},
						getCenterX: function(t) {
							return (this.getLeft(t) + this.getRight(t)) / 2
						},
						getCenterY: function(t) {
							return (this.getTop(t) + this.getBottom(t)) / 2
						},
						destroy: function() {
							this.collisionCallback = void 0, this.collisionCallbackContext = void 0, this.properties = void 0
						},
						intersects: function(t, e, i, n) {
							return !(i <= this.pixelX || n <= this.pixelY || t >= this.right || e >= this.bottom)
						},
						isInteresting: function(t, e) {
							return t && e ? this.canCollide || this.hasInterestingFace : t ? this.collides : !!e && this.hasInterestingFace
						},
						resetCollision: function(t) {
							return void 0 === t && (t = !0), this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, t && this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y), this
						},
						resetFaces: function() {
							return this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this
						},
						setCollision: function(t, e, i, n, s) {
							return void 0 === e && (e = t), void 0 === i && (i = t), void 0 === n && (n = t), void 0 === s && (s = !0), this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = n, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = n, s && this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y), this
						},
						setCollisionCallback: function(t, e) {
							return null === t ? (this.collisionCallback = void 0, this.collisionCallbackContext = void 0) : (this.collisionCallback = t, this.collisionCallbackContext = e), this
						},
						setSize: function(t, e, i, n) {
							return void 0 !== t && (this.width = t), void 0 !== e && (this.height = e), void 0 !== i && (this.baseWidth = i), void 0 !== n && (this.baseHeight = n), this.updatePixelXY(), this
						},
						updatePixelXY: function() {
							return this.pixelX = this.x * this.baseWidth, this.pixelY = this.y * this.baseHeight, this
						},
						canCollide: {
							get: function() {
								return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
							}
						},
						collides: {
							get: function() {
								return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
							}
						},
						hasInterestingFace: {
							get: function() {
								return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight
							}
						},
						tileset: {
							get: function() {
								var t = this.layer.tilemapLayer;
								if (t) {
									var e = t.gidMap[this.index];
									if (e) return e
								}
								return null
							}
						},
						tilemapLayer: {
							get: function() {
								return this.layer.tilemapLayer
							}
						},
						tilemap: {
							get: function() {
								var t = this.tilemapLayer;
								return t ? t.tilemap : null
							}
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(14),
					o = i(967),
					a = new n({
						Extends: r,
						Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Size, s.TextureCrop, s.Tint, s.Transform, s.Visible, o],
						initialize: function(t, e, i, n, o) {
							r.call(this, t, "Sprite"), this._crop = this.resetCropObject(), this.anims = new s.Animation(this), this.setTexture(n, o), this.setPosition(e, i), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline()
						},
						preUpdate: function(t, e) {
							this.anims.update(t, e)
						},
						play: function(t, e, i) {
							return this.anims.play(t, e, i), this
						},
						toJSON: function() {
							return s.ToJSON(this)
						},
						preDestroy: function() {
							this.anims.destroy(), this.anims = void 0
						}
					});
				t.exports = a
			}, function(t, e) {
				t.exports = function(t) {
					return t.x - t.width * t.originX + .5 * t.width
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = t.width * t.originX;
					return t.x = e + i - .5 * t.width, t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.y - t.height * t.originY + .5 * t.height
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = t.height * t.originY;
					return t.y = e + i - .5 * t.height, t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					if (!(e >= t.length)) {
						for (var i = t.length - 1, n = t[e], s = e; s < i; s++) t[s] = t[s + 1];
						return t.length = i, n
					}
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(176),
					r = i(11),
					o = i(3),
					a = new n({
						initialize: function(t) {
							this.type = t, this.defaultDivisions = 5, this.arcLengthDivisions = 100, this.cacheArcLengths = [], this.needsUpdate = !0, this.active = !0, this._tmpVec2A = new o, this._tmpVec2B = new o
						},
						draw: function(t, e) {
							return void 0 === e && (e = 32), t.strokePoints(this.getPoints(e))
						},
						getBounds: function(t, e) {
							t = t || new r, void 0 === e && (e = 16);
							var i = this.getLength();
							i < e && (e = i / 2);
							var n = Math.max(1, Math.round(i / e));
							return s(this.getSpacedPoints(n), t)
						},
						getDistancePoints: function(t) {
							var e = this.getLength(),
								i = Math.max(1, e / t);
							return this.getSpacedPoints(i)
						},
						getEndPoint: function(t) {
							return void 0 === t && (t = new o), this.getPointAt(1, t)
						},
						getLength: function() {
							var t = this.getLengths();
							return t[t.length - 1]
						},
						getLengths: function(t) {
							if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
							this.needsUpdate = !1;
							var e, i = [],
								n = this.getPoint(0, this._tmpVec2A),
								s = 0;
							i.push(0);
							for (var r = 1; r <= t; r++) s += (e = this.getPoint(r / t, this._tmpVec2B)).distance(n), i.push(s), n.copy(e);
							return this.cacheArcLengths = i
						},
						getPointAt: function(t, e) {
							var i = this.getUtoTmapping(t);
							return this.getPoint(i, e)
						},
						getPoints: function(t, e, i) {
							void 0 === i && (i = []), t = t || (e ? this.getLength() / e : this.defaultDivisions);
							for (var n = 0; n <= t; n++) i.push(this.getPoint(n / t));
							return i
						},
						getRandomPoint: function(t) {
							return void 0 === t && (t = new o), this.getPoint(Math.random(), t)
						},
						getSpacedPoints: function(t, e, i) {
							void 0 === i && (i = []), t = t || (e ? this.getLength() / e : this.defaultDivisions);
							for (var n = 0; n <= t; n++) {
								var s = this.getUtoTmapping(n / t, null, t);
								i.push(this.getPoint(s))
							}
							return i
						},
						getStartPoint: function(t) {
							return void 0 === t && (t = new o), this.getPointAt(0, t)
						},
						getTangent: function(t, e) {
							void 0 === e && (e = new o);
							var i = t - 1e-4,
								n = t + 1e-4;
							return i < 0 && (i = 0), 1 < n && (n = 1), this.getPoint(i, this._tmpVec2A), this.getPoint(n, e), e.subtract(this._tmpVec2A).normalize()
						},
						getTangentAt: function(t, e) {
							var i = this.getUtoTmapping(t);
							return this.getTangent(i, e)
						},
						getTFromDistance: function(t, e) {
							return t <= 0 ? 0 : this.getUtoTmapping(0, t, e)
						},
						getUtoTmapping: function(t, e, i) {
							for (var n, s = this.getLengths(i), r = 0, o = s.length, a = e ? Math.min(e, s[o - 1]) : t * s[o - 1], h = 0, u = o - 1; h <= u;)
								if ((n = s[r = Math.floor(h + (u - h) / 2)] - a) < 0) h = r + 1;
								else {
									if (!(0 < n)) {
										u = r;
										break
									}
									u = r - 1
								} if (s[r = u] === a) return r / (o - 1);
							var l = s[r];
							return (r + (a - l) / (s[r + 1] - l)) / (o - 1)
						},
						updateArcLengths: function() {
							this.needsUpdate = !0, this.getLengths()
						}
					});
				t.exports = a
			}, function(t, e, i) {
				t.exports = {
					ADD: i(870),
					COMPLETE: i(871),
					FILE_COMPLETE: i(872),
					FILE_KEY_COMPLETE: i(873),
					FILE_LOAD_ERROR: i(874),
					FILE_LOAD: i(875),
					FILE_PROGRESS: i(876),
					POST_PROCESS: i(877),
					PROGRESS: i(878),
					START: i(879)
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					var n = t.x3 - t.x1,
						s = t.y3 - t.y1,
						r = t.x2 - t.x1,
						o = t.y2 - t.y1,
						a = e - t.x1,
						h = i - t.y1,
						u = n * n + s * s,
						l = n * r + s * o,
						c = n * a + s * h,
						d = r * r + o * o,
						f = r * a + o * h,
						p = u * d - l * l,
						g = 0 == p ? 0 : 1 / p,
						v = (d * c - l * f) * g,
						m = (u * f - l * c) * g;
					return 0 <= v && 0 <= m && v + m < 1
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e, i) {
					void 0 === i && (i = new n);
					var s = t.x1,
						r = t.y1,
						o = t.x2,
						a = t.y2,
						h = e.x1,
						u = e.y1,
						l = e.x2,
						c = e.y2,
						d = (c - u) * (o - s) - (l - h) * (a - r);
					if (0 == d) return !1;
					var f = ((l - h) * (r - u) - (c - u) * (s - h)) / d,
						p = ((o - s) * (r - u) - (a - r) * (s - h)) / d;
					return 0 <= f && f <= 1 && 0 <= p && p <= 1 && (i.x = s + f * (o - s), i.y = r + f * (a - r), !0)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return Math.atan2(t.y2 - t.y1, t.x2 - t.x1)
				}
			}, , function(t, e, i) {
				var n = i(19);
				t.exports = function(t, e, i) {
					return (i - e) * n(t, 0, 1)
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return t && t.hasOwnProperty(e) ? t[e] : i
				}
			}, function(t, e) {
				t.exports = {
					CREATED: 0,
					INIT: 1,
					DELAY: 2,
					OFFSET_DELAY: 3,
					PENDING_RENDER: 4,
					PLAYING_FORWARD: 5,
					PLAYING_BACKWARD: 6,
					HOLD_DELAY: 7,
					REPEAT_DELAY: 8,
					COMPLETE: 9,
					PENDING_ADD: 20,
					PAUSED: 21,
					LOOP_DELAY: 22,
					ACTIVE: 23,
					COMPLETE_DELAY: 24,
					PENDING_REMOVE: 25,
					REMOVED: 26
				}
			}, function(t, e, i) {
				t.exports = {
					DESTROY: i(582),
					VIDEO_COMPLETE: i(583),
					VIDEO_CREATED: i(584),
					VIDEO_ERROR: i(585),
					VIDEO_LOOP: i(586),
					VIDEO_PLAY: i(587),
					VIDEO_SEEKED: i(588),
					VIDEO_SEEKING: i(589),
					VIDEO_STOP: i(590),
					VIDEO_TIMEOUT: i(591),
					VIDEO_UNLOCKED: i(592)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(39),
					o = i(10),
					a = i(40),
					h = i(11),
					u = i(29),
					l = i(164),
					c = i(3),
					d = new n({
						Extends: o,
						Mixins: [s.Alpha, s.Visible],
						initialize: function(t, e, i, n) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), o.call(this), this.scene, this.sceneManager, this.scaleManager, this.cameraManager, this.id = 0, this.name = "", this.resolution = 1, this.roundPixels = !1, this.useBounds = !1, this.worldView = new h, this.dirty = !0, this._x = t, this._y = e, this._cx = 0, this._cy = 0, this._cw = 0, this._ch = 0, this._width = i, this._height = n, this._bounds = new h, this._scrollX = 0, this._scrollY = 0, this._zoom = 1, this._rotation = 0, this.matrix = new u, this.transparent = !0, this.backgroundColor = l("rgba(0,0,0,0)"), this.disableCull = !1, this.culledObjects = [], this.midPoint = new c(i / 2, n / 2), this.originX = .5, this.originY = .5, this._customViewport = !1, this.mask = null, this._maskCamera = null
						},
						setOrigin: function(t, e) {
							return void 0 === t && (t = .5), void 0 === e && (e = t), this.originX = t, this.originY = e, this
						},
						getScroll: function(t, e, i) {
							void 0 === i && (i = new c);
							var n = .5 * this.width,
								s = .5 * this.height;
							return i.x = t - n, i.y = e - s, this.useBounds && (i.x = this.clampX(i.x), i.y = this.clampY(i.y)), i
						},
						centerOnX: function(t) {
							var e = .5 * this.width;
							return this.midPoint.x = t, this.scrollX = t - e, this.useBounds && (this.scrollX = this.clampX(this.scrollX)), this
						},
						centerOnY: function(t) {
							var e = .5 * this.height;
							return this.midPoint.y = t, this.scrollY = t - e, this.useBounds && (this.scrollY = this.clampY(this.scrollY)), this
						},
						centerOn: function(t, e) {
							return this.centerOnX(t), this.centerOnY(e), this
						},
						centerToBounds: function() {
							var t, e, i;
							return this.useBounds && (t = this._bounds, e = .5 * this.width, i = .5 * this.height, this.midPoint.set(t.centerX, t.centerY), this.scrollX = t.centerX - e, this.scrollY = t.centerY - i), this
						},
						centerToSize: function() {
							return this.scrollX = .5 * this.width, this.scrollY = .5 * this.height, this
						},
						cull: function(t) {
							if (this.disableCull) return t;
							var e = this.matrix.matrix,
								i = e[0],
								n = e[1],
								s = e[2],
								r = e[3];
							if (!(i * r - n * s)) return t;
							for (var o = e[4], a = e[5], h = this.scrollX, u = this.scrollY, l = this.width, c = this.height, d = this.y, f = d + c, p = this.x, g = p + l, v = this.culledObjects, m = t.length, y = v.length = 0; y < m; ++y) {
								var x, T, w, E, _ = t[y];
								_.hasOwnProperty("width") && !_.parentContainer ? (x = _.width, T = _.height, p < ((w = _.x - h * _.scrollFactorX - x * _.originX) + x) * i + ((E = _.y - u * _.scrollFactorY - T * _.originY) + T) * s + o && w * i + E * s + o < g && d < (w + x) * n + (E + T) * r + a && w * n + E * r + a < f && v.push(_)) : v.push(_)
							}
							return v
						},
						getWorldPoint: function(t, e, i) {
							void 0 === i && (i = new c);
							var n = this.matrix.matrix,
								s = n[0],
								r = n[1],
								o = n[2],
								a = n[3],
								h = n[4],
								u = n[5],
								l = s * a - r * o;
							if (!l) return i.x = t, i.y = e, i;
							var d = a * (l = 1 / l),
								f = -r * l,
								p = -o * l,
								g = s * l,
								v = (o * u - a * h) * l,
								m = (r * h - s * u) * l,
								y = Math.cos(this.rotation),
								x = Math.sin(this.rotation),
								T = this.zoom,
								w = this.resolution,
								E = this.scrollX,
								_ = this.scrollY,
								b = t + (E * y - _ * x) * T,
								A = e + (E * x + _ * y) * T;
							return i.x = (b * d + A * p) * w + v, i.y = (b * f + A * g) * w + m, i
						},
						ignore: function(t) {
							var e = this.id;
							Array.isArray(t) || (t = [t]);
							for (var i = 0; i < t.length; i++) {
								var n = t[i];
								Array.isArray(n) ? this.ignore(n) : n.isParent ? this.ignore(n.getChildren()) : n.cameraFilter |= e
							}
							return this
						},
						preRender: function(t) {
							var e = this.width,
								i = this.height,
								n = .5 * e,
								s = .5 * i,
								r = this.zoom * t,
								o = this.matrix,
								a = e * this.originX,
								h = i * this.originY,
								u = this.scrollX,
								l = this.scrollY;
							this.useBounds && (u = this.clampX(u), l = this.clampY(l)), this.roundPixels && (a = Math.round(a), h = Math.round(h));
							var c = (this.scrollX = u) + n,
								d = (this.scrollY = l) + s;
							this.midPoint.set(c, d);
							var f = e / r,
								p = i / r;
							this.worldView.setTo(c - f / 2, d - p / 2, f, p), o.applyITRS(this.x + a, this.y + h, this.rotation, r, r), o.translate(-a, -h)
						},
						clampX: function(t) {
							var e = this._bounds,
								i = this.displayWidth,
								n = e.x + (i - this.width) / 2,
								s = Math.max(n, n + e.width - i);
							return t < n ? t = n : s < t && (t = s), t
						},
						clampY: function(t) {
							var e = this._bounds,
								i = this.displayHeight,
								n = e.y + (i - this.height) / 2,
								s = Math.max(n, n + e.height - i);
							return t < n ? t = n : s < t && (t = s), t
						},
						removeBounds: function() {
							return this.useBounds = !1, this.dirty = !0, this._bounds.setEmpty(), this
						},
						setAngle: function(t) {
							return void 0 === t && (t = 0), this.rotation = r(t), this
						},
						setBackgroundColor: function(t) {
							return void 0 === t && (t = "rgba(0,0,0,0)"), this.backgroundColor = l(t), this.transparent = 0 === this.backgroundColor.alpha, this
						},
						setBounds: function(t, e, i, n, s) {
							return void 0 === s && (s = !1), this._bounds.setTo(t, e, i, n), this.dirty = !0, this.useBounds = !0, s ? this.centerToBounds() : (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this
						},
						getBounds: function(t) {
							void 0 === t && (t = new h);
							var e = this._bounds;
							return t.setTo(e.x, e.y, e.width, e.height), t
						},
						setName: function(t) {
							return void 0 === t && (t = ""), this.name = t, this
						},
						setPosition: function(t, e) {
							return void 0 === e && (e = t), this.x = t, this.y = e, this
						},
						setRotation: function(t) {
							return void 0 === t && (t = 0), this.rotation = t, this
						},
						setRoundPixels: function(t) {
							return this.roundPixels = t, this
						},
						setScene: function(t) {
							this.scene && this._customViewport && this.sceneManager.customViewports--;
							var e = (this.scene = t).sys;
							this.sceneManager = e.game.scene, this.scaleManager = e.scale, this.cameraManager = e.cameras;
							var i = this.scaleManager.resolution;
							return this.resolution = i, this._cx = this._x * i, this._cy = this._y * i, this._cw = this._width * i, this._ch = this._height * i, this.updateSystem(), this
						},
						setScroll: function(t, e) {
							return void 0 === e && (e = t), this.scrollX = t, this.scrollY = e, this
						},
						setSize: function(t, e) {
							return void 0 === e && (e = t), this.width = t, this.height = e, this
						},
						setViewport: function(t, e, i, n) {
							return this.x = t, this.y = e, this.width = i, this.height = n, this
						},
						setZoom: function(t) {
							return void 0 === t && (t = 1), 0 === t && (t = .001), this.zoom = t, this
						},
						setMask: function(t, e) {
							return void 0 === e && (e = !0), this.mask = t, this._maskCamera = e ? this.cameraManager.default : this, this
						},
						clearMask: function(t) {
							return void 0 === t && (t = !1), t && this.mask && this.mask.destroy(), this.mask = null, this
						},
						toJSON: function() {
							var t = {
								name: this.name,
								x: this.x,
								y: this.y,
								width: this.width,
								height: this.height,
								zoom: this.zoom,
								rotation: this.rotation,
								roundPixels: this.roundPixels,
								scrollX: this.scrollX,
								scrollY: this.scrollY,
								backgroundColor: this.backgroundColor.rgba
							};
							return this.useBounds && (t.bounds = {
								x: this._bounds.x,
								y: this._bounds.y,
								width: this._bounds.width,
								height: this._bounds.height
							}), t
						},
						update: function() {},
						updateSystem: function() {
							var t, e;
							this.scaleManager && (t = 0 !== this._x || 0 !== this._y || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height, e = this.sceneManager, t && !this._customViewport ? e.customViewports++ : !t && this._customViewport && e.customViewports--, this.dirty = !0, this._customViewport = t)
						},
						destroy: function() {
							this.emit(a.DESTROY, this), this.removeAllListeners(), this.matrix.destroy(), this.culledObjects = [], this._customViewport && this.sceneManager.customViewports--, this._bounds = null, this.scene = null, this.scaleManager = null, this.sceneManager = null, this.cameraManager = null
						},
						x: {
							get: function() {
								return this._x
							},
							set: function(t) {
								this._x = t, this._cx = t * this.resolution, this.updateSystem()
							}
						},
						y: {
							get: function() {
								return this._y
							},
							set: function(t) {
								this._y = t, this._cy = t * this.resolution, this.updateSystem()
							}
						},
						width: {
							get: function() {
								return this._width
							},
							set: function(t) {
								this._width = t, this._cw = t * this.resolution, this.updateSystem()
							}
						},
						height: {
							get: function() {
								return this._height
							},
							set: function(t) {
								this._height = t, this._ch = t * this.resolution, this.updateSystem()
							}
						},
						scrollX: {
							get: function() {
								return this._scrollX
							},
							set: function(t) {
								this._scrollX = t, this.dirty = !0
							}
						},
						scrollY: {
							get: function() {
								return this._scrollY
							},
							set: function(t) {
								this._scrollY = t, this.dirty = !0
							}
						},
						zoom: {
							get: function() {
								return this._zoom
							},
							set: function(t) {
								this._zoom = t, this.dirty = !0
							}
						},
						rotation: {
							get: function() {
								return this._rotation
							},
							set: function(t) {
								this._rotation = t, this.dirty = !0
							}
						},
						centerX: {
							get: function() {
								return this.x + .5 * this.width
							}
						},
						centerY: {
							get: function() {
								return this.y + .5 * this.height
							}
						},
						displayWidth: {
							get: function() {
								return this.width / this.zoom
							}
						},
						displayHeight: {
							get: function() {
								return this.height / this.zoom
							}
						}
					});
				t.exports = d
			}, function(t, e, i) {
				t.exports = {
					ENTER_FULLSCREEN: i(703),
					FULLSCREEN_FAILED: i(704),
					FULLSCREEN_UNSUPPORTED: i(705),
					LEAVE_FULLSCREEN: i(706),
					ORIENTATION_CHANGE: i(707),
					RESIZE: i(708)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.floor(t / e), n ? (i + t) / e : i + t)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(19),
					r = i(18),
					o = new n({
						initialize: function(t, e, i, n, s, r, o) {
							this.texture = t, this.name = e, this.source = t.source[i], this.sourceIndex = i, this.glTexture = this.source.glTexture, this.cutX, this.cutY, this.cutWidth, this.cutHeight, this.x = 0, this.y = 0, this.width, this.height, this.halfWidth, this.halfHeight, this.centerX, this.centerY, this.pivotX = 0, this.pivotY = 0, this.customPivot = !1, this.rotated = !1, this.autoRound = -1, this.customData = {}, this.u0 = 0, this.v0 = 0, this.u1 = 0, this.v1 = 0, this.data = {
								cut: {
									x: 0,
									y: 0,
									w: 0,
									h: 0,
									r: 0,
									b: 0
								},
								trim: !1,
								sourceSize: {
									w: 0,
									h: 0
								},
								spriteSourceSize: {
									x: 0,
									y: 0,
									w: 0,
									h: 0,
									r: 0,
									b: 0
								},
								radius: 0,
								drawImage: {
									x: 0,
									y: 0,
									width: 0,
									height: 0
								}
							}, this.setSize(r, o, n, s)
						},
						setSize: function(t, e, i, n) {
							void 0 === i && (i = 0), void 0 === n && (n = 0), this.cutX = i, this.cutY = n, this.cutWidth = t, this.cutHeight = e, this.width = t, this.height = e, this.halfWidth = Math.floor(.5 * t), this.halfHeight = Math.floor(.5 * e), this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2);
							var s = this.data,
								r = s.cut;
							r.x = i, r.y = n, r.w = t, r.h = e, r.r = i + t, r.b = n + e, s.sourceSize.w = t, s.sourceSize.h = e, s.spriteSourceSize.w = t, s.spriteSourceSize.h = e, s.radius = .5 * Math.sqrt(t * t + e * e);
							var o = s.drawImage;
							return o.x = i, o.y = n, o.width = t, o.height = e, this.updateUVs()
						},
						setTrim: function(t, e, i, n, s, r) {
							var o = this.data,
								a = o.spriteSourceSize;
							return o.trim = !0, o.sourceSize.w = t, o.sourceSize.h = e, a.x = i, a.y = n, a.w = s, a.h = r, a.r = i + s, a.b = n + r, this.x = i, this.y = n, this.width = s, this.height = r, this.halfWidth = .5 * s, this.halfHeight = .5 * r, this.centerX = Math.floor(s / 2), this.centerY = Math.floor(r / 2), this.updateUVs()
						},
						setCropUVs: function(t, e, i, n, r, o, a) {
							var h, u, l, c, d, f, p, g = this.cutX,
								v = this.cutY,
								m = this.cutWidth,
								y = this.cutHeight,
								x = this.realWidth,
								T = this.realHeight,
								w = g + (e = s(e, 0, x)),
								E = v + (i = s(i, 0, T)),
								_ = n = s(n, 0, x - e),
								b = r = s(r, 0, T - i),
								A = this.data;
							A.trim ? (h = A.spriteSourceSize, u = e + (n = s(n, 0, m - e)), l = i + (r = s(r, 0, y - i)), h.r < e || h.b < i || h.x > u || h.y > l ? b = _ = E = w = 0 : (c = Math.max(h.x, e), d = Math.max(h.y, i), _ = f = Math.min(h.r, u) - c, b = p = Math.min(h.b, l) - d, w = o ? g + (m - (c - h.x) - f) : g + (c - h.x), E = a ? v + (y - (d - h.y) - p) : v + (d - h.y), e = c, i = d, n = f, r = p)) : (o && (w = g + (m - e - n)), a && (E = v + (y - i - r)));
							var S = this.source.width,
								C = this.source.height;
							return t.u0 = Math.max(0, w / S), t.v0 = Math.max(0, E / C), t.u1 = Math.min(1, (w + _) / S), t.v1 = Math.min(1, (E + b) / C), t.x = e, t.y = i, t.cx = w, t.cy = E, t.cw = _, t.ch = b, t.width = n, t.height = r, t.flipX = o, t.flipY = a, t
						},
						updateCropUVs: function(t, e, i) {
							return this.setCropUVs(t, t.x, t.y, t.width, t.height, e, i)
						},
						updateUVs: function() {
							var t = this.cutX,
								e = this.cutY,
								i = this.cutWidth,
								n = this.cutHeight,
								s = this.data.drawImage;
							s.width = i, s.height = n;
							var r = this.source.width,
								o = this.source.height;
							return this.u0 = t / r, this.v0 = e / o, this.u1 = (t + i) / r, this.v1 = (e + n) / o, this
						},
						updateUVsInverted: function() {
							var t = this.source.width,
								e = this.source.height;
							return this.u0 = (this.cutX + this.cutHeight) / t, this.v0 = this.cutY / e, this.u1 = this.cutX / t, this.v1 = (this.cutY + this.cutWidth) / e, this
						},
						clone: function() {
							var t = new o(this.texture, this.name, this.sourceIndex);
							return t.cutX = this.cutX, t.cutY = this.cutY, t.cutWidth = this.cutWidth, t.cutHeight = this.cutHeight, t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t.halfWidth = this.halfWidth, t.halfHeight = this.halfHeight, t.centerX = this.centerX, t.centerY = this.centerY, t.rotated = this.rotated, t.data = r(!0, t.data, this.data), t.updateUVs(), t
						},
						destroy: function() {
							this.source = null, this.texture = null, this.glTexture = null, this.customData = null, this.data = null
						},
						realWidth: {
							get: function() {
								return this.data.sourceSize.w
							}
						},
						realHeight: {
							get: function() {
								return this.data.sourceSize.h
							}
						},
						radius: {
							get: function() {
								return this.data.radius
							}
						},
						trimmed: {
							get: function() {
								return this.data.trim
							}
						},
						canvasData: {
							get: function() {
								return this.data.drawImage
							}
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(0),
					s = i(96),
					r = i(398),
					o = i(399),
					a = i(47),
					h = i(157),
					u = new n({
						initialize: function(t, e, i, n) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.type = a.ELLIPSE, this.x = t, this.y = e, this.width = i, this.height = n
						},
						contains: function(t, e) {
							return s(this, t, e)
						},
						getPoint: function(t, e) {
							return r(this, t, e)
						},
						getPoints: function(t, e, i) {
							return o(this, t, e, i)
						},
						getRandomPoint: function(t) {
							return h(this, t)
						},
						setTo: function(t, e, i, n) {
							return this.x = t, this.y = e, this.width = i, this.height = n, this
						},
						setEmpty: function() {
							return this.width = 0, this.height = 0, this
						},
						setPosition: function(t, e) {
							return void 0 === e && (e = t), this.x = t, this.y = e, this
						},
						setSize: function(t, e) {
							return void 0 === e && (e = t), this.width = t, this.height = e, this
						},
						isEmpty: function() {
							return this.width <= 0 || this.height <= 0
						},
						getMinorRadius: function() {
							return Math.min(this.width, this.height) / 2
						},
						getMajorRadius: function() {
							return Math.max(this.width, this.height) / 2
						},
						left: {
							get: function() {
								return this.x - this.width / 2
							},
							set: function(t) {
								this.x = t + this.width / 2
							}
						},
						right: {
							get: function() {
								return this.x + this.width / 2
							},
							set: function(t) {
								this.x = t - this.width / 2
							}
						},
						top: {
							get: function() {
								return this.y - this.height / 2
							},
							set: function(t) {
								this.y = t + this.height / 2
							}
						},
						bottom: {
							get: function() {
								return this.y + this.height / 2
							},
							set: function(t) {
								this.y = t - this.height / 2
							}
						}
					});
				t.exports = u
			}, function(t, e) {
				t.exports = function(t, e, i) {
					if (t.width <= 0 || t.height <= 0) return !1;
					var n = (e - t.x) / t.width,
						s = (i - t.y) / t.height;
					return (n *= n) + (s *= s) < .25
				}
			}, function(t, e, i) {
				var n = i(241),
					s = i(0),
					r = i(90),
					o = i(2),
					a = i(6),
					h = i(7),
					u = i(392),
					l = i(133),
					c = i(75),
					d = new s({
						initialize: function(t, e, i) {
							i ? e && !Array.isArray(e) && (e = [e]) : Array.isArray(e) ? h(e[0]) && (i = e, e = null) : h(e) && (i = e, e = null), this.scene = t, this.children = new l, this.isParent = !0, this.type = "Group", this.classType = o(i, "classType", c), this.name = o(i, "name", ""), this.active = o(i, "active", !0), this.maxSize = o(i, "maxSize", -1), this.defaultKey = o(i, "defaultKey", null), this.defaultFrame = o(i, "defaultFrame", null), this.runChildUpdate = o(i, "runChildUpdate", !1), this.createCallback = o(i, "createCallback", null), this.removeCallback = o(i, "removeCallback", null), this.createMultipleCallback = o(i, "createMultipleCallback", null), this.internalCreateCallback = o(i, "internalCreateCallback", null), this.internalRemoveCallback = o(i, "internalRemoveCallback", null), e && this.addMultiple(e), i && this.createMultiple(i)
						},
						create: function(t, e, i, n, s, r) {
							if (void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.defaultKey), void 0 === n && (n = this.defaultFrame), void 0 === s && (s = !0), void 0 === r && (r = !0), this.isFull()) return null;
							var o = new this.classType(this.scene, t, e, i, n);
							return this.scene.sys.displayList.add(o), o.preUpdate && this.scene.sys.updateList.add(o), o.visible = s, o.setActive(r), this.add(o), o
						},
						createMultiple: function(t) {
							if (this.isFull()) return [];
							Array.isArray(t) || (t = [t]);
							var e = [];
							if (t[0].key)
								for (var i = 0; i < t.length; i++) {
									var n = this.createFromConfig(t[i]);
									e = e.concat(n)
								}
							return e
						},
						createFromConfig: function(t) {
							if (this.isFull()) return [];
							this.classType = o(t, "classType", this.classType);
							var e = o(t, "key", void 0),
								i = o(t, "frame", null),
								s = o(t, "visible", !0),
								r = o(t, "active", !0),
								h = [];
							if (void 0 === e) return h;
							Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
							var l = o(t, "repeat", 0),
								c = o(t, "randomKey", !1),
								d = o(t, "randomFrame", !1),
								f = o(t, "yoyo", !1),
								p = o(t, "quantity", !1),
								g = o(t, "frameQuantity", 1),
								v = o(t, "max", 0),
								m = u(e, i, {
									max: v,
									qty: p || g,
									random: c,
									randomB: d,
									repeat: l,
									yoyo: f
								});
							t.createCallback && (this.createCallback = t.createCallback), t.removeCallback && (this.removeCallback = t.removeCallback);
							for (var y = 0; y < m.length; y++) {
								var x = this.create(0, 0, m[y].a, m[y].b, s, r);
								if (!x) break;
								h.push(x)
							}
							var T = a(t, "setXY.x", 0),
								w = a(t, "setXY.y", 0),
								E = a(t, "setXY.stepX", 0),
								_ = a(t, "setXY.stepY", 0);
							n.SetXY(h, T, w, E, _);
							var b = a(t, "setRotation.value", 0),
								A = a(t, "setRotation.step", 0);
							n.SetRotation(h, b, A);
							var S = a(t, "setScale.x", 1),
								C = a(t, "setScale.y", S),
								M = a(t, "setScale.stepX", 0),
								O = a(t, "setScale.stepY", 0);
							n.SetScale(h, S, C, M, O);
							var P = a(t, "setAlpha.value", 1),
								R = a(t, "setAlpha.step", 0);
							n.SetAlpha(h, P, R);
							var L = a(t, "setDepth.value", 0),
								D = a(t, "setDepth.step", 0);
							n.SetDepth(h, L, D);
							var F = a(t, "setScrollFactor.x", 1),
								k = a(t, "setScrollFactor.y", F),
								I = a(t, "setScrollFactor.stepX", 0),
								B = a(t, "setScrollFactor.stepY", 0);
							n.SetScrollFactor(h, F, k, I, B);
							var Y = o(t, "hitArea", null),
								N = o(t, "hitAreaCallback", null);
							Y && n.SetHitArea(h, Y, N);
							var X = o(t, "gridAlign", !1);
							return X && n.GridAlign(h, X), this.createMultipleCallback && this.createMultipleCallback.call(this, h), h
						},
						preUpdate: function(t, e) {
							if (this.runChildUpdate && 0 !== this.children.size)
								for (var i = this.children.entries.slice(), n = 0; n < i.length; n++) {
									var s = i[n];
									s.active && s.update(t, e)
								}
						},
						add: function(t, e) {
							return void 0 === e && (e = !1), this.isFull() || (this.children.set(t), this.internalCreateCallback && this.internalCreateCallback.call(this, t), this.createCallback && this.createCallback.call(this, t), e && (this.scene.sys.displayList.add(t), t.preUpdate && this.scene.sys.updateList.add(t)), t.on(r.DESTROY, this.remove, this)), this
						},
						addMultiple: function(t, e) {
							if (void 0 === e && (e = !1), Array.isArray(t))
								for (var i = 0; i < t.length; i++) this.add(t[i], e);
							return this
						},
						remove: function(t, e, i) {
							return void 0 === e && (e = !1), void 0 === i && (i = !1), this.children.contains(t) && (this.children.delete(t), this.internalRemoveCallback && this.internalRemoveCallback.call(this, t), this.removeCallback && this.removeCallback.call(this, t), t.off(r.DESTROY, this.remove, this), i ? t.destroy() : e && (t.scene.sys.displayList.remove(t), t.preUpdate && t.scene.sys.updateList.remove(t))), this
						},
						clear: function(t, e) {
							void 0 === t && (t = !1), void 0 === e && (e = !1);
							for (var i = this.children, n = 0; n < i.size; n++) {
								var s = i.entries[n];
								s.off(r.DESTROY, this.remove, this), e ? s.destroy() : t && (s.scene.sys.displayList.remove(s), s.preUpdate && s.scene.sys.updateList.remove(s))
							}
							return this.children.clear(), this
						},
						contains: function(t) {
							return this.children.contains(t)
						},
						getChildren: function() {
							return this.children.entries
						},
						getLength: function() {
							return this.children.size
						},
						getFirst: function(t, e, i, n, s, r, o) {
							return this.getHandler(!0, 1, t, e, i, n, s, r, o)
						},
						getFirstNth: function(t, e, i, n, s, r, o, a) {
							return this.getHandler(!0, t, e, i, n, s, r, o, a)
						},
						getLast: function(t, e, i, n, s, r, o) {
							return this.getHandler(!1, 1, t, e, i, n, s, r, o)
						},
						getLastNth: function(t, e, i, n, s, r, o, a) {
							return this.getHandler(!1, t, e, i, n, s, r, o, a)
						},
						getHandler: function(t, e, i, n, s, r, o, a, h) {
							var u, l;
							void 0 === i && (i = !1), void 0 === n && (n = !1);
							var c = 0,
								d = this.children.entries;
							if (t)
								for (l = 0; l < d.length; l++)
									if ((u = d[l]).active === i) {
										if (++c === e) break
									} else u = null;
							else
								for (l = d.length - 1; 0 <= l; l--)
									if ((u = d[l]).active === i) {
										if (++c === e) break
									} else u = null;
							return u ? ("number" == typeof s && (u.x = s), "number" == typeof r && (u.y = r), u) : n ? this.create(s, r, o, a, h) : null
						},
						get: function(t, e, i, n, s) {
							return this.getFirst(!1, !0, t, e, i, n, s)
						},
						getFirstAlive: function(t, e, i, n, s, r) {
							return this.getFirst(!0, t, e, i, n, s, r)
						},
						getFirstDead: function(t, e, i, n, s, r) {
							return this.getFirst(!1, t, e, i, n, s, r)
						},
						playAnimation: function(t, e) {
							return n.PlayAnimation(this.children.entries, t, e), this
						},
						isFull: function() {
							return -1 !== this.maxSize && this.children.size >= this.maxSize
						},
						countActive: function(t) {
							void 0 === t && (t = !0);
							for (var e = 0, i = 0; i < this.children.size; i++) this.children.entries[i].active === t && e++;
							return e
						},
						getTotalUsed: function() {
							return this.countActive()
						},
						getTotalFree: function() {
							var t = this.getTotalUsed();
							return (-1 === this.maxSize ? 999999999999 : this.maxSize) - t
						},
						setActive: function(t) {
							return this.active = t, this
						},
						setName: function(t) {
							return this.name = t, this
						},
						propertyValueSet: function(t, e, i, s, r) {
							return n.PropertyValueSet(this.children.entries, t, e, i, s, r), this
						},
						propertyValueInc: function(t, e, i, s, r) {
							return n.PropertyValueInc(this.children.entries, t, e, i, s, r), this
						},
						setX: function(t, e) {
							return n.SetX(this.children.entries, t, e), this
						},
						setY: function(t, e) {
							return n.SetY(this.children.entries, t, e), this
						},
						setXY: function(t, e, i, s) {
							return n.SetXY(this.children.entries, t, e, i, s), this
						},
						incX: function(t, e) {
							return n.IncX(this.children.entries, t, e), this
						},
						incY: function(t, e) {
							return n.IncY(this.children.entries, t, e), this
						},
						incXY: function(t, e, i, s) {
							return n.IncXY(this.children.entries, t, e, i, s), this
						},
						shiftPosition: function(t, e, i) {
							return n.ShiftPosition(this.children.entries, t, e, i), this
						},
						angle: function(t, e) {
							return n.Angle(this.children.entries, t, e), this
						},
						rotate: function(t, e) {
							return n.Rotate(this.children.entries, t, e), this
						},
						rotateAround: function(t, e) {
							return n.RotateAround(this.children.entries, t, e), this
						},
						rotateAroundDistance: function(t, e, i) {
							return n.RotateAroundDistance(this.children.entries, t, e, i), this
						},
						setAlpha: function(t, e) {
							return n.SetAlpha(this.children.entries, t, e), this
						},
						setTint: function(t, e, i, s) {
							return n.SetTint(this.children.entries, t, e, i, s), this
						},
						setOrigin: function(t, e, i, s) {
							return n.SetOrigin(this.children.entries, t, e, i, s), this
						},
						scaleX: function(t, e) {
							return n.ScaleX(this.children.entries, t, e), this
						},
						scaleY: function(t, e) {
							return n.ScaleY(this.children.entries, t, e), this
						},
						scaleXY: function(t, e, i, s) {
							return n.ScaleXY(this.children.entries, t, e, i, s), this
						},
						setDepth: function(t, e) {
							return n.SetDepth(this.children.entries, t, e), this
						},
						setBlendMode: function(t) {
							return n.SetBlendMode(this.children.entries, t), this
						},
						setHitArea: function(t, e) {
							return n.SetHitArea(this.children.entries, t, e), this
						},
						shuffle: function() {
							return n.Shuffle(this.children.entries), this
						},
						kill: function(t) {
							this.children.contains(t) && t.setActive(!1)
						},
						killAndHide: function(t) {
							this.children.contains(t) && (t.setActive(!1), t.setVisible(!1))
						},
						setVisible: function(t, e, i) {
							return n.SetVisible(this.children.entries, t, e, i), this
						},
						toggleVisible: function() {
							return n.ToggleVisible(this.children.entries), this
						},
						destroy: function(t) {
							void 0 === t && (t = !1), this.scene && !this.ignoreDestroy && (this.clear(!1, t), this.scene = void 0, this.children = void 0)
						}
					});
				t.exports = d
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r, o) {
					for (var a = n.getTintAppendFloatAlphaAndSwap(i.fillColor, i.fillAlpha * s), h = i.pathData, u = i.pathIndexes, l = 0; l < u.length; l += 3) {
						var c = 2 * u[l],
							d = 2 * u[l + 1],
							f = 2 * u[l + 2],
							p = h[0 + c] - r,
							g = h[1 + c] - o,
							v = h[0 + d] - r,
							m = h[1 + d] - o,
							y = h[0 + f] - r,
							x = h[1 + f] - o,
							T = e.getX(p, g),
							w = e.getY(p, g),
							E = e.getX(v, m),
							_ = e.getY(v, m),
							b = e.getX(y, x),
							A = e.getY(y, x);
						t.setTexture2D(), t.batchTri(T, w, E, _, b, A, 0, 0, 1, 1, a, a, a, t.tintEffect)
					}
				}
			}, , , function(t, e) {
				t.exports = function(t, e, i) {
					return 0 <= t && t < i.width && 0 <= e && e < i.height
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(2),
					r = new n({
						initialize: function(t) {
							void 0 === t && (t = {}), this.name = s(t, "name", "layer"), this.x = s(t, "x", 0), this.y = s(t, "y", 0), this.width = s(t, "width", 0), this.height = s(t, "height", 0), this.tileWidth = s(t, "tileWidth", 0), this.tileHeight = s(t, "tileHeight", 0), this.baseTileWidth = s(t, "baseTileWidth", this.tileWidth), this.baseTileHeight = s(t, "baseTileHeight", this.tileHeight), this.widthInPixels = s(t, "widthInPixels", this.width * this.baseTileWidth), this.heightInPixels = s(t, "heightInPixels", this.height * this.baseTileHeight), this.alpha = s(t, "alpha", 1), this.visible = s(t, "visible", !0), this.properties = s(t, "properties", []), this.indexes = s(t, "indexes", []), this.collideIndexes = s(t, "collideIndexes", []), this.callbacks = s(t, "callbacks", []), this.bodies = s(t, "bodies", []), this.data = s(t, "data", []), this.tilemapLayer = s(t, "tilemapLayer", null)
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = i(0),
					s = i(2),
					r = new n({
						initialize: function(t) {
							void 0 === t && (t = {}), this.name = s(t, "name", "map"), this.width = s(t, "width", 0), this.height = s(t, "height", 0), this.infinite = s(t, "infinite", !1), this.tileWidth = s(t, "tileWidth", 0), this.tileHeight = s(t, "tileHeight", 0), this.widthInPixels = s(t, "widthInPixels", this.width * this.tileWidth), this.heightInPixels = s(t, "heightInPixels", this.height * this.tileHeight), this.format = s(t, "format", null), this.orientation = s(t, "orientation", "orthogonal"), this.renderOrder = s(t, "renderOrder", "right-down"), this.version = s(t, "version", "1"), this.properties = s(t, "properties", {}), this.layers = s(t, "layers", []), this.images = s(t, "images", []), this.objects = s(t, "objects", {}), this.collision = s(t, "collision", {}), this.tilesets = s(t, "tilesets", []), this.imageCollections = s(t, "imageCollections", []), this.tiles = s(t, "tiles", [])
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t, e, i, n, s, r, o, a) {
						(void 0 === i || i <= 0) && (i = 32), (void 0 === n || n <= 0) && (n = 32), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === o && (o = {}), void 0 === a && (a = {}), this.name = t, this.firstgid = e, this.tileWidth = i, this.tileHeight = n, this.tileMargin = s, this.tileSpacing = r, this.tileProperties = o, this.tileData = a, this.image = null, this.glTexture = null, this.rows = 0, this.columns = 0, this.total = 0, this.texCoordinates = []
					},
					getTileProperties: function(t) {
						return this.containsTileIndex(t) ? this.tileProperties[t - this.firstgid] : null
					},
					getTileData: function(t) {
						return this.containsTileIndex(t) ? this.tileData[t - this.firstgid] : null
					},
					getTileCollisionGroup: function(t) {
						var e = this.getTileData(t);
						return e && e.objectgroup ? e.objectgroup : null
					},
					containsTileIndex: function(t) {
						return t >= this.firstgid && t < this.firstgid + this.total
					},
					getTileTextureCoordinates: function(t) {
						return this.containsTileIndex(t) ? this.texCoordinates[t - this.firstgid] : null
					},
					setImage: function(t) {
						return this.image = t, this.glTexture = t.get().source.glTexture, this.updateTileData(this.image.source[0].width, this.image.source[0].height), this
					},
					setTileSize: function(t, e) {
						return void 0 !== t && (this.tileWidth = t), void 0 !== e && (this.tileHeight = e), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this
					},
					setSpacing: function(t, e) {
						return void 0 !== t && (this.tileMargin = t), void 0 !== e && (this.tileSpacing = e), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this
					},
					updateTileData: function(t, e) {
						var i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing),
							n = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
						i % 1 == 0 && n % 1 == 0 || console.warn("Image tile area not tile size multiple in: " + this.name), i = Math.floor(i), n = Math.floor(n), this.rows = i, this.columns = n, this.total = i * n, this.texCoordinates.length = 0;
						for (var s = this.tileMargin, r = this.tileMargin, o = 0; o < this.rows; o++) {
							for (var a = 0; a < this.columns; a++) this.texCoordinates.push({
								x: s,
								y: r
							}), s += this.tileWidth + this.tileSpacing;
							s = this.tileMargin, r += this.tileHeight + this.tileSpacing
						}
						return this
					}
				});
				t.exports = n
			}, function(t, e) {
				t.exports = {
					TOP_LEFT: 0,
					TOP_CENTER: 1,
					TOP_RIGHT: 2,
					LEFT_TOP: 3,
					LEFT_CENTER: 4,
					LEFT_BOTTOM: 5,
					CENTER: 6,
					RIGHT_TOP: 7,
					RIGHT_CENTER: 8,
					RIGHT_BOTTOM: 9,
					BOTTOM_LEFT: 10,
					BOTTOM_CENTER: 11,
					BOTTOM_RIGHT: 12
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return void 0 === i && (i = 1e-4), Math.abs(t - e) < i
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(14),
					o = i(970),
					a = new n({
						Extends: r,
						Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Size, s.TextureCrop, s.Tint, s.Transform, s.Visible, o],
						initialize: function(t, e, i, n, s) {
							r.call(this, t, "Image"), this._crop = this.resetCropObject(), this.setTexture(n, s), this.setPosition(e, i), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline()
						}
					});
				t.exports = a
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.hasOwnProperty(e)
				}
			}, , function(t, e, i) {
				var n = i(52),
					s = i(65),
					r = i(55),
					o = i(0),
					a = i(12),
					h = i(14),
					u = i(11),
					l = i(48),
					c = new o({
						Extends: h,
						Mixins: [a.Depth, a.GetBounds, a.Origin, a.Transform, a.ScrollFactor, a.Visible],
						initialize: function(t, e, i, s, r) {
							void 0 === s && (s = 1), void 0 === r && (r = s), h.call(this, t, "Zone"), this.setPosition(e, i), this.width = s, this.height = r, this.blendMode = n.NORMAL, this.updateDisplayOrigin()
						},
						displayWidth: {
							get: function() {
								return this.scaleX * this.width
							},
							set: function(t) {
								this.scaleX = t / this.width
							}
						},
						displayHeight: {
							get: function() {
								return this.scaleY * this.height
							},
							set: function(t) {
								this.scaleY = t / this.height
							}
						},
						setSize: function(t, e, i) {
							void 0 === i && (i = !0), this.width = t, this.height = e, this.updateDisplayOrigin();
							var n = this.input;
							return i && n && !n.customHitArea && (n.hitArea.width = t, n.hitArea.height = e), this
						},
						setDisplaySize: function(t, e) {
							return this.displayWidth = t, this.displayHeight = e, this
						},
						setCircleDropZone: function(t) {
							return this.setDropZone(new s(0, 0, t), r)
						},
						setRectangleDropZone: function(t, e) {
							return this.setDropZone(new u(0, 0, t, e), l)
						},
						setDropZone: function(t, e) {
							return void 0 === t ? this.setRectangleDropZone(this.width, this.height) : this.input || this.setInteractive(t, e, !0), this
						},
						setAlpha: function() {},
						setBlendMode: function() {},
						renderCanvas: function() {},
						renderWebGL: function() {}
					});
				t.exports = c
			}, function(t, e, i) {
				t.exports = {
					ADD_ANIMATION: i(534),
					ANIMATION_COMPLETE: i(535),
					ANIMATION_REPEAT: i(536),
					ANIMATION_RESTART: i(537),
					ANIMATION_START: i(538),
					PAUSE_ALL: i(539),
					REMOVE_ANIMATION: i(540),
					RESUME_ALL: i(541),
					SPRITE_ANIMATION_COMPLETE: i(542),
					SPRITE_ANIMATION_KEY_COMPLETE: i(543),
					SPRITE_ANIMATION_KEY_REPEAT: i(544),
					SPRITE_ANIMATION_KEY_RESTART: i(545),
					SPRITE_ANIMATION_KEY_START: i(546),
					SPRITE_ANIMATION_KEY_UPDATE: i(547),
					SPRITE_ANIMATION_REPEAT: i(548),
					SPRITE_ANIMATION_RESTART: i(549),
					SPRITE_ANIMATION_START: i(550),
					SPRITE_ANIMATION_UPDATE: i(551)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return 2 * (t.width + t.height)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(284),
					r = new n({
						initialize: function(t, e) {
							this.parent = t, (this.events = e) || (this.events = t.events ? t.events : t), this.list = {}, this.values = {}, this._frozen = !1, !t.hasOwnProperty("sys") && this.events && this.events.once("destroy", this.destroy, this)
						},
						get: function(t) {
							var e = this.list;
							if (Array.isArray(t)) {
								for (var i = [], n = 0; n < t.length; n++) i.push(e[t[n]]);
								return i
							}
							return e[t]
						},
						getAll: function() {
							var t = {};
							for (var e in this.list) this.list.hasOwnProperty(e) && (t[e] = this.list[e]);
							return t
						},
						query: function(t) {
							var e = {};
							for (var i in this.list) this.list.hasOwnProperty(i) && i.match(t) && (e[i] = this.list[i]);
							return e
						},
						set: function(t, e) {
							if (this._frozen) return this;
							if ("string" == typeof t) return this.setValue(t, e);
							for (var i in t) this.setValue(i, t[i]);
							return this
						},
						inc: function(t, e) {
							if (this._frozen) return this;
							void 0 === e && (e = 1);
							var i = this.get(t);
							return void 0 === i && (i = 0), this.set(t, i + e), this
						},
						toggle: function(t) {
							return this._frozen || this.set(t, !this.get(t)), this
						},
						setValue: function(t, e) {
							return this._frozen || (this.has(t) ? this.values[t] = e : (n = (i = this).list, r = this.events, o = this.parent, Object.defineProperty(this.values, t, {
								enumerable: !0,
								configurable: !0,
								get: function() {
									return n[t]
								},
								set: function(e) {
									var a;
									i._frozen || (a = n[t], n[t] = e, r.emit(s.CHANGE_DATA, o, t, e, a), r.emit(s.CHANGE_DATA_KEY + t, o, e, a))
								}
							}), n[t] = e, r.emit(s.SET_DATA, o, t, e))), this;
							var i, n, r, o
						},
						each: function(t, e) {
							for (var i = [this.parent, null, void 0], n = 1; n < arguments.length; n++) i.push(arguments[n]);
							for (var s in this.list) i[1] = s, i[2] = this.list[s], t.apply(e, i);
							return this
						},
						merge: function(t, e) {
							for (var i in void 0 === e && (e = !0), t) t.hasOwnProperty(i) && (e || !e && !this.has(i)) && this.setValue(i, t[i]);
							return this
						},
						remove: function(t) {
							if (this._frozen) return this;
							if (!Array.isArray(t)) return this.removeValue(t);
							for (var e = 0; e < t.length; e++) this.removeValue(t[e]);
							return this
						},
						removeValue: function(t) {
							var e;
							return this.has(t) && (e = this.list[t], delete this.list[t], delete this.values[t], this.events.emit(s.REMOVE_DATA, this.parent, t, e)), this
						},
						pop: function(t) {
							var e = void 0;
							return !this._frozen && this.has(t) && (e = this.list[t], delete this.list[t], delete this.values[t], this.events.emit(s.REMOVE_DATA, this.parent, t, e)), e
						},
						has: function(t) {
							return this.list.hasOwnProperty(t)
						},
						setFreeze: function(t) {
							return this._frozen = t, this
						},
						reset: function() {
							for (var t in this.list) delete this.list[t], delete this.values[t];
							return this._frozen = !1, this
						},
						destroy: function() {
							this.reset(), this.events.off(s.CHANGE_DATA), this.events.off(s.SET_DATA), this.events.off(s.REMOVE_DATA), this.parent = null
						},
						freeze: {
							get: function() {
								return this._frozen
							},
							set: function(t) {
								this._frozen = !!t
							}
						},
						count: {
							get: function() {
								var t = 0;
								for (var e in this.list) void 0 !== this.list[e] && t++;
								return t
							}
						}
					});
				t.exports = r
			}, function(t, e) {
				t.exports = function(t) {
					for (var e = t.length - 1; 0 < e; e--) {
						var i = Math.floor(Math.random() * (e + 1)),
							n = t[e];
						t[e] = t[i], t[i] = n
					}
					return t
				}
			}, function(t, e, i) {
				var n = i(302),
					s = i(303),
					r = i(304),
					o = i(305),
					a = i(306),
					h = i(307),
					u = i(308),
					l = i(309),
					c = i(310),
					d = i(311),
					f = i(312),
					p = i(313);
				t.exports = {
					Power0: u,
					Power1: l.Out,
					Power2: o.Out,
					Power3: c.Out,
					Power4: d.Out,
					Linear: u,
					Quad: l.Out,
					Cubic: o.Out,
					Quart: c.Out,
					Quint: d.Out,
					Sine: f.Out,
					Expo: h.Out,
					Circ: r.Out,
					Elastic: a.Out,
					Back: n.Out,
					Bounce: s.Out,
					Stepped: p,
					"Quad.easeIn": l.In,
					"Cubic.easeIn": o.In,
					"Quart.easeIn": c.In,
					"Quint.easeIn": d.In,
					"Sine.easeIn": f.In,
					"Expo.easeIn": h.In,
					"Circ.easeIn": r.In,
					"Elastic.easeIn": a.In,
					"Back.easeIn": n.In,
					"Bounce.easeIn": s.In,
					"Quad.easeOut": l.Out,
					"Cubic.easeOut": o.Out,
					"Quart.easeOut": c.Out,
					"Quint.easeOut": d.Out,
					"Sine.easeOut": f.Out,
					"Expo.easeOut": h.Out,
					"Circ.easeOut": r.Out,
					"Elastic.easeOut": a.Out,
					"Back.easeOut": n.Out,
					"Bounce.easeOut": s.Out,
					"Quad.easeInOut": l.InOut,
					"Cubic.easeInOut": o.InOut,
					"Quart.easeInOut": c.InOut,
					"Quint.easeInOut": d.InOut,
					"Sine.easeInOut": f.InOut,
					"Expo.easeInOut": h.InOut,
					"Circ.easeInOut": r.InOut,
					"Elastic.easeInOut": a.InOut,
					"Back.easeInOut": n.InOut,
					"Bounce.easeInOut": s.InOut
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return (e - t) * i + t
				}
			}, function(t, e, i) {
				(function(e) {
					var i = {
						android: !1,
						chromeOS: !1,
						cordova: !1,
						crosswalk: !1,
						desktop: !1,
						ejecta: !1,
						electron: !1,
						iOS: !1,
						iOSVersion: 0,
						iPad: !1,
						iPhone: !1,
						kindle: !1,
						linux: !1,
						macOS: !1,
						node: !1,
						nodeWebkit: !1,
						pixelRatio: 1,
						webApp: !1,
						windows: !1,
						windowsPhone: !1
					};
					t.exports = function() {
						var t = navigator.userAgent;
						/Windows/.test(t) ? i.windows = !0 : /Mac OS/.test(t) && !/like Mac OS/.test(t) ? i.macOS = !0 : /Android/.test(t) ? i.android = !0 : /Linux/.test(t) ? i.linux = !0 : /iP[ao]d|iPhone/i.test(t) ? (i.iOS = !0, navigator.appVersion.match(/OS (\d+)/), i.iOSVersion = parseInt(RegExp.$1, 10), i.iPhone = -1 !== t.toLowerCase().indexOf("iphone"), i.iPad = -1 !== t.toLowerCase().indexOf("ipad")) : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? i.kindle = !0 : /CrOS/.test(t) && (i.chromeOS = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (i.android = !1, i.iOS = !1, i.macOS = !1, i.windows = !0, i.windowsPhone = !0);
						var n = /Silk/.test(t);
						return (i.windows || i.macOS || i.linux && !n || i.chromeOS) && (i.desktop = !0), (i.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (i.desktop = !1), navigator.standalone && (i.webApp = !0), void 0 !== window.cordova && (i.cordova = !0), void 0 !== e && e.versions && e.versions.node && (i.node = !0), i.node && "object" == typeof e.versions && (i.nodeWebkit = !!e.versions["node-webkit"], i.electron = !!e.versions.electron), void 0 !== window.ejecta && (i.ejecta = !0), /Crosswalk/.test(t) && (i.crosswalk = !0), i.pixelRatio = window.devicePixelRatio || 1, i
					}()
				}).call(this, i(729))
			}, function(t, e, i) {
				var n, s = i(117),
					r = {
						chrome: !1,
						chromeVersion: 0,
						edge: !1,
						firefox: !1,
						firefoxVersion: 0,
						ie: !1,
						ieVersion: 0,
						mobileSafari: !1,
						opera: !1,
						safari: !1,
						safariVersion: 0,
						silk: !1,
						trident: !1,
						tridentVersion: 0
					};
				t.exports = (n = navigator.userAgent, /Edge\/\d+/.test(n) ? r.edge = !0 : /Chrome\/(\d+)/.test(n) && !s.windowsPhone ? (r.chrome = !0, r.chromeVersion = parseInt(RegExp.$1, 10)) : /Firefox\D+(\d+)/.test(n) ? (r.firefox = !0, r.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(n) && s.iOS ? r.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(n) ? (r.ie = !0, r.ieVersion = parseInt(RegExp.$1, 10)) : /Opera/.test(n) ? r.opera = !0 : /Safari/.test(n) && !s.windowsPhone ? r.safari = !0 : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(n) && (r.ie = !0, r.trident = !0, r.tridentVersion = parseInt(RegExp.$1, 10), r.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(n) && (r.silk = !0), r)
			}, function(t, e) {
				t.exports = function(t, e) {
					return Math.random() * (e - t) + t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return 0 < t && 0 == (t & t - 1) && 0 < e && 0 == (e & e - 1)
				}
			}, function(t, e, i) {
				t.exports = {
					ADD: i(781),
					ERROR: i(782),
					LOAD: i(783),
					READY: i(784),
					REMOVE: i(785)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i;
					if (e) "string" == typeof e ? i = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (i = e);
					else if (t.parentElement || null === e) return t;
					return (i = i || document.body).appendChild(t), t
				}
			}, function(t, e, i) {
				var n = i(80);
				t.exports = function(t, e, i, s) {
					if (void 0 === s && (s = t), !Array.isArray(e)) return -1 !== (o = t.indexOf(e)) ? (n(t, o), i && i.call(s, e), e) : null;
					for (var r = e.length - 1; 0 <= r;) {
						var o, a = e[r]; - 1 !== (o = t.indexOf(a)) ? (n(t, o), i && i.call(s, a)) : e.pop(), r--
					}
					return e
				}
			}, function(t, e) {
				t.exports = {
					BACKSPACE: 8,
					TAB: 9,
					ENTER: 13,
					SHIFT: 16,
					CTRL: 17,
					ALT: 18,
					PAUSE: 19,
					CAPS_LOCK: 20,
					ESC: 27,
					SPACE: 32,
					PAGE_UP: 33,
					PAGE_DOWN: 34,
					END: 35,
					HOME: 36,
					LEFT: 37,
					UP: 38,
					RIGHT: 39,
					DOWN: 40,
					PRINT_SCREEN: 42,
					INSERT: 45,
					DELETE: 46,
					ZERO: 48,
					ONE: 49,
					TWO: 50,
					THREE: 51,
					FOUR: 52,
					FIVE: 53,
					SIX: 54,
					SEVEN: 55,
					EIGHT: 56,
					NINE: 57,
					NUMPAD_ZERO: 96,
					NUMPAD_ONE: 97,
					NUMPAD_TWO: 98,
					NUMPAD_THREE: 99,
					NUMPAD_FOUR: 100,
					NUMPAD_FIVE: 101,
					NUMPAD_SIX: 102,
					NUMPAD_SEVEN: 103,
					NUMPAD_EIGHT: 104,
					NUMPAD_NINE: 105,
					NUMPAD_ADD: 107,
					NUMPAD_SUBTRACT: 109,
					A: 65,
					B: 66,
					C: 67,
					D: 68,
					E: 69,
					F: 70,
					G: 71,
					H: 72,
					I: 73,
					J: 74,
					K: 75,
					L: 76,
					M: 77,
					N: 78,
					O: 79,
					P: 80,
					Q: 81,
					R: 82,
					S: 83,
					T: 84,
					U: 85,
					V: 86,
					W: 87,
					X: 88,
					Y: 89,
					Z: 90,
					F1: 112,
					F2: 113,
					F3: 114,
					F4: 115,
					F5: 116,
					F6: 117,
					F7: 118,
					F8: 119,
					F9: 120,
					F10: 121,
					F11: 122,
					F12: 123,
					SEMICOLON: 186,
					PLUS: 187,
					COMMA: 188,
					MINUS: 189,
					PERIOD: 190,
					FORWARD_SLASH: 191,
					BACK_SLASH: 220,
					QUOTES: 222,
					BACKTICK: 192,
					OPEN_BRACKET: 219,
					CLOSED_BRACKET: 221,
					SEMICOLON_FIREFOX: 59,
					COLON: 58,
					COMMA_FIREFOX_WINDOWS: 60,
					COMMA_FIREFOX: 62,
					BRACKET_RIGHT_FIREFOX: 174,
					BRACKET_LEFT_FIREFOX: 175
				}
			}, function(t, e) {
				t.exports = {
					PENDING: 0,
					INIT: 1,
					START: 2,
					LOADING: 3,
					CREATING: 4,
					RUNNING: 5,
					PAUSED: 6,
					SLEEPING: 7,
					SHUTDOWN: 8,
					DESTROYED: 9
				}
			}, function(t, e, i) {
				var n = i(67);
				t.exports = function(t, e) {
					var i = n(t);
					for (var s in e) i.hasOwnProperty(s) || (i[s] = e[s]);
					return i
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(67),
					r = i(10),
					o = i(59),
					a = i(20),
					h = i(1),
					u = i(382),
					l = i(383),
					c = new n({
						Extends: r,
						initialize: function(t) {
							r.call(this), this.game = t, this.jsonCache = t.cache.json, this.sounds = [], this.mute = !1, this.volume = 1, this.pauseOnBlur = !0, this._rate = 1, this._detune = 0, this.locked = this.locked || !1, this.unlocked = !1, t.events.on(a.BLUR, this.onGameBlur, this), t.events.on(a.FOCUS, this.onGameFocus, this), t.events.on(a.PRE_STEP, this.update, this), t.events.once(a.DESTROY, this.destroy, this)
						},
						add: h,
						addAudioSprite: function(t, e) {
							void 0 === e && (e = {});
							var i, n, r = this.add(t, e);
							for (var o in r.spritemap = this.jsonCache.get(t).spritemap, r.spritemap) r.spritemap.hasOwnProperty(o) && (i = s(e), n = r.spritemap[o], i.loop = !!n.hasOwnProperty("loop") && n.loop, r.addMarker({
								name: o,
								start: n.start,
								duration: n.end - n.start,
								config: i
							}));
							return r
						},
						get: function(t) {
							return l(this.sounds, "key", t)
						},
						getAll: function(t) {
							return u(this.sounds, "key", t)
						},
						play: function(t, e) {
							var i = this.add(t);
							return i.once(o.COMPLETE, i.destroy, i), e ? e.name ? (i.addMarker(e), i.play(e.name)) : i.play(e) : i.play()
						},
						playAudioSprite: function(t, e, i) {
							var n = this.addAudioSprite(t);
							return n.once(o.COMPLETE, n.destroy, n), n.play(e, i)
						},
						remove: function(t) {
							var e = this.sounds.indexOf(t);
							return -1 !== e && (t.destroy(), this.sounds.splice(e, 1), !0)
						},
						removeAll: function() {
							this.sounds.forEach(function(t) {
								t.destroy()
							}), this.sounds.length = 0
						},
						removeByKey: function(t) {
							for (var e = 0, i = this.sounds.length - 1; 0 <= i; i--) {
								var n = this.sounds[i];
								n.key === t && (n.destroy(), this.sounds.splice(i, 1), e++)
							}
							return e
						},
						pauseAll: function() {
							this.forEachActiveSound(function(t) {
								t.pause()
							}), this.emit(o.PAUSE_ALL, this)
						},
						resumeAll: function() {
							this.forEachActiveSound(function(t) {
								t.resume()
							}), this.emit(o.RESUME_ALL, this)
						},
						stopAll: function() {
							this.forEachActiveSound(function(t) {
								t.stop()
							}), this.emit(o.STOP_ALL, this)
						},
						stopByKey: function(t) {
							var e = 0;
							return this.getAll(t).forEach(function(t) {
								t.stop() && e++
							}), e
						},
						unlock: h,
						onBlur: h,
						onFocus: h,
						onGameBlur: function() {
							this.pauseOnBlur && this.onBlur()
						},
						onGameFocus: function() {
							this.pauseOnBlur && this.onFocus()
						},
						update: function(t, e) {
							this.unlocked && (this.unlocked = !1, this.locked = !1, this.emit(o.UNLOCKED, this));
							for (var i = this.sounds.length - 1; 0 <= i; i--) this.sounds[i].pendingRemove && this.sounds.splice(i, 1);
							this.sounds.forEach(function(i) {
								i.update(t, e)
							})
						},
						destroy: function() {
							this.game.events.off(a.BLUR, this.onGameBlur, this), this.game.events.off(a.FOCUS, this.onGameFocus, this), this.game.events.off(a.PRE_STEP, this.update, this), this.removeAllListeners(), this.removeAll(), this.sounds.length = 0, this.sounds = null, this.game = null
						},
						forEachActiveSound: function(t, e) {
							var i = this;
							this.sounds.forEach(function(n, s) {
								n && !n.pendingRemove && t.call(e || i, n, s, i.sounds)
							})
						},
						setRate: function(t) {
							return this.rate = t, this
						},
						rate: {
							get: function() {
								return this._rate
							},
							set: function(t) {
								this._rate = t, this.forEachActiveSound(function(t) {
									t.calculateRate()
								}), this.emit(o.GLOBAL_RATE, this, t)
							}
						},
						setDetune: function(t) {
							return this.detune = t, this
						},
						detune: {
							get: function() {
								return this._detune
							},
							set: function(t) {
								this._detune = t, this.forEachActiveSound(function(t) {
									t.calculateRate()
								}), this.emit(o.GLOBAL_DETUNE, this, t)
							}
						}
					});
				t.exports = c
			}, function(t, e, i) {
				var n = i(0),
					s = i(10),
					r = i(59),
					o = i(18),
					a = i(1),
					h = new n({
						Extends: s,
						initialize: function(t, e, i) {
							s.call(this), this.manager = t, this.key = e, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = this.duration || 0, this.totalDuration = this.totalDuration || 0, this.config = {
								mute: !1,
								volume: 1,
								rate: 1,
								detune: 0,
								seek: 0,
								loop: !1,
								delay: 0
							}, this.currentConfig = this.config, this.config = o(this.config, i), this.markers = {}, this.currentMarker = null, this.pendingRemove = !1
						},
						addMarker: function(t) {
							return !(!t || !t.name || "string" != typeof t.name || (this.markers[t.name] ? (console.error("addMarker " + t.name + " already exists in Sound"), 1) : (t = o(!0, {
								name: "",
								start: 0,
								duration: this.totalDuration - (t.start || 0),
								config: {
									mute: !1,
									volume: 1,
									rate: 1,
									detune: 0,
									seek: 0,
									loop: !1,
									delay: 0
								}
							}, t), this.markers[t.name] = t, 0)))
						},
						updateMarker: function(t) {
							return !(!t || !t.name || "string" != typeof t.name || (this.markers[t.name] ? (this.markers[t.name] = o(!0, this.markers[t.name], t), 0) : (console.warn("Audio Marker: " + t.name + " missing in Sound: " + this.key), 1)))
						},
						removeMarker: function(t) {
							var e = this.markers[t];
							return e ? (this.markers[t] = null, e) : null
						},
						play: function(t, e) {
							if (void 0 === t && (t = ""), "object" == typeof t && (e = t, t = ""), "string" != typeof t) return !1;
							if (t) {
								if (!this.markers[t]) return console.warn("Marker: " + t + " missing in Sound: " + this.key), !1;
								this.currentMarker = this.markers[t], this.currentConfig = this.currentMarker.config, this.duration = this.currentMarker.duration
							} else this.currentMarker = null, this.currentConfig = this.config, this.duration = this.totalDuration;
							return this.resetConfig(), this.currentConfig = o(this.currentConfig, e), this.isPlaying = !0, !(this.isPaused = !1)
						},
						pause: function() {
							return !(this.isPaused || !this.isPlaying) && (this.isPlaying = !1, this.isPaused = !0)
						},
						resume: function() {
							return !(!this.isPaused || this.isPlaying || (this.isPlaying = !0, this.isPaused = !1))
						},
						stop: function() {
							return !(!this.isPaused && !this.isPlaying || (this.isPlaying = !1, this.isPaused = !1, this.resetConfig(), 0))
						},
						applyConfig: function() {
							this.mute = this.currentConfig.mute, this.volume = this.currentConfig.volume, this.rate = this.currentConfig.rate, this.detune = this.currentConfig.detune, this.loop = this.currentConfig.loop
						},
						resetConfig: function() {
							this.currentConfig.seek = 0, this.currentConfig.delay = 0
						},
						update: a,
						calculateRate: function() {
							var t = this.currentConfig.detune + this.manager.detune,
								e = Math.pow(1.0005777895065548, t);
							this.totalRate = this.currentConfig.rate * this.manager.rate * e
						},
						destroy: function() {
							this.pendingRemove || (this.emit(r.DESTROY, this), this.pendingRemove = !0, this.manager = null, this.key = "", this.removeAllListeners(), this.isPlaying = !1, this.isPaused = !1, this.config = null, this.currentConfig = null, this.markers = null, this.currentMarker = null)
						}
					});
				t.exports = h
			}, function(t, e, i) {
				var n = i(183),
					s = i(0),
					r = i(1),
					o = i(131),
					a = new s({
						initialize: function(t) {
							this.parent = t, this.list = [], this.position = 0, this.addCallback = r, this.removeCallback = r, this._sortKey = ""
						},
						add: function(t, e) {
							return e ? n.Add(this.list, t) : n.Add(this.list, t, 0, this.addCallback, this)
						},
						addAt: function(t, e, i) {
							return i ? n.AddAt(this.list, t, e) : n.AddAt(this.list, t, e, 0, this.addCallback, this)
						},
						getAt: function(t) {
							return this.list[t]
						},
						getIndex: function(t) {
							return this.list.indexOf(t)
						},
						sort: function(t, e) {
							return t && (void 0 === e && (e = function(e, i) {
								return e[t] - i[t]
							}), o.inplace(this.list, e)), this
						},
						getByName: function(t) {
							return n.GetFirst(this.list, "name", t)
						},
						getRandom: function(t, e) {
							return n.GetRandom(this.list, t, e)
						},
						getFirst: function(t, e, i, s) {
							return n.GetFirst(this.list, t, e, i, s)
						},
						getAll: function(t, e, i, s) {
							return n.GetAll(this.list, t, e, i, s)
						},
						count: function(t, e) {
							return n.CountAllMatching(this.list, t, e)
						},
						swap: function(t, e) {
							n.Swap(this.list, t, e)
						},
						moveTo: function(t, e) {
							return n.MoveTo(this.list, t, e)
						},
						remove: function(t, e) {
							return e ? n.Remove(this.list, t) : n.Remove(this.list, t, this.removeCallback, this)
						},
						removeAt: function(t, e) {
							return e ? n.RemoveAt(this.list, t) : n.RemoveAt(this.list, t, this.removeCallback, this)
						},
						removeBetween: function(t, e, i) {
							return i ? n.RemoveBetween(this.list, t, e) : n.RemoveBetween(this.list, t, e, this.removeCallback, this)
						},
						removeAll: function(t) {
							for (var e = this.list.length; e--;) this.remove(this.list[e], t);
							return this
						},
						bringToTop: function(t) {
							return n.BringToTop(this.list, t)
						},
						sendToBack: function(t) {
							return n.SendToBack(this.list, t)
						},
						moveUp: function(t) {
							return n.MoveUp(this.list, t), t
						},
						moveDown: function(t) {
							return n.MoveDown(this.list, t), t
						},
						reverse: function() {
							return this.list.reverse(), this
						},
						shuffle: function() {
							return n.Shuffle(this.list), this
						},
						replace: function(t, e) {
							return n.Replace(this.list, t, e)
						},
						exists: function(t) {
							return -1 < this.list.indexOf(t)
						},
						setAll: function(t, e, i, s) {
							return n.SetAll(this.list, t, e, i, s), this
						},
						each: function(t, e) {
							for (var i = [null], n = 2; n < arguments.length; n++) i.push(arguments[n]);
							for (n = 0; n < this.list.length; n++) i[0] = this.list[n], t.apply(e, i)
						},
						shutdown: function() {
							this.removeAll(), this.list = []
						},
						destroy: function() {
							this.removeAll(), this.parent = null, this.addCallback = null, this.removeCallback = null
						},
						length: {
							get: function() {
								return this.list.length
							}
						},
						first: {
							get: function() {
								return (this.position = 0) < this.list.length ? this.list[0] : null
							}
						},
						last: {
							get: function() {
								return 0 < this.list.length ? (this.position = this.list.length - 1, this.list[this.position]) : null
							}
						},
						next: {
							get: function() {
								return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
							}
						},
						previous: {
							get: function() {
								return 0 < this.position ? (this.position--, this.list[this.position]) : null
							}
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(184),
					s = i(390);
				t.exports = function(t, e) {
					if (void 0 === e && (e = 90), !n(t)) return null;
					if ("string" != typeof e && (e = (e % 360 + 360) % 360), 90 === e || -270 === e || "rotateLeft" === e)(t = s(t)).reverse();
					else if (-90 === e || 270 === e || "rotateRight" === e) t.reverse(), t = s(t);
					else if (180 === Math.abs(e) || "rotate180" === e) {
						for (var i = 0; i < t.length; i++) t[i].reverse();
						t.reverse()
					}
					return t
				}
			}, function(t, e, i) {
				! function() {
					function e(t, e) {
						return i(t.slice(), e)
					}

					function i(t, e) {
						"function" != typeof e && (e = function(t, e) {
							return String(t).localeCompare(e)
						});
						var i = t.length;
						if (i <= 1) return t;
						for (var s = new Array(i), r = 1; r < i; r *= 2) {
							n(t, e, r, s);
							var o = t;
							t = s, s = o
						}
						return t
					}
					e.inplace = function(t, e) {
						var s = i(t, e);
						return s !== t && n(s, null, t.length, t), t
					};
					var n = function(t, e, i, n) {
						for (var s, r, o, a, h = t.length, u = 0, l = 2 * i, c = 0; c < h; c += l)
							for (r = (s = c + i) + i, h < s && (s = h), h < r && (r = h), o = c, a = s;;)
								if (o < s && a < r) e(t[o], t[a]) <= 0 ? n[u++] = t[o++] : n[u++] = t[a++];
								else if (o < s) n[u++] = t[o++];
						else {
							if (!(a < r)) break;
							n[u++] = t[a++]
						}
					};
					t.exports = e
				}()
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(14),
					o = i(945),
					a = i(946),
					h = i(187),
					u = i(947),
					l = new n({
						Extends: r,
						Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Texture, s.Tint, s.Transform, s.Visible, u],
						initialize: function(t, e, i, n, s, a, h) {
							void 0 === s && (s = ""), void 0 === h && (h = 0), r.call(this, t, "BitmapText"), this.font = n;
							var u = this.scene.sys.cache.bitmapFont.get(n);
							this.fontData = u.data, this._text = "", this._fontSize = a || this.fontData.size, this._letterSpacing = 0, this._align = h, this._bounds = o(), this._dirty = !0, this._maxWidth = 0, this.wordWrapCharCode = 32, this.setTexture(u.texture, u.frame), this.setPosition(e, i), this.setOrigin(0, 0), this.initPipeline(), this.setText(s)
						},
						setLeftAlign: function() {
							return this._align = l.ALIGN_LEFT, this._dirty = !0, this
						},
						setCenterAlign: function() {
							return this._align = l.ALIGN_CENTER, this._dirty = !0, this
						},
						setRightAlign: function() {
							return this._align = l.ALIGN_RIGHT, this._dirty = !0, this
						},
						setFontSize: function(t) {
							return this._fontSize = t, this._dirty = !0, this
						},
						setLetterSpacing: function(t) {
							return void 0 === t && (t = 0), this._letterSpacing = t, this._dirty = !0, this
						},
						setText: function(t) {
							return t || 0 === t || (t = ""), Array.isArray(t) && (t = t.join("\n")), t !== this.text && (this._text = t.toString(), this._dirty = !0, this.updateDisplayOrigin()), this
						},
						getTextBounds: function(t) {
							var e = this._bounds;
							return !this._dirty && this.scaleX === e.scaleX && this.scaleY === e.scaleY || (o(this, t, e), this._dirty = !1, this.updateDisplayOrigin()), e
						},
						updateDisplayOrigin: function() {
							return this._displayOriginX = this.originX * this.width, this._displayOriginY = this.originY * this.height, this._dirty = !0, this
						},
						setFont: function(t, e, i) {
							var n;
							return void 0 === e && (e = this._fontSize), void 0 === i && (i = this._align), t === this.font || (n = this.scene.sys.cache.bitmapFont.get(t)) && (this.font = t, this.fontData = n.data, this._fontSize = e, this._align = i, this.setTexture(n.texture, n.frame), o(this, !1, this._bounds)), this
						},
						setMaxWidth: function(t, e) {
							return this._maxWidth = t, this._dirty = !0, void 0 !== e && (this.wordWrapCharCode = e), this
						},
						align: {
							set: function(t) {
								this._align = t, this._dirty = !0
							},
							get: function() {
								return this._align
							}
						},
						text: {
							set: function(t) {
								this.setText(t)
							},
							get: function() {
								return this._text
							}
						},
						fontSize: {
							set: function(t) {
								this._fontSize = t, this._dirty = !0
							},
							get: function() {
								return this._fontSize
							}
						},
						letterSpacing: {
							set: function(t) {
								this._letterSpacing = t, this._dirty = !0
							},
							get: function() {
								return this._letterSpacing
							}
						},
						maxWidth: {
							set: function(t) {
								this._maxWidth = t, this._dirty = !0
							},
							get: function() {
								return this._maxWidth
							}
						},
						width: {
							get: function() {
								return this.getTextBounds(!1), this._bounds.global.width
							}
						},
						height: {
							get: function() {
								return this.getTextBounds(!1), this._bounds.global.height
							}
						},
						toJSON: function() {
							var t = s.ToJSON(this),
								e = {
									font: this.font,
									text: this.text,
									fontSize: this.fontSize,
									letterSpacing: this.letterSpacing,
									align: this.align
								};
							return t.data = e, t
						}
					});
				l.ALIGN_LEFT = 0, l.ALIGN_CENTER = 1, l.ALIGN_RIGHT = 2, l.ParseFromAtlas = a, l.ParseXMLBitmapFont = h, t.exports = l
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t) {
						if (this.entries = [], Array.isArray(t))
							for (var e = 0; e < t.length; e++) this.set(t[e])
					},
					set: function(t) {
						return -1 === this.entries.indexOf(t) && this.entries.push(t), this
					},
					get: function(t, e) {
						for (var i = 0; i < this.entries.length; i++) {
							var n = this.entries[i];
							if (n[t] === e) return n
						}
					},
					getArray: function() {
						return this.entries.slice(0)
					},
					delete: function(t) {
						var e = this.entries.indexOf(t);
						return -1 < e && this.entries.splice(e, 1), this
					},
					dump: function() {
						console.group("Set");
						for (var t = 0; t < this.entries.length; t++) {
							var e = this.entries[t];
							console.log(e)
						}
						console.groupEnd()
					},
					each: function(t, e) {
						var i, n = this.entries.slice(),
							s = n.length;
						if (e)
							for (i = 0; i < s && !1 !== t.call(e, n[i], i); i++);
						else
							for (i = 0; i < s && !1 !== t(n[i], i); i++);
						return this
					},
					iterate: function(t, e) {
						var i, n = this.entries.length;
						if (e)
							for (i = 0; i < n && !1 !== t.call(e, this.entries[i], i); i++);
						else
							for (i = 0; i < n && !1 !== t(this.entries[i], i); i++);
						return this
					},
					iterateLocal: function(t) {
						for (var e = [], i = 1; i < arguments.length; i++) e.push(arguments[i]);
						var n = this.entries.length;
						for (i = 0; i < n; i++) {
							var s = this.entries[i];
							s[t].apply(s, e)
						}
						return this
					},
					clear: function() {
						return this.entries.length = 0, this
					},
					contains: function(t) {
						return -1 < this.entries.indexOf(t)
					},
					union: function(t) {
						var e = new n;
						return t.entries.forEach(function(t) {
							e.set(t)
						}), this.entries.forEach(function(t) {
							e.set(t)
						}), e
					},
					intersect: function(t) {
						var e = new n;
						return this.entries.forEach(function(i) {
							t.contains(i) && e.set(i)
						}), e
					},
					difference: function(t) {
						var e = new n;
						return this.entries.forEach(function(i) {
							t.contains(i) || e.set(i)
						}), e
					},
					size: {
						get: function() {
							return this.entries.length
						},
						set: function(t) {
							return t < this.entries.length ? this.entries.length = t : this.entries.length
						}
					}
				});
				t.exports = n
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(14),
					o = i(1077),
					a = i(1),
					h = new n({
						Extends: r,
						Mixins: [s.BlendMode, s.Depth, s.Mask, s.Pipeline, s.Size, s.Texture, s.Transform, s.Visible, s.ScrollFactor, o],
						initialize: function(t, e, i, n, s, o, a, h, u) {
							if (r.call(this, t, "Mesh"), n.length !== s.length) throw new Error("Mesh Vertex count must match UV count");
							var l, c = n.length / 2 | 0;
							if (0 < o.length && o.length < c) throw new Error("Mesh Color count must match Vertex count");
							if (0 < a.length && a.length < c) throw new Error("Mesh Alpha count must match Vertex count");
							if (0 === o.length)
								for (l = 0; l < c; ++l) o[l] = 16777215;
							if (0 === a.length)
								for (l = 0; l < c; ++l) a[l] = 1;
							this.vertices = new Float32Array(n), this.uv = new Float32Array(s), this.colors = new Uint32Array(o), this.alphas = new Float32Array(a), this.tintFill = !1, this.setTexture(h, u), this.setPosition(e, i), this.setSizeToFrame(), this.initPipeline()
						},
						setAlpha: a
					});
				t.exports = h
			}, function(t, e) {
				t.exports = function(t, e) {
					return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0 || t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
				}
			}, function(t, e, i) {
				var n = i(6),
					s = {},
					r = {
						register: function(t, e, i, n, r) {
							s[t] = {
								plugin: e,
								mapping: i,
								settingsKey: n,
								configKey: r
							}
						},
						getPlugin: function(t) {
							return s[t]
						},
						install: function(t) {
							var e = t.scene.sys,
								i = e.settings.input,
								r = e.game.config;
							for (var o in s) {
								var a = s[o].plugin,
									h = s[o].mapping,
									u = s[o].settingsKey,
									l = s[o].configKey;
								n(i, u, r[l]) && (t[h] = new a(t))
							}
						},
						remove: function(t) {
							s.hasOwnProperty(t) && delete s[t]
						}
					};
				t.exports = r
			}, function(t, e, i) {
				t.exports = {
					ANY_KEY_DOWN: i(1217),
					ANY_KEY_UP: i(1218),
					COMBO_MATCH: i(1219),
					DOWN: i(1220),
					KEY_DOWN: i(1221),
					KEY_UP: i(1222),
					UP: i(1223)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return !!t.url && (t.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t.url : e + t.url)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s, r) {
					return void 0 === t && (t = ""), void 0 === e && (e = !0), void 0 === i && (i = ""), void 0 === n && (n = ""), void 0 === s && (s = 0), void 0 === r && (r = !1), {
						responseType: t,
						async: e,
						user: i,
						password: n,
						timeout: s,
						headers: void 0,
						header: void 0,
						headerValue: void 0,
						requestedWith: !1,
						overrideMimeType: void 0,
						withCredentials: r
					}
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(217),
					r = i(75),
					o = new n({
						Extends: r,
						Mixins: [s.Acceleration, s.Angular, s.Bounce, s.Debug, s.Drag, s.Enable, s.Friction, s.Gravity, s.Immovable, s.Mass, s.Size, s.Velocity],
						initialize: function(t, e, i, n, s) {
							r.call(this, t, e, i, n, s), this.body = null
						}
					});
				t.exports = o
			}, function(t, e, i) {
				t.exports = {
					CalculateFacesAt: i(220),
					CalculateFacesWithin: i(51),
					Copy: i(1313),
					CreateFromTiles: i(1314),
					CullTiles: i(1315),
					Fill: i(1316),
					FilterTiles: i(1317),
					FindByIndex: i(1318),
					FindTile: i(1319),
					ForEachTile: i(1320),
					GetTileAt: i(142),
					GetTileAtWorldXY: i(1321),
					GetTilesWithin: i(24),
					GetTilesWithinShape: i(1322),
					GetTilesWithinWorldXY: i(1323),
					HasTileAt: i(476),
					HasTileAtWorldXY: i(1324),
					IsInLayerBounds: i(101),
					PutTileAt: i(221),
					PutTileAtWorldXY: i(1325),
					PutTilesAt: i(1326),
					Randomize: i(1327),
					RemoveTileAt: i(477),
					RemoveTileAtWorldXY: i(1328),
					RenderDebug: i(1329),
					ReplaceByIndex: i(475),
					SetCollision: i(1330),
					SetCollisionBetween: i(1331),
					SetCollisionByExclusion: i(1332),
					SetCollisionByProperty: i(1333),
					SetCollisionFromCollisionGroup: i(1334),
					SetTileIndexCallback: i(1335),
					SetTileLocationCallback: i(1336),
					Shuffle: i(1337),
					SwapByIndex: i(1338),
					TileToWorldX: i(143),
					TileToWorldXY: i(1339),
					TileToWorldY: i(144),
					WeightedRandomize: i(1340),
					WorldToTileX: i(63),
					WorldToTileXY: i(1341),
					WorldToTileY: i(64)
				}
			}, function(t, e, i) {
				var n = i(101);
				t.exports = function(t, e, i, s) {
					if (void 0 === i && (i = !1), n(t, e, s)) {
						var r = s.data[e][t] || null;
						return null === r || -1 === r.index && !i ? null : r
					}
					return null
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					var n = i.baseTileWidth,
						s = i.tilemapLayer,
						r = 0;
					return s && (void 0 === e && (e = s.scene.cameras.main), r = s.x + e.scrollX * (1 - s.scrollFactorX), n *= s.scaleX), r + t * n
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					var n = i.baseTileHeight,
						s = i.tilemapLayer,
						r = 0;
					return s && (void 0 === e && (e = s.scene.cameras.main), r = s.y + e.scrollY * (1 - s.scrollFactorY), n *= s.scaleY), r + t * n
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return t.hasOwnProperty(e) ? "function" == typeof t[e] ? function(i, n, s, r, o, a) {
						return t[e](i, n, s, r, o, a)
					} : function() {
						return t[e]
					} : "function" == typeof i ? i : function() {
						return i
					}
				}
			}, function(t, e, i) {
				var n = i(230),
					s = i(15),
					r = i(88),
					o = i(69),
					a = i(145),
					h = i(498),
					u = i(228),
					l = i(6),
					c = i(229),
					d = i(231),
					f = i(233);
				t.exports = function(t, e, i) {
					void 0 === i && (i = n);
					for (var p = i.targets ? i.targets : u(e), g = h(e), v = a(e, "delay", i.delay), m = a(e, "duration", i.duration), y = l(e, "easeParams", i.easeParams), x = o(l(e, "ease", i.ease), y), T = a(e, "hold", i.hold), w = a(e, "repeat", i.repeat), E = a(e, "repeatDelay", i.repeatDelay), _ = r(e, "yoyo", i.yoyo), b = r(e, "flipX", i.flipX), A = r(e, "flipY", i.flipY), S = [], C = 0; C < g.length; C++)
						for (var M = g[C].key, O = g[C].value, P = 0; P < p.length; P++) {
							var R = c(M, O),
								L = f(p[P], P, M, R.getEnd, R.getStart, R.getActive, o(l(O, "ease", x), y), a(O, "delay", v), a(O, "duration", m), r(O, "yoyo", _), a(O, "hold", T), a(O, "repeat", w), a(O, "repeatDelay", E), r(O, "flipX", b), r(O, "flipY", A));
							S.push(L)
						}
					var D = new d(t, S, p);
					D.offset = s(e, "offset", null), D.completeDelay = s(e, "completeDelay", 0), D.loop = Math.round(s(e, "loop", 0)), D.loopDelay = Math.round(s(e, "loopDelay", 0)), D.paused = r(e, "paused", !1), D.useFrames = r(e, "useFrames", !1);
					for (var F = l(e, "callbackScope", D), k = [D, null], I = d.TYPES, B = 0; B < I.length; B++) {
						var Y, N, X = I[B],
							U = l(e, X, !1);
						U && (Y = l(e, X + "Scope", F), N = l(e, X + "Params", []), D.setCallback(X, U, k.concat(N), Y))
					}
					return D
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(9),
					r = new n({
						initialize: function(t) {
							this.name = "WebGLPipeline", this.game = t.game, this.view = t.game.canvas, this.resolution = 1, this.width = 0, this.height = 0, this.gl = t.gl, this.vertexCount = 0, this.vertexCapacity = t.vertexCapacity, this.renderer = t.renderer, this.vertexData = t.vertices ? t.vertices : new ArrayBuffer(t.vertexCapacity * t.vertexSize), this.vertexBuffer = this.renderer.createVertexBuffer(t.vertices ? t.vertices : this.vertexData.byteLength, this.gl.STREAM_DRAW), this.program = this.renderer.createProgram(t.vertShader, t.fragShader), this.attributes = t.attributes, this.vertexSize = t.vertexSize, this.topology = t.topology, this.bytes = new Uint8Array(this.vertexData), this.vertexComponentCount = s.getComponentCount(t.attributes, this.gl), this.flushLocked = !1, this.active = !1
						},
						boot: function() {},
						addAttribute: function(t, e, i, n, r) {
							return this.attributes.push({
								name: t,
								size: e,
								type: this.renderer.glFormats[i],
								normalized: n,
								offset: r
							}), this.vertexComponentCount = s.getComponentCount(this.attributes, this.gl), this
						},
						shouldFlush: function() {
							return this.vertexCount >= this.vertexCapacity
						},
						resize: function(t, e, i) {
							return this.width = t * i, this.height = e * i, this.resolution = i, this
						},
						bind: function() {
							var t = this.gl,
								e = this.vertexBuffer,
								i = this.attributes,
								n = this.program,
								s = this.renderer,
								r = this.vertexSize;
							s.setProgram(n), s.setVertexBuffer(e);
							for (var o = 0; o < i.length; ++o) {
								var a = i[o],
									h = t.getAttribLocation(n, a.name);
								0 <= h ? (t.enableVertexAttribArray(h), t.vertexAttribPointer(h, a.size, a.type, a.normalized, r, a.offset)) : -1 !== h && t.disableVertexAttribArray(h)
							}
							return this
						},
						onBind: function() {
							return this
						},
						onPreRender: function() {
							return this
						},
						onRender: function() {
							return this
						},
						onPostRender: function() {
							return this
						},
						flush: function() {
							if (this.flushLocked) return this;
							this.flushLocked = !0;
							var t = this.gl,
								e = this.vertexCount,
								i = this.topology,
								n = this.vertexSize;
							if (0 !== e) return t.bufferSubData(t.ARRAY_BUFFER, 0, this.bytes.subarray(0, e * n)), t.drawArrays(i, 0, e), this.vertexCount = 0, this.flushLocked = !1, this;
							this.flushLocked = !1
						},
						destroy: function() {
							var t = this.gl;
							return t.deleteProgram(this.program), t.deleteBuffer(this.vertexBuffer), delete this.program, delete this.vertexBuffer, delete this.gl, this
						},
						setFloat1: function(t, e) {
							return this.renderer.setFloat1(this.program, t, e), this
						},
						setFloat2: function(t, e, i) {
							return this.renderer.setFloat2(this.program, t, e, i), this
						},
						setFloat3: function(t, e, i, n) {
							return this.renderer.setFloat3(this.program, t, e, i, n), this
						},
						setFloat4: function(t, e, i, n, s) {
							return this.renderer.setFloat4(this.program, t, e, i, n, s), this
						},
						setFloat1v: function(t, e) {
							return this.renderer.setFloat1v(this.program, t, e), this
						},
						setFloat2v: function(t, e) {
							return this.renderer.setFloat2v(this.program, t, e), this
						},
						setFloat3v: function(t, e) {
							return this.renderer.setFloat3v(this.program, t, e), this
						},
						setFloat4v: function(t, e) {
							return this.renderer.setFloat4v(this.program, t, e), this
						},
						setInt1: function(t, e) {
							return this.renderer.setInt1(this.program, t, e), this
						},
						setInt2: function(t, e, i) {
							return this.renderer.setInt2(this.program, t, e, i), this
						},
						setInt3: function(t, e, i, n) {
							return this.renderer.setInt3(this.program, t, e, i, n), this
						},
						setInt4: function(t, e, i, n, s) {
							return this.renderer.setInt4(this.program, t, e, i, n, s), this
						},
						setMatrix2: function(t, e, i) {
							return this.renderer.setMatrix2(this.program, t, e, i), this
						},
						setMatrix3: function(t, e, i) {
							return this.renderer.setMatrix3(this.program, t, e, i), this
						},
						setMatrix4: function(t, e, i) {
							return this.renderer.setMatrix4(this.program, t, e, i), this
						}
					});
				t.exports = r
			}, , function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e, i) {
					return void 0 === i && (i = new n), i.x = t.x + t.radius * Math.cos(e), i.y = t.y + t.radius * Math.sin(e), i
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e) {
					void 0 === e && (e = new n);
					var i = 2 * Math.PI * Math.random(),
						s = Math.random() + Math.random(),
						r = 1 < s ? 2 - s : s,
						o = r * Math.cos(i),
						a = r * Math.sin(i);
					return e.x = t.x + o * t.radius, e.y = t.y + a * t.radius, e
				}
			}, function(t, e, i) {
				var n = i(19),
					s = i(0),
					r = i(10),
					o = i(111),
					a = i(270),
					h = i(271),
					u = i(6),
					l = new s({
						Extends: r,
						initialize: function(t, e, i) {
							r.call(this), this.manager = t, this.key = e, this.type = "frame", this.frames = this.getFrames(t.textureManager, u(i, "frames", []), u(i, "defaultTextureKey", null)), this.frameRate = u(i, "frameRate", null), this.duration = u(i, "duration", null), null === this.duration && null === this.frameRate ? (this.frameRate = 24, this.duration = this.frameRate / this.frames.length * 1e3) : this.duration && null === this.frameRate ? this.frameRate = this.frames.length / (this.duration / 1e3) : this.duration = this.frames.length / this.frameRate * 1e3, this.msPerFrame = 1e3 / this.frameRate, this.skipMissedFrames = u(i, "skipMissedFrames", !0), this.delay = u(i, "delay", 0), this.repeat = u(i, "repeat", 0), this.repeatDelay = u(i, "repeatDelay", 0), this.yoyo = u(i, "yoyo", !1), this.showOnStart = u(i, "showOnStart", !1), this.hideOnComplete = u(i, "hideOnComplete", !1), this.paused = !1, this.manager.on(o.PAUSE_ALL, this.pause, this), this.manager.on(o.RESUME_ALL, this.resume, this)
						},
						addFrame: function(t) {
							return this.addFrameAt(this.frames.length, t)
						},
						addFrameAt: function(t, e) {
							var i, n, s = this.getFrames(this.manager.textureManager, e);
							return 0 < s.length && (0 === t ? this.frames = s.concat(this.frames) : t === this.frames.length ? this.frames = this.frames.concat(s) : (i = this.frames.slice(0, t), n = this.frames.slice(t), this.frames = i.concat(s, n)), this.updateFrameSequence()), this
						},
						checkFrame: function(t) {
							return 0 <= t && t < this.frames.length
						},
						completeAnimation: function(t) {
							this.hideOnComplete && (t.parent.visible = !1), t.stop()
						},
						getFirstTick: function(t, e) {
							void 0 === e && (e = !0), t.accumulator = 0, t.nextTick = t.msPerFrame + t.currentFrame.duration, e && (t.nextTick += t._delay)
						},
						getFrameAt: function(t) {
							return this.frames[t]
						},
						getFrames: function(t, e, i) {
							var n, s, r, o = [],
								a = 1;
							if ("string" == typeof e && (s = e, r = t.get(s).getFrameNames(), e = [], r.forEach(function(t, i) {
									e.push({
										key: s,
										frame: i
									})
								})), !Array.isArray(e) || 0 === e.length) return o;
							for (v = 0; v < e.length; v++) {
								var l, c, d, f = e[v],
									p = u(f, "key", i);
								p && (l = u(f, "frame", 0), c = t.getFrame(p, l), (d = new h(p, l, a, c)).duration = u(f, "duration", 0), d.isFirst = !n, n && ((n.nextFrame = d).prevFrame = n), o.push(d), n = d, a++)
							}
							if (0 < o.length) {
								d.isLast = !0, d.nextFrame = o[0], o[0].prevFrame = d;
								for (var g = 1 / (o.length - 1), v = 0; v < o.length; v++) o[v].progress = v * g
							}
							return o
						},
						getNextTick: function(t) {
							t.accumulator -= t.nextTick, t.nextTick = t.msPerFrame + t.currentFrame.duration
						},
						load: function(t, e) {
							e >= this.frames.length && (e = 0), t.currentAnim !== this && (t.currentAnim = this, t.frameRate = this.frameRate, t.duration = this.duration, t.msPerFrame = this.msPerFrame, t.skipMissedFrames = this.skipMissedFrames, t._delay = this.delay, t._repeat = this.repeat, t._repeatDelay = this.repeatDelay, t._yoyo = this.yoyo);
							var i = this.frames[e];
							0 !== e || t.forward || (i = this.getLastFrame()), t.updateFrame(i)
						},
						getFrameByProgress: function(t) {
							return t = n(t, 0, 1), a(t, this.frames, "progress")
						},
						nextFrame: function(t) {
							var e = t.currentFrame;
							e.isLast ? t._yoyo ? this.handleYoyoFrame(t, !1) : 0 < t.repeatCounter ? t._reverse && t.forward ? t.forward = !1 : this.repeatAnimation(t) : this.completeAnimation(t) : this.updateAndGetNextTick(t, e.nextFrame)
						},
						handleYoyoFrame: function(t, e) {
							if (e = e || !1, t._reverse === !e && 0 < t.repeatCounter) return t._repeatDelay && !t.pendingRepeat || (t.forward = e), void this.repeatAnimation(t);
							var i;
							t._reverse === e || 0 !== t.repeatCounter ? (i = (t.forward = e) ? t.currentFrame.nextFrame : t.currentFrame.prevFrame, this.updateAndGetNextTick(t, i)) : this.completeAnimation(t)
						},
						getLastFrame: function() {
							return this.frames[this.frames.length - 1]
						},
						previousFrame: function(t) {
							var e = t.currentFrame;
							e.isFirst ? t._yoyo ? this.handleYoyoFrame(t, !0) : 0 < t.repeatCounter ? (t._reverse && !t.forward ? t.currentFrame = this.getLastFrame() : t.forward = !0, this.repeatAnimation(t)) : this.completeAnimation(t) : this.updateAndGetNextTick(t, e.prevFrame)
						},
						updateAndGetNextTick: function(t, e) {
							t.updateFrame(e), this.getNextTick(t)
						},
						removeFrame: function(t) {
							var e = this.frames.indexOf(t);
							return -1 !== e && this.removeFrameAt(e), this
						},
						removeFrameAt: function(t) {
							return this.frames.splice(t, 1), this.updateFrameSequence(), this
						},
						repeatAnimation: function(t) {
							if (2 === t._pendingStop) return this.completeAnimation(t);
							var e, i;
							0 < t._repeatDelay && !1 === t.pendingRepeat ? (t.pendingRepeat = !0, t.accumulator -= t.nextTick, t.nextTick += t._repeatDelay) : (t.repeatCounter--, t.updateFrame(t.currentFrame[t.forward ? "nextFrame" : "prevFrame"]), t.isPlaying && (this.getNextTick(t), t.pendingRepeat = !1, e = t.currentFrame, i = t.parent, this.emit(o.ANIMATION_REPEAT, this, e), i.emit(o.SPRITE_ANIMATION_KEY_REPEAT + this.key, this, e, t.repeatCounter, i), i.emit(o.SPRITE_ANIMATION_REPEAT, this, e, t.repeatCounter, i)))
						},
						setFrame: function(t) {
							t.forward ? this.nextFrame(t) : this.previousFrame(t)
						},
						toJSON: function() {
							var t = {
								key: this.key,
								type: this.type,
								frames: [],
								frameRate: this.frameRate,
								duration: this.duration,
								skipMissedFrames: this.skipMissedFrames,
								delay: this.delay,
								repeat: this.repeat,
								repeatDelay: this.repeatDelay,
								yoyo: this.yoyo,
								showOnStart: this.showOnStart,
								hideOnComplete: this.hideOnComplete
							};
							return this.frames.forEach(function(e) {
								t.frames.push(e.toJSON())
							}), t
						},
						updateFrameSequence: function() {
							for (var t, e = this.frames.length, i = 1 / (e - 1), n = 0; n < e; n++)(t = this.frames[n]).index = n + 1, t.isFirst = !1, t.isLast = !1, t.progress = n * i, 0 === n ? (t.isFirst = !0, 1 === e ? (t.isLast = !0, (t.nextFrame = t).prevFrame = t) : (t.isLast = !1, t.prevFrame = this.frames[e - 1], t.nextFrame = this.frames[n + 1])) : n === e - 1 && 1 < e ? (t.isLast = !0, t.prevFrame = this.frames[e - 2], t.nextFrame = this.frames[0]) : 1 < e && (t.prevFrame = this.frames[n - 1], t.nextFrame = this.frames[n + 1]);
							return this
						},
						pause: function() {
							return this.paused = !0, this
						},
						resume: function() {
							return this.paused = !1, this
						},
						destroy: function() {
							this.removeAllListeners(), this.manager.off(o.PAUSE_ALL, this.pause, this), this.manager.off(o.RESUME_ALL, this.resume, this), this.manager.remove(this.key);
							for (var t = 0; t < this.frames.length; t++) this.frames[t].destroy();
							this.frames = [], this.manager = null
						}
					});
				t.exports = l
			}, function(t, e, i) {
				var n = i(112),
					s = i(4);
				t.exports = function(t, e, i) {
					if (void 0 === i && (i = new s), e <= 0 || 1 <= e) return i.x = t.x, i.y = t.y, i;
					var r = n(t) * e;
					return .5 < e ? (r -= t.width + t.height) <= t.width ? (i.x = t.right - r, i.y = t.bottom) : (i.x = t.x, i.y = t.bottom - (r - t.width)) : r <= t.width ? (i.x = t.x + r, i.y = t.y) : (i.x = t.right, i.y = t.y + (r - t.width)), i
				}
			}, function(t, e, i) {
				var n = i(57),
					s = i(4);
				t.exports = function(t, e, i, r) {
					void 0 === r && (r = []), !e && 0 < i && (e = n(t) / i);
					for (var o = t.x1, a = t.y1, h = t.x2, u = t.y2, l = 0; l < e; l++) {
						var c = l / e,
							d = o + (h - o) * c,
							f = a + (u - a) * c;
						r.push(new s(d, f))
					}
					return r
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e) {
					void 0 === e && (e = new n);
					var i = Math.random();
					return e.x = t.x1 + i * (t.x2 - t.x1), e.y = t.y1 + i * (t.y2 - t.y1), e
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e) {
					return void 0 === e && (e = new n), e.x = t.x + Math.random() * t.width, e.y = t.y + Math.random() * t.height, e
				}
			}, function(t, e) {
				t.exports = {
					defaultPipeline: null,
					pipeline: null,
					initPipeline: function(t) {
						void 0 === t && (t = "TextureTintPipeline");
						var e = this.scene.sys.game.renderer;
						return !!(e && e.gl && e.hasPipeline(t)) && (this.defaultPipeline = e.getPipeline(t), this.pipeline = this.defaultPipeline, !0)
					},
					setPipeline: function(t) {
						var e = this.scene.sys.game.renderer;
						return e && e.gl && e.hasPipeline(t) && (this.pipeline = e.getPipeline(t)), this
					},
					resetPipeline: function() {
						return this.pipeline = this.defaultPipeline, null !== this.pipeline
					},
					getPipelineName: function() {
						return this.pipeline.name
					}
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e) {
					void 0 === e && (e = new n);
					var i = Math.random() * Math.PI * 2,
						s = Math.sqrt(Math.random());
					return e.x = t.x + s * Math.cos(i) * t.width / 2, e.y = t.y + s * Math.sin(i) * t.height / 2, e
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e) {
					void 0 === e && (e = new n);
					var i = t.x2 - t.x1,
						s = t.y2 - t.y1,
						r = t.x3 - t.x1,
						o = t.y3 - t.y1,
						a = Math.random(),
						h = Math.random();
					return 1 <= a + h && (a = 1 - a, h = 1 - h), e.x = t.x1 + (i * a + r * h), e.y = t.y1 + (s * a + o * h), e
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					var r = n + Math.atan2(t.y - i, t.x - e);
					return t.x = e + s * Math.cos(r), t.y = i + s * Math.sin(r), t
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
				}
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t) {
						if (this.entries = {}, this.size = 0, Array.isArray(t))
							for (var e = 0; e < t.length; e++) this.set(t[e][0], t[e][1])
					},
					set: function(t, e) {
						return this.has(t) || this.size++, this.entries[t] = e, this
					},
					get: function(t) {
						if (this.has(t)) return this.entries[t]
					},
					getArray: function() {
						var t = [],
							e = this.entries;
						for (var i in e) t.push(e[i]);
						return t
					},
					has: function(t) {
						return this.entries.hasOwnProperty(t)
					},
					delete: function(t) {
						return this.has(t) && (delete this.entries[t], this.size--), this
					},
					clear: function() {
						return Object.keys(this.entries).forEach(function(t) {
							delete this.entries[t]
						}, this), this.size = 0, this
					},
					keys: function() {
						return Object.keys(this.entries)
					},
					values: function() {
						var t = [],
							e = this.entries;
						for (var i in e) t.push(e[i]);
						return t
					},
					dump: function() {
						var t = this.entries;
						for (var e in console.group("Map"), t) console.log(e, t[e]);
						console.groupEnd()
					},
					each: function(t) {
						var e = this.entries;
						for (var i in e)
							if (!1 === t(i, e[i])) break;
						return this
					},
					contains: function(t) {
						var e = this.entries;
						for (var i in e)
							if (e[i] === t) return !0;
						return !1
					},
					merge: function(t, e) {
						void 0 === e && (e = !1);
						var i = this.entries,
							n = t.entries;
						for (var s in n) i.hasOwnProperty(s) && e ? i[s] = n[s] : this.set(s, n[s]);
						return this
					}
				});
				t.exports = n
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					var s;
					if (void 0 === e && (e = 0), void 0 === i && (i = " "), void 0 === n && (n = 3), e + 1 >= (t = t.toString()).length) switch (n) {
						case 1:
							t = new Array(e + 1 - t.length).join(i) + t;
							break;
						case 3:
							var r = Math.ceil((s = e - t.length) / 2);
							t = new Array(s - r + 1).join(i) + t + new Array(r + 1).join(i);
							break;
						default:
							t += new Array(e + 1 - t.length).join(i)
					}
					return t
				}
			}, function(t, e, i) {
				var n = i(294),
					s = i(297),
					r = i(299),
					o = i(300);
				t.exports = function(t) {
					switch (typeof t) {
						case "string":
							return ("rgb" === t.substr(0, 3).toLowerCase() ? o : n)(t);
						case "number":
							return s(t);
						case "object":
							return r(t)
					}
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return t << 16 | e << 8 | i
				}
			}, function(t, e, i) {
				var n = i(165);
				t.exports = function(t, e, i, s) {
					void 0 === e && (e = 1), void 0 === i && (i = 1);
					var r = Math.floor(6 * t),
						o = 6 * t - r,
						a = Math.floor(i * (1 - e) * 255),
						h = Math.floor(i * (1 - o * e) * 255),
						u = Math.floor(i * (1 - (1 - o) * e) * 255),
						l = i = Math.floor(i *= 255),
						c = i,
						d = i,
						f = r % 6;
					return 0 == f ? (c = u, d = a) : 1 == f ? (l = h, d = a) : 2 == f ? (l = a, d = u) : 3 == f ? (l = a, c = h) : 4 == f ? (l = u, c = a) : 5 == f && (c = a, d = h), s ? s.setTo ? s.setTo(l, c, d, s.alpha, !1) : (s.r = l, s.g = c, s.b = d, s.color = n(l, c, d), s) : {
						r: l,
						g: c,
						b: d,
						color: n(l, c, d)
					}
				}
			}, function(t, e) {
				var i = "";

				function n(t) {
					for (var e = ["i", "webkitI", "msI", "mozI", "oI"], i = 0; i < e.length; i++) {
						var n = e[i] + "mageSmoothingEnabled";
						if (n in t) return n
					}
					return null
				}
				t.exports = {
					disable: function(t) {
						return "" === i && (i = n(t)), i && (t[i] = !1), t
					},
					enable: function(t) {
						return "" === i && (i = n(t)), i && (t[i] = !0), t
					},
					getPrefix: n,
					isEnabled: function(t) {
						return null !== i ? t[i] : null
					}
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return t.x = e - t.width / 2, t.y = i - t.height / 2, t
				}
			}, function(t, e, i) {
				var n = i(117),
					s = i(118),
					r = i(26),
					o = {
						canvas: !1,
						canvasBitBltShift: null,
						file: !1,
						fileSystem: !1,
						getUserMedia: !0,
						littleEndian: !1,
						localStorage: !1,
						pointerLock: !1,
						support32bit: !1,
						vibration: !1,
						webGL: !1,
						worker: !1
					};
				t.exports = function() {
					o.canvas = !!window.CanvasRenderingContext2D;
					try {
						o.localStorage = !!localStorage.getItem
					} catch (t) {
						o.localStorage = !1
					}
					o.file = !!(window.File && window.FileReader && window.FileList && window.Blob), o.fileSystem = !!window.requestFileSystem;
					var t, e, i, a = !1;
					return o.webGL = function() {
						if (window.WebGLRenderingContext) try {
							var t = r.createWebGL(this),
								e = t.getContext("webgl") || t.getContext("experimental-webgl"),
								i = r.create2D(this),
								n = i.getContext("2d").createImageData(1, 1);
							return a = n.data instanceof Uint8ClampedArray, r.remove(t), r.remove(i), !!e
						} catch (t) {
							return !1
						}
						return !1
					}(), o.worker = !!window.Worker, o.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, o.getUserMedia = o.getUserMedia && !!navigator.getUserMedia && !!window.URL, s.firefox && s.firefoxVersion < 21 && (o.getUserMedia = !1), !n.iOS && (s.ie || s.firefox || s.chrome) && (o.canvasBitBltShift = !0), (s.safari || s.mobileSafari) && (o.canvasBitBltShift = !1), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (o.vibration = !0), "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (o.littleEndian = (t = new ArrayBuffer(4), e = new Uint8Array(t), i = new Uint32Array(t), e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === i[0] || 2712847316 !== i[0] && null)), o.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== o.littleEndian && a, o
				}()
			}, function(t, e, i) {
				var n = i(13),
					s = i(18)(!1, s = {
						Angle: i(734),
						Distance: i(743),
						Easing: i(748),
						Fuzzy: i(749),
						Interpolation: i(752),
						Pow2: i(757),
						Snap: i(759),
						RandomDataGenerator: i(761),
						Average: i(762),
						Bernstein: i(324),
						Between: i(172),
						CatmullRom: i(171),
						CeilTo: i(763),
						Clamp: i(19),
						DegToRad: i(39),
						Difference: i(764),
						Factorial: i(325),
						FloatBetween: i(119),
						FloorTo: i(765),
						FromPercent: i(87),
						GetSpeed: i(766),
						IsEven: i(767),
						IsEvenStrict: i(768),
						Linear: i(116),
						MaxAdd: i(769),
						MinSub: i(770),
						Percent: i(771),
						RadToDeg: i(173),
						RandomXY: i(772),
						RandomXYZ: i(773),
						RandomXYZW: i(774),
						Rotate: i(331),
						RotateAround: i(276),
						RotateAroundDistance: i(159),
						RotateTo: i(775),
						RoundAwayFromZero: i(332),
						RoundTo: i(776),
						SinCosTableGenerator: i(777),
						SmootherStep: i(160),
						SmoothStep: i(161),
						ToXY: i(778),
						TransformXY: i(333),
						Within: i(779),
						Wrap: i(58),
						Vector2: i(3),
						Vector3: i(174),
						Vector4: i(334),
						Matrix3: i(335),
						Matrix4: i(336),
						Quaternion: i(337),
						RotateVec3: i(780)
					}, n);
				t.exports = s
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					var r = .5 * (n - e),
						o = .5 * (s - i),
						a = t * t;
					return (2 * i - 2 * n + r + o) * (t * a) + (-3 * i + 3 * n - 2 * r - o) * a + r * t + i
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return Math.floor(Math.random() * (e - t + 1) + t)
				}
			}, function(t, e, i) {
				var n = i(13);
				t.exports = function(t) {
					return t * n.RAD_TO_DEG
				}
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t, e, i) {
						this.x = 0, this.y = 0, this.z = 0, "object" == typeof t ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0)
					},
					up: function() {
						return this.x = 0, this.y = 1, this.z = 0, this
					},
					clone: function() {
						return new n(this.x, this.y, this.z)
					},
					crossVectors: function(t, e) {
						var i = t.x,
							n = t.y,
							s = t.z,
							r = e.x,
							o = e.y,
							a = e.z;
						return this.x = n * a - s * o, this.y = s * r - i * a, this.z = i * o - n * r, this
					},
					equals: function(t) {
						return this.x === t.x && this.y === t.y && this.z === t.z
					},
					copy: function(t) {
						return this.x = t.x, this.y = t.y, this.z = t.z || 0, this
					},
					set: function(t, e, i) {
						return "object" == typeof t ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0), this
					},
					add: function(t) {
						return this.x += t.x, this.y += t.y, this.z += t.z || 0, this
					},
					subtract: function(t) {
						return this.x -= t.x, this.y -= t.y, this.z -= t.z || 0, this
					},
					multiply: function(t) {
						return this.x *= t.x, this.y *= t.y, this.z *= t.z || 1, this
					},
					scale: function(t) {
						return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t) : (this.x = 0, this.y = 0, this.z = 0), this
					},
					divide: function(t) {
						return this.x /= t.x, this.y /= t.y, this.z /= t.z || 1, this
					},
					negate: function() {
						return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
					},
					distance: function(t) {
						var e = t.x - this.x,
							i = t.y - this.y,
							n = t.z - this.z || 0;
						return Math.sqrt(e * e + i * i + n * n)
					},
					distanceSq: function(t) {
						var e = t.x - this.x,
							i = t.y - this.y,
							n = t.z - this.z || 0;
						return e * e + i * i + n * n
					},
					length: function() {
						var t = this.x,
							e = this.y,
							i = this.z;
						return Math.sqrt(t * t + e * e + i * i)
					},
					lengthSq: function() {
						var t = this.x,
							e = this.y,
							i = this.z;
						return t * t + e * e + i * i
					},
					normalize: function() {
						var t = this.x,
							e = this.y,
							i = this.z,
							n = t * t + e * e + i * i;
						return 0 < n && (n = 1 / Math.sqrt(n), this.x = t * n, this.y = e * n, this.z = i * n), this
					},
					dot: function(t) {
						return this.x * t.x + this.y * t.y + this.z * t.z
					},
					cross: function(t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							s = t.x,
							r = t.y,
							o = t.z;
						return this.x = i * o - n * r, this.y = n * s - e * o, this.z = e * r - i * s, this
					},
					lerp: function(t, e) {
						void 0 === e && (e = 0);
						var i = this.x,
							n = this.y,
							s = this.z;
						return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this
					},
					transformMat3: function(t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							s = t.val;
						return this.x = e * s[0] + i * s[3] + n * s[6], this.y = e * s[1] + i * s[4] + n * s[7], this.z = e * s[2] + i * s[5] + n * s[8], this
					},
					transformMat4: function(t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							s = t.val;
						return this.x = s[0] * e + s[4] * i + s[8] * n + s[12], this.y = s[1] * e + s[5] * i + s[9] * n + s[13], this.z = s[2] * e + s[6] * i + s[10] * n + s[14], this
					},
					transformCoordinates: function(t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							s = t.val,
							r = e * s[0] + i * s[4] + n * s[8] + s[12],
							o = e * s[1] + i * s[5] + n * s[9] + s[13],
							a = e * s[2] + i * s[6] + n * s[10] + s[14],
							h = e * s[3] + i * s[7] + n * s[11] + s[15];
						return this.x = r / h, this.y = o / h, this.z = a / h, this
					},
					transformQuat: function(t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							s = t.x,
							r = t.y,
							o = t.z,
							a = t.w,
							h = a * e + r * n - o * i,
							u = a * i + o * e - s * n,
							l = a * n + s * i - r * e,
							c = -s * e - r * i - o * n;
						return this.x = h * a + c * -s + u * -o - l * -r, this.y = u * a + c * -r + l * -s - h * -o, this.z = l * a + c * -o + h * -r - u * -s, this
					},
					project: function(t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							s = t.val,
							r = s[0],
							o = s[1],
							a = s[2],
							h = s[3],
							u = s[4],
							l = s[5],
							c = s[6],
							d = s[7],
							f = s[8],
							p = s[9],
							g = s[10],
							v = s[11],
							m = s[12],
							y = s[13],
							x = s[14],
							T = 1 / (e * h + i * d + n * v + s[15]);
						return this.x = (e * r + i * u + n * f + m) * T, this.y = (e * o + i * l + n * p + y) * T, this.z = (e * a + i * c + n * g + x) * T, this
					},
					unproject: function(t, e) {
						var i = t.x,
							n = t.y,
							s = t.z,
							r = t.w,
							o = this.x - i,
							a = r - this.y - 1 - n,
							h = this.z;
						return this.x = 2 * o / s - 1, this.y = 2 * a / r - 1, this.z = 2 * h - 1, this.project(e)
					},
					reset: function() {
						return this.x = 0, this.y = 0, this.z = 0, this
					}
				});
				n.ZERO = new n, n.RIGHT = new n(1, 0, 0), n.LEFT = new n(-1, 0, 0), n.UP = new n(0, -1, 0), n.DOWN = new n(0, 1, 0), n.FORWARD = new n(0, 0, 1), n.BACK = new n(0, 0, -1), n.ONE = new n(1, 1, 1), t.exports = n
			}, function(t, e, i) {
				t.exports = {
					Global: ["game", "anims", "cache", "plugins", "registry", "scale", "sound", "textures"],
					CoreScene: ["EventEmitter", "CameraManager", "GameObjectCreator", "GameObjectFactory", "ScenePlugin", "DisplayList", "UpdateList"],
					DefaultScene: ["Clock", "DataManagerPlugin", "InputPlugin", "Loader", "TweenManager", "LightsPlugin"]
				}
			}, function(t, e, i) {
				var n = i(11),
					s = i(13);
				t.exports = function(t, e) {
					if (void 0 === e && (e = new n), 0 === t.length) return e;
					for (var i, r, o, a = Number.MAX_VALUE, h = Number.MAX_VALUE, u = s.MIN_SAFE_INTEGER, l = s.MIN_SAFE_INTEGER, c = 0; c < t.length; c++) i = t[c], o = Array.isArray(i) ? (r = i[0], i[1]) : (r = i.x, i.y), a = Math.min(a, r), h = Math.min(h, o), u = Math.max(u, r), l = Math.max(l, o);
					return e.x = a, e.y = h, e.width = u - a, e.height = l - h, e
				}
			}, function(t, e, i) {
				var n = {
					CENTER: i(359),
					ORIENTATION: i(360),
					SCALE_MODE: i(361),
					ZOOM: i(362)
				};
				t.exports = n
			}, function(t, e) {
				t.exports = function(t) {
					t.parentNode && t.parentNode.removeChild(t)
				}
			}, function(t, e) {
				t.exports = {
					MOUSE_DOWN: 0,
					MOUSE_MOVE: 1,
					MOUSE_UP: 2,
					TOUCH_START: 3,
					TOUCH_MOVE: 4,
					TOUCH_END: 5,
					POINTER_LOCK_CHANGE: 6,
					TOUCH_CANCEL: 7,
					MOUSE_WHEEL: 8
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(125),
					r = i(175),
					o = i(22),
					a = i(880),
					h = i(881),
					u = i(1),
					l = i(375),
					c = new n({
						initialize: function(t, e) {
							this.scene = t, this.game, this.renderer, this.config = e, this.settings = l.create(e), this.canvas, this.context, this.anims, this.cache, this.plugins, this.registry, this.scale, this.sound, this.textures, this.add, this.cameras, this.displayList, this.events, this.make, this.scenePlugin, this.updateList, this.sceneUpdate = u
						},
						init: function(t) {
							this.settings.status = s.INIT, this.sceneUpdate = u, this.game = t, this.renderer = t.renderer, this.canvas = t.canvas, this.context = t.context;
							var e = t.plugins;
							(this.plugins = e).addToScene(this, r.Global, [r.CoreScene, h(this), a(this)]), this.events.emit(o.BOOT, this), this.settings.isBooted = !0
						},
						install: function(t) {
							Array.isArray(t) || (t = [t]), this.plugins.installLocal(this, t)
						},
						step: function(t, e) {
							this.events.emit(o.PRE_UPDATE, t, e), this.events.emit(o.UPDATE, t, e), this.sceneUpdate.call(this.scene, t, e), this.events.emit(o.POST_UPDATE, t, e)
						},
						render: function(t) {
							var e = this.displayList;
							e.depthSort(), this.cameras.render(t, e), this.events.emit(o.RENDER, t)
						},
						queueDepthSort: function() {
							this.displayList.queueDepthSort()
						},
						depthSort: function() {
							this.displayList.depthSort()
						},
						pause: function(t) {
							return this.settings.active && (this.settings.status = s.PAUSED, this.settings.active = !1, this.events.emit(o.PAUSE, this, t)), this
						},
						resume: function(t) {
							return this.settings.active || (this.settings.status = s.RUNNING, this.settings.active = !0, this.events.emit(o.RESUME, this, t)), this
						},
						sleep: function(t) {
							return this.settings.status = s.SLEEPING, this.settings.active = !1, this.settings.visible = !1, this.events.emit(o.SLEEP, this, t), this
						},
						wake: function(t) {
							var e = this.settings;
							return e.status = s.RUNNING, e.active = !0, e.visible = !0, this.events.emit(o.WAKE, this, t), e.isTransition && this.events.emit(o.TRANSITION_WAKE, e.transitionFrom, e.transitionDuration), this
						},
						getData: function() {
							return this.settings.data
						},
						isSleeping: function() {
							return this.settings.status === s.SLEEPING
						},
						isActive: function() {
							return this.settings.status === s.RUNNING
						},
						isPaused: function() {
							return this.settings.status === s.PAUSED
						},
						isTransitioning: function() {
							return this.settings.isTransition || null !== this.scenePlugin._target
						},
						isTransitionOut: function() {
							return null !== this.scenePlugin._target && 0 < this.scenePlugin._duration
						},
						isTransitionIn: function() {
							return this.settings.isTransition
						},
						isVisible: function() {
							return this.settings.visible
						},
						setVisible: function(t) {
							return this.settings.visible = t, this
						},
						setActive: function(t, e) {
							return t ? this.resume(e) : this.pause(e)
						},
						start: function(t) {
							t && (this.settings.data = t), this.settings.status = s.START, this.settings.active = !0, this.settings.visible = !0, this.events.emit(o.START, this), this.events.emit(o.READY, this, t)
						},
						shutdown: function(t) {
							this.events.off(o.TRANSITION_INIT), this.events.off(o.TRANSITION_START), this.events.off(o.TRANSITION_COMPLETE), this.events.off(o.TRANSITION_OUT), this.settings.status = s.SHUTDOWN, this.settings.active = !1, this.settings.visible = !1, this.events.emit(o.SHUTDOWN, this, t)
						},
						destroy: function() {
							this.settings.status = s.DESTROYED, this.settings.active = !1, this.settings.visible = !1, this.events.emit(o.DESTROY, this), this.events.removeAllListeners();
							for (var t = ["scene", "game", "anims", "cache", "plugins", "registry", "sound", "textures", "add", "camera", "displayList", "events", "make", "scenePlugin", "updateList"], e = 0; e < t.length; e++) this[t[e]] = null
						}
					});
				t.exports = c
			}, function(t, e) {
				t.exports = function(t) {
					return t && t[0].toUpperCase() + t.slice(1)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(94),
					r = i(378),
					o = "Texture.frame missing: ",
					a = new n({
						initialize: function(t, e, i, n, s) {
							Array.isArray(i) || (i = [i]), this.manager = t, this.key = e, this.source = [], this.dataSource = [], this.frames = {}, this.customData = {}, this.firstFrame = "__BASE";
							for (var o = this.frameTotal = 0; o < i.length; o++) this.source.push(new r(this, i[o], n, s))
						},
						add: function(t, e, i, n, r, o) {
							if (this.has(t)) return null;
							var a = new s(this, t, e, i, n, r, o);
							return this.frames[t] = a, "__BASE" === this.firstFrame && (this.firstFrame = t), this.frameTotal++, a
						},
						remove: function(t) {
							return !!this.has(t) && (this.get(t).destroy(), delete this.frames[t], !0)
						},
						has: function(t) {
							return this.frames[t]
						},
						get: function(t) {
							t = t || this.firstFrame;
							var e = this.frames[t];
							return e || (console.warn(o + t), e = this.frames[this.firstFrame]), e
						},
						getTextureSourceIndex: function(t) {
							for (var e = 0; e < this.source.length; e++)
								if (this.source[e] === t) return e;
							return -1
						},
						getFramesFromTextureSource: function(t, e) {
							void 0 === e && (e = !1);
							var i, n = [];
							for (var s in this.frames) "__BASE" === s && !e || (i = this.frames[s]).sourceIndex === t && n.push(i);
							return n
						},
						getFrameNames: function(t) {
							void 0 === t && (t = !1);
							var e, i = Object.keys(this.frames);
							return t || -1 !== (e = i.indexOf("__BASE")) && i.splice(e, 1), i
						},
						getSourceImage: function(t) {
							null != t && 1 !== this.frameTotal || (t = "__BASE");
							var e = this.frames[t];
							return e ? e.source.image : (console.warn(o + t), this.frames.__BASE.source.image)
						},
						getDataSourceImage: function(t) {
							null != t && 1 !== this.frameTotal || (t = "__BASE");
							var e = this.frames[t],
								i = e ? e.sourceIndex : (console.warn(o + t), this.frames.__BASE.sourceIndex);
							return this.dataSource[i].image
						},
						setDataSource: function(t) {
							Array.isArray(t) || (t = [t]);
							for (var e = 0; e < t.length; e++) {
								var i = this.source[e];
								this.dataSource.push(new r(this, t[e], i.width, i.height))
							}
						},
						setFilter: function(t) {
							for (var e = 0; e < this.source.length; e++) this.source[e].setFilter(t);
							for (e = 0; e < this.dataSource.length; e++) this.dataSource[e].setFilter(t)
						},
						destroy: function() {
							for (var t = 0; t < this.source.length; t++) this.source[t].destroy();
							for (t = 0; t < this.dataSource.length; t++) this.dataSource[t].destroy();
							for (var e in this.frames) this.frames[e].destroy();
							this.source = [], this.dataSource = [], this.frames = {}, this.manager.removeKey(this.key), this.manager = null
						}
					});
				t.exports = a
			}, function(t, e, i) {
				t.exports = {
					Matrix: i(916),
					Add: i(923),
					AddAt: i(924),
					BringToTop: i(925),
					CountAllMatching: i(926),
					Each: i(927),
					EachInRange: i(928),
					FindClosestInSorted: i(270),
					GetAll: i(382),
					GetFirst: i(383),
					GetRandom: i(185),
					MoveDown: i(929),
					MoveTo: i(930),
					MoveUp: i(931),
					NumberArray: i(932),
					NumberArrayStep: i(933),
					QuickSelect: i(391),
					Range: i(392),
					Remove: i(123),
					RemoveAt: i(934),
					RemoveBetween: i(935),
					RemoveRandomElement: i(936),
					Replace: i(937),
					RotateLeft: i(286),
					RotateRight: i(287),
					SafeRange: i(68),
					SendToBack: i(938),
					SetAll: i(939),
					Shuffle: i(114),
					SpliceOne: i(80),
					StableSort: i(131),
					Swap: i(940)
				}
			}, function(t, e) {
				t.exports = function(t) {
					if (!Array.isArray(t) || t.length < 2 || !Array.isArray(t[0])) return !1;
					for (var e = t[0].length, i = 1; i < t.length; i++)
						if (t[i].length !== e) return !1;
					return !0
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					void 0 === e && (e = 0), void 0 === i && (i = t.length);
					var n = e + Math.floor(Math.random() * i);
					return void 0 === t[n] ? null : t[n]
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(10),
					r = i(942),
					o = new n({
						Extends: s,
						initialize: function() {
							s.call(this), this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0
						},
						add: function(t) {
							return this._pending.push(t), this._toProcess++, t
						},
						remove: function(t) {
							return this._destroy.push(t), this._toProcess++, t
						},
						removeAll: function() {
							for (var t = this._active, e = this._destroy, i = t.length; i--;) e.push(t[i]), this._toProcess++;
							return this
						},
						update: function() {
							if (0 === this._toProcess) return this._active;
							for (var t, e = this._destroy, i = this._active, n = 0; n < e.length; n++) {
								t = e[n];
								var s = i.indexOf(t); - 1 !== s && (i.splice(s, 1), this.emit(r.REMOVE, t))
							}
							for (e.length = 0, e = this._pending, n = 0; n < e.length; n++) t = e[n], this._active.push(t), this.emit(r.ADD, t);
							return e.length = 0, this._toProcess = 0, this._active
						},
						getActive: function() {
							return this._active
						},
						length: {
							get: function() {
								return this._active.length
							}
						},
						destroy: function() {
							this._toProcess = 0, this._pending = [], this._active = [], this._destroy = []
						}
					});
				t.exports = o
			}, function(t, e) {
				function i(t, e) {
					return parseInt(t.getAttribute(e), 10)
				}
				t.exports = function(t, e, n, s) {
					void 0 === e && (e = 0), void 0 === n && (n = 0);
					var r = {},
						o = t.getElementsByTagName("info")[0],
						a = t.getElementsByTagName("common")[0];
					r.font = o.getAttribute("face"), r.size = i(o, "size"), r.lineHeight = i(a, "lineHeight") + n, r.chars = {};
					var h, u, l = t.getElementsByTagName("char"),
						c = void 0 !== s && s.trimmed;
					c && (h = s.height, u = s.width);
					for (var d = 0; d < l.length; d++) {
						var f = l[d],
							p = i(f, "id"),
							g = i(f, "x"),
							v = i(f, "y"),
							m = i(f, "width"),
							y = i(f, "height");
						c && (g < u && (u = g), v < h && (h = v)), r.chars[p] = {
							x: g,
							y: v,
							width: m,
							height: y,
							centerX: Math.floor(m / 2),
							centerY: Math.floor(y / 2),
							xOffset: i(f, "xoffset"),
							yOffset: i(f, "yoffset"),
							xAdvance: i(f, "xadvance") + e,
							data: {},
							kerning: {}
						}
					}
					if (c && 0 !== h && 0 !== u)
						for (var x in r.chars) {
							var T = r.chars[x];
							T.x -= s.x, T.y -= s.y
						}
					var w = t.getElementsByTagName("kerning");
					for (d = 0; d < w.length; d++) {
						var E = w[d],
							_ = i(E, "first"),
							b = i(E, "second"),
							A = i(E, "amount");
						r.chars[b].kerning[_] = A
					}
					return r
				}
			}, function(t, e, i) {
				var n = i(950),
					s = i(953),
					r = i(0),
					o = i(12),
					a = i(94),
					h = i(14),
					u = i(129),
					l = new r({
						Extends: h,
						Mixins: [o.Alpha, o.BlendMode, o.Depth, o.Mask, o.Pipeline, o.ScrollFactor, o.Size, o.Texture, o.Transform, o.Visible, n],
						initialize: function(t, e, i, n, s) {
							h.call(this, t, "Blitter"), this.setTexture(n, s), this.setPosition(e, i), this.initPipeline(), this.children = new u, this.renderList = [], this.dirty = !1
						},
						create: function(t, e, i, n, r) {
							void 0 === n && (n = !0), void 0 === r && (r = this.children.length), void 0 === i ? i = this.frame : i instanceof a || (i = this.texture.get(i));
							var o = new s(this, t, e, i, n);
							return this.children.addAt(o, r, !1), this.dirty = !0, o
						},
						createFromCallback: function(t, e, i, n) {
							for (var s = this.createMultiple(e, i, n), r = 0; r < s.length; r++) {
								var o = s[r];
								t.call(this, o, r)
							}
							return s
						},
						createMultiple: function(t, e, i) {
							void 0 === e && (e = this.frame.name), void 0 === i && (i = !0), Array.isArray(e) || (e = [e]);
							var n = [],
								s = this;
							return e.forEach(function(e) {
								for (var r = 0; r < t; r++) n.push(s.create(0, 0, e, i))
							}), n
						},
						childCanRender: function(t) {
							return t.visible && 0 < t.alpha
						},
						getRenderList: function() {
							return this.dirty && (this.renderList = this.children.list.filter(this.childCanRender, this), this.dirty = !1), this.renderList
						},
						clear: function() {
							this.children.removeAll(), this.dirty = !0
						},
						preDestroy: function() {
							this.children.destroy(), this.renderList = []
						}
					});
				t.exports = l
			}, function(t, e, i) {
				var n = i(183),
					s = i(52),
					r = i(0),
					o = i(12),
					a = i(90),
					h = i(14),
					u = i(11),
					l = i(954),
					c = i(394),
					d = i(3),
					f = new r({
						Extends: h,
						Mixins: [o.AlphaSingle, o.BlendMode, o.ComputedSize, o.Depth, o.Mask, o.Transform, o.Visible, l],
						initialize: function(t, e, i, n) {
							h.call(this, t, "Container"), this.list = [], this.exclusive = !0, this.maxSize = -1, this.position = 0, this.localTransform = new o.TransformMatrix, this.tempTransformMatrix = new o.TransformMatrix, this._displayList = t.sys.displayList, this._sortKey = "", this._sysEvents = t.sys.events, this.scrollFactorX = 1, this.scrollFactorY = 1, this.setPosition(e, i), this.clearAlpha(), this.setBlendMode(s.SKIP_CHECK), n && this.add(n)
						},
						originX: {
							get: function() {
								return .5
							}
						},
						originY: {
							get: function() {
								return .5
							}
						},
						displayOriginX: {
							get: function() {
								return .5 * this.width
							}
						},
						displayOriginY: {
							get: function() {
								return .5 * this.height
							}
						},
						setExclusive: function(t) {
							return void 0 === t && (t = !0), this.exclusive = t, this
						},
						getBounds: function(t) {
							var e;
							if (void 0 === t && (t = new u), t.setTo(this.x, this.y, 0, 0), this.parentContainer && (e = this.parentContainer.getBoundsTransformMatrix().transformPoint(this.x, this.y), t.setTo(e.x, e.y, 0, 0)), 0 < this.list.length) {
								var i = this.list,
									n = new u,
									s = !1;
								t.setEmpty();
								for (var r = 0; r < i.length; r++) {
									var o = i[r];
									o.getBounds && (o.getBounds(n), s ? c(n, t, t) : (t.setTo(n.x, n.y, n.width, n.height), s = !0))
								}
							}
							return t
						},
						addHandler: function(t) {
							t.once(a.DESTROY, this.remove, this), this.exclusive && (this._displayList.remove(t), t.parentContainer && t.parentContainer.remove(t), t.parentContainer = this)
						},
						removeHandler: function(t) {
							t.off(a.DESTROY, this.remove), this.exclusive && (t.parentContainer = null)
						},
						pointToContainer: function(t, e) {
							void 0 === e && (e = new d), this.parentContainer ? this.parentContainer.pointToContainer(t, e) : e = new d(t.x, t.y);
							var i = this.tempTransformMatrix;
							return i.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY), i.invert(), i.transformPoint(t.x, t.y, e), e
						},
						getBoundsTransformMatrix: function() {
							return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform)
						},
						add: function(t) {
							return n.Add(this.list, t, this.maxSize, this.addHandler, this), this
						},
						addAt: function(t, e) {
							return n.AddAt(this.list, t, e, this.maxSize, this.addHandler, this), this
						},
						getAt: function(t) {
							return this.list[t]
						},
						getIndex: function(t) {
							return this.list.indexOf(t)
						},
						sort: function(t, e) {
							return t && (void 0 === e && (e = function(e, i) {
								return e[t] - i[t]
							}), n.StableSort.inplace(this.list, e)), this
						},
						getByName: function(t) {
							return n.GetFirst(this.list, "name", t)
						},
						getRandom: function(t, e) {
							return n.GetRandom(this.list, t, e)
						},
						getFirst: function(t, e, i, s) {
							return n.GetFirst(this.list, t, e, i, s)
						},
						getAll: function(t, e, i, s) {
							return n.GetAll(this.list, t, e, i, s)
						},
						count: function(t, e, i, s) {
							return n.CountAllMatching(this.list, t, e, i, s)
						},
						swap: function(t, e) {
							return n.Swap(this.list, t, e), this
						},
						moveTo: function(t, e) {
							return n.MoveTo(this.list, t, e), this
						},
						remove: function(t, e) {
							var i = n.Remove(this.list, t, this.removeHandler, this);
							if (e && i) {
								Array.isArray(i) || (i = [i]);
								for (var s = 0; s < i.length; s++) i[s].destroy()
							}
							return this
						},
						removeAt: function(t, e) {
							var i = n.RemoveAt(this.list, t, this.removeHandler, this);
							return e && i && i.destroy(), this
						},
						removeBetween: function(t, e, i) {
							var s = n.RemoveBetween(this.list, t, e, this.removeHandler, this);
							if (i)
								for (var r = 0; r < s.length; r++) s[r].destroy();
							return this
						},
						removeAll: function(t) {
							var e = n.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this);
							if (t)
								for (var i = 0; i < e.length; i++) e[i].destroy();
							return this
						},
						bringToTop: function(t) {
							return n.BringToTop(this.list, t), this
						},
						sendToBack: function(t) {
							return n.SendToBack(this.list, t), this
						},
						moveUp: function(t) {
							return n.MoveUp(this.list, t), this
						},
						moveDown: function(t) {
							return n.MoveDown(this.list, t), this
						},
						reverse: function() {
							return this.list.reverse(), this
						},
						shuffle: function() {
							return n.Shuffle(this.list), this
						},
						replace: function(t, e, i) {
							return n.Replace(this.list, t, e) && (this.addHandler(e), this.removeHandler(t), i && t.destroy()), this
						},
						exists: function(t) {
							return -1 < this.list.indexOf(t)
						},
						setAll: function(t, e, i, s) {
							return n.SetAll(this.list, t, e, i, s), this
						},
						each: function(t, e) {
							for (var i = [null], n = this.list.slice(), s = n.length, r = 2; r < arguments.length; r++) i.push(arguments[r]);
							for (r = 0; r < s; r++) i[0] = n[r], t.apply(e, i);
							return this
						},
						iterate: function(t, e) {
							for (var i = [null], n = 2; n < arguments.length; n++) i.push(arguments[n]);
							for (n = 0; n < this.list.length; n++) i[0] = this.list[n], t.apply(e, i);
							return this
						},
						setScrollFactor: function(t, e, i) {
							return void 0 === e && (e = t), void 0 === i && (i = !1), this.scrollFactorX = t, this.scrollFactorY = e, i && (n.SetAll(this.list, "scrollFactorX", t), n.SetAll(this.list, "scrollFactorY", e)), this
						},
						length: {
							get: function() {
								return this.list.length
							}
						},
						first: {
							get: function() {
								return (this.position = 0) < this.list.length ? this.list[0] : null
							}
						},
						last: {
							get: function() {
								return 0 < this.list.length ? (this.position = this.list.length - 1, this.list[this.position]) : null
							}
						},
						next: {
							get: function() {
								return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
							}
						},
						previous: {
							get: function() {
								return 0 < this.position ? (this.position--, this.list[this.position]) : null
							}
						},
						preDestroy: function() {
							this.removeAll(!!this.exclusive), this.localTransform.destroy(), this.tempTransformMatrix.destroy(), this.list = [], this._displayList = null
						}
					});
				t.exports = f
			}, function(t, e, i) {
				var n = i(132),
					s = i(0),
					r = i(959),
					o = new s({
						Extends: n,
						Mixins: [r],
						initialize: function(t, e, i, s, r, o, a) {
							n.call(this, t, e, i, s, r, o, a), this.type = "DynamicBitmapText", this.scrollX = 0, this.scrollY = 0, this.cropWidth = 0, this.cropHeight = 0, this.displayCallback, this.callbackData = {
								parent: this,
								color: 0,
								tint: {
									topLeft: 0,
									topRight: 0,
									bottomLeft: 0,
									bottomRight: 0
								},
								index: 0,
								charCode: 0,
								x: 0,
								y: 0,
								scale: 0,
								rotation: 0,
								data: 0
							}
						},
						setSize: function(t, e) {
							return this.cropWidth = t, this.cropHeight = e, this
						},
						setDisplayCallback: function(t) {
							return this.displayCallback = t, this
						},
						setScrollX: function(t) {
							return this.scrollX = t, this
						},
						setScrollY: function(t) {
							return this.scrollY = t, this
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(91),
					s = i(0),
					r = i(192),
					o = i(269),
					a = i(272),
					h = i(273),
					u = i(277),
					l = i(156),
					c = i(282),
					d = i(283),
					f = i(280),
					p = i(29),
					g = i(95),
					v = i(14),
					m = i(2),
					y = i(6),
					x = i(13),
					T = i(965),
					w = new s({
						Extends: v,
						Mixins: [o, a, h, u, l, c, d, f, T],
						initialize: function(t, e) {
							var i = y(e, "x", 0),
								n = y(e, "y", 0);
							v.call(this, t, "Graphics"), this.setPosition(i, n), this.initPipeline(), this.displayOriginX = 0, this.displayOriginY = 0, this.commandBuffer = [], this.defaultFillColor = -1, this.defaultFillAlpha = 1, this.defaultStrokeWidth = 1, this.defaultStrokeColor = -1, this.defaultStrokeAlpha = 1, this._lineWidth = 1, this._tempMatrix1 = new p, this._tempMatrix2 = new p, this._tempMatrix3 = new p, this.setDefaultStyles(e)
						},
						setDefaultStyles: function(t) {
							return y(t, "lineStyle", null) && (this.defaultStrokeWidth = y(t, "lineStyle.width", 1), this.defaultStrokeColor = y(t, "lineStyle.color", 16777215), this.defaultStrokeAlpha = y(t, "lineStyle.alpha", 1), this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha)), y(t, "fillStyle", null) && (this.defaultFillColor = y(t, "fillStyle.color", 16777215), this.defaultFillAlpha = y(t, "fillStyle.alpha", 1), this.fillStyle(this.defaultFillColor, this.defaultFillAlpha)), this
						},
						lineStyle: function(t, e, i) {
							return void 0 === i && (i = 1), this.commandBuffer.push(r.LINE_STYLE, t, e, i), this._lineWidth = t, this
						},
						fillStyle: function(t, e) {
							return void 0 === e && (e = 1), this.commandBuffer.push(r.FILL_STYLE, t, e), this
						},
						fillGradientStyle: function(t, e, i, n, s) {
							return void 0 === s && (s = 1), this.commandBuffer.push(r.GRADIENT_FILL_STYLE, s, t, e, i, n), this
						},
						lineGradientStyle: function(t, e, i, n, s, o) {
							return void 0 === o && (o = 1), this.commandBuffer.push(r.GRADIENT_LINE_STYLE, t, o, e, i, n, s), this
						},
						setTexture: function(t, e, i) {
							var n;
							return void 0 === i && (i = 0), void 0 === t ? this.commandBuffer.push(r.CLEAR_TEXTURE) : (n = this.scene.sys.textures.getFrame(t, e)) && (2 === i && (i = 3), this.commandBuffer.push(r.SET_TEXTURE, n, i)), this
						},
						beginPath: function() {
							return this.commandBuffer.push(r.BEGIN_PATH), this
						},
						closePath: function() {
							return this.commandBuffer.push(r.CLOSE_PATH), this
						},
						fillPath: function() {
							return this.commandBuffer.push(r.FILL_PATH), this
						},
						fill: function() {
							return this.commandBuffer.push(r.FILL_PATH), this
						},
						strokePath: function() {
							return this.commandBuffer.push(r.STROKE_PATH), this
						},
						stroke: function() {
							return this.commandBuffer.push(r.STROKE_PATH), this
						},
						fillCircleShape: function(t) {
							return this.fillCircle(t.x, t.y, t.radius)
						},
						strokeCircleShape: function(t) {
							return this.strokeCircle(t.x, t.y, t.radius)
						},
						fillCircle: function(t, e, i) {
							return this.beginPath(), this.arc(t, e, i, 0, x.PI2), this.fillPath(), this
						},
						strokeCircle: function(t, e, i) {
							return this.beginPath(), this.arc(t, e, i, 0, x.PI2), this.strokePath(), this
						},
						fillRectShape: function(t) {
							return this.fillRect(t.x, t.y, t.width, t.height)
						},
						strokeRectShape: function(t) {
							return this.strokeRect(t.x, t.y, t.width, t.height)
						},
						fillRect: function(t, e, i, n) {
							return this.commandBuffer.push(r.FILL_RECT, t, e, i, n), this
						},
						strokeRect: function(t, e, i, n) {
							var s = this._lineWidth / 2,
								r = t - s,
								o = t + s;
							return this.beginPath(), this.moveTo(t, e), this.lineTo(t, e + n), this.strokePath(), this.beginPath(), this.moveTo(t + i, e), this.lineTo(t + i, e + n), this.strokePath(), this.beginPath(), this.moveTo(r, e), this.lineTo(o + i, e), this.strokePath(), this.beginPath(), this.moveTo(r, e + n), this.lineTo(o + i, e + n), this.strokePath(), this
						},
						fillRoundedRect: function(t, e, i, n, s) {
							void 0 === s && (s = 20);
							var r = s,
								o = s,
								a = s,
								h = s;
							return "number" != typeof s && (r = m(s, "tl", 20), o = m(s, "tr", 20), a = m(s, "bl", 20), h = m(s, "br", 20)), this.beginPath(), this.moveTo(t + r, e), this.lineTo(t + i - o, e), this.arc(t + i - o, e + o, o, -x.TAU, 0), this.lineTo(t + i, e + n - h), this.arc(t + i - h, e + n - h, h, 0, x.TAU), this.lineTo(t + a, e + n), this.arc(t + a, e + n - a, a, x.TAU, Math.PI), this.lineTo(t, e + r), this.arc(t + r, e + r, r, -Math.PI, -x.TAU), this.fillPath(), this
						},
						strokeRoundedRect: function(t, e, i, n, s) {
							void 0 === s && (s = 20);
							var r = s,
								o = s,
								a = s,
								h = s;
							return "number" != typeof s && (r = m(s, "tl", 20), o = m(s, "tr", 20), a = m(s, "bl", 20), h = m(s, "br", 20)), this.beginPath(), this.moveTo(t + r, e), this.lineTo(t + i - o, e), this.arc(t + i - o, e + o, o, -x.TAU, 0), this.lineTo(t + i, e + n - h), this.arc(t + i - h, e + n - h, h, 0, x.TAU), this.lineTo(t + a, e + n), this.arc(t + a, e + n - a, a, x.TAU, Math.PI), this.lineTo(t, e + r), this.arc(t + r, e + r, r, -Math.PI, -x.TAU), this.strokePath(), this
						},
						fillPointShape: function(t, e) {
							return this.fillPoint(t.x, t.y, e)
						},
						fillPoint: function(t, e, i) {
							return !i || i < 1 ? i = 1 : (t -= i / 2, e -= i / 2), this.commandBuffer.push(r.FILL_RECT, t, e, i, i), this
						},
						fillTriangleShape: function(t) {
							return this.fillTriangle(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3)
						},
						strokeTriangleShape: function(t) {
							return this.strokeTriangle(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3)
						},
						fillTriangle: function(t, e, i, n, s, o) {
							return this.commandBuffer.push(r.FILL_TRIANGLE, t, e, i, n, s, o), this
						},
						strokeTriangle: function(t, e, i, n, s, o) {
							return this.commandBuffer.push(r.STROKE_TRIANGLE, t, e, i, n, s, o), this
						},
						strokeLineShape: function(t) {
							return this.lineBetween(t.x1, t.y1, t.x2, t.y2)
						},
						lineBetween: function(t, e, i, n) {
							return this.beginPath(), this.moveTo(t, e), this.lineTo(i, n), this.strokePath(), this
						},
						lineTo: function(t, e) {
							return this.commandBuffer.push(r.LINE_TO, t, e), this
						},
						moveTo: function(t, e) {
							return this.commandBuffer.push(r.MOVE_TO, t, e), this
						},
						strokePoints: function(t, e, i, n) {
							void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === n && (n = t.length), this.beginPath(), this.moveTo(t[0].x, t[0].y);
							for (var s = 1; s < n; s++) this.lineTo(t[s].x, t[s].y);
							return e && this.lineTo(t[0].x, t[0].y), i && this.closePath(), this.strokePath(), this
						},
						fillPoints: function(t, e, i, n) {
							void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === n && (n = t.length), this.beginPath(), this.moveTo(t[0].x, t[0].y);
							for (var s = 1; s < n; s++) this.lineTo(t[s].x, t[s].y);
							return e && this.lineTo(t[0].x, t[0].y), i && this.closePath(), this.fillPath(), this
						},
						strokeEllipseShape: function(t, e) {
							void 0 === e && (e = 32);
							var i = t.getPoints(e);
							return this.strokePoints(i, !0)
						},
						strokeEllipse: function(t, e, i, n, s) {
							void 0 === s && (s = 32);
							var r = new g(t, e, i, n).getPoints(s);
							return this.strokePoints(r, !0)
						},
						fillEllipseShape: function(t, e) {
							void 0 === e && (e = 32);
							var i = t.getPoints(e);
							return this.fillPoints(i, !0)
						},
						fillEllipse: function(t, e, i, n, s) {
							void 0 === s && (s = 32);
							var r = new g(t, e, i, n).getPoints(s);
							return this.fillPoints(r, !0)
						},
						arc: function(t, e, i, n, s, o, a) {
							return void 0 === o && (o = !1), void 0 === a && (a = 0), this.commandBuffer.push(r.ARC, t, e, i, n, s, o, a), this
						},
						slice: function(t, e, i, n, s, o, a) {
							return void 0 === o && (o = !1), void 0 === a && (a = 0), this.commandBuffer.push(r.BEGIN_PATH), this.commandBuffer.push(r.MOVE_TO, t, e), this.commandBuffer.push(r.ARC, t, e, i, n, s, o, a), this.commandBuffer.push(r.CLOSE_PATH), this
						},
						save: function() {
							return this.commandBuffer.push(r.SAVE), this
						},
						restore: function() {
							return this.commandBuffer.push(r.RESTORE), this
						},
						translateCanvas: function(t, e) {
							return this.commandBuffer.push(r.TRANSLATE, t, e), this
						},
						scaleCanvas: function(t, e) {
							return this.commandBuffer.push(r.SCALE, t, e), this
						},
						rotateCanvas: function(t) {
							return this.commandBuffer.push(r.ROTATE, t), this
						},
						clear: function() {
							return this.commandBuffer.length = 0, -1 < this.defaultFillColor && this.fillStyle(this.defaultFillColor, this.defaultFillAlpha), -1 < this.defaultStrokeColor && this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha), this
						},
						generateTexture: function(t, e, i) {
							var n, s, r, o = this.scene.sys,
								a = o.game.renderer;
							return void 0 === e && (e = o.scale.width), void 0 === i && (i = o.scale.height), w.TargetCamera.setScene(this.scene), w.TargetCamera.setViewport(0, 0, e, i), w.TargetCamera.scrollX = this.x, w.TargetCamera.scrollY = this.y, "string" == typeof t ? o.textures.exists(t) ? (r = (n = o.textures.get(t)).getSourceImage()) instanceof HTMLCanvasElement && (s = r.getContext("2d")) : s = (n = o.textures.createCanvas(t, e, i)).getSourceImage().getContext("2d") : t instanceof HTMLCanvasElement && (s = t.getContext("2d")), s && (this.renderCanvas(a, this, 0, w.TargetCamera, null, s, !1), n && n.refresh()), this
						},
						preDestroy: function() {
							this.commandBuffer = []
						}
					});
				w.TargetCamera = new n, t.exports = w
			}, function(t, e) {
				t.exports = {
					ARC: 0,
					BEGIN_PATH: 1,
					CLOSE_PATH: 2,
					FILL_RECT: 3,
					LINE_TO: 4,
					MOVE_TO: 5,
					LINE_STYLE: 6,
					FILL_STYLE: 7,
					FILL_PATH: 8,
					STROKE_PATH: 9,
					FILL_TRIANGLE: 10,
					STROKE_TRIANGLE: 11,
					SAVE: 14,
					RESTORE: 15,
					TRANSLATE: 16,
					SCALE: 17,
					ROTATE: 18,
					SET_TEXTURE: 19,
					CLEAR_TEXTURE: 20,
					GRADIENT_FILL_STYLE: 21,
					GRADIENT_LINE_STYLE: 22
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e, i) {
					void 0 === i && (i = new n);
					var s = t.width / 2,
						r = t.height / 2;
					return i.x = t.x + s * Math.cos(e), i.y = t.y + r * Math.sin(e), i
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(14),
					o = i(402),
					a = i(129),
					h = i(404),
					u = i(975),
					l = new n({
						Extends: r,
						Mixins: [s.Depth, s.Mask, s.Pipeline, s.Transform, s.Visible, u],
						initialize: function(t, e, i, n) {
							if (r.call(this, t, "ParticleEmitterManager"), this.blendMode = -1, this.timeScale = 1, this.texture = null, this.frame = null, this.frameNames = [], null === i || "object" != typeof i && !Array.isArray(i) || (n = i, i = null), this.setTexture(e, i), this.initPipeline(), this.emitters = new a(this), this.wells = new a(this), n) {
								Array.isArray(n) || (n = [n]);
								for (var s = 0; s < n.length; s++) this.createEmitter(n[s])
							}
						},
						setTexture: function(t, e) {
							return this.texture = this.scene.sys.textures.get(t), this.setFrame(e)
						},
						setFrame: function(t) {
							this.frame = this.texture.get(t);
							var e = this.texture.getFramesFromTextureSource(this.frame.sourceIndex),
								i = [];
							return e.forEach(function(t) {
								i.push(t.name)
							}), this.frameNames = i, this.defaultFrame = this.frame, this
						},
						setEmitterFrames: function(t, e) {
							Array.isArray(t) || (t = [t]);
							for (var i = e.frames, n = i.length = 0; n < t.length; n++) {
								var s = t[n]; - 1 !== this.frameNames.indexOf(s) && i.push(this.texture.get(s))
							}
							return 0 < i.length ? e.defaultFrame = i[0] : e.defaultFrame = this.defaultFrame, this
						},
						addEmitter: function(t) {
							return this.emitters.add(t)
						},
						createEmitter: function(t) {
							return this.addEmitter(new h(this, t))
						},
						removeEmitter: function(t) {
							return this.emitters.remove(t, !0)
						},
						addGravityWell: function(t) {
							return this.wells.add(t)
						},
						createGravityWell: function(t) {
							return this.addGravityWell(new o(t))
						},
						emitParticle: function(t, e, i) {
							for (var n = this.emitters.list, s = 0; s < n.length; s++) {
								var r = n[s];
								r.active && r.emitParticle(t, e, i)
							}
							return this
						},
						emitParticleAt: function(t, e, i) {
							return this.emitParticle(i, t, e)
						},
						pause: function() {
							return this.active = !1, this
						},
						resume: function() {
							return this.active = !0, this
						},
						getProcessors: function() {
							return this.wells.getAll("active", !0)
						},
						preUpdate: function(t, e) {
							e *= this.timeScale;
							for (var i = this.emitters.list, n = 0; n < i.length; n++) {
								var s = i[n];
								s.active && s.preUpdate(t, e)
							}
						},
						setAlpha: function() {},
						setScrollFactor: function() {},
						setBlendMode: function() {}
					});
				t.exports = l
			}, function(t, e, i) {
				var n = i(52),
					s = i(91),
					r = i(26),
					o = i(0),
					a = i(12),
					h = i(33),
					u = i(94),
					l = i(14),
					c = i(1),
					d = i(979),
					f = i(9),
					p = i(196),
					g = new o({
						Extends: l,
						Mixins: [a.Alpha, a.BlendMode, a.ComputedSize, a.Crop, a.Depth, a.Flip, a.GetBounds, a.Mask, a.Origin, a.Pipeline, a.ScrollFactor, a.Tint, a.Transform, a.Visible, d],
						initialize: function(t, e, i, n, o, a, u) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 32), void 0 === o && (o = 32), l.call(this, t, "RenderTexture"), this.renderer = t.sys.game.renderer, this.textureManager = t.sys.textures, this.globalTint = 16777215, this.globalAlpha = 1, this.canvas = null, this.framebuffer = null, this.dirty = !1, this._crop = this.resetCropObject(), this.texture = null, this.frame = null, this._saved = !1, void 0 === a ? (this.canvas = r.create2D(this, n, o), this.texture = t.sys.textures.addCanvas(p(), this.canvas), this.frame = this.texture.get()) : (this.texture = t.sys.textures.get(a), this.frame = this.texture.get(u), this.canvas = this.frame.source.image, this._saved = !0, this.dirty = !0, this.width = this.frame.cutWidth, this.height = this.frame.cutHeight), this.context = this.canvas.getContext("2d"), this._eraseMode = !1, this.camera = new s(0, 0, n, o), this.gl = null, this.glTexture = null;
							var d, f = this.renderer;
							f ? f.type === h.WEBGL ? (d = f.gl, this.gl = d, this.glTexture = this.frame.source.glTexture, this.drawGameObject = this.batchGameObjectWebGL, this.framebuffer = f.createFramebuffer(n, o, this.glTexture, !1)) : f.type === h.CANVAS && (this.drawGameObject = this.batchGameObjectCanvas) : this.drawGameObject = c, this.camera.setScene(t), this.setPosition(e, i), void 0 === a && this.setSize(n, o), this.setOrigin(0, 0), this.initPipeline()
						},
						setSize: function(t, e) {
							return this.resize(t, e)
						},
						resize: function(t, e) {
							var i, n, s;
							void 0 === e && (e = t), t !== this.width || e !== this.height ? "__BASE" === this.frame.name && (this.canvas.width = t, this.canvas.height = e, this.texture.width = t, this.texture.height = e, this.gl && (i = this.gl, this.renderer.deleteTexture(this.frame.source.glTexture), this.renderer.deleteFramebuffer(this.framebuffer), n = this.renderer.createTexture2D(0, i.NEAREST, i.NEAREST, i.CLAMP_TO_EDGE, i.CLAMP_TO_EDGE, i.RGBA, null, t, e, !1), this.framebuffer = this.renderer.createFramebuffer(t, e, n, !1), this.frame.source.isRenderTexture = !0, this.frame.glTexture = n, this.glTexture = n), this.frame.source.width = t, this.frame.source.height = e, this.camera.setSize(t, e), this.frame.setSize(t, e), this.width = t, this.height = e) : (s = this.texture.getSourceImage(), this.frame.cutX + t > s.width && (t = s.width - this.frame.cutX), this.frame.cutY + e > s.height && (e = s.height - this.frame.cutY), this.frame.setSize(t, e, this.frame.cutX, this.frame.cutY)), this.updateDisplayOrigin();
							var r = this.input;
							return r && !r.customHitArea && (r.hitArea.width = t, r.hitArea.height = e), this
						},
						setGlobalTint: function(t) {
							return this.globalTint = t, this
						},
						setGlobalAlpha: function(t) {
							return this.globalAlpha = t, this
						},
						saveTexture: function(t) {
							return this.textureManager.renameTexture(this.texture.key, t), this._saved = !0, this.texture
						},
						fill: function(t, e, i, n, s, r) {
							void 0 === e && (e = 1), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = this.frame.cutWidth), void 0 === r && (r = this.frame.cutHeight);
							var o, a, h, u, l, c = 255 & (t >> 16 | 0),
								d = 255 & (t >> 8 | 0),
								p = 255 & (0 | t),
								g = this.gl,
								v = this.frame;
							return this.camera.preRender(1, 1), g ? (o = this.camera._cx, a = this.camera._cy, h = this.camera._cw, u = this.camera._ch, this.renderer.setFramebuffer(this.framebuffer, !1), this.renderer.pushScissor(o, a, h, u, u), (l = this.pipeline).projOrtho(0, this.texture.width, 0, this.texture.height, -1e3, 1e3), l.drawFillRect(i, n, s, r, f.getTintFromFloats(c / 255, d / 255, p / 255, 1), e), this.renderer.setFramebuffer(null, !1), this.renderer.popScissor(), l.projOrtho(0, l.width, l.height, 0, -1e3, 1e3)) : (this.renderer.setContext(this.context), this.context.fillStyle = "rgba(" + c + "," + d + "," + p + "," + e + ")", this.context.fillRect(i + v.cutX, n + v.cutY, s, r), this.renderer.setContext()), this.dirty = !0, this
						},
						clear: function() {
							var t, e, i;
							return this.dirty && ((t = this.gl) ? ((e = this.renderer).setFramebuffer(this.framebuffer, !0), this.frame.cutWidth === this.canvas.width && this.frame.cutHeight === this.canvas.height || t.scissor(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight), t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), e.setFramebuffer(null, !0)) : ((i = this.context).save(), i.setTransform(1, 0, 0, 1, 0, 0), i.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight), i.restore()), this.dirty = !1), this
						},
						erase: function(t, e, i) {
							this._eraseMode = !0;
							var s = this.renderer.currentBlendMode;
							return this.renderer.setBlendMode(n.ERASE), this.draw(t, e, i, 1, 16777215), this.renderer.setBlendMode(s), this._eraseMode = !1, this
						},
						draw: function(t, e, i, n, s) {
							void 0 === n && (n = this.globalAlpha), s = void 0 === s ? (this.globalTint >> 16) + (65280 & this.globalTint) + ((255 & this.globalTint) << 16) : (s >> 16) + (65280 & s) + ((255 & s) << 16), Array.isArray(t) || (t = [t]);
							var r, o, a, h, u, l = this.gl;
							return this.camera.preRender(1, 1), l ? (r = this.camera._cx, o = this.camera._cy, a = this.camera._cw, h = this.camera._ch, this.renderer.setFramebuffer(this.framebuffer, !1), this.renderer.pushScissor(r, o, a, h, h), (u = this.pipeline).projOrtho(0, this.texture.width, 0, this.texture.height, -1e3, 1e3), this.batchList(t, e, i, n, s), u.flush(), this.renderer.setFramebuffer(null, !1), this.renderer.popScissor(), u.projOrtho(0, u.width, u.height, 0, -1e3, 1e3)) : (this.renderer.setContext(this.context), this.batchList(t, e, i, n, s), this.renderer.setContext()), this.dirty = !0, this
						},
						drawFrame: function(t, e, i, n, s, r) {
							void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = this.globalAlpha), r = void 0 === r ? (this.globalTint >> 16) + (65280 & this.globalTint) + ((255 & this.globalTint) << 16) : (r >> 16) + (65280 & r) + ((255 & r) << 16);
							var o, a, h, u, l, c = this.gl,
								d = this.textureManager.getFrame(t, e);
							return d && (this.camera.preRender(1, 1), c ? (o = this.camera._cx, a = this.camera._cy, h = this.camera._cw, u = this.camera._ch, this.renderer.setFramebuffer(this.framebuffer, !1), this.renderer.pushScissor(o, a, h, u, u), (l = this.pipeline).projOrtho(0, this.texture.width, 0, this.texture.height, -1e3, 1e3), l.batchTextureFrame(d, i + this.frame.cutX, n + this.frame.cutY, r, s, this.camera.matrix, null), l.flush(), this.renderer.setFramebuffer(null, !1), this.renderer.popScissor(), l.projOrtho(0, l.width, l.height, 0, -1e3, 1e3)) : this.batchTextureFrame(d, i + this.frame.cutX, n + this.frame.cutY, s, r), this.dirty = !0), this
						},
						batchList: function(t, e, i, n, s) {
							for (var r = 0; r < t.length; r++) {
								var o = t[r];
								o && o !== this && (o.renderWebGL || o.renderCanvas ? this.drawGameObject(o, e, i) : o.isParent || o.list ? this.batchGroup(o.getChildren(), e, i) : "string" == typeof o ? this.batchTextureFrameKey(o, null, e, i, n, s) : o instanceof u ? this.batchTextureFrame(o, e, i, n, s) : Array.isArray(o) && this.batchList(o, e, i, n, s))
							}
						},
						batchGroup: function(t, e, i) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), e += this.frame.cutX, i += this.frame.cutY;
							for (var n = 0; n < t.length; n++) {
								var s, r, o = t[n];
								o.willRender() && (s = o.x + e, r = o.y + i, this.drawGameObject(o, s, r))
							}
						},
						batchGameObjectWebGL: function(t, e, i) {
							void 0 === e && (e = t.x), void 0 === i && (i = t.y);
							var n = t.x,
								s = t.y;
							this._eraseMode || this.renderer.setBlendMode(t.blendMode), t.setPosition(e + this.frame.cutX, i + this.frame.cutY), t.renderWebGL(this.renderer, t, 0, this.camera, null), t.setPosition(n, s)
						},
						batchGameObjectCanvas: function(t, e, i) {
							void 0 === e && (e = t.x), void 0 === i && (i = t.y);
							var s, r = t.x,
								o = t.y;
							this._eraseMode && (s = t.blendMode, t.blendMode = n.ERASE), t.setPosition(e + this.frame.cutX, i + this.frame.cutY), t.renderCanvas(this.renderer, t, 0, this.camera, null), t.setPosition(r, o), this._eraseMode && (t.blendMode = s)
						},
						batchTextureFrameKey: function(t, e, i, n, s, r) {
							var o = this.textureManager.getFrame(t, e);
							o && this.batchTextureFrame(o, i, n, s, r)
						},
						batchTextureFrame: function(t, e, i, n, s) {
							var r, o, a, h;
							void 0 === e && (e = 0), void 0 === i && (i = 0), e += this.frame.cutX, i += this.frame.cutY, this.gl ? this.pipeline.batchTextureFrame(t, e, i, s, n, this.camera.matrix, null) : (r = this.context, o = t.canvasData, a = t.source.image, h = this.camera.matrix, r.globalAlpha = this.globalAlpha, r.setTransform(h[0], h[1], h[2], h[3], h[4], h[5]), r.drawImage(a, o.x, o.y, o.width, o.height, e, i, o.width, o.height))
						},
						snapshotArea: function(t, e, i, n, s, r, o) {
							return this.gl ? this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, s, !1, t, e, i, n, r, o) : this.renderer.snapshotCanvas(this.canvas, s, !1, t, e, i, n, r, o), this
						},
						snapshot: function(t, e, i) {
							return this.gl ? this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, t, !1, 0, 0, this.width, this.height, e, i) : this.renderer.snapshotCanvas(this.canvas, t, !1, 0, 0, this.width, this.height, e, i), this
						},
						snapshotPixel: function(t, e, i) {
							return this.gl ? this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, i, !0, t, e) : this.renderer.snapshotCanvas(this.canvas, i, !0, t, e), this
						},
						preDestroy: function() {
							this._saved || (r.remove(this.canvas), this.gl && this.renderer.deleteFramebuffer(this.framebuffer), this.texture.destroy(), this.camera.destroy(), this.canvas = null, this.context = null, this.framebuffer = null, this.texture = null, this.glTexture = null)
						}
					});
				t.exports = g
			}, function(t, e) {
				t.exports = function() {
					return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
						var e = 16 * Math.random() | 0;
						return ("x" === t ? e : 3 & e | 8).toString(16)
					})
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(14),
					o = i(985),
					a = i(3),
					h = new n({
						Extends: r,
						Mixins: [s.AlphaSingle, s.BlendMode, s.Depth, s.Flip, s.Mask, s.Pipeline, s.Size, s.Texture, s.Transform, s.Visible, s.ScrollFactor, o],
						initialize: function(t, e, i, n, o, h, u, l, c) {
							void 0 === n && (n = "__DEFAULT"), void 0 === h && (h = 2), void 0 === u && (u = !0), r.call(this, t, "Rope"), this.anims = new s.Animation(this), this.points = h, this.vertices, this.uv, this.colors, this.alphas, this.tintFill = "__DEFAULT" === n ? 2 : 0, this.dirty = !1, this.horizontal = u, this._flipX = !1, this._flipY = !1, this._perp = new a, this.debugCallback = null, this.debugGraphic = null, this.setTexture(n, o), this.setPosition(e, i), this.setSizeToFrame(), this.initPipeline("TextureTintStripPipeline"), Array.isArray(h) && this.resizeArrays(h.length), this.setPoints(h, l, c), this.updateVertices()
						},
						preUpdate: function(t, e) {
							var i = this.anims.currentFrame;
							this.anims.update(t, e), this.anims.currentFrame !== i && (this.updateUVs(), this.updateVertices())
						},
						play: function(t, e, i) {
							return this.anims.play(t, e, i), this
						},
						setDirty: function() {
							return this.dirty = !0, this
						},
						setHorizontal: function(t, e, i) {
							return void 0 === t && (t = this.points.length), this.horizontal ? this : (this.horizontal = !0, this.setPoints(t, e, i))
						},
						setVertical: function(t, e, i) {
							return void 0 === t && (t = this.points.length), this.horizontal ? (this.horizontal = !1, this.setPoints(t, e, i)) : this
						},
						setTintFill: function(t) {
							return void 0 === t && (t = 0), this.tintFill = t, this
						},
						setAlphas: function(t, e) {
							var i = this.points.length;
							if (i < 1) return this;
							var n = this.alphas;
							void 0 === t ? t = [1] : Array.isArray(t) || void 0 !== e || (t = [t]);
							var s = 0;
							if (void 0 !== e)
								for (o = 0; o < i; o++) n[s = 2 * o] = t, n[s + 1] = e;
							else if (t.length === i)
								for (o = 0; o < i; o++) n[s = 2 * o] = t[o], n[s + 1] = t[o];
							else
								for (var r = t[0], o = 0; o < i; o++) s = 2 * o, t.length > s && (r = t[s]), n[s] = r, t.length > s + 1 && (r = t[s + 1]), n[s + 1] = r;
							return this
						},
						setColors: function(t) {
							var e = this.points.length;
							if (e < 1) return this;
							var i = this.colors;
							void 0 === t ? t = [16777215] : Array.isArray(t) || (t = [t]);
							var n = 0;
							if (t.length === e)
								for (r = 0; r < e; r++) i[n = 2 * r] = t[r], i[n + 1] = t[r];
							else
								for (var s = t[0], r = 0; r < e; r++) n = 2 * r, t.length > n && (s = t[n]), i[n] = s, t.length > n + 1 && (s = t[n + 1]), i[n + 1] = s;
							return this
						},
						setPoints: function(t, e, i) {
							if (void 0 === t && (t = 2), "number" == typeof t) {
								var n, s, r, o = t;
								if (o < 2 && (o = 2), t = [], this.horizontal)
									for (r = -this.frame.halfWidth, s = this.frame.width / (o - 1), n = 0; n < o; n++) t.push({
										x: r + n * s,
										y: 0
									});
								else
									for (r = -this.frame.halfHeight, s = this.frame.height / (o - 1), n = 0; n < o; n++) t.push({
										x: 0,
										y: r + n * s
									})
							}
							var a = t.length,
								h = this.points.length;
							return a < 1 ? console.warn("Rope: Not enough points given") : (1 === a && (t.unshift({
								x: 0,
								y: 0
							}), a++), h !== a && this.resizeArrays(a), this.points = t, this.updateUVs(), null != e && this.setColors(e), null != i && this.setAlphas(i)), this
						},
						updateUVs: function() {
							for (var t = this.uv, e = this.points.length, i = this.frame.u0, n = this.frame.v0, s = this.frame.u1, r = this.frame.v1, o = (s - i) / (e - 1), a = (r - n) / (e - 1), h = 0; h < e; h++) {
								var u, l, c, d = 4 * h,
									f = this.horizontal ? (c = u = this._flipX ? s - h * o : i + h * o, this._flipY ? (l = r, n) : (l = n, r)) : (c = this._flipX ? (u = i, s) : (u = s, i), l = this._flipY ? r - h * a : n + h * a);
								t[0 + d] = u, t[1 + d] = l, t[2 + d] = c, t[3 + d] = f
							}
							return this
						},
						resizeArrays: function(t) {
							var e = this.colors,
								i = this.alphas;
							this.vertices = new Float32Array(4 * t), this.uv = new Float32Array(4 * t), e = new Uint32Array(2 * t), i = new Float32Array(2 * t);
							for (var n = 0; n < 2 * t; n++) e[n] = 16777215, i[n] = 1;
							return this.colors = e, this.alphas = i, this.dirty = !0, this
						},
						updateVertices: function() {
							var t = this._perp,
								e = this.points,
								i = this.vertices,
								n = e.length;
							if (this.dirty = !1, !(n < 1)) {
								for (var s = e[0], r = this.horizontal ? this.frame.halfHeight : this.frame.halfWidth, o = 0; o < n; o++) {
									var a = e[o],
										h = 4 * o,
										u = o < n - 1 ? e[o + 1] : a;
									t.x = u.y - s.y, t.y = -(u.x - s.x);
									var l = t.length();
									t.x /= l, t.y /= l, t.x *= r, t.y *= r, i[h] = a.x + t.x, i[1 + h] = a.y + t.y, i[2 + h] = a.x - t.x, i[3 + h] = a.y - t.y, s = a
								}
								return this
							}
						},
						setDebug: function(t, e) {
							return this.debugGraphic = t, this.debugCallback = t || e ? e || this.renderDebugVerts : null, this
						},
						renderDebugVerts: function(t, e, i) {
							var n = t.debugGraphic,
								s = i[0],
								r = i[1],
								o = i[2],
								a = i[3];
							n.lineBetween(s, r, o, a);
							for (var h = 4; h < e; h += 4) {
								var u = i[h + 0],
									l = i[h + 1],
									c = i[h + 2],
									d = i[h + 3];
								n.lineBetween(s, r, u, l), n.lineBetween(o, a, c, d), n.lineBetween(o, a, u, l), n.lineBetween(u, l, c, d), s = u, r = l, o = c, a = d
							}
						},
						preDestroy: function() {
							this.anims.destroy(), this.anims = void 0, this.points = null, this.vertices = null, this.uv = null, this.colors = null, this.alphas = null, this.debugCallback = null, this.debugGraphic = null
						},
						flipX: {
							get: function() {
								return this._flipX
							},
							set: function(t) {
								return this._flipX = t, this.updateUVs()
							}
						},
						flipY: {
							get: function() {
								return this._flipY
							},
							set: function(t) {
								return this._flipY = t, this.updateUVs()
							}
						}
					});
				t.exports = h
			}, function(t, e, i) {
				var n = i(122),
					s = i(26),
					r = i(0),
					o = i(12),
					a = i(20),
					h = i(14),
					u = i(988),
					l = i(6),
					c = i(178),
					d = i(989),
					f = i(992),
					p = new r({
						Extends: h,
						Mixins: [o.Alpha, o.BlendMode, o.ComputedSize, o.Crop, o.Depth, o.Flip, o.GetBounds, o.Mask, o.Origin, o.Pipeline, o.ScrollFactor, o.Tint, o.Transform, o.Visible, d],
						initialize: function(t, e, i, n, r) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), h.call(this, t, "Text"), this.renderer = t.sys.game.renderer, this.setPosition(e, i), this.setOrigin(0, 0), this.initPipeline(), this.canvas = s.create(this), this.context = this.canvas.getContext("2d"), this.style = new f(this, r), this.autoRound = !0, this.splitRegExp = /(?:\r\n|\r|\n)/, this._text = void 0, this.padding = {
								left: 0,
								right: 0,
								top: 0,
								bottom: 0
							}, this.width = 1, this.height = 1, this.lineSpacing = 0, this.dirty = !1, 0 === this.style.resolution && (this.style.resolution = t.sys.game.config.resolution), this._crop = this.resetCropObject(), this.texture = t.sys.textures.addCanvas(null, this.canvas, !0), this.frame = this.texture.get(), this.frame.source.resolution = this.style.resolution, this.renderer && this.renderer.gl && (this.renderer.deleteTexture(this.frame.source.glTexture), this.frame.source.glTexture = null), this.initRTL(), this.setText(n), r && r.padding && this.setPadding(r.padding), r && r.lineSpacing && this.setLineSpacing(r.lineSpacing), t.sys.game.events.on(a.CONTEXT_RESTORED, function() {
								this.dirty = !0
							}, this)
						},
						initRTL: function() {
							this.style.rtl && (this.canvas.dir = "rtl", this.context.direction = "rtl", this.canvas.style.display = "none", n(this.canvas, this.scene.sys.canvas), this.originX = 1)
						},
						runWordWrap: function(t) {
							var e = this.style;
							if (e.wordWrapCallback) {
								var i = e.wordWrapCallback.call(e.wordWrapCallbackScope, t, this);
								return Array.isArray(i) && (i = i.join("\n")), i
							}
							return e.wordWrapWidth ? e.wordWrapUseAdvanced ? this.advancedWordWrap(t, this.context, this.style.wordWrapWidth) : this.basicWordWrap(t, this.context, this.style.wordWrapWidth) : t
						},
						advancedWordWrap: function(t, e, i) {
							for (var n = "", s = t.replace(/ +/gi, " ").split(this.splitRegExp), r = s.length, o = 0; o < r; o++) {
								var a = "",
									h = (h = s[o]).replace(/^ *|\s*$/gi, "");
								if (e.measureText(h).width < i) n += h + "\n";
								else {
									for (var u = i, l = h.split(" "), c = 0; c < l.length; c++) {
										var d = l[c],
											f = d + " ",
											p = e.measureText(f).width;
										if (u < p) {
											if (0 === c) {
												for (var g = f; g.length && (g = g.slice(0, -1), !((p = e.measureText(g).width) <= u)););
												if (!g.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
												var v = d.substr(g.length);
												l[c] = v, a += g
											}
											var m = l[c].length ? c : c + 1,
												y = l.slice(m).join(" ").replace(/[ \n]*$/gi, "");
											s[o + 1] = y + " " + (s[o + 1] || ""), r = s.length;
											break
										}
										a += f, u -= p
									}
									n += a.replace(/[ \n]*$/gi, "") + "\n"
								}
							}
							return n.replace(/[\s|\n]*$/gi, "")
						},
						basicWordWrap: function(t, e, i) {
							for (var n = "", s = t.split(this.splitRegExp), r = s.length - 1, o = e.measureText(" ").width, a = 0; a <= r; a++) {
								for (var h = i, u = s[a].split(" "), l = u.length - 1, c = 0; c <= l; c++) {
									var d = u[c],
										f = e.measureText(d).width,
										p = f + o;
									h < p && 0 < c && (n += "\n", h = i), n += d, c < l ? (n += " ", h -= p) : h -= f
								}
								a < r && (n += "\n")
							}
							return n
						},
						getWrappedText: function(t) {
							return void 0 === t && (t = this._text), this.style.syncFont(this.canvas, this.context), this.runWordWrap(t).split(this.splitRegExp)
						},
						setText: function(t) {
							return t || 0 === t || (t = ""), Array.isArray(t) && (t = t.join("\n")), t !== this._text && (this._text = t.toString(), this.updateText()), this
						},
						setStyle: function(t) {
							return this.style.setStyle(t)
						},
						setFont: function(t) {
							return this.style.setFont(t)
						},
						setFontFamily: function(t) {
							return this.style.setFontFamily(t)
						},
						setFontSize: function(t) {
							return this.style.setFontSize(t)
						},
						setFontStyle: function(t) {
							return this.style.setFontStyle(t)
						},
						setFixedSize: function(t, e) {
							return this.style.setFixedSize(t, e)
						},
						setBackgroundColor: function(t) {
							return this.style.setBackgroundColor(t)
						},
						setFill: function(t) {
							return this.style.setFill(t)
						},
						setColor: function(t) {
							return this.style.setColor(t)
						},
						setStroke: function(t, e) {
							return this.style.setStroke(t, e)
						},
						setShadow: function(t, e, i, n, s, r) {
							return this.style.setShadow(t, e, i, n, s, r)
						},
						setShadowOffset: function(t, e) {
							return this.style.setShadowOffset(t, e)
						},
						setShadowColor: function(t) {
							return this.style.setShadowColor(t)
						},
						setShadowBlur: function(t) {
							return this.style.setShadowBlur(t)
						},
						setShadowStroke: function(t) {
							return this.style.setShadowStroke(t)
						},
						setShadowFill: function(t) {
							return this.style.setShadowFill(t)
						},
						setWordWrapWidth: function(t, e) {
							return this.style.setWordWrapWidth(t, e)
						},
						setWordWrapCallback: function(t, e) {
							return this.style.setWordWrapCallback(t, e)
						},
						setAlign: function(t) {
							return this.style.setAlign(t)
						},
						setResolution: function(t) {
							return this.style.setResolution(t)
						},
						setLineSpacing: function(t) {
							return this.lineSpacing = t, this.updateText()
						},
						setPadding: function(t, e, i, n) {
							var s, r, o;
							return "object" == typeof t ? (i = null !== (r = l(s = t, "x", null)) ? t = r : (t = l(s, "left", 0), l(s, "right", t)), n = null !== (o = l(s, "y", null)) ? e = o : (e = l(s, "top", 0), l(s, "bottom", e))) : (void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = t), void 0 === n && (n = e)), this.padding.left = t, this.padding.top = e, this.padding.right = i, this.padding.bottom = n, this.updateText()
						},
						setMaxLines: function(t) {
							return this.style.setMaxLines(t)
						},
						updateText: function() {
							var t = this.canvas,
								e = this.context,
								i = this.style,
								n = i.resolution,
								s = i.metrics;
							i.syncFont(t, e);
							var r = this._text;
							(i.wordWrapWidth || i.wordWrapCallback) && (r = this.runWordWrap(this._text));
							var o, a = r.split(this.splitRegExp),
								h = u(this, s, a),
								l = this.padding;
							0 === i.fixedWidth ? (this.width = h.width + l.left + l.right, o = h.width) : (this.width = i.fixedWidth, (o = this.width - l.left - l.right) < h.width && (o = h.width)), 0 === i.fixedHeight ? this.height = h.height + l.top + l.bottom : this.height = i.fixedHeight;
							var c, d, f = this.width,
								p = this.height;
							this.updateDisplayOrigin(), f *= n, p *= n, f = Math.max(f, 1), p = Math.max(p, 1), t.width !== f || t.height !== p ? (t.width = f, t.height = p, this.frame.setSize(f, p), i.syncFont(t, e)) : e.clearRect(0, 0, f, p), e.save(), e.scale(n, n), i.backgroundColor && (e.fillStyle = i.backgroundColor, e.fillRect(0, 0, f, p)), i.syncStyle(t, e), e.textBaseline = "alphabetic", e.translate(l.left, l.top);
							for (var g = 0; g < h.lines; g++) {
								if (c = i.strokeThickness / 2, d = i.strokeThickness / 2 + g * h.lineHeight + s.ascent, 0 < g && (d += h.lineSpacing * g), i.rtl) c = f - c;
								else if ("right" === i.align) c += o - h.lineWidths[g];
								else if ("center" === i.align) c += (o - h.lineWidths[g]) / 2;
								else if ("justify" === i.align && .85 <= h.lineWidths[g] / h.width) {
									var v = h.width - h.lineWidths[g],
										m = e.measureText(" ").width,
										y = a[g].trim(),
										x = y.split(" ");
									v += (a[g].length - y.length) * m;
									for (var T = Math.floor(v / m), w = 0; 0 < T;) x[w] += " ", w = (w + 1) % (x.length - 1 || 1), --T;
									a[g] = x.join(" ")
								}
								this.autoRound && (c = Math.round(c), d = Math.round(d)), i.strokeThickness && (this.style.syncShadow(e, i.shadowStroke), e.strokeText(a[g], c, d)), i.color && (this.style.syncShadow(e, i.shadowFill), e.fillText(a[g], c, d))
							}
							e.restore(), this.renderer && this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(t, this.frame.source.glTexture, !0), this.frame.glTexture = this.frame.source.glTexture), this.dirty = !0;
							var E = this.input;
							return E && !E.customHitArea && (E.hitArea.width = this.width, E.hitArea.height = this.height), this
						},
						getTextMetrics: function() {
							return this.style.getTextMetrics()
						},
						text: {
							get: function() {
								return this._text
							},
							set: function(t) {
								this.setText(t)
							}
						},
						toJSON: function() {
							var t = o.ToJSON(this),
								e = {
									autoRound: this.autoRound,
									text: this._text,
									style: this.style.toJSON(),
									padding: {
										left: this.padding.left,
										right: this.padding.right,
										top: this.padding.top,
										bottom: this.padding.bottom
									}
								};
							return t.data = e, t
						},
						preDestroy: function() {
							this.style.rtl && c(this.canvas), s.remove(this.canvas), this.texture.destroy()
						}
					});
				t.exports = p
			}, function(t, e, i) {
				var n = i(26),
					s = i(0),
					r = i(12),
					o = i(20),
					a = i(14),
					h = i(329),
					u = i(167),
					l = i(994),
					c = i(3),
					d = new s({
						Extends: a,
						Mixins: [r.Alpha, r.BlendMode, r.ComputedSize, r.Crop, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.ScrollFactor, r.Tint, r.Transform, r.Visible, l],
						initialize: function(t, e, i, s, r, u, l) {
							var d = t.sys.game.renderer;
							a.call(this, t, "TileSprite");
							var f = t.sys.textures.get(u),
								p = f.get(l);
							r = s && r ? (s = Math.floor(s), Math.floor(r)) : (s = p.width, p.height), this._tilePosition = new c, this._tileScale = new c(1, 1), this.dirty = !1, this.renderer = d, this.canvas = n.create(this, s, r), this.context = this.canvas.getContext("2d"), this.displayTexture = f, this.displayFrame = p, this._crop = this.resetCropObject(), this.texture = t.sys.textures.addCanvas(null, this.canvas, !0), this.frame = this.texture.get(), this.potWidth = h(p.width), this.potHeight = h(p.height), this.fillCanvas = n.create2D(this, this.potWidth, this.potHeight), this.fillContext = this.fillCanvas.getContext("2d"), this.fillPattern = null, this.setPosition(e, i), this.setSize(s, r), this.setFrame(l), this.setOriginFromFrame(), this.initPipeline(), t.sys.game.events.on(o.CONTEXT_RESTORED, function(t) {
								var e = t.gl;
								this.dirty = !0, this.fillPattern = null, this.fillPattern = t.createTexture2D(0, e.LINEAR, e.LINEAR, e.REPEAT, e.REPEAT, e.RGBA, this.fillCanvas, this.potWidth, this.potHeight)
							}, this)
						},
						setTexture: function(t, e) {
							return this.displayTexture = this.scene.sys.textures.get(t), this.setFrame(e)
						},
						setFrame: function(t) {
							var e = this.displayTexture.get(t);
							return this.potWidth = h(e.width), this.potHeight = h(e.height), this.canvas.width = 0, e.cutWidth && e.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this.displayFrame = e, this.dirty = !0, this.updateTileTexture(), this
						},
						setTilePosition: function(t, e) {
							return void 0 !== t && (this.tilePositionX = t), void 0 !== e && (this.tilePositionY = e), this
						},
						setTileScale: function(t, e) {
							return void 0 === t && (t = this.tileScaleX), void 0 === e && (e = t), this.tileScaleX = t, this.tileScaleY = e, this
						},
						updateTileTexture: function() {
							if (this.dirty && this.renderer) {
								var t = this.displayFrame;
								if (t.source.isRenderTexture || t.source.isGLTexture) return console.warn("TileSprites can only use Image or Canvas based textures"), void(this.dirty = !1);
								var e = this.fillContext,
									i = this.fillCanvas,
									n = this.potWidth,
									s = this.potHeight;
								this.renderer.gl || (n = t.cutWidth, s = t.cutHeight), e.clearRect(0, 0, n, s), i.width = n, i.height = s, e.drawImage(t.source.image, t.cutX, t.cutY, t.cutWidth, t.cutHeight, 0, 0, n, s), this.renderer.gl ? this.fillPattern = this.renderer.canvasToTexture(i, this.fillPattern) : this.fillPattern = e.createPattern(i, "repeat"), this.updateCanvas(), this.dirty = !1
							}
						},
						updateCanvas: function() {
							var t, e, i, n, s, r = this.canvas;
							r.width === this.width && r.height === this.height || (r.width = this.width, r.height = this.height, this.frame.setSize(this.width, this.height), this.updateDisplayOrigin(), this.dirty = !0), !this.dirty || this.renderer && this.renderer.gl || (t = this.context, this.scene.sys.game.config.antialias || u.disable(t), e = this._tileScale.x, i = this._tileScale.y, n = this._tilePosition.x, s = this._tilePosition.y, t.clearRect(0, 0, this.width, this.height), t.save(), t.scale(e, i), t.translate(-n, -s), t.fillStyle = this.fillPattern, t.fillRect(n, s, this.width / e, this.height / i), t.restore()), this.dirty = !1
						},
						preDestroy: function() {
							this.renderer && this.renderer.gl && this.renderer.deleteTexture(this.fillPattern), n.remove(this.canvas), n.remove(this.fillCanvas), this.fillPattern = null, this.fillContext = null, this.fillCanvas = null, this.displayTexture = null, this.displayFrame = null, this.texture.destroy(), this.renderer = null
						},
						tilePositionX: {
							get: function() {
								return this._tilePosition.x
							},
							set: function(t) {
								this._tilePosition.x = t, this.dirty = !0
							}
						},
						tilePositionY: {
							get: function() {
								return this._tilePosition.y
							},
							set: function(t) {
								this._tilePosition.y = t, this.dirty = !0
							}
						},
						tileScaleX: {
							get: function() {
								return this._tileScale.x
							},
							set: function(t) {
								this._tileScale.x = t, this.dirty = !0
							}
						},
						tileScaleY: {
							get: function() {
								return this._tileScale.y
							},
							set: function(t) {
								this._tileScale.y = t, this.dirty = !0
							}
						}
					});
				t.exports = d
			}, function(t, e, i) {
				var n = i(0),
					s = i(19),
					r = i(12),
					o = i(90),
					a = i(20),
					h = i(14),
					u = i(59),
					l = i(196),
					c = i(997),
					d = i(13),
					f = new n({
						Extends: h,
						Mixins: [r.Alpha, r.BlendMode, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.ScrollFactor, r.Size, r.TextureCrop, r.Tint, r.Transform, r.Visible, c],
						initialize: function(t, e, i, n) {
							h.call(this, t, "Video"), this.video = null, this.videoTexture = null, this.videoTextureSource = null, this.snapshotTexture = null, this.flipY = !1, this._key = l(), this.touchLocked = !0, this.playWhenUnlocked = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._systemMuted = !1, this._codeMuted = !1, this._systemPaused = !1, this._codePaused = !1, this._callbacks = {
								play: this.playHandler.bind(this),
								error: this.loadErrorHandler.bind(this),
								end: this.completeHandler.bind(this),
								time: this.timeUpdateHandler.bind(this),
								seeking: this.seekingHandler.bind(this),
								seeked: this.seekedHandler.bind(this)
							}, this._crop = this.resetCropObject(), this.markers = {}, this._markerIn = -1, this._markerOut = d.MAX_SAFE_INTEGER, this._lastUpdate = 0, this._cacheKey = "", this._isSeeking = !1, this.removeVideoElementOnDestroy = !1, this.setPosition(e, i), this.initPipeline(), n && this.changeSource(n, !1);
							var s = t.sys.game.events;
							s.on(a.PAUSE, this.globalPause, this), s.on(a.RESUME, this.globalResume, this);
							var r = t.sys.sound;
							r && r.on(u.GLOBAL_MUTE, this.globalMute, this)
						},
						play: function(t, e, i) {
							if (this.touchLocked && this.playWhenUnlocked || this.isPlaying()) return this;
							var n = this.video;
							if (!n) return console.warn("Video not loaded"), this;
							void 0 === t && (t = n.loop);
							var s = this.scene.sys.sound;
							s && s.mute && this.setMute(!0), isNaN(e) || (this._markerIn = e), !isNaN(i) && e < i && (this._markerOut = i), n.loop = t;
							var r = this._callbacks,
								o = n.play();
							return void 0 !== o ? o.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this)) : (n.addEventListener("playing", r.play, !0), n.readyState < 2 && (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval))), n.addEventListener("ended", r.end, !0), n.addEventListener("timeupdate", r.time, !0), n.addEventListener("seeking", r.seeking, !0), n.addEventListener("seeked", r.seeked, !0), this
						},
						changeSource: function(t, e, i, n, s) {
							void 0 === e && (e = !0), this.video && this.stop();
							var r = this.scene.sys.cache.video.get(t);
							return r ? (this.video = r, this._cacheKey = t, this._codePaused = r.paused, this._codeMuted = r.muted, this.videoTexture ? (this.scene.sys.textures.remove(this._key), this.videoTexture = this.scene.sys.textures.create(this._key, r, r.videoWidth, r.videoHeight), this.videoTextureSource = this.videoTexture.source[0], this.videoTexture.add("__BASE", 0, 0, 0, r.videoWidth, r.videoHeight), this.setTexture(this.videoTexture), this.setSizeToFrame(), this.updateDisplayOrigin(), this.emit(o.VIDEO_CREATED, this, r.videoWidth, r.videoHeight)) : this.updateTexture(), r.currentTime = 0, this._lastUpdate = 0, e && this.play(i, n, s)) : this.video = null, this
						},
						addMarker: function(t, e, i) {
							return !isNaN(e) && 0 <= e && !isNaN(i) && (this.markers[t] = [e, i]), this
						},
						playMarker: function(t, e) {
							var i = this.markers[t];
							return i && this.play(e, i[0], i[1]), this
						},
						removeMarker: function(t) {
							return delete this.markers[t], this
						},
						snapshot: function(t, e) {
							return void 0 === t && (t = this.width), void 0 === e && (e = this.height), this.snapshotArea(0, 0, this.width, this.height, t, e)
						},
						snapshotArea: function(t, e, i, n, s, r) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === n && (n = this.height), void 0 === s && (s = i), void 0 === r && (r = n);
							var o = this.video,
								a = this.snapshotTexture;
							return a ? a.setSize(s, r) : (a = this.scene.sys.textures.createCanvas(l(), s, r), this.snapshotTexture = a), o && a.context.drawImage(o, t, e, i, n, 0, 0, s, r), a.update()
						},
						saveSnapshotTexture: function(t) {
							return this.snapshotTexture ? this.scene.sys.textures.renameTexture(this.snapshotTexture.key, t) : this.snapshotTexture = this.scene.sys.textures.createCanvas(t, this.width, this.height), this.snapshotTexture
						},
						loadURL: function(t, e, i) {
							void 0 === e && (e = "loadeddata"), void 0 === i && (i = !1), this.video && this.stop(), this.videoTexture && this.scene.sys.textures.remove(this._key);
							var n = document.createElement("video");
							return n.controls = !1, i && (n.muted = !0, n.defaultMuted = !0, n.setAttribute("autoplay", "autoplay")), n.setAttribute("playsinline", "playsinline"), n.setAttribute("preload", "auto"), n.addEventListener("error", this._callbacks.error, !0), n.src = t, n.load(), this.video = n, this
						},
						playPromiseSuccessHandler: function() {
							this.touchLocked = !1, this.emit(o.VIDEO_PLAY, this), -1 < this._markerIn && (this.video.currentTime = this._markerIn)
						},
						playPromiseErrorHandler: function(t) {
							this.scene.sys.input.once("pointerdown", this.unlockHandler, this), this.touchLocked = !0, this.playWhenUnlocked = !0, this.emit(o.VIDEO_ERROR, this, t)
						},
						playHandler: function() {
							this.touchLocked = !1, this.emit(o.VIDEO_PLAY, this), this.video.removeEventListener("playing", this._callbacks.play, !0)
						},
						loadErrorHandler: function(t) {
							this.stop(), this.emit(o.VIDEO_ERROR, this, t)
						},
						unlockHandler: function() {
							this.touchLocked = !1, this.playWhenUnlocked = !1, this.emit(o.VIDEO_UNLOCKED, this), -1 < this._markerIn && (this.video.currentTime = this._markerIn), this.video.play(), this.emit(o.VIDEO_PLAY, this)
						},
						completeHandler: function() {
							this.emit(o.VIDEO_COMPLETE, this)
						},
						timeUpdateHandler: function() {
							this.video && this.video.currentTime < this._lastUpdate && (this.emit(o.VIDEO_LOOP, this), this._lastUpdate = 0)
						},
						preUpdate: function() {
							var t, e = this.video;
							!e || (t = e.currentTime) !== this._lastUpdate && (this._lastUpdate = t, this.updateTexture(), t >= this._markerOut && (e.loop ? (e.currentTime = this._markerIn, this.updateTexture(), this._lastUpdate = t, this.emit(o.VIDEO_LOOP, this)) : (this.emit(o.VIDEO_COMPLETE, this), this.stop())))
						},
						checkVideoProgress: function() {
							2 <= this.video.readyState ? this.updateTexture() : (this.retry--, 0 < this.retry ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : this.emit(o.VIDEO_TIMEOUT, this))
						},
						updateTexture: function() {
							var t, e = this.video,
								i = e.videoWidth,
								n = e.videoHeight;
							this.videoTexture ? ((t = this.videoTextureSource).source !== e && (t.source = e, t.width = i, t.height = n), t.update()) : (this.videoTexture = this.scene.sys.textures.create(this._key, e, i, n), this.videoTextureSource = this.videoTexture.source[0], this.videoTexture.add("__BASE", 0, 0, 0, i, n), this.setTexture(this.videoTexture), this.setSizeToFrame(), this.updateDisplayOrigin(), this.emit(o.VIDEO_CREATED, this, i, n))
						},
						getVideoKey: function() {
							return this._cacheKey
						},
						seekTo: function(t) {
							var e, i, n = this.video;
							return n && ((e = n.duration) === 1 / 0 || isNaN(e) || (i = e * t, this.setCurrentTime(i))), this
						},
						getCurrentTime: function() {
							return this.video ? this.video.currentTime : 0
						},
						setCurrentTime: function(t) {
							var e, i, n = this.video;
							return n && ("string" == typeof t && (e = t[0], i = parseFloat(t.substr(1)), "+" === e ? t = n.currentTime + i : "-" === e && (t = n.currentTime - i)), n.currentTime = t, this._lastUpdate = t), this
						},
						isSeeking: function() {
							return this._isSeeking
						},
						seekingHandler: function() {
							this._isSeeking = !0, this.emit(o.VIDEO_SEEKING, this)
						},
						seekedHandler: function() {
							this._isSeeking = !1, this.emit(o.VIDEO_SEEKED, this), this.video && this.updateTexture()
						},
						getProgress: function() {
							var t = this.video;
							if (t) {
								var e = t.currentTime,
									i = t.duration;
								if (i !== 1 / 0 && !isNaN(i)) return e / i
							}
							return 0
						},
						getDuration: function() {
							return this.video ? this.video.duration : 0
						},
						setMute: function(t) {
							void 0 === t && (t = !0), this._codeMuted = t;
							var e = this.video;
							return e && (e.muted = !!this._systemMuted || t), this
						},
						isMuted: function() {
							return this._codeMuted
						},
						globalMute: function(t, e) {
							this._systemMuted = e;
							var i = this.video;
							i && (i.muted = !!this._codeMuted || e)
						},
						globalPause: function() {
							this._systemPaused = !0, this.video && this.video.pause()
						},
						globalResume: function() {
							this._systemPaused = !1, this.video && !this._codePaused && this.video.play()
						},
						setPaused: function(t) {
							void 0 === t && (t = !0);
							var e = this.video;
							return this._codePaused = t, e && (t ? e.paused || e.pause() : t || e.paused && !this._systemPaused && e.play()), this
						},
						getVolume: function() {
							return this.video ? this.video.volume : 1
						},
						setVolume: function(t) {
							return void 0 === t && (t = 1), this.video && (this.video.volume = s(t, 0, 1)), this
						},
						getPlaybackRate: function() {
							return this.video ? this.video.playbackRate : 1
						},
						setPlaybackRate: function(t) {
							return this.video && (this.video.playbackRate = t), this
						},
						getLoop: function() {
							return !!this.video && this.video.loop
						},
						setLoop: function(t) {
							return void 0 === t && (t = !0), this.video && (this.video.loop = t), this
						},
						isPlaying: function() {
							return !!this.video && !(this.video.paused || this.video.ended)
						},
						isPaused: function() {
							return this.video && this.video.paused || this._codePaused || this._systemPaused
						},
						saveTexture: function(t, e) {
							return void 0 === e && (e = !1), this.videoTexture && this.scene.sys.textures.renameTexture(this._key, t), this._key = t, this.flipY = e, this.videoTextureSource && this.videoTextureSource.setFlipY(e), this.videoTexture
						},
						stop: function() {
							var t = this.video;
							if (t) {
								var e = this._callbacks;
								for (var i in e) t.removeEventListener(i, e[i], !0);
								t.pause()
							}
							return this._retryID && window.clearTimeout(this._retryID), this.emit(o.VIDEO_STOP, this), this
						},
						removeVideoElement: function() {
							var t = this.video;
							if (t) {
								for (t.parentNode && t.parentNode.removeChild(t); t.hasChildNodes();) t.removeChild(t.firstChild);
								t.removeAttribute("autoplay"), t.removeAttribute("src"), this.video = null
							}
						},
						preDestroy: function() {
							this.stop(), this.removeVideoElementOnDestroy && this.removeVideoElement();
							var t = this.scene.sys.game.events;
							t.off(a.PAUSE, this.globalPause, this), t.off(a.RESUME, this.globalResume, this);
							var e = this.scene.sys.sound;
							e && e.off(u.GLOBAL_MUTE, this.globalMute, this), this._retryID && window.clearTimeout(this._retryID)
						}
					});
				t.exports = f
			}, function(t, e, i) {
				var n = i(0),
					s = i(202),
					r = i(419),
					o = i(47),
					a = new n({
						initialize: function(t) {
							this.type = o.POLYGON, this.area = 0, this.points = [], t && this.setTo(t)
						},
						contains: function(t, e) {
							return s(this, t, e)
						},
						setTo: function(t) {
							if (this.area = 0, this.points = [], "string" == typeof t && (t = t.split(" ")), !Array.isArray(t)) return this;
							for (var e, i = Number.MAX_VALUE, n = 0; n < t.length; n++) e = {
								x: 0,
								y: 0
							}, "number" == typeof t[n] || "string" == typeof t[n] ? (e.x = parseFloat(t[n]), e.y = parseFloat(t[n + 1]), n++) : Array.isArray(t[n]) ? (e.x = t[n][0], e.y = t[n][1]) : (e.x = t[n].x, e.y = t[n].y), this.points.push(e), e.y < i && (i = e.y);
							return this.calculateArea(i), this
						},
						calculateArea: function() {
							if (this.points.length < 3) return this.area = 0, this.area;
							for (var t, e, i = 0, n = 0; n < this.points.length - 1; n++) t = this.points[n], i += ((e = this.points[n + 1]).x - t.x) * (t.y + e.y);
							return t = this.points[0], e = this.points[this.points.length - 1], i += (t.x - e.x) * (e.y + t.y), this.area = .5 * -i, this.area
						},
						getPoints: function(t, e, i) {
							return r(this, t, e, i)
						}
					});
				t.exports = a
			}, function(t, e) {
				t.exports = function(t, e, i) {
					for (var n = !1, s = -1, r = t.points.length - 1; ++s < t.points.length; r = s) {
						var o = t.points[s].x,
							a = t.points[s].y,
							h = t.points[r].x,
							u = t.points[r].y;
						(a <= i && i < u || u <= i && i < a) && e < (h - o) * (i - a) / (u - a) + o && (n = !n)
					}
					return n
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(134),
					r = new n({
						Extends: s,
						initialize: function(t, e, i, n, r) {
							s.call(this, t, e, i, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0], [16777215, 16777215, 16777215, 16777215, 16777215, 16777215], [1, 1, 1, 1, 1, 1], n, r), this.resetPosition()
						},
						setFrame: function(t) {
							return this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, t = this.frame, this.uv[0] = t.u0, this.uv[1] = t.v0, this.uv[2] = t.u0, this.uv[3] = t.v1, this.uv[4] = t.u1, this.uv[5] = t.v1, this.uv[6] = t.u0, this.uv[7] = t.v0, this.uv[8] = t.u1, this.uv[9] = t.v1, this.uv[10] = t.u1, this.uv[11] = t.v0, this
						},
						topLeftX: {
							get: function() {
								return this.x + this.vertices[0]
							},
							set: function(t) {
								this.vertices[0] = t - this.x, this.vertices[6] = t - this.x
							}
						},
						topLeftY: {
							get: function() {
								return this.y + this.vertices[1]
							},
							set: function(t) {
								this.vertices[1] = t - this.y, this.vertices[7] = t - this.y
							}
						},
						topRightX: {
							get: function() {
								return this.x + this.vertices[10]
							},
							set: function(t) {
								this.vertices[10] = t - this.x
							}
						},
						topRightY: {
							get: function() {
								return this.y + this.vertices[11]
							},
							set: function(t) {
								this.vertices[11] = t - this.y
							}
						},
						bottomLeftX: {
							get: function() {
								return this.x + this.vertices[2]
							},
							set: function(t) {
								this.vertices[2] = t - this.x
							}
						},
						bottomLeftY: {
							get: function() {
								return this.y + this.vertices[3]
							},
							set: function(t) {
								this.vertices[3] = t - this.y
							}
						},
						bottomRightX: {
							get: function() {
								return this.x + this.vertices[4]
							},
							set: function(t) {
								this.vertices[4] = t - this.x, this.vertices[8] = t - this.x
							}
						},
						bottomRightY: {
							get: function() {
								return this.y + this.vertices[5]
							},
							set: function(t) {
								this.vertices[5] = t - this.y, this.vertices[9] = t - this.y
							}
						},
						topLeftAlpha: {
							get: function() {
								return this.alphas[0]
							},
							set: function(t) {
								this.alphas[0] = t, this.alphas[3] = t
							}
						},
						topRightAlpha: {
							get: function() {
								return this.alphas[5]
							},
							set: function(t) {
								this.alphas[5] = t
							}
						},
						bottomLeftAlpha: {
							get: function() {
								return this.alphas[1]
							},
							set: function(t) {
								this.alphas[1] = t
							}
						},
						bottomRightAlpha: {
							get: function() {
								return this.alphas[2]
							},
							set: function(t) {
								this.alphas[2] = t, this.alphas[4] = t
							}
						},
						topLeftColor: {
							get: function() {
								return this.colors[0]
							},
							set: function(t) {
								this.colors[0] = t, this.colors[3] = t
							}
						},
						topRightColor: {
							get: function() {
								return this.colors[5]
							},
							set: function(t) {
								this.colors[5] = t
							}
						},
						bottomLeftColor: {
							get: function() {
								return this.colors[1]
							},
							set: function(t) {
								this.colors[1] = t
							}
						},
						bottomRightColor: {
							get: function() {
								return this.colors[2]
							},
							set: function(t) {
								this.colors[2] = t, this.colors[4] = t
							}
						},
						setTopLeft: function(t, e) {
							return this.topLeftX = t, this.topLeftY = e, this
						},
						setTopRight: function(t, e) {
							return this.topRightX = t, this.topRightY = e, this
						},
						setBottomLeft: function(t, e) {
							return this.bottomLeftX = t, this.bottomLeftY = e, this
						},
						setBottomRight: function(t, e) {
							return this.bottomRightX = t, this.bottomRightY = e, this
						},
						resetPosition: function() {
							var t = this.x,
								e = this.y,
								i = Math.floor(this.width / 2),
								n = Math.floor(this.height / 2);
							return this.setTopLeft(t - i, e - n), this.setTopRight(t + i, e - n), this.setBottomLeft(t - i, e + n), this.setBottomRight(t + i, e + n), this
						},
						resetAlpha: function() {
							var t = this.alphas;
							return t[0] = 1, t[1] = 1, t[2] = 1, t[3] = 1, t[4] = 1, t[5] = 1, this
						},
						resetColors: function() {
							var t = this.colors;
							return t[0] = 16777215, t[1] = 16777215, t[2] = 16777215, t[3] = 16777215, t[4] = 16777215, t[5] = 16777215, this
						},
						reset: function() {
							return this.resetPosition(), this.resetAlpha(), this.resetColors()
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(14),
					o = i(2),
					a = i(18),
					h = i(427),
					u = i(1080),
					l = i(29),
					c = new n({
						Extends: r,
						Mixins: [s.ComputedSize, s.Depth, s.GetBounds, s.Mask, s.Origin, s.ScrollFactor, s.Transform, s.Visible, u],
						initialize: function(t, e, i, n, s, o, a, h) {
							void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 128), void 0 === o && (o = 128), r.call(this, t, "Shader"), this.blendMode = -1, this.shader;
							var u = t.sys.renderer;
							this.renderer = u, this.gl = u.gl, this.vertexData = new ArrayBuffer(2 * Float32Array.BYTES_PER_ELEMENT * 6), this.vertexBuffer = u.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW), this.program = null, this.bytes = new Uint8Array(this.vertexData), this.vertexViewF32 = new Float32Array(this.vertexData), this._tempMatrix1 = new l, this._tempMatrix2 = new l, this._tempMatrix3 = new l, this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.uniforms = {}, this.pointer = null, this._rendererWidth = u.width, this._rendererHeight = u.height, this._textureCount = 0, this.framebuffer = null, this.glTexture = null, this.renderToTexture = !1, this.texture = null, this.setPosition(i, n), this.setSize(s, o), this.setOrigin(.5, .5), this.setShader(e, a, h)
						},
						willRender: function(t) {
							return !!this.renderToTexture || !(r.RENDER_MASK !== this.renderFlags || 0 !== this.cameraFilter && this.cameraFilter & t.id)
						},
						setRenderToTexture: function(t, e) {
							var i, n, s, r;
							return void 0 === e && (e = !1), this.renderToTexture || (i = this.width, n = this.height, s = this.renderer, this.glTexture = s.createTextureFromSource(null, i, n, 0), this.glTexture.flipY = e, this.framebuffer = s.createFramebuffer(i, n, this.glTexture, !1), this._rendererWidth = i, this._rendererHeight = n, this.renderToTexture = !0, this.projOrtho(0, this.width, this.height, 0), t && (this.texture = this.scene.sys.textures.addGLTexture(t, this.glTexture, i, n))), this.shader && (r = s.currentPipeline, s.clearPipeline(), this.load(), this.flush(), s.rebindPipeline(r)), this
						},
						setShader: function(t, e, i) {
							if (void 0 === e && (e = []), "string" == typeof t) {
								var n = this.scene.sys.cache.shader;
								if (!n.has(t)) return console.warn("Shader missing: " + t), this;
								this.shader = n.get(t)
							} else this.shader = t;
							var s = this.gl,
								r = this.renderer;
							this.program && s.deleteProgram(this.program);
							var o = r.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);
							r.setMatrix4(o, "uViewMatrix", !1, this.viewMatrix), r.setMatrix4(o, "uProjectionMatrix", !1, this.projectionMatrix), r.setFloat2(o, "uResolution", this.width, this.height), this.program = o;
							var h = new Date,
								u = {
									resolution: {
										type: "2f",
										value: {
											x: this.width,
											y: this.height
										}
									},
									time: {
										type: "1f",
										value: 0
									},
									mouse: {
										type: "2f",
										value: {
											x: this.width / 2,
											y: this.height / 2
										}
									},
									date: {
										type: "4fv",
										value: [h.getFullYear(), h.getMonth(), h.getDate(), 60 * h.getHours() * 60 + 60 * h.getMinutes() + h.getSeconds()]
									},
									sampleRate: {
										type: "1f",
										value: 44100
									},
									iChannel0: {
										type: "sampler2D",
										value: null,
										textureData: {
											repeat: !0
										}
									},
									iChannel1: {
										type: "sampler2D",
										value: null,
										textureData: {
											repeat: !0
										}
									},
									iChannel2: {
										type: "sampler2D",
										value: null,
										textureData: {
											repeat: !0
										}
									},
									iChannel3: {
										type: "sampler2D",
										value: null,
										textureData: {
											repeat: !0
										}
									}
								};
							this.shader.uniforms ? this.uniforms = a(!0, {}, this.shader.uniforms, u) : this.uniforms = u;
							for (var l = 0; l < 4; l++) e[l] && this.setSampler2D("iChannel" + l, e[l], l, i);
							return this.initUniforms(), this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0), this
						},
						setPointer: function(t) {
							return this.pointer = t, this
						},
						projOrtho: function(t, e, i, n) {
							var s = 1 / (t - e),
								r = 1 / (i - n),
								o = this.projectionMatrix;
							o[0] = -2 * s, o[5] = -2 * r, o[10] = -.001, o[12] = (t + e) * s, o[13] = (n + i) * r, o[14] = -0;
							var a = this.program;
							this.renderer.setMatrix4(a, "uProjectionMatrix", !1, this.projectionMatrix), this._rendererWidth = e, this._rendererHeight = i
						},
						initUniforms: function() {
							var t = this.gl,
								e = this.renderer.glFuncMap,
								i = this.program;
							for (var n in this._textureCount = 0, this.uniforms) {
								var s = this.uniforms[n],
									r = s.type,
									o = e[r];
								s.uniformLocation = t.getUniformLocation(i, n), "sampler2D" !== r && (s.glMatrix = o.matrix, s.glValueLength = o.length, s.glFunc = o.func)
							}
						},
						setSampler2DBuffer: function(t, e, i, n, s, r) {
							void 0 === s && (s = 0), void 0 === r && (r = {});
							var o = this.uniforms[t];
							return o.value = e, r.width = i, r.height = n, o.textureData = r, this._textureCount = s, this.initSampler2D(o), this
						},
						setSampler2D: function(t, e, i, n) {
							void 0 === i && (i = 0);
							var s, r, o, a = this.scene.sys.textures;
							return a.exists(e) && (s = a.getFrame(e), r = this.uniforms[t], o = s.source, r.textureKey = e, r.source = o.image, r.value = s.glTexture, o.isGLTexture && ((n = n || {}).width = o.width, n.height = o.height), n && (r.textureData = n), this._textureCount = i, this.initSampler2D(r)), this
						},
						setUniform: function(t, e) {
							return h(this.uniforms, t, e), this
						},
						getUniform: function(t) {
							return o(this.uniforms, t, null)
						},
						setChannel0: function(t, e) {
							return this.setSampler2D("iChannel0", t, 0, e)
						},
						setChannel1: function(t, e) {
							return this.setSampler2D("iChannel1", t, 1, e)
						},
						setChannel2: function(t, e) {
							return this.setSampler2D("iChannel2", t, 2, e)
						},
						setChannel3: function(t, e) {
							return this.setSampler2D("iChannel3", t, 3, e)
						},
						initSampler2D: function(t) {
							var e, i, n, s, r, a, h, u, l, c;
							t.value && ((e = this.gl).activeTexture(e.TEXTURE0 + this._textureCount), e.bindTexture(e.TEXTURE_2D, t.value), (i = t.textureData) && (n = e[o(i, "magFilter", "linear").toUpperCase()], s = e[o(i, "minFilter", "linear").toUpperCase()], r = e[o(i, "wrapS", "repeat").toUpperCase()], a = e[o(i, "wrapT", "repeat").toUpperCase()], h = e[o(i, "format", "rgba").toUpperCase()], i.repeat && (r = e.REPEAT, a = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width ? (u = o(i, "width", 512), l = o(i, "height", 2), c = o(i, "border", 0), e.texImage2D(e.TEXTURE_2D, 0, h, u, l, c, h, e.UNSIGNED_BYTE, null)) : e.texImage2D(e.TEXTURE_2D, 0, h, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, a)), this.renderer.setProgram(this.program), e.uniform1i(t.uniformLocation, this._textureCount), this._textureCount++)
						},
						syncUniforms: function() {
							var t, e, i, n, s, r = this.gl,
								o = this.uniforms,
								a = 0;
							for (var h in o) i = (t = o[h]).glFunc, e = t.glValueLength, n = t.uniformLocation, null !== (s = t.value) && (1 === e ? t.glMatrix ? i.call(r, n, t.transpose, s) : i.call(r, n, s) : 2 === e ? i.call(r, n, s.x, s.y) : 3 === e ? i.call(r, n, s.x, s.y, s.z) : 4 === e ? i.call(r, n, s.x, s.y, s.z, s.w) : "sampler2D" === t.type && (r.activeTexture(r["TEXTURE" + a]), r.bindTexture(r.TEXTURE_2D, s), r.uniform1i(n, a), a++))
						},
						load: function(t) {
							var e, i, n = this.gl,
								s = this.width,
								r = this.height,
								o = this.renderer,
								a = this.program,
								h = this.viewMatrix;
							this.renderToTexture || (e = -this._displayOriginX, i = -this._displayOriginY, h[0] = t[0], h[1] = t[1], h[4] = t[2], h[5] = t[3], h[8] = t[4], h[9] = t[5], h[12] = h[0] * e + h[4] * i, h[13] = h[1] * e + h[5] * i), n.useProgram(a), n.uniformMatrix4fv(n.getUniformLocation(a, "uViewMatrix"), !1, h), n.uniform2f(n.getUniformLocation(a, "uResolution"), this.width, this.height);
							var u = this.uniforms,
								l = u.resolution;
							l.value.x = s, l.value.y = r, u.time.value = o.game.loop.getDuration();
							var c, d, f, p = this.pointer;
							p && (c = u.mouse, d = p.x / s, f = 1 - p.y / r, c.value.x = d.toFixed(2), c.value.y = f.toFixed(2)), this.syncUniforms()
						},
						flush: function() {
							var t = this.width,
								e = this.height,
								i = this.program,
								n = this.gl,
								s = this.vertexBuffer,
								r = this.renderer,
								o = 2 * Float32Array.BYTES_PER_ELEMENT;
							this.renderToTexture && (r.setFramebuffer(this.framebuffer), n.clearColor(0, 0, 0, 0), n.clear(n.COLOR_BUFFER_BIT)), n.bindBuffer(n.ARRAY_BUFFER, s);
							var a = n.getAttribLocation(i, "inPosition"); - 1 !== a && (n.enableVertexAttribArray(a), n.vertexAttribPointer(a, 2, n.FLOAT, !1, o, 0));
							var h = this.vertexViewF32;
							h[3] = e, h[4] = t, h[5] = e, h[8] = t, h[9] = e, h[10] = t, n.bufferSubData(n.ARRAY_BUFFER, 0, this.bytes.subarray(0, 6 * o)), n.drawArrays(n.TRIANGLES, 0, 6), this.renderToTexture && r.setFramebuffer(null, !1)
						},
						setAlpha: function() {},
						setBlendMode: function() {},
						preDestroy: function() {
							var t = this.gl;
							t.deleteProgram(this.program), t.deleteBuffer(this.vertexBuffer), this.renderToTexture && (this.renderer.deleteFramebuffer(this.framebuffer), this.texture.destroy(), this.framebuffer = null, this.glTexture = null, this.texture = null)
						}
					});
				t.exports = c
			}, function(t, e, i) {
				var n = i(53);
				t.exports = function(t, e) {
					return n(t.x, t.y, e.x, e.y) <= t.radius + e.radius
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = e.width / 2,
						n = e.height / 2,
						s = Math.abs(t.x - e.x - i),
						r = Math.abs(t.y - e.y - n),
						o = i + t.radius,
						a = n + t.radius;
					if (o < s || a < r) return !1;
					if (s <= i || r <= n) return !0;
					var h = s - i,
						u = r - n;
					return h * h + u * u <= t.radius * t.radius
				}
			}, function(t, e, i) {
				var n = i(4),
					s = i(208);
				t.exports = function(t, e, i) {
					var r, o, a, h, u, l, c, d, f, p, g, v, m, y, x, T, w;
					return void 0 === i && (i = []), s(t, e) && (r = t.x1, o = t.y1, a = t.x2, h = t.y2, 0 == (v = (g = 2 * ((l = a - r) * (d = r - e.x) + (c = h - o) * (f = o - e.y))) * g - 4 * (p = l * l + c * c) * (d * d + f * f - (u = e.radius) * u)) ? (y = r + (m = -g / (2 * p)) * l, x = o + m * c, 0 <= m && m <= 1 && i.push(new n(y, x))) : 0 < v && (y = r + (T = (-g - Math.sqrt(v)) / (2 * p)) * l, x = o + T * c, 0 <= T && T <= 1 && i.push(new n(y, x)), y = r + (w = (-g + Math.sqrt(v)) / (2 * p)) * l, x = o + w * c, 0 <= w && w <= 1 && i.push(new n(y, x)))), i
				}
			}, function(t, e, i) {
				var n = i(55),
					s = new(i(4));
				t.exports = function(t, e, i) {
					if (void 0 === i && (i = s), n(e, t.x1, t.y1)) return i.x = t.x1, i.y = t.y1, !0;
					if (n(e, t.x2, t.y2)) return i.x = t.x2, i.y = t.y2, !0;
					var r, o = t.x2 - t.x1,
						a = t.y2 - t.y1,
						h = e.x - t.x1,
						u = e.y - t.y1,
						l = o * o + a * a,
						c = o,
						d = a;
					return 0 < l && (c *= r = (h * o + u * a) / l, d *= r), i.x = t.x1 + c, i.y = t.y1 + d, c * c + d * d <= l && 0 <= c * o + d * a && n(e, i.x, i.y)
				}
			}, function(t, e, i) {
				var n = i(4),
					s = i(84),
					r = i(432);
				t.exports = function(t, e, i) {
					if (void 0 === i && (i = []), r(t, e))
						for (var o = e.getLineA(), a = e.getLineB(), h = e.getLineC(), u = e.getLineD(), l = [new n, new n, new n, new n], c = [s(o, t, l[0]), s(a, t, l[1]), s(h, t, l[2]), s(u, t, l[3])], d = 0; d < 4; d++) c[d] && i.push(l[d]);
					return i
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					void 0 === i && (i = !1), void 0 === n && (n = []);
					for (var s, r, o, a, h, u, l = t.x3 - t.x1, c = t.y3 - t.y1, d = t.x2 - t.x1, f = t.y2 - t.y1, p = l * l + c * c, g = l * d + c * f, v = d * d + f * f, m = p * v - g * g, y = 0 == m ? 0 : 1 / m, x = t.x1, T = t.y1, w = 0; w < e.length && (r = (p * (u = d * (o = e[w].x - x) + f * (a = e[w].y - T)) - g * (h = l * o + c * a)) * y, !(0 <= (s = (v * h - g * u) * y) && 0 <= r && s + r < 1 && (n.push({
							x: e[w].x,
							y: e[w].y
						}), i))); w++);
					return n
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					var s = Math.cos(n),
						r = Math.sin(n),
						o = t.x1 - e,
						a = t.y1 - i;
					return t.x1 = o * s - a * r + e, t.y1 = o * r + a * s + i, o = t.x2 - e, a = t.y2 - i, t.x2 = o * s - a * r + e, t.y2 = o * r + a * s + i, t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return 0 === t.height ? NaN : t.width / t.height
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					var s = Math.cos(n),
						r = Math.sin(n),
						o = t.x1 - e,
						a = t.y1 - i;
					return t.x1 = o * s - a * r + e, t.y1 = o * r + a * s + i, o = t.x2 - e, a = t.y2 - i, t.x2 = o * s - a * r + e, t.y2 = o * r + a * s + i, o = t.x3 - e, a = t.y3 - i, t.x3 = o * s - a * r + e, t.y3 = o * r + a * s + i, t
				}
			}, function(t, e, i) {
				t.exports = {
					BUTTON_DOWN: i(1203),
					BUTTON_UP: i(1204),
					CONNECTED: i(1205),
					DISCONNECTED: i(1206),
					GAMEPAD_BUTTON_DOWN: i(1207),
					GAMEPAD_BUTTON_UP: i(1208)
				}
			}, function(t, e, i) {
				var n = i(18),
					s = i(139);
				t.exports = function(t, e) {
					var i = void 0 === t ? s() : n({}, t);
					if (e)
						for (var r in e) void 0 !== e[r] && (i[r] = e[r]);
					return i
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = i(364),
					l = new n({
						Extends: r,
						initialize: function(t, e, i, n) {
							var s, o = "xml";
							h(e) && (e = a(s = e, "key"), i = a(s, "url"), n = a(s, "xhrSettings"), o = a(s, "extension", o));
							var u = {
								type: "xml",
								cache: t.cacheManager.xml,
								extension: o,
								responseType: "text",
								key: e,
								url: i,
								xhrSettings: n
							};
							r.call(this, t, u)
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING, this.data = u(this.xhrLoader.responseText), this.data ? this.onProcessComplete() : (console.warn("Invalid XMLFile: " + this.key), this.onProcessError())
						}
					});
				o.register("xml", function(t, e, i) {
					if (Array.isArray(t))
						for (var n = 0; n < t.length; n++) this.addFile(new l(this, t[n]));
					else this.addFile(new l(this, t, e, i));
					return this
				}), t.exports = l
			}, function(t, e, i) {
				t.exports = {
					Acceleration: i(1263),
					Angular: i(1264),
					Bounce: i(1265),
					Debug: i(1266),
					Drag: i(1267),
					Enable: i(1268),
					Friction: i(1269),
					Gravity: i(1270),
					Immovable: i(1271),
					Mass: i(1272),
					Size: i(1273),
					Velocity: i(1274)
				}
			}, function(t, e, i) {
				t.exports = {
					COLLIDE: i(1276),
					OVERLAP: i(1277),
					PAUSE: i(1278),
					RESUME: i(1279),
					TILE_COLLIDE: i(1280),
					TILE_OVERLAP: i(1281),
					WORLD_BOUNDS: i(1282),
					WORLD_STEP: i(1283)
				}
			}, , function(t, e, i) {
				var n = i(142);
				t.exports = function(t, e, i) {
					var s = n(t, e, !0, i),
						r = n(t, e - 1, !0, i),
						o = n(t, e + 1, !0, i),
						a = n(t - 1, e, !0, i),
						h = n(t + 1, e, !0, i),
						u = s && s.collides;
					return u && (s.faceTop = !0, s.faceBottom = !0, s.faceLeft = !0, s.faceRight = !0), r && r.collides && (u && (s.faceTop = !1), r.faceBottom = !u), o && o.collides && (u && (s.faceBottom = !1), o.faceTop = !u), a && a.collides && (u && (s.faceLeft = !1), a.faceRight = !u), h && h.collides && (u && (s.faceRight = !1), h.faceLeft = !u), s && !s.collides && s.resetFaces(), s
				}
			}, function(t, e, i) {
				var n = i(74),
					s = i(101),
					r = i(220),
					o = i(73);
				t.exports = function(t, e, i, a, h) {
					if (!s(e, i, h)) return null;
					void 0 === a && (a = !0);
					var u, l = h.data[i][e],
						c = l && l.collides;
					t instanceof n ? (null === h.data[i][e] && (h.data[i][e] = new n(h, t.index, e, i, t.width, t.height)), h.data[i][e].copy(t)) : (u = t, null === h.data[i][e] ? h.data[i][e] = new n(h, u, e, i, h.tileWidth, h.tileHeight) : h.data[i][e].index = u);
					var d = h.data[i][e],
						f = -1 !== h.collideIndexes.indexOf(d.index);
					return o(d, f), a && c !== d.collides && r(e, i, h), d
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					var n = i.collideIndexes.indexOf(t);
					e && -1 === n ? i.collideIndexes.push(t) : e || -1 === n || i.collideIndexes.splice(n, 1)
				}
			}, function(t, e, i) {
				var n = i(32),
					s = i(102),
					r = i(103),
					o = i(74);
				t.exports = function(t, e, i, a, h) {
					for (var u = new s({
							tileWidth: i,
							tileHeight: a
						}), l = new r({
							name: t,
							tileWidth: i,
							tileHeight: a,
							format: n.ARRAY_2D,
							layers: [u]
						}), c = [], d = e.length, f = 0, p = 0; p < e.length; p++) {
						c[p] = [];
						for (var g = e[p], v = 0; v < g.length; v++) {
							var m = parseInt(g[v], 10);
							isNaN(m) || -1 === m ? c[p][v] = h ? null : new o(u, -1, v, p, i, a) : c[p][v] = new o(u, m, v, p, i, a)
						}
						0 === f && (f = g.length)
					}
					return l.width = u.width = f, l.height = u.height = d, l.widthInPixels = u.widthInPixels = f * i, l.heightInPixels = u.heightInPixels = d * a, u.data = c, l
				}
			}, function(t, e) {
				t.exports = function(t) {
					var e = Boolean(2147483648 & t),
						i = Boolean(1073741824 & t),
						n = Boolean(536870912 & t);
					t &= 536870911;
					var s = 0,
						r = !1;
					return e && i && n ? (s = Math.PI / 2, r = !0) : e && i && !n ? (s = Math.PI, r = !1) : e && !i && n ? (s = Math.PI / 2, r = !1) : !e || i || n ? !e && i && n ? (s = 3 * Math.PI / 2, r = !1) : e || !i || n ? e || i || !n ? e || i || n || (s = 0, r = !1) : (s = 3 * Math.PI / 2, r = !0) : (s = Math.PI, r = !0) : r = !(s = 0), {
						gid: t,
						flippedHorizontal: e,
						flippedVertical: i,
						flippedAntiDiagonal: n,
						rotation: s,
						flipped: r
					}
				}
			}, function(t, e, i) {
				var n = i(2);
				t.exports = function(t, e, i) {
					if (!e) return {
						i: 0,
						layers: t.layers,
						name: "",
						opacity: 1,
						visible: !0,
						x: 0,
						y: 0
					};
					var s = e.x + n(e, "startx", 0) * t.tilewidth + n(e, "offsetx", 0),
						r = e.y + n(e, "starty", 0) * t.tileheight + n(e, "offsety", 0);
					return {
						i: 0,
						layers: e.layers,
						name: i.name + e.name + "/",
						opacity: i.opacity * e.opacity,
						visible: i.visible && e.visible,
						x: i.x + s,
						y: i.y + r
					}
				}
			}, function(t, e, i) {
				function n(t) {
					return {
						x: t.x,
						y: t.y
					}
				}
				var s = i(486),
					r = i(224),
					o = ["id", "name", "type", "rotation", "properties", "visible", "x", "y", "width", "height"];
				t.exports = function(t, e, i) {
					void 0 === e && (e = 0), void 0 === i && (i = 0);
					var a, h = s(t, o);
					return h.x += e, h.y += i, t.gid ? (a = r(t.gid), h.gid = a.gid, h.flippedHorizontal = a.flippedHorizontal, h.flippedVertical = a.flippedVertical, h.flippedAntiDiagonal = a.flippedAntiDiagonal) : t.polyline ? h.polyline = t.polyline.map(n) : t.polygon ? h.polygon = t.polygon.map(n) : t.ellipse ? h.ellipse = t.ellipse : t.text ? h.text = t.text : t.point ? h.point = !0 : h.rectangle = !0, h
				}
			}, function(t, e, i) {
				var n = i(32),
					s = i(103),
					r = i(478),
					o = i(494);
				t.exports = function(t, e, i, a, h, u, l, c) {
					void 0 === i && (i = 32), void 0 === a && (a = 32), void 0 === h && (h = 10), void 0 === u && (u = 10), void 0 === c && (c = !1);
					var d, f = null;
					return Array.isArray(l) ? f = r(void 0 !== e ? e : "map", n.ARRAY_2D, l, i, a, c) : void 0 !== e && ((d = t.cache.tilemap.get(e)) ? f = r(e, d.format, d.data, i, a, c) : console.warn("No map data found for key " + e)), null === f && (f = new s({
						tileWidth: i,
						tileHeight: a,
						width: h,
						height: u
					})), new o(t, f)
				}
			}, function(t, e, i) {
				var n = i(6);
				t.exports = function(t) {
					var e = n(t, "targets", null);
					return null === e || ("function" == typeof e && (e = e.call()), Array.isArray(e) || (e = [e])), e
				}
			}, function(t, e) {
				function i(t) {
					return !!t.getActive && "function" == typeof t.getActive
				}

				function n(t) {
					return !!t.getStart && "function" == typeof t.getStart
				}

				function s(t) {
					return !!t.getEnd && "function" == typeof t.getEnd
				}
				var r = function(t, e) {
					var o, a, h, u, l, c, d, f = function(t, e, i) {
							return i
						},
						p = function(t, e, i) {
							return i
						},
						g = null,
						v = typeof e;
					if ("number" == v) f = function() {
						return e
					};
					else if ("string" == v) {
						var m = e[0],
							y = parseFloat(e.substr(2));
						switch (m) {
							case "+":
								f = function(t, e, i) {
									return i + y
								};
								break;
							case "-":
								f = function(t, e, i) {
									return i - y
								};
								break;
							case "*":
								f = function(t, e, i) {
									return i * y
								};
								break;
							case "/":
								f = function(t, e, i) {
									return i / y
								};
								break;
							default:
								f = function() {
									return parseFloat(e)
								}
						}
					} else "function" == v ? f = e : "object" == v && (n(d = e) || s(d) || i(d) ? (i(e) && (g = e.getActive), s(e) && (f = e.getEnd), n(e) && (p = e.getStart)) : e.hasOwnProperty("value") ? c = r(t, e.value) : (o = e.hasOwnProperty("to"), a = e.hasOwnProperty("from"), h = e.hasOwnProperty("start"), o && (a || h) && (c = r(t, e.to), h && (u = r(t, e.start), c.getActive = u.getEnd), a && (l = r(t, e.from), c.getStart = l.getEnd))));
					return c || {
						getActive: g,
						getEnd: f,
						getStart: p
					}
				};
				t.exports = r
			}, function(t, e) {
				t.exports = {
					targets: null,
					delay: 0,
					duration: 1e3,
					ease: "Power0",
					easeParams: null,
					hold: 0,
					repeat: 0,
					repeatDelay: 0,
					yoyo: !1,
					flipX: !1,
					flipY: !1
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(10),
					r = i(232),
					o = i(16),
					a = i(5),
					h = i(89),
					u = i(13),
					l = new n({
						Extends: s,
						initialize: function(t, e, i) {
							s.call(this), this.parent = t, this.parentIsTimeline = t.hasOwnProperty("isTimeline"), this.data = e, this.totalData = e.length, this.targets = i, this.totalTargets = i.length, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.startDelay = 0, this.hasStarted = !1, this.isSeeking = !1, this.completeDelay = 0, this.countdown = 0, this.offset = 0, this.calculatedOffset = 0, this.state = h.PENDING_ADD, this._pausedState = h.INIT, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = {
								onActive: null,
								onComplete: null,
								onLoop: null,
								onRepeat: null,
								onStart: null,
								onStop: null,
								onUpdate: null,
								onYoyo: null
							}, this.callbackScope
						},
						getValue: function(t) {
							return void 0 === t && (t = 0), this.data[t].current
						},
						setTimeScale: function(t) {
							return this.timeScale = t, this
						},
						getTimeScale: function() {
							return this.timeScale
						},
						isPlaying: function() {
							return this.state === h.ACTIVE
						},
						isPaused: function() {
							return this.state === h.PAUSED
						},
						hasTarget: function(t) {
							return -1 !== this.targets.indexOf(t)
						},
						updateTo: function(t, e, i) {
							void 0 === i && (i = !1);
							for (var n = 0; n < this.totalData; n++) {
								var s = this.data[n];
								s.key === t && (s.end = e, i && (s.start = s.current))
							}
							return this
						},
						restart: function() {
							return this.elapsed = 0, this.progress = 0, this.totalElapsed = 0, this.totalProgress = 0, this.state === h.ACTIVE ? this.seek(0) : this.state === h.REMOVED ? (this.seek(0), this.parent.makeActive(this), this) : this.state === h.PENDING_ADD ? this : this.play()
						},
						calcDuration: function() {
							for (var t = 0, e = u.MAX_SAFE_INTEGER, i = this.data, n = 0; n < this.totalData; n++) {
								var s = i[n];
								s.t1 = s.duration + s.hold, s.yoyo && (s.t1 += s.duration), s.t2 = s.t1 + s.repeatDelay, s.totalDuration = s.delay + s.t1, -1 === s.repeat ? s.totalDuration += 999999999999 * s.t2 : 0 < s.repeat && (s.totalDuration += s.t2 * s.repeat), s.totalDuration > t && (t = s.totalDuration), s.delay < e && (e = s.delay)
							}
							this.duration = Math.max(t, .001), this.loopCounter = -1 === this.loop ? 999999999999 : this.loop, 0 < this.loopCounter ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay, this.startDelay = e
						},
						init: function() {
							if (this.paused && !this.parentIsTimeline) return this.state = h.PENDING_ADD, this._pausedState = h.INIT, !1;
							for (var t = this.data, e = this.totalTargets, i = 0; i < this.totalData; i++) {
								var n = t[i],
									s = n.target,
									r = n.gen,
									o = n.key,
									a = n.index;
								n.delay = r.delay(s, o, 0, a, e, this), n.duration = Math.max(r.duration(s, o, 0, a, e, this), .001), n.hold = r.hold(s, o, 0, a, e, this), n.repeat = r.repeat(s, o, 0, a, e, this), n.repeatDelay = r.repeatDelay(s, o, 0, a, e, this)
							}
							return this.calcDuration(), this.progress = 0, this.totalProgress = 0, this.elapsed = 0, this.totalElapsed = 0, this.state = h.INIT, !0
						},
						makeActive: function() {
							this.parent.makeActive(this), this.dispatchTweenEvent(r.TWEEN_ACTIVE, this.callbacks.onActive)
						},
						nextState: function() {
							0 < this.loopCounter ? (this.elapsed = 0, this.progress = 0, this.loopCounter--, this.resetTweenData(!0), 0 < this.loopDelay ? (this.countdown = this.loopDelay, this.state = h.LOOP_DELAY) : (this.state = h.ACTIVE, this.dispatchTweenEvent(r.TWEEN_LOOP, this.callbacks.onLoop))) : 0 < this.completeDelay ? (this.state = h.COMPLETE_DELAY, this.countdown = this.completeDelay) : (this.state = h.PENDING_REMOVE, this.dispatchTweenEvent(r.TWEEN_COMPLETE, this.callbacks.onComplete))
						},
						pause: function() {
							return this.state === h.PAUSED || (this.paused = !0, this._pausedState = this.state, this.state = h.PAUSED), this
						},
						play: function(t) {
							void 0 === t && (t = !1);
							var e = this.state;
							return e !== h.INIT || this.parentIsTimeline ? e === h.ACTIVE || e === h.PENDING_ADD && this._pausedState === h.PENDING_ADD || (this.parentIsTimeline || e !== h.PENDING_REMOVE && e !== h.REMOVED ? this.parentIsTimeline ? (this.resetTweenData(t), 0 === this.calculatedOffset ? this.state = h.ACTIVE : (this.countdown = this.calculatedOffset, this.state = h.OFFSET_DELAY)) : (this.paused ? this.paused = !1 : (this.resetTweenData(t), this.state = h.ACTIVE), this.makeActive()) : (this.seek(0), this.parent.makeActive(this))) : (this.resetTweenData(!1), this.state = h.ACTIVE), this
						},
						resetTweenData: function(t) {
							for (var e = this.data, i = this.totalData, n = this.totalTargets, s = 0; s < i; s++) {
								var r = e[s],
									o = r.target,
									a = r.key,
									u = r.index;
								r.progress = 0, r.elapsed = 0, r.repeatCounter = -1 === r.repeat ? 999999999999 : r.repeat, t ? (r.start = r.getStartValue(o, a, r.start, u, n, this), r.end = r.getEndValue(o, a, r.end, u, n, this), r.current = r.start, r.state = h.PLAYING_FORWARD) : r.state = h.PENDING_RENDER, 0 < r.delay && (r.elapsed = r.delay, r.state = h.DELAY), r.getActiveValue && (o[a] = r.getActiveValue(r.target, r.key, r.start))
							}
						},
						resume: function() {
							return this.state === h.PAUSED ? (this.paused = !1, this.state = this._pausedState) : this.play(), this
						},
						seek: function(t, e) {
							if (void 0 === e && (e = 16.6), 36e5 <= this.totalDuration) return console.warn("Tween.seek duration too long"), this;
							this.state === h.REMOVED && this.makeActive(), this.elapsed = 0, this.progress = 0, this.totalElapsed = 0, this.totalProgress = 0;
							for (var i = this.data, n = this.totalTargets, s = 0; s < this.totalData; s++) {
								var r = i[s],
									o = r.target,
									a = r.gen,
									u = r.key,
									l = r.index;
								r.progress = 0, r.elapsed = 0, r.repeatCounter = -1 === r.repeat ? 999999999999 : r.repeat, r.delay = a.delay(o, u, 0, l, n, this), r.duration = Math.max(a.duration(o, u, 0, l, n, this), .001), r.hold = a.hold(o, u, 0, l, n, this), r.repeat = a.repeat(o, u, 0, l, n, this), r.repeatDelay = a.repeatDelay(o, u, 0, l, n, this), r.current = r.start, r.state = h.PLAYING_FORWARD, this.updateTweenData(this, r, 0, l, n), 0 < r.delay && (r.elapsed = r.delay, r.state = h.DELAY)
							}
							this.calcDuration();
							var c = !1;
							for (this.state === h.PAUSED && (c = !0, this.state = h.ACTIVE), this.isSeeking = !0; this.update(0, e), this.totalProgress < t;);
							return this.isSeeking = !1, c && (this.state = h.PAUSED), this
						},
						setCallback: function(t, e, i, n) {
							return this.callbacks[t] = {
								func: e,
								scope: n,
								params: i
							}, this
						},
						complete: function(t) {
							return void 0 === t && (t = 0), t ? (this.state = h.COMPLETE_DELAY, this.countdown = t) : (this.state = h.PENDING_REMOVE, this.dispatchTweenEvent(r.TWEEN_COMPLETE, this.callbacks.onComplete)), this
						},
						remove: function() {
							return this.parent.remove(this), this
						},
						stop: function(t) {
							return this.state === h.ACTIVE && void 0 !== t && this.seek(t), this.state !== h.REMOVED && (this.state !== h.PAUSED && this.state !== h.PENDING_ADD || (this.parentIsTimeline ? (this.parent.manager._destroy.push(this), this.parent.manager._toProcess++) : (this.parent._destroy.push(this), this.parent._toProcess++)), this.dispatchTweenEvent(r.TWEEN_STOP, this.callbacks.onStop), this.removeAllListeners(), this.state = h.PENDING_REMOVE), this
						},
						update: function(t, e) {
							if (this.state === h.PAUSED) return !1;
							switch (this.useFrames && (e = +this.parent.timeScale), e *= this.timeScale, this.elapsed += e, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += e, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) {
								case h.ACTIVE:
									this.hasStarted || this.isSeeking || (this.startDelay -= e, this.startDelay <= 0 && (this.hasStarted = !0, this.dispatchTweenEvent(r.TWEEN_START, this.callbacks.onStart)));
									for (var i = !1, n = 0; n < this.totalData; n++) {
										var s = this.data[n];
										this.updateTweenData(this, s, e) && (i = !0)
									}
									i || this.nextState();
									break;
								case h.LOOP_DELAY:
									this.countdown -= e, this.countdown <= 0 && (this.state = h.ACTIVE, this.dispatchTweenEvent(r.TWEEN_LOOP, this.callbacks.onLoop));
									break;
								case h.OFFSET_DELAY:
									this.countdown -= e, this.countdown <= 0 && (this.state = h.ACTIVE);
									break;
								case h.COMPLETE_DELAY:
									this.countdown -= e, this.countdown <= 0 && (this.state = h.PENDING_REMOVE, this.dispatchTweenEvent(r.TWEEN_COMPLETE, this.callbacks.onComplete))
							}
							return this.state === h.PENDING_REMOVE
						},
						dispatchTweenDataEvent: function(t, e, i) {
							this.isSeeking || (this.emit(t, this, i.key, i.target, i.current, i.previous), e && (e.params[1] = i.target, e.func.apply(e.scope, e.params)))
						},
						dispatchTweenEvent: function(t, e) {
							this.isSeeking || (this.emit(t, this, this.targets), e && (e.params[1] = this.targets, e.func.apply(e.scope, e.params)))
						},
						setStateFromEnd: function(t, e, i) {
							return e.yoyo ? (e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(), this.dispatchTweenDataEvent(r.TWEEN_YOYO, t.callbacks.onYoyo, e), e.start = e.getStartValue(e.target, e.key, e.start, e.index, t.totalTargets, t), h.PLAYING_BACKWARD) : 0 < e.repeatCounter ? (e.repeatCounter--, e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(), e.start = e.getStartValue(e.target, e.key, e.start, e.index, t.totalTargets, t), e.end = e.getEndValue(e.target, e.key, e.start, e.index, t.totalTargets, t), 0 < e.repeatDelay ? (e.elapsed = e.repeatDelay - i, e.current = e.start, e.target[e.key] = e.current, h.REPEAT_DELAY) : (this.dispatchTweenDataEvent(r.TWEEN_REPEAT, t.callbacks.onRepeat, e), h.PLAYING_FORWARD)) : h.COMPLETE
						},
						setStateFromStart: function(t, e, i) {
							return 0 < e.repeatCounter ? (e.repeatCounter--, e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(), e.end = e.getEndValue(e.target, e.key, e.start, e.index, t.totalTargets, t), 0 < e.repeatDelay ? (e.elapsed = e.repeatDelay - i, e.current = e.start, e.target[e.key] = e.current, h.REPEAT_DELAY) : (this.dispatchTweenDataEvent(r.TWEEN_REPEAT, t.callbacks.onRepeat, e), h.PLAYING_FORWARD)) : h.COMPLETE
						},
						updateTweenData: function(t, e, i) {
							var n = e.target;
							switch (e.state) {
								case h.PLAYING_FORWARD:
								case h.PLAYING_BACKWARD:
									if (!n) {
										e.state = h.COMPLETE;
										break
									}
									var s = e.elapsed,
										o = e.duration,
										a = 0;
									o < (s += i) && (a = s - o, s = o);
									var u, l = e.state === h.PLAYING_FORWARD,
										c = s / o;
									e.elapsed = s, e.progress = c, e.previous = e.current, 1 == c ? l ? (e.current = e.end, n[e.key] = e.end, 0 < e.hold ? (e.elapsed = e.hold - a, e.state = h.HOLD_DELAY) : e.state = this.setStateFromEnd(t, e, a)) : (e.current = e.start, n[e.key] = e.start, e.state = this.setStateFromStart(t, e, a)) : (u = l ? e.ease(c) : e.ease(1 - c), e.current = e.start + (e.end - e.start) * u, n[e.key] = e.current), this.dispatchTweenDataEvent(r.TWEEN_UPDATE, t.callbacks.onUpdate, e);
									break;
								case h.DELAY:
									e.elapsed -= i, e.elapsed <= 0 && (e.elapsed = Math.abs(e.elapsed), e.state = h.PENDING_RENDER);
									break;
								case h.REPEAT_DELAY:
									e.elapsed -= i, e.elapsed <= 0 && (e.elapsed = Math.abs(e.elapsed), e.state = h.PLAYING_FORWARD, this.dispatchTweenDataEvent(r.TWEEN_REPEAT, t.callbacks.onRepeat, e));
									break;
								case h.HOLD_DELAY:
									e.elapsed -= i, e.elapsed <= 0 && (e.state = this.setStateFromEnd(t, e, Math.abs(e.elapsed)));
									break;
								case h.PENDING_RENDER:
									n ? (e.start = e.getStartValue(n, e.key, n[e.key], e.index, t.totalTargets, t), e.end = e.getEndValue(n, e.key, e.start, e.index, t.totalTargets, t), e.current = e.start, n[e.key] = e.start, e.state = h.PLAYING_FORWARD) : e.state = h.COMPLETE
							}
							return e.state !== h.COMPLETE
						}
					});
				l.TYPES = ["onActive", "onComplete", "onLoop", "onRepeat", "onStart", "onStop", "onUpdate", "onYoyo"], a.register("tween", function(t) {
					return this.scene.sys.tweens.add(t)
				}), o.register("tween", function(t) {
					return this.scene.sys.tweens.create(t)
				}), t.exports = l
			}, function(t, e, i) {
				t.exports = {
					TIMELINE_COMPLETE: i(1358),
					TIMELINE_LOOP: i(1359),
					TIMELINE_PAUSE: i(1360),
					TIMELINE_RESUME: i(1361),
					TIMELINE_START: i(1362),
					TIMELINE_UPDATE: i(1363),
					TWEEN_ACTIVE: i(1364),
					TWEEN_COMPLETE: i(1365),
					TWEEN_LOOP: i(1366),
					TWEEN_REPEAT: i(1367),
					TWEEN_START: i(1368),
					TWEEN_STOP: i(1369),
					TWEEN_UPDATE: i(1370),
					TWEEN_YOYO: i(1371)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s, r, o, a, h, u, l, c, d, f, p) {
					return {
						target: t,
						index: e,
						key: i,
						getActiveValue: r,
						getEndValue: n,
						getStartValue: s,
						ease: o,
						duration: 0,
						totalDuration: 0,
						delay: 0,
						yoyo: u,
						hold: 0,
						repeat: 0,
						repeatDelay: 0,
						flipX: f,
						flipY: p,
						progress: 0,
						elapsed: 0,
						repeatCounter: 0,
						start: 0,
						previous: 0,
						current: 0,
						end: 0,
						t1: 0,
						t2: 0,
						gen: {
							delay: a,
							duration: h,
							hold: l,
							repeat: c,
							repeatDelay: d
						},
						state: 0
					}
				}
			}, function(t, e) {
				t.exports = {
					DEFAULT: 0,
					LINEAR: 0,
					NEAREST: 1
				}
			}, function(t, e, i) {
				var n = i(58);
				t.exports = function(t) {
					return n(t, -Math.PI, Math.PI)
				}
			}, function(t, e, i) {
				var n = i(58);
				t.exports = function(t) {
					return n(t, -180, 180)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(66),
					r = i(2),
					o = i(238),
					a = i(340),
					h = i(341),
					u = i(29),
					l = i(9),
					c = i(147),
					d = new n({
						Extends: c,
						Mixins: [o],
						initialize: function(t) {
							var e = t.renderer.config;
							c.call(this, {
								game: t.game,
								renderer: t.renderer,
								gl: t.renderer.gl,
								topology: r(t, "topology", t.renderer.gl.TRIANGLES),
								vertShader: r(t, "vertShader", h),
								fragShader: r(t, "fragShader", a),
								vertexCapacity: r(t, "vertexCapacity", 6 * e.batchSize),
								vertexSize: r(t, "vertexSize", 5 * Float32Array.BYTES_PER_ELEMENT + 4 * Uint8Array.BYTES_PER_ELEMENT),
								attributes: [{
									name: "inPosition",
									size: 2,
									type: t.renderer.gl.FLOAT,
									normalized: !1,
									offset: 0
								}, {
									name: "inTexCoord",
									size: 2,
									type: t.renderer.gl.FLOAT,
									normalized: !1,
									offset: 2 * Float32Array.BYTES_PER_ELEMENT
								}, {
									name: "inTintEffect",
									size: 1,
									type: t.renderer.gl.FLOAT,
									normalized: !1,
									offset: 4 * Float32Array.BYTES_PER_ELEMENT
								}, {
									name: "inTint",
									size: 4,
									type: t.renderer.gl.UNSIGNED_BYTE,
									normalized: !0,
									offset: 5 * Float32Array.BYTES_PER_ELEMENT
								}]
							}), this.vertexViewF32 = new Float32Array(this.vertexData), this.vertexViewU32 = new Uint32Array(this.vertexData), this.maxQuads = e.batchSize, this.batches = [], this._tempMatrix1 = new u, this._tempMatrix2 = new u, this._tempMatrix3 = new u, this._tempMatrix4 = new u, this.tempTriangle = [{
								x: 0,
								y: 0,
								width: 0
							}, {
								x: 0,
								y: 0,
								width: 0
							}, {
								x: 0,
								y: 0,
								width: 0
							}, {
								x: 0,
								y: 0,
								width: 0
							}], this.tintEffect = 2, this.strokeTint = {
								TL: 0,
								TR: 0,
								BL: 0,
								BR: 0
							}, this.fillTint = {
								TL: 0,
								TR: 0,
								BL: 0,
								BR: 0
							}, this.currentFrame = {
								u0: 0,
								v0: 0,
								u1: 1,
								v1: 1
							}, this.firstQuad = [0, 0, 0, 0, 0], this.prevQuad = [0, 0, 0, 0, 0], this.polygonCache = [], this.mvpInit()
						},
						onBind: function() {
							return c.prototype.onBind.call(this), this.mvpUpdate(), this
						},
						resize: function(t, e, i) {
							return c.prototype.resize.call(this, t, e, i), this.projOrtho(0, this.width, this.height, 0, -1e3, 1e3), this
						},
						setTexture2D: function(t, e) {
							return void 0 === t && (t = this.renderer.blankTexture.glTexture), void 0 === e && (e = 0), this.requireTextureBatch(t, e) && this.pushBatch(t, e), this
						},
						requireTextureBatch: function(t, e) {
							var i = this.batches,
								n = i.length;
							return !(0 < n && (0 < e ? i[n - 1].textures[e - 1] : i[n - 1].texture) === t)
						},
						pushBatch: function(t, e) {
							var i;
							0 === e ? this.batches.push({
								first: this.vertexCount,
								texture: t,
								textures: []
							}) : ((i = [])[e - 1] = t, this.batches.push({
								first: this.vertexCount,
								texture: null,
								textures: i
							}))
						},
						flush: function() {
							if (this.flushLocked) return this;
							this.flushLocked = !0;
							var t, e, i, n = this.gl,
								s = this.vertexCount,
								r = this.topology,
								o = this.vertexSize,
								a = this.renderer,
								h = this.batches,
								u = h.length,
								l = 0,
								c = null;
							if (0 === u || 0 === s) return this.flushLocked = !1, this;
							n.bufferSubData(n.ARRAY_BUFFER, 0, this.bytes.subarray(0, s * o));
							for (var d = 0; d < u - 1; d++) {
								if (c = h[d], t = h[d + 1], 0 < c.textures.length) {
									for (e = 0; e < c.textures.length; ++e)(i = c.textures[e]) && a.setTexture2D(i, 1 + e, !1);
									n.activeTexture(n.TEXTURE0)
								}
								l = t.first - c.first, null === c.texture || l <= 0 || (a.setTexture2D(c.texture, 0, !1), n.drawArrays(r, c.first, l))
							}
							if (0 < (c = h[u - 1]).textures.length) {
								for (e = 0; e < c.textures.length; ++e)(i = c.textures[e]) && a.setTexture2D(i, 1 + e, !1);
								n.activeTexture(n.TEXTURE0)
							}
							return l = s - c.first, c.texture && 0 < l && (a.setTexture2D(c.texture, 0, !1), n.drawArrays(r, c.first, l)), this.vertexCount = 0, h.length = 0, this.flushLocked = !1, this
						},
						batchSprite: function(t, e, i) {
							this.renderer.setPipeline(this);
							var n, s = this._tempMatrix1,
								r = this._tempMatrix2,
								o = this._tempMatrix3,
								a = t.frame,
								h = a.glTexture,
								u = a.u0,
								c = a.v0,
								d = a.u1,
								f = a.v1,
								p = a.x,
								g = a.y,
								v = a.cutWidth,
								m = a.cutHeight,
								y = a.customPivot,
								x = t.displayOriginX,
								T = t.displayOriginY,
								w = -x + p,
								E = -T + g;
							t.isCropped && ((n = t._crop).flipX === t.flipX && n.flipY === t.flipY || a.updateCropUVs(n, t.flipX, t.flipY), u = n.u0, c = n.v0, d = n.u1, f = n.v1, v = n.width, m = n.height, w = -x + n.x, E = -T + n.y);
							var _ = 1,
								b = 1;
							t.flipX && (y || (w += -a.realWidth + 2 * x), _ = -1), (t.flipY || a.source.isGLTexture && !h.flipY) && (y || (E += -a.realHeight + 2 * T), b = -1), r.applyITRS(t.x, t.y, t.rotation, t.scaleX * _, t.scaleY * b), s.copyFrom(e.matrix), i ? (s.multiplyWithOffset(i, -e.scrollX * t.scrollFactorX, -e.scrollY * t.scrollFactorY), r.e = t.x, r.f = t.y) : (r.e -= e.scrollX * t.scrollFactorX, r.f -= e.scrollY * t.scrollFactorY), s.multiply(r, o);
							var A = w + v,
								S = E + m,
								C = o.getX(w, E),
								M = o.getY(w, E),
								O = o.getX(w, S),
								P = o.getY(w, S),
								R = o.getX(A, S),
								L = o.getY(A, S),
								D = o.getX(A, E),
								F = o.getY(A, E),
								k = l.getTintAppendFloatAlpha(t._tintTL, e.alpha * t._alphaTL),
								I = l.getTintAppendFloatAlpha(t._tintTR, e.alpha * t._alphaTR),
								B = l.getTintAppendFloatAlpha(t._tintBL, e.alpha * t._alphaBL),
								Y = l.getTintAppendFloatAlpha(t._tintBR, e.alpha * t._alphaBR);
							e.roundPixels && (C = Math.round(C), M = Math.round(M), O = Math.round(O), P = Math.round(P), R = Math.round(R), L = Math.round(L), D = Math.round(D), F = Math.round(F)), this.setTexture2D(h, 0);
							var N = t._isTinted && t.tintFill;
							this.batchQuad(C, M, O, P, R, L, D, F, u, c, d, f, k, I, B, Y, N, h, 0)
						},
						batchQuad: function(t, e, i, n, s, r, o, a, h, u, l, c, d, f, p, g, v, m, y) {
							var x = !1;
							this.vertexCount + 6 > this.vertexCapacity && (this.flush(), x = !0, this.setTexture2D(m, y));
							var T = this.vertexViewF32,
								w = this.vertexViewU32,
								E = this.vertexCount * this.vertexComponentCount - 1;
							return T[++E] = t, T[++E] = e, T[++E] = h, T[++E] = u, T[++E] = v, w[++E] = d, T[++E] = i, T[++E] = n, T[++E] = h, T[++E] = c, T[++E] = v, w[++E] = p, T[++E] = s, T[++E] = r, T[++E] = l, T[++E] = c, T[++E] = v, w[++E] = g, T[++E] = t, T[++E] = e, T[++E] = h, T[++E] = u, T[++E] = v, w[++E] = d, T[++E] = s, T[++E] = r, T[++E] = l, T[++E] = c, T[++E] = v, w[++E] = g, T[++E] = o, T[++E] = a, T[++E] = l, T[++E] = u, T[++E] = v, w[++E] = f, this.vertexCount += 6, x
						},
						batchTri: function(t, e, i, n, s, r, o, a, h, u, l, c, d, f, p, g) {
							var v = !1;
							this.vertexCount + 3 > this.vertexCapacity && (this.flush(), this.setTexture2D(p, g), v = !0);
							var m = this.vertexViewF32,
								y = this.vertexViewU32,
								x = this.vertexCount * this.vertexComponentCount - 1;
							return m[++x] = t, m[++x] = e, m[++x] = o, m[++x] = a, m[++x] = f, y[++x] = l, m[++x] = i, m[++x] = n, m[++x] = o, m[++x] = u, m[++x] = f, y[++x] = c, m[++x] = s, m[++x] = r, m[++x] = h, m[++x] = u, m[++x] = f, y[++x] = d, this.vertexCount += 3, v
						},
						batchTexture: function(t, e, i, n, s, r, o, a, h, u, l, c, d, f, p, g, v, m, y, x, T, w, E, _, b, A, S, C, M, O, P) {
							this.renderer.setPipeline(this, t);
							var R, L, D, F = this._tempMatrix1,
								k = this._tempMatrix2,
								I = this._tempMatrix3,
								B = m / i + S,
								Y = y / n + C,
								N = (m + x) / i + S,
								X = (y + T) / n + C,
								U = o,
								z = a,
								G = -g,
								W = -v;
							t.isCropped && (U = (R = t._crop).width, z = R.height, o = R.width, a = R.height, L = m = R.x, D = y = R.y, c && (L = x - R.x - R.width), d && !e.isRenderTexture && (D = T - R.y - R.height), B = L / i + S, Y = D / n + C, N = (L + R.width) / i + S, X = (D + R.height) / n + C, G = -g + m, W = -v + y), c && (U *= -1, G += o), (d ^= !P && e.isRenderTexture ? 1 : 0) && (z *= -1, W += a);
							var V = G + U,
								H = W + z;
							k.applyITRS(s, r, l, h, u), F.copyFrom(M.matrix), O ? (F.multiplyWithOffset(O, -M.scrollX * f, -M.scrollY * p), k.e = s, k.f = r) : (k.e -= M.scrollX * f, k.f -= M.scrollY * p), F.multiply(k, I);
							var j = I.getX(G, W),
								K = I.getY(G, W),
								q = I.getX(G, H),
								J = I.getY(G, H),
								Z = I.getX(V, H),
								Q = I.getY(V, H),
								$ = I.getX(V, W),
								tt = I.getY(V, W);
							M.roundPixels && (j = Math.round(j), K = Math.round(K), q = Math.round(q), J = Math.round(J), Z = Math.round(Z), Q = Math.round(Q), $ = Math.round($), tt = Math.round(tt)), this.setTexture2D(e, 0), this.batchQuad(j, K, q, J, Z, Q, $, tt, B, Y, N, X, w, E, _, b, A, e, 0)
						},
						batchTextureFrame: function(t, e, i, n, s, r, o) {
							this.renderer.setPipeline(this);
							var a = this._tempMatrix1.copyFrom(r),
								h = this._tempMatrix2,
								u = e + t.width,
								c = i + t.height;
							o ? a.multiply(o, h) : h = a;
							var d = h.getX(e, i),
								f = h.getY(e, i),
								p = h.getX(e, c),
								g = h.getY(e, c),
								v = h.getX(u, c),
								m = h.getY(u, c),
								y = h.getX(u, i),
								x = h.getY(u, i);
							this.setTexture2D(t.glTexture, 0), n = l.getTintAppendFloatAlpha(n, s), this.batchQuad(d, f, p, g, v, m, y, x, t.u0, t.v0, t.u1, t.v1, n, n, n, n, 0, t.glTexture, 0)
						},
						drawFillRect: function(t, e, i, n, s, r) {
							var o = t + i,
								a = e + n;
							this.setTexture2D();
							var h = l.getTintAppendFloatAlphaAndSwap(s, r);
							this.batchQuad(t, e, t, a, o, a, o, e, 0, 0, 1, 1, h, h, h, h, 2)
						},
						batchFillRect: function(t, e, i, n, s, r) {
							this.renderer.setPipeline(this);
							var o = this._tempMatrix3;
							r && r.multiply(s, o);
							var a = t + i,
								h = e + n,
								u = o.getX(t, e),
								l = o.getY(t, e),
								c = o.getX(t, h),
								d = o.getY(t, h),
								f = o.getX(a, h),
								p = o.getY(a, h),
								g = o.getX(a, e),
								v = o.getY(a, e),
								m = this.currentFrame,
								y = m.u0,
								x = m.v0,
								T = m.u1,
								w = m.v1;
							this.batchQuad(u, l, c, d, f, p, g, v, y, x, T, w, this.fillTint.TL, this.fillTint.TR, this.fillTint.BL, this.fillTint.BR, this.tintEffect)
						},
						batchFillTriangle: function(t, e, i, n, s, r, o, a) {
							this.renderer.setPipeline(this);
							var h = this._tempMatrix3;
							a && a.multiply(o, h);
							var u = h.getX(t, e),
								l = h.getY(t, e),
								c = h.getX(i, n),
								d = h.getY(i, n),
								f = h.getX(s, r),
								p = h.getY(s, r),
								g = this.currentFrame,
								v = g.u0,
								m = g.v0,
								y = g.u1,
								x = g.v1;
							this.batchTri(u, l, c, d, f, p, v, m, y, x, this.fillTint.TL, this.fillTint.TR, this.fillTint.BL, this.tintEffect)
						},
						batchStrokeTriangle: function(t, e, i, n, s, r, o, a, h) {
							var u = this.tempTriangle;
							u[0].x = t, u[0].y = e, u[0].width = o, u[1].x = i, u[1].y = n, u[1].width = o, u[2].x = s, u[2].y = r, u[2].width = o, u[3].x = t, u[3].y = e, u[3].width = o, this.batchStrokePath(u, o, !1, a, h)
						},
						batchFillPath: function(t, e, i) {
							this.renderer.setPipeline(this);
							var n = this._tempMatrix3;
							i && i.multiply(e, n);
							for (var r, o, a = t.length, h = this.polygonCache, u = this.fillTint.TL, l = this.fillTint.TR, c = this.fillTint.BL, d = this.tintEffect, f = 0; f < a; ++f) o = t[f], h.push(o.x, o.y);
							a = (r = s(h)).length;
							for (var p = this.currentFrame, g = 0; g < a; g += 3) {
								var v = 2 * r[g + 0],
									m = 2 * r[g + 1],
									y = 2 * r[g + 2],
									x = h[0 + v],
									T = h[1 + v],
									w = h[0 + m],
									E = h[1 + m],
									_ = h[0 + y],
									b = h[1 + y],
									A = n.getX(x, T),
									S = n.getY(x, T),
									C = n.getX(w, E),
									M = n.getY(w, E),
									O = n.getX(_, b),
									P = n.getY(_, b),
									R = p.u0,
									L = p.v0,
									D = p.u1,
									F = p.v1;
								this.batchTri(A, S, C, M, O, P, R, L, D, F, u, l, c, d)
							}
							h.length = 0
						},
						batchStrokePath: function(t, e, i, n, s) {
							this.renderer.setPipeline(this), this.prevQuad[4] = 0, this.firstQuad[4] = 0;
							for (var r = t.length - 1, o = 0; o < r; o++) {
								var a = t[o],
									h = t[o + 1];
								this.batchLine(a.x, a.y, h.x, h.y, a.width / 2, h.width / 2, e, o, !i && o === r - 1, n, s)
							}
						},
						batchLine: function(t, e, i, n, s, r, o, a, h, u, l) {
							this.renderer.setPipeline(this);
							var c = this._tempMatrix3;
							l && l.multiply(u, c);
							var d, f, p = i - t,
								g = n - e,
								v = Math.sqrt(p * p + g * g),
								m = s * (n - e) / v,
								y = s * (t - i) / v,
								x = r * (n - e) / v,
								T = r * (t - i) / v,
								w = i - x,
								E = n - T,
								_ = t - m,
								b = e - y,
								A = i + x,
								S = n + T,
								C = t + m,
								M = e + y,
								O = c.getX(w, E),
								P = c.getY(w, E),
								R = c.getX(_, b),
								L = c.getY(_, b),
								D = c.getX(A, S),
								F = c.getY(A, S),
								k = c.getX(C, M),
								I = c.getY(C, M),
								B = this.strokeTint,
								Y = this.tintEffect,
								N = B.TL,
								X = B.TR,
								U = B.BL,
								z = B.BR,
								G = this.currentFrame,
								W = G.u0,
								V = G.v0,
								H = G.u1,
								j = G.v1;
							this.batchQuad(k, I, R, L, O, P, D, F, W, V, H, j, N, X, U, z, Y), o <= 2 || (d = this.prevQuad, f = this.firstQuad, 0 < a && d[4] ? this.batchQuad(k, I, R, L, d[0], d[1], d[2], d[3], W, V, H, j, N, X, U, z, Y) : (f[0] = k, f[1] = I, f[2] = R, f[3] = L, f[4] = 1), h && f[4] ? this.batchQuad(O, P, D, F, f[0], f[1], f[2], f[3], W, V, H, j, N, X, U, z, Y) : (d[0] = O, d[1] = P, d[2] = D, d[3] = F, d[4] = 1))
						}
					});
				t.exports = d
			}, function(t, e) {
				var i = {
					modelMatrixDirty: !1,
					viewMatrixDirty: !1,
					projectionMatrixDirty: !1,
					modelMatrix: null,
					viewMatrix: null,
					projectionMatrix: null,
					mvpInit: function() {
						return this.modelMatrixDirty = !0, this.viewMatrixDirty = !0, this.projectionMatrixDirty = !0, this.modelMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this
					},
					mvpUpdate: function() {
						var t = this.program;
						return this.modelMatrixDirty && (this.renderer.setMatrix4(t, "uModelMatrix", !1, this.modelMatrix), this.modelMatrixDirty = !1), this.viewMatrixDirty && (this.renderer.setMatrix4(t, "uViewMatrix", !1, this.viewMatrix), this.viewMatrixDirty = !1), this.projectionMatrixDirty && (this.renderer.setMatrix4(t, "uProjectionMatrix", !1, this.projectionMatrix), this.projectionMatrixDirty = !1), this
					},
					modelIdentity: function() {
						var t = this.modelMatrix;
						return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.modelMatrixDirty = !0, this
					},
					modelScale: function(t, e, i) {
						var n = this.modelMatrix;
						return n[0] = n[0] * t, n[1] = n[1] * t, n[2] = n[2] * t, n[3] = n[3] * t, n[4] = n[4] * e, n[5] = n[5] * e, n[6] = n[6] * e, n[7] = n[7] * e, n[8] = n[8] * i, n[9] = n[9] * i, n[10] = n[10] * i, n[11] = n[11] * i, this.modelMatrixDirty = !0, this
					},
					modelTranslate: function(t, e, i) {
						var n = this.modelMatrix;
						return n[12] = n[0] * t + n[4] * e + n[8] * i + n[12], n[13] = n[1] * t + n[5] * e + n[9] * i + n[13], n[14] = n[2] * t + n[6] * e + n[10] * i + n[14], n[15] = n[3] * t + n[7] * e + n[11] * i + n[15], this.modelMatrixDirty = !0, this
					},
					modelRotateX: function(t) {
						var e = this.modelMatrix,
							i = Math.sin(t),
							n = Math.cos(t),
							s = e[4],
							r = e[5],
							o = e[6],
							a = e[7],
							h = e[8],
							u = e[9],
							l = e[10],
							c = e[11];
						return e[4] = s * n + h * i, e[5] = r * n + u * i, e[6] = o * n + l * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = u * n - r * i, e[10] = l * n - o * i, e[11] = c * n - a * i, this.modelMatrixDirty = !0, this
					},
					modelRotateY: function(t) {
						var e = this.modelMatrix,
							i = Math.sin(t),
							n = Math.cos(t),
							s = e[0],
							r = e[1],
							o = e[2],
							a = e[3],
							h = e[8],
							u = e[9],
							l = e[10],
							c = e[11];
						return e[0] = s * n - h * i, e[1] = r * n - u * i, e[2] = o * n - l * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + u * n, e[10] = o * i + l * n, e[11] = a * i + c * n, this.modelMatrixDirty = !0, this
					},
					modelRotateZ: function(t) {
						var e = this.modelMatrix,
							i = Math.sin(t),
							n = Math.cos(t),
							s = e[0],
							r = e[1],
							o = e[2],
							a = e[3],
							h = e[4],
							u = e[5],
							l = e[6],
							c = e[7];
						return e[0] = s * n + h * i, e[1] = r * n + u * i, e[2] = o * n + l * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = u * n - r * i, e[6] = l * n - o * i, e[7] = c * n - a * i, this.modelMatrixDirty = !0, this
					},
					viewIdentity: function() {
						var t = this.viewMatrix;
						return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.viewMatrixDirty = !0, this
					},
					viewScale: function(t, e, i) {
						var n = this.viewMatrix;
						return n[0] = n[0] * t, n[1] = n[1] * t, n[2] = n[2] * t, n[3] = n[3] * t, n[4] = n[4] * e, n[5] = n[5] * e, n[6] = n[6] * e, n[7] = n[7] * e, n[8] = n[8] * i, n[9] = n[9] * i, n[10] = n[10] * i, n[11] = n[11] * i, this.viewMatrixDirty = !0, this
					},
					viewTranslate: function(t, e, i) {
						var n = this.viewMatrix;
						return n[12] = n[0] * t + n[4] * e + n[8] * i + n[12], n[13] = n[1] * t + n[5] * e + n[9] * i + n[13], n[14] = n[2] * t + n[6] * e + n[10] * i + n[14], n[15] = n[3] * t + n[7] * e + n[11] * i + n[15], this.viewMatrixDirty = !0, this
					},
					viewRotateX: function(t) {
						var e = this.viewMatrix,
							i = Math.sin(t),
							n = Math.cos(t),
							s = e[4],
							r = e[5],
							o = e[6],
							a = e[7],
							h = e[8],
							u = e[9],
							l = e[10],
							c = e[11];
						return e[4] = s * n + h * i, e[5] = r * n + u * i, e[6] = o * n + l * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = u * n - r * i, e[10] = l * n - o * i, e[11] = c * n - a * i, this.viewMatrixDirty = !0, this
					},
					viewRotateY: function(t) {
						var e = this.viewMatrix,
							i = Math.sin(t),
							n = Math.cos(t),
							s = e[0],
							r = e[1],
							o = e[2],
							a = e[3],
							h = e[8],
							u = e[9],
							l = e[10],
							c = e[11];
						return e[0] = s * n - h * i, e[1] = r * n - u * i, e[2] = o * n - l * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + u * n, e[10] = o * i + l * n, e[11] = a * i + c * n, this.viewMatrixDirty = !0, this
					},
					viewRotateZ: function(t) {
						var e = this.viewMatrix,
							i = Math.sin(t),
							n = Math.cos(t),
							s = e[0],
							r = e[1],
							o = e[2],
							a = e[3],
							h = e[4],
							u = e[5],
							l = e[6],
							c = e[7];
						return e[0] = s * n + h * i, e[1] = r * n + u * i, e[2] = o * n + l * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = u * n - r * i, e[6] = l * n - o * i, e[7] = c * n - a * i, this.viewMatrixDirty = !0, this
					},
					viewLoad2D: function(t) {
						var e = this.viewMatrix;
						return e[0] = t[0], e[1] = t[1], e[2] = 0, e[3] = 0, e[4] = t[2], e[5] = t[3], e[6] = 0, e[7] = 0, e[8] = t[4], e[9] = t[5], e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this.viewMatrixDirty = !0, this
					},
					viewLoad: function(t) {
						var e = this.viewMatrix;
						return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this.viewMatrixDirty = !0, this
					},
					projIdentity: function() {
						var t = this.projectionMatrix;
						return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.projectionMatrixDirty = !0, this
					},
					projOrtho: function(t, e, i, n, s, r) {
						var o = this.projectionMatrix,
							a = 1 / (t - e),
							h = 1 / (i - n),
							u = 1 / (s - r);
						return o[0] = -2 * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * h, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * u, o[11] = 0, o[12] = (t + e) * a, o[13] = (n + i) * h, o[14] = (r + s) * u, o[15] = 1, this.projectionMatrixDirty = !0, this
					},
					projPersp: function(t, e, i, n) {
						var s = this.projectionMatrix,
							r = 1 / Math.tan(t / 2),
							o = 1 / (i - n);
						return s[0] = r / e, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = r, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = (n + i) * o, s[11] = -1, s[12] = 0, s[13] = 0, s[14] = 2 * n * i * o, s[15] = 0, this.projectionMatrixDirty = !0, this
					}
				};
				t.exports = i
			}, , , function(t, e, i) {
				t.exports = {
					AlignTo: i(527),
					Angle: i(528),
					Call: i(529),
					GetFirst: i(530),
					GetLast: i(531),
					GridAlign: i(532),
					IncAlpha: i(593),
					IncX: i(594),
					IncXY: i(595),
					IncY: i(596),
					PlaceOnCircle: i(597),
					PlaceOnEllipse: i(598),
					PlaceOnLine: i(599),
					PlaceOnRectangle: i(600),
					PlaceOnTriangle: i(601),
					PlayAnimation: i(602),
					PropertyValueInc: i(38),
					PropertyValueSet: i(25),
					RandomCircle: i(603),
					RandomEllipse: i(604),
					RandomLine: i(605),
					RandomRectangle: i(606),
					RandomTriangle: i(607),
					Rotate: i(608),
					RotateAround: i(609),
					RotateAroundDistance: i(610),
					ScaleX: i(611),
					ScaleXY: i(612),
					ScaleY: i(613),
					SetAlpha: i(614),
					SetBlendMode: i(615),
					SetDepth: i(616),
					SetHitArea: i(617),
					SetOrigin: i(618),
					SetRotation: i(619),
					SetScale: i(620),
					SetScaleX: i(621),
					SetScaleY: i(622),
					SetScrollFactor: i(623),
					SetScrollFactorX: i(624),
					SetScrollFactorY: i(625),
					SetTint: i(626),
					SetVisible: i(627),
					SetX: i(628),
					SetXY: i(629),
					SetY: i(630),
					ShiftPosition: i(631),
					Shuffle: i(632),
					SmootherStep: i(633),
					SmoothStep: i(634),
					Spread: i(635),
					ToggleVisible: i(636),
					WrapInRectangle: i(637)
				}
			}, function(t, e, i) {
				var n = i(105),
					s = [];
				s[n.BOTTOM_CENTER] = i(243), s[n.BOTTOM_LEFT] = i(244), s[n.BOTTOM_RIGHT] = i(245), s[n.LEFT_BOTTOM] = i(246), s[n.LEFT_CENTER] = i(247), s[n.LEFT_TOP] = i(248), s[n.RIGHT_BOTTOM] = i(249), s[n.RIGHT_CENTER] = i(250), s[n.RIGHT_TOP] = i(251), s[n.TOP_CENTER] = i(252), s[n.TOP_LEFT] = i(253), s[n.TOP_RIGHT] = i(254), t.exports = function(t, e, i, n, r) {
					return s[i](t, e, n, r)
				}
			}, function(t, e, i) {
				var n = i(34),
					s = i(76),
					r = i(77),
					o = i(43);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) + i), o(t, n(e) + a), t
				}
			}, function(t, e, i) {
				var n = i(34),
					s = i(35),
					r = i(44),
					o = i(43);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) - i), o(t, n(e) + a), t
				}
			}, function(t, e, i) {
				var n = i(34),
					s = i(36),
					r = i(45),
					o = i(43);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) + i), o(t, n(e) + a), t
				}
			}, function(t, e, i) {
				var n = i(34),
					s = i(35),
					r = i(46),
					o = i(45);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t
				}
			}, function(t, e, i) {
				var n = i(78),
					s = i(35),
					r = i(79),
					o = i(45);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t
				}
			}, function(t, e, i) {
				var n = i(35),
					s = i(37),
					r = i(45),
					o = i(43);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) - i), o(t, s(e) - a), t
				}
			}, function(t, e, i) {
				var n = i(34),
					s = i(36),
					r = i(46),
					o = i(44);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t
				}
			}, function(t, e, i) {
				var n = i(78),
					s = i(36),
					r = i(79),
					o = i(44);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t
				}
			}, function(t, e, i) {
				var n = i(36),
					s = i(37),
					r = i(44),
					o = i(43);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) - a), t
				}
			}, function(t, e, i) {
				var n = i(76),
					s = i(37),
					r = i(46),
					o = i(77);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) + i), r(t, s(e) - a), t
				}
			}, function(t, e, i) {
				var n = i(35),
					s = i(37),
					r = i(46),
					o = i(44);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) - i), r(t, s(e) - a), t
				}
			}, function(t, e, i) {
				var n = i(36),
					s = i(37),
					r = i(46),
					o = i(45);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) + i), r(t, s(e) - a), t
				}
			}, function(t, e, i) {
				var n = i(105),
					s = [];
				s[n.BOTTOM_CENTER] = i(256), s[n.BOTTOM_LEFT] = i(257), s[n.BOTTOM_RIGHT] = i(258), s[n.CENTER] = i(259), s[n.LEFT_CENTER] = i(261), s[n.RIGHT_CENTER] = i(262), s[n.TOP_CENTER] = i(263), s[n.TOP_LEFT] = i(264), s[n.TOP_RIGHT] = i(265), s[n.LEFT_BOTTOM] = s[n.BOTTOM_LEFT], s[n.LEFT_TOP] = s[n.TOP_LEFT], s[n.RIGHT_BOTTOM] = s[n.BOTTOM_RIGHT], s[n.RIGHT_TOP] = s[n.TOP_RIGHT], t.exports = function(t, e, i, n, r) {
					return s[i](t, e, n, r)
				}
			}, function(t, e, i) {
				var n = i(34),
					s = i(76),
					r = i(46),
					o = i(77);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t
				}
			}, function(t, e, i) {
				var n = i(34),
					s = i(35),
					r = i(46),
					o = i(44);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t
				}
			}, function(t, e, i) {
				var n = i(34),
					s = i(36),
					r = i(46),
					o = i(45);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t
				}
			}, function(t, e, i) {
				var n = i(260),
					s = i(76),
					r = i(78);
				t.exports = function(t, e, i, o) {
					return void 0 === i && (i = 0), void 0 === o && (o = 0), n(t, s(e) + i, r(e) + o), t
				}
			}, function(t, e, i) {
				var n = i(77),
					s = i(79);
				t.exports = function(t, e, i) {
					return n(t, e), s(t, i)
				}
			}, function(t, e, i) {
				var n = i(78),
					s = i(35),
					r = i(79),
					o = i(44);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t
				}
			}, function(t, e, i) {
				var n = i(78),
					s = i(36),
					r = i(79),
					o = i(45);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t
				}
			}, function(t, e, i) {
				var n = i(76),
					s = i(37),
					r = i(77),
					o = i(43);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) - a), t
				}
			}, function(t, e, i) {
				var n = i(35),
					s = i(37),
					r = i(44),
					o = i(43);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) - i), o(t, s(e) - a), t
				}
			}, function(t, e, i) {
				var n = i(36),
					s = i(37),
					r = i(45),
					o = i(43);
				t.exports = function(t, e, i, a) {
					return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) - a), t
				}
			}, function(t, e, i) {
				var n = i(149),
					s = i(87),
					r = i(13),
					o = i(4);
				t.exports = function(t, e, i) {
					void 0 === i && (i = new o);
					var a = s(e, 0, r.PI2);
					return n(t, a, i)
				}
			}, function(t, e, i) {
				var n = i(268),
					s = i(149),
					r = i(87),
					o = i(13);
				t.exports = function(t, e, i, a) {
					void 0 === a && (a = []), !e && 0 < i && (e = n(t) / i);
					for (var h = 0; h < e; h++) {
						var u = r(h / e, 0, o.PI2);
						a.push(s(t, u))
					}
					return a
				}
			}, function(t, e) {
				t.exports = function(t) {
					return Math.PI * t.radius * 2
				}
			}, function(t, e, i) {
				var n = i(19),
					s = {
						_alpha: 1,
						clearAlpha: function() {
							return this.setAlpha(1)
						},
						setAlpha: function(t) {
							return void 0 === t && (t = 1), this.alpha = t, this
						},
						alpha: {
							get: function() {
								return this._alpha
							},
							set: function(t) {
								var e = n(t, 0, 1);
								0 === (this._alpha = e) ? this.renderFlags &= -3 : this.renderFlags |= 2
							}
						}
					};
				t.exports = s
			}, function(t, e) {
				t.exports = function(t, e, i) {
					if (!e.length) return NaN;
					if (1 === e.length) return e[0];
					var n, s, r = 1;
					if (i) {
						if (t < e[0][i]) return e[0];
						for (; e[r][i] < t;) r++
					} else
						for (; e[r] < t;) r++;
					return r > e.length && (r = e.length), i ? (n = e[r - 1][i], (s = e[r][i]) - t <= t - n ? e[r] : e[r - 1]) : (n = e[r - 1], (s = e[r]) - t <= t - n ? s : n)
				}
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t, e, i, n) {
						this.textureKey = t, this.textureFrame = e, this.index = i, this.frame = n, this.isFirst = !1, this.isLast = !1, this.prevFrame = null, this.nextFrame = null, this.duration = 0, this.progress = 0
					},
					toJSON: function() {
						return {
							key: this.textureKey,
							frame: this.textureFrame,
							duration: this.duration
						}
					},
					destroy: function() {
						this.frame = void 0
					}
				});
				t.exports = n
			}, function(t, e, i) {
				var n = i(52),
					s = {
						_blendMode: n.NORMAL,
						blendMode: {
							get: function() {
								return this._blendMode
							},
							set: function(t) {
								"string" == typeof t && (t = n[t]), -1 <= (t |= 0) && (this._blendMode = t)
							}
						},
						setBlendMode: function(t) {
							return this.blendMode = t, this
						}
					};
				t.exports = s
			}, function(t, e) {
				t.exports = {
					_depth: 0,
					depth: {
						get: function() {
							return this._depth
						},
						set: function(t) {
							this.scene.sys.queueDepthSort(), this._depth = t
						}
					},
					setDepth: function(t) {
						return void 0 === t && (t = 0), this.depth = t, this
					}
				}
			}, function(t, e, i) {
				var n = i(152),
					s = i(112);
				t.exports = function(t, e, i, r) {
					void 0 === r && (r = []), !e && 0 < i && (e = s(t) / i);
					for (var o = 0; o < e; o++) {
						var a = o / e;
						r.push(n(t, a))
					}
					return r
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e, i) {
					return void 0 === i && (i = new n), i.x = t.x1 + (t.x2 - t.x1) * e, i.y = t.y1 + (t.y2 - t.y1) * e, i
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					var s = Math.cos(n),
						r = Math.sin(n),
						o = t.x - e,
						a = t.y - i;
					return t.x = o * s - a * r + e, t.y = o * r + a * s + i, t
				}
			}, function(t, e, i) {
				var n = i(278),
					s = i(279),
					r = {
						mask: null,
						setMask: function(t) {
							return this.mask = t, this
						},
						clearMask: function(t) {
							return void 0 === t && (t = !1), t && this.mask && this.mask.destroy(), this.mask = null, this
						},
						createBitmapMask: function(t) {
							return void 0 === t && (this.texture || this.shader) && (t = this), new n(this.scene, t)
						},
						createGeometryMask: function(t) {
							return void 0 === t && "Graphics" === this.type && (t = this), new s(this.scene, t)
						}
					};
				t.exports = r
			}, function(t, e, i) {
				var n = i(0),
					s = i(20),
					r = new n({
						initialize: function(t, e) {
							var i, n, r, o, a, h, u = t.sys.game.renderer;
							this.renderer = u, this.bitmapMask = e, this.maskTexture = null, this.mainTexture = null, this.dirty = !0, this.mainFramebuffer = null, this.maskFramebuffer = null, this.prevFramebuffer = null, this.invertAlpha = !1, this.isStencil = !1, u && u.gl && (i = u.width, n = u.height, r = 0 == (i & i - 1) && 0 == (n & n - 1), o = u.gl, a = r ? o.REPEAT : o.CLAMP_TO_EDGE, h = o.LINEAR, this.mainTexture = u.createTexture2D(0, h, h, a, a, o.RGBA, null, i, n), this.maskTexture = u.createTexture2D(0, h, h, a, a, o.RGBA, null, i, n), this.mainFramebuffer = u.createFramebuffer(i, n, this.mainTexture, !0), this.maskFramebuffer = u.createFramebuffer(i, n, this.maskTexture, !0), t.sys.game.events.on(s.CONTEXT_RESTORED, function(t) {
								var e = t.width,
									i = t.height,
									n = 0 == (e & e - 1) && 0 == (i & i - 1),
									s = t.gl,
									r = n ? s.REPEAT : s.CLAMP_TO_EDGE,
									o = s.LINEAR;
								this.mainTexture = t.createTexture2D(0, o, o, r, r, s.RGBA, null, e, i), this.maskTexture = t.createTexture2D(0, o, o, r, r, s.RGBA, null, e, i), this.mainFramebuffer = t.createFramebuffer(e, i, this.mainTexture, !0), this.maskFramebuffer = t.createFramebuffer(e, i, this.maskTexture, !0)
							}, this))
						},
						setBitmap: function(t) {
							this.bitmapMask = t
						},
						preRenderWebGL: function(t, e, i) {
							t.pipelines.BitmapMaskPipeline.beginMask(this, e, i)
						},
						postRenderWebGL: function(t, e) {
							t.pipelines.BitmapMaskPipeline.endMask(this, e)
						},
						preRenderCanvas: function() {},
						postRenderCanvas: function() {},
						destroy: function() {
							this.bitmapMask = null;
							var t = this.renderer;
							t && t.gl && (t.deleteTexture(this.mainTexture), t.deleteTexture(this.maskTexture), t.deleteFramebuffer(this.mainFramebuffer), t.deleteFramebuffer(this.maskFramebuffer)), this.mainTexture = null, this.maskTexture = null, this.mainFramebuffer = null, this.maskFramebuffer = null, this.prevFramebuffer = null, this.renderer = null
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t, e) {
						this.geometryMask = e, this.invertAlpha = !1, this.isStencil = !0, this.level = 0
					},
					setShape: function(t) {
						return this.geometryMask = t, this
					},
					setInvertAlpha: function(t) {
						return void 0 === t && (t = !0), this.invertAlpha = t, this
					},
					preRenderWebGL: function(t, e, i) {
						var n = t.gl;
						t.flush(), 0 === t.maskStack.length && (n.enable(n.STENCIL_TEST), n.clear(n.STENCIL_BUFFER_BIT), t.maskCount = 0), t.currentCameraMask.mask !== this && (t.currentMask.mask = this), t.maskStack.push({
							mask: this,
							camera: i
						}), this.applyStencil(t, i, !0), t.maskCount++
					},
					applyStencil: function(t, e, i) {
						var n = t.gl,
							s = this.geometryMask,
							r = t.maskCount;
						n.colorMask(!1, !1, !1, !1), i ? (n.stencilFunc(n.EQUAL, r, 255), n.stencilOp(n.KEEP, n.KEEP, n.INCR)) : (n.stencilFunc(n.EQUAL, r + 1, 255), n.stencilOp(n.KEEP, n.KEEP, n.DECR)), s.renderWebGL(t, s, 0, e), t.flush(), n.colorMask(!0, !0, !0, !0), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), i ? this.invertAlpha ? n.stencilFunc(n.NOTEQUAL, r + 1, 255) : n.stencilFunc(n.EQUAL, r + 1, 255) : this.invertAlpha ? n.stencilFunc(n.NOTEQUAL, r, 255) : n.stencilFunc(n.EQUAL, r, 255)
					},
					postRenderWebGL: function(t) {
						var e, i = t.gl;
						t.maskStack.pop(), t.maskCount--, 0 === t.maskStack.length ? (t.flush(), t.currentMask.mask = null, i.disable(i.STENCIL_TEST)) : (t.flush(), (e = t.maskStack[t.maskStack.length - 1]).mask.applyStencil(t, e.camera, !1), t.currentCameraMask.mask !== e.mask ? (t.currentMask.mask = e.mask, t.currentMask.camera = e.camera) : t.currentMask.mask = null)
					},
					preRenderCanvas: function(t, e, i) {
						var n = this.geometryMask;
						t.currentContext.save(), n.renderCanvas(t, n, 0, i, null, null, !0), t.currentContext.clip()
					},
					postRenderCanvas: function(t) {
						t.currentContext.restore()
					},
					destroy: function() {
						this.geometryMask = null
					}
				});
				t.exports = n
			}, function(t, e) {
				t.exports = {
					scrollFactorX: 1,
					scrollFactorY: 1,
					setScrollFactor: function(t, e) {
						return void 0 === e && (e = t), this.scrollFactorX = t, this.scrollFactorY = e, this
					}
				}
			}, function(t, e) {
				t.exports = function(t) {
					var e = {
						name: t.name,
						type: t.type,
						x: t.x,
						y: t.y,
						depth: t.depth,
						scale: {
							x: t.scaleX,
							y: t.scaleY
						},
						origin: {
							x: t.originX,
							y: t.originY
						},
						flipX: t.flipX,
						flipY: t.flipY,
						rotation: t.rotation,
						alpha: t.alpha,
						visible: t.visible,
						blendMode: t.blendMode,
						textureKey: "",
						frameKey: "",
						data: {}
					};
					return t.texture && (e.textureKey = t.texture.key, e.frameKey = t.frame.name), e
				}
			}, function(t, e, i) {
				var n = i(13),
					s = i(29),
					r = i(235),
					o = i(236),
					a = {
						_scaleX: 1,
						_scaleY: 1,
						_rotation: 0,
						x: 0,
						y: 0,
						z: 0,
						w: 0,
						scale: {
							get: function() {
								return (this._scaleX + this._scaleY) / 2
							},
							set: function(t) {
								this._scaleX = t, 0 === (this._scaleY = t) ? this.renderFlags &= -5 : this.renderFlags |= 4
							}
						},
						scaleX: {
							get: function() {
								return this._scaleX
							},
							set: function(t) {
								0 === (this._scaleX = t) ? this.renderFlags &= -5 : this.renderFlags |= 4
							}
						},
						scaleY: {
							get: function() {
								return this._scaleY
							},
							set: function(t) {
								0 === (this._scaleY = t) ? this.renderFlags &= -5 : this.renderFlags |= 4
							}
						},
						angle: {
							get: function() {
								return o(this._rotation * n.RAD_TO_DEG)
							},
							set: function(t) {
								this.rotation = o(t) * n.DEG_TO_RAD
							}
						},
						rotation: {
							get: function() {
								return this._rotation
							},
							set: function(t) {
								this._rotation = r(t)
							}
						},
						setPosition: function(t, e, i, n) {
							return void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.z = i, this.w = n, this
						},
						setRandomPosition: function(t, e, i, n) {
							return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.scale.width), void 0 === n && (n = this.scene.sys.scale.height), this.x = t + Math.random() * i, this.y = e + Math.random() * n, this
						},
						setRotation: function(t) {
							return void 0 === t && (t = 0), this.rotation = t, this
						},
						setAngle: function(t) {
							return void 0 === t && (t = 0), this.angle = t, this
						},
						setScale: function(t, e) {
							return void 0 === t && (t = 1), void 0 === e && (e = t), this.scaleX = t, this.scaleY = e, this
						},
						setX: function(t) {
							return void 0 === t && (t = 0), this.x = t, this
						},
						setY: function(t) {
							return void 0 === t && (t = 0), this.y = t, this
						},
						setZ: function(t) {
							return void 0 === t && (t = 0), this.z = t, this
						},
						setW: function(t) {
							return void 0 === t && (t = 0), this.w = t, this
						},
						getLocalTransformMatrix: function(t) {
							return void 0 === t && (t = new s), t.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY)
						},
						getWorldTransformMatrix: function(t, e) {
							void 0 === t && (t = new s), void 0 === e && (e = new s);
							var i = this.parentContainer;
							if (!i) return this.getLocalTransformMatrix(t);
							for (t.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY); i;) e.applyITRS(i.x, i.y, i._rotation, i._scaleX, i._scaleY), e.multiply(t, t), i = i.parentContainer;
							return t
						},
						getParentRotation: function() {
							for (var t = 0, e = this.parentContainer; e;) t += e.rotation, e = e.parentContainer;
							return t
						}
					};
				t.exports = a
			}, function(t, e) {
				t.exports = {
					_visible: !0,
					visible: {
						get: function() {
							return this._visible
						},
						set: function(t) {
							t ? (this._visible = !0, this.renderFlags |= 1) : (this._visible = !1, this.renderFlags &= -2)
						}
					},
					setVisible: function(t) {
						return this.visible = t, this
					}
				}
			}, function(t, e, i) {
				t.exports = {
					CHANGE_DATA: i(578),
					CHANGE_DATA_KEY: i(579),
					REMOVE_DATA: i(580),
					SET_DATA: i(581)
				}
			}, function(t, e, i) {
				var n = i(112),
					s = i(4);
				t.exports = function(t, e, i, r) {
					if (void 0 === r && (r = []), !e && !i) return r;
					e ? i = Math.round(n(t) / e) : e = n(t) / i;
					for (var o = t.x, a = t.y, h = 0, u = 0; u < i; u++) switch (r.push(new s(o, a)), h) {
						case 0:
							(o += e) >= t.right && (h = 1, a += o - t.right, o = t.right);
							break;
						case 1:
							(a += e) >= t.bottom && (h = 2, o -= a - t.bottom, a = t.bottom);
							break;
						case 2:
							(o -= e) <= t.left && (h = 3, a -= t.left - o, o = t.left);
							break;
						case 3:
							(a -= e) <= t.top && (h = 0, a = t.top)
					}
					return r
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					void 0 === e && (e = 1);
					for (var i = null, n = 0; n < e; n++) i = t.shift(), t.push(i);
					return i
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					void 0 === e && (e = 1);
					for (var i = null, n = 0; n < e; n++) i = t.pop(), t.unshift(i);
					return i
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					void 0 === e && (e = 1), void 0 === i && (i = []);
					var n = Math.round(t.x1),
						s = Math.round(t.y1),
						r = Math.round(t.x2),
						o = Math.round(t.y2),
						a = Math.abs(r - n),
						h = Math.abs(o - s),
						u = n < r ? 1 : -1,
						l = s < o ? 1 : -1,
						c = a - h;
					i.push({
						x: n,
						y: s
					});
					for (var d = 1; n !== r || s !== o;) {
						var f = c << 1; - h < f && (c -= h, n += u), f < a && (c += a, s += l), d % e == 0 && i.push({
							x: n,
							y: s
						}), d++
					}
					return i
				}
			}, function(t, e, i) {
				var n = i(151),
					s = i(0),
					r = i(162),
					o = i(10),
					a = i(111),
					h = i(20),
					u = i(6),
					l = i(163),
					c = new s({
						Extends: o,
						initialize: function(t) {
							o.call(this), this.game = t, this.textureManager = null, this.globalTimeScale = 1, this.anims = new r, this.paused = !1, this.name = "AnimationManager", t.events.once(h.BOOT, this.boot, this)
						},
						boot: function() {
							this.textureManager = this.game.textures, this.game.events.once(h.DESTROY, this.destroy, this)
						},
						add: function(t, e) {
							return this.anims.has(t) ? console.warn("Animation key exists: " + t) : (e.key = t, this.anims.set(t, e), this.emit(a.ADD_ANIMATION, t, e)), this
						},
						exists: function(t) {
							return this.anims.has(t)
						},
						create: function(t) {
							var e = t.key,
								i = !1;
							return e && ((i = this.get(e)) || (i = new n(this, e, t), this.anims.set(e, i), this.emit(a.ADD_ANIMATION, e, i))), i
						},
						fromJSON: function(t, e) {
							void 0 === e && (e = !1), e && this.anims.clear(), "string" == typeof t && (t = JSON.parse(t));
							var i = [];
							if (t.hasOwnProperty("anims") && Array.isArray(t.anims)) {
								for (var n = 0; n < t.anims.length; n++) i.push(this.create(t.anims[n]));
								t.hasOwnProperty("globalTimeScale") && (this.globalTimeScale = t.globalTimeScale)
							} else t.hasOwnProperty("key") && "frame" === t.type && i.push(this.create(t));
							return i
						},
						generateFrameNames: function(t, e) {
							var i = u(e, "prefix", ""),
								n = u(e, "start", 0),
								s = u(e, "end", 0),
								r = u(e, "suffix", ""),
								o = u(e, "zeroPad", 0),
								a = u(e, "outputArray", []),
								h = u(e, "frames", !1),
								c = this.textureManager.get(t);
							if (!c) return a;
							var d, f, p = n < s ? 1 : -1;
							if (s += p, e)
								if (Array.isArray(h))
									for (d = 0; d < h.length; d++) f = i + l(h[d], o, "0", 1) + r, c.has(f) && a.push({
										key: t,
										frame: f
									});
								else
									for (d = n; d !== s; d += p) f = i + l(d, o, "0", 1) + r, c.has(f) && a.push({
										key: t,
										frame: f
									});
							else
								for (h = c.getFrameNames(), d = 0; d < h.length; d++) a.push({
									key: t,
									frame: h[d]
								});
							return a
						},
						generateFrameNumbers: function(t, e) {
							var i, n = u(e, "start", 0),
								s = u(e, "end", -1),
								r = u(e, "first", !1),
								o = u(e, "outputArray", []),
								a = u(e, "frames", !1),
								h = this.textureManager.get(t);
							if (!h) return o;
							if (r && h.has(r) && o.push({
									key: t,
									frame: r
								}), Array.isArray(a))
								for (i = 0; i < a.length; i++) h.has(a[i]) && o.push({
									key: t,
									frame: a[i]
								});
							else {
								-1 === s && (s = h.frameTotal);
								var l = n < s ? 1 : -1;
								for (s += l, i = n; i !== s; i += l) h.has(i) && o.push({
									key: t,
									frame: i
								})
							}
							return o
						},
						get: function(t) {
							return this.anims.get(t)
						},
						load: function(t, e, i) {
							var n = this.get(e);
							return n ? n.load(t, i) : console.warn("Missing animation: " + e), t
						},
						pauseAll: function() {
							return this.paused || (this.paused = !0, this.emit(a.PAUSE_ALL)), this
						},
						play: function(t, e) {
							if (Array.isArray(e) || (e = [e]), !this.get(t)) return this;
							for (var i = 0; i < e.length; i++) e[i].anims.play(t);
							return this
						},
						remove: function(t) {
							var e = this.get(t);
							return e && (this.emit(a.REMOVE_ANIMATION, t, e), this.anims.delete(t)), e
						},
						resumeAll: function() {
							return this.paused && (this.paused = !1, this.emit(a.RESUME_ALL)), this
						},
						staggerPlay: function(t, e, i) {
							if (void 0 === i && (i = 0), Array.isArray(e) || (e = [e]), !this.get(t)) return this;
							for (var n = 0; n < e.length; n++) e[n].anims.delayedPlay(i * n, t);
							return this
						},
						toJSON: function(t) {
							var e = {
								anims: [],
								globalTimeScale: this.globalTimeScale
							};
							return void 0 !== t && "" !== t ? e.anims.push(this.anims.get(t).toJSON()) : this.anims.each(function(t, i) {
								e.anims.push(i.toJSON())
							}), e
						},
						destroy: function() {
							this.anims.clear(), this.textureManager = null, this.game = null
						}
					});
				t.exports = c
			}, function(t, e, i) {
				var n = i(0),
					s = i(162),
					r = i(10),
					o = i(291),
					a = new n({
						initialize: function() {
							this.entries = new s, this.events = new r
						},
						add: function(t, e) {
							return this.entries.set(t, e), this.events.emit(o.ADD, this, t, e), this
						},
						has: function(t) {
							return this.entries.has(t)
						},
						exists: function(t) {
							return this.entries.has(t)
						},
						get: function(t) {
							return this.entries.get(t)
						},
						remove: function(t) {
							var e = this.get(t);
							return e && (this.entries.delete(t), this.events.emit(o.REMOVE, this, t, e.data)), this
						},
						getKeys: function() {
							return this.entries.keys()
						},
						destroy: function() {
							this.entries.clear(), this.events.removeAllListeners(), this.entries = null, this.events = null
						}
					});
				t.exports = a
			}, function(t, e, i) {
				t.exports = {
					ADD: i(640),
					REMOVE: i(641)
				}
			}, function(t, e, i) {
				var n = i(290),
					s = i(0),
					r = i(20),
					o = new s({
						initialize: function(t) {
							this.game = t, this.binary = new n, this.bitmapFont = new n, this.json = new n, this.physics = new n, this.shader = new n, this.audio = new n, this.video = new n, this.text = new n, this.html = new n, this.obj = new n, this.tilemap = new n, this.xml = new n, this.custom = {}, this.game.events.once(r.DESTROY, this.destroy, this)
						},
						addCustom: function(t) {
							return this.custom.hasOwnProperty(t) || (this.custom[t] = new n), this.custom[t]
						},
						destroy: function() {
							for (var t = ["binary", "bitmapFont", "json", "physics", "shader", "audio", "video", "text", "html", "obj", "tilemap", "xml"], e = 0; e < t.length; e++) this[t[e]].destroy(), this[t[e]] = null;
							for (var i in this.custom) this.custom[i].destroy();
							this.custom = null, this.game = null
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(91),
					s = i(26),
					r = i(168),
					o = i(19),
					a = i(0),
					h = i(12),
					u = i(301),
					l = i(116),
					c = i(11),
					d = i(3),
					f = new a({
						Extends: n,
						Mixins: [h.Flip, h.Tint],
						initialize: function(t, e, i, s) {
							n.call(this, t, e, i, s), this.inputEnabled = !0, this.fadeEffect = new u.Fade(this), this.flashEffect = new u.Flash(this), this.shakeEffect = new u.Shake(this), this.panEffect = new u.Pan(this), this.rotateToEffect = new u.RotateTo(this), this.zoomEffect = new u.Zoom(this), this.lerp = new d(1, 1), this.followOffset = new d, this.deadzone = null, this._follow = null, this.renderToTexture = !1, this.renderToGame = !0, this.canvas = null, this.context = null, this.glTexture = null, this.framebuffer = null, this.pipeline = null
						},
						setRenderToTexture: function(t, e) {
							void 0 === e && (e = !0);
							var i = this.scene.sys.game.renderer;
							return i.gl ? (this.glTexture = i.createTextureFromSource(null, this.width, this.height, 0), this.framebuffer = i.createFramebuffer(this.width, this.height, this.glTexture, !1)) : (this.canvas = s.create2D(this, this.width, this.height), this.context = this.canvas.getContext("2d")), this.renderToTexture = !0, this.renderToGame = e, t && this.setPipeline(t), this
						},
						setPipeline: function(t) {
							var e;
							return "string" == typeof t ? (e = this.scene.sys.game.renderer).gl && e.hasPipeline(t) && (this.pipeline = e.getPipeline(t)) : this.pipeline = t, this
						},
						clearRenderToTexture: function() {
							if (this.scene) {
								var t = this.scene.sys.game.renderer;
								if (t) return t.gl ? (this.framebuffer && t.deleteFramebuffer(this.framebuffer), this.glTexture && t.deleteTexture(this.glTexture), this.framebuffer = null, this.glTexture = null, this.pipeline = null) : (s.remove(this), this.canvas = null, this.context = null), this.renderToTexture = !1, this
							}
						},
						setDeadzone: function(t, e) {
							var i, n, s, o;
							return void 0 === t ? this.deadzone = null : (this.deadzone ? (this.deadzone.width = t, this.deadzone.height = e) : this.deadzone = new c(0, 0, t, e), this._follow && (i = this.width / 2, n = this.height / 2, s = this._follow.x - this.followOffset.x, o = this._follow.y - this.followOffset.y, this.midPoint.set(s, o), this.scrollX = s - i, this.scrollY = o - n), r(this.deadzone, this.midPoint.x, this.midPoint.y)), this
						},
						fadeIn: function(t, e, i, n, s, r) {
							return this.fadeEffect.start(!1, t, e, i, n, !0, s, r)
						},
						fadeOut: function(t, e, i, n, s, r) {
							return this.fadeEffect.start(!0, t, e, i, n, !0, s, r)
						},
						fadeFrom: function(t, e, i, n, s, r, o) {
							return this.fadeEffect.start(!1, t, e, i, n, s, r, o)
						},
						fade: function(t, e, i, n, s, r, o) {
							return this.fadeEffect.start(!0, t, e, i, n, s, r, o)
						},
						flash: function(t, e, i, n, s, r, o) {
							return this.flashEffect.start(t, e, i, n, s, r, o)
						},
						shake: function(t, e, i, n, s) {
							return this.shakeEffect.start(t, e, i, n, s)
						},
						pan: function(t, e, i, n, s, r, o) {
							return this.panEffect.start(t, e, i, n, s, r, o)
						},
						rotateTo: function(t, e, i, n, s, r, o) {
							return this.rotateToEffect.start(t, e, i, n, s, r, o)
						},
						zoomTo: function(t, e, i, n, s, r) {
							return this.zoomEffect.start(t, e, i, n, s, r)
						},
						preRender: function(t) {
							var e, i, n = this.width,
								s = this.height,
								o = .5 * n,
								a = .5 * s,
								h = this.zoom * t,
								u = this.matrix,
								c = n * this.originX,
								d = s * this.originY,
								f = this._follow,
								p = this.deadzone,
								g = this.scrollX,
								v = this.scrollY;
							p && r(p, this.midPoint.x, this.midPoint.y), f && !this.panEffect.isRunning && (e = f.x - this.followOffset.x, i = f.y - this.followOffset.y, p ? (e < p.x ? g = l(g, g - (p.x - e), this.lerp.x) : e > p.right && (g = l(g, g + (e - p.right), this.lerp.x)), i < p.y ? v = l(v, v - (p.y - i), this.lerp.y) : i > p.bottom && (v = l(v, v + (i - p.bottom), this.lerp.y))) : (g = l(g, e - c, this.lerp.x), v = l(v, i - d, this.lerp.y))), this.useBounds && (g = this.clampX(g), v = this.clampY(v)), this.roundPixels && (c = Math.round(c), d = Math.round(d));
							var m = (this.scrollX = g) + o,
								y = (this.scrollY = v) + a;
							this.midPoint.set(m, y);
							var x = n / h,
								T = s / h;
							this.worldView.setTo(m - x / 2, y - T / 2, x, T), u.applyITRS(this.x + c, this.y + d, this.rotation, h, h), u.translate(-c, -d), this.shakeEffect.preRender()
						},
						setLerp: function(t, e) {
							return void 0 === t && (t = 1), void 0 === e && (e = t), this.lerp.set(t, e), this
						},
						setFollowOffset: function(t, e) {
							return void 0 === t && (t = 0), void 0 === e && (e = 0), this.followOffset.set(t, e), this
						},
						startFollow: function(t, e, i, n, s, r) {
							void 0 === e && (e = !1), void 0 === i && (i = 1), void 0 === n && (n = i), void 0 === s && (s = 0), void 0 === r && (r = s), this._follow = t, this.roundPixels = e, i = o(i, 0, 1), n = o(n, 0, 1), this.lerp.set(i, n), this.followOffset.set(s, r);
							var a = this.width / 2,
								h = this.height / 2,
								u = t.x - s,
								l = t.y - r;
							return this.midPoint.set(u, l), this.scrollX = u - a, this.scrollY = l - h, this.useBounds && (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this
						},
						stopFollow: function() {
							return this._follow = null, this
						},
						resetFX: function() {
							return this.rotateToEffect.reset(), this.panEffect.reset(), this.shakeEffect.reset(), this.flashEffect.reset(), this.fadeEffect.reset(), this
						},
						update: function(t, e) {
							this.visible && (this.rotateToEffect.update(t, e), this.panEffect.update(t, e), this.zoomEffect.update(t, e), this.shakeEffect.update(t, e), this.flashEffect.update(t, e), this.fadeEffect.update(t, e))
						},
						destroy: function() {
							this.clearRenderToTexture(), this.resetFX(), n.prototype.destroy.call(this), this._follow = null, this.deadzone = null
						}
					});
				t.exports = f
			}, function(t, e, i) {
				var n = i(31);
				t.exports = function(t) {
					var e = new n;
					t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, n) {
						return e + e + i + i + n + n
					});
					var i, s, r, o = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
					return o && (i = parseInt(o[1], 16), s = parseInt(o[2], 16), r = parseInt(o[3], 16), e.setTo(i, s, r)), e
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					return n << 24 | t << 16 | e << 8 | i
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					void 0 === n && (n = {
						h: 0,
						s: 0,
						v: 0
					}), t /= 255, e /= 255, i /= 255;
					var s = Math.min(t, e, i),
						r = Math.max(t, e, i),
						o = r - s,
						a = 0,
						h = 0 === r ? 0 : o / r,
						u = r;
					return r !== s && (r === t ? a = (e - i) / o + (e < i ? 6 : 0) : r === e ? a = (i - t) / o + 2 : r === i && (a = (t - e) / o + 4), a /= 6), n.hasOwnProperty("_h") ? (n._h = a, n._s = h, n._v = u) : (n.h = a, n.s = h, n.v = u), n
				}
			}, function(t, e, i) {
				var n = i(31),
					s = i(298);
				t.exports = function(t) {
					var e = s(t);
					return new n(e.r, e.g, e.b, e.a)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return 16777215 < t ? {
						a: t >>> 24,
						r: t >> 16 & 255,
						g: t >> 8 & 255,
						b: 255 & t
					} : {
						a: 255,
						r: t >> 16 & 255,
						g: t >> 8 & 255,
						b: 255 & t
					}
				}
			}, function(t, e, i) {
				var n = i(31);
				t.exports = function(t) {
					return new n(t.r, t.g, t.b, t.a)
				}
			}, function(t, e, i) {
				var n = i(31);
				t.exports = function(t) {
					var e, i, s, r, o = new n,
						a = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t.toLowerCase());
					return a && (e = parseInt(a[1], 10), i = parseInt(a[2], 10), s = parseInt(a[3], 10), r = void 0 !== a[4] ? parseFloat(a[4]) : 1, o.setTo(e, i, s, 255 * r)), o
				}
			}, function(t, e, i) {
				t.exports = {
					Fade: i(664),
					Flash: i(665),
					Pan: i(666),
					Shake: i(699),
					RotateTo: i(700),
					Zoom: i(701)
				}
			}, function(t, e, i) {
				t.exports = {
					In: i(667),
					Out: i(668),
					InOut: i(669)
				}
			}, function(t, e, i) {
				t.exports = {
					In: i(670),
					Out: i(671),
					InOut: i(672)
				}
			}, function(t, e, i) {
				t.exports = {
					In: i(673),
					Out: i(674),
					InOut: i(675)
				}
			}, function(t, e, i) {
				t.exports = {
					In: i(676),
					Out: i(677),
					InOut: i(678)
				}
			}, function(t, e, i) {
				t.exports = {
					In: i(679),
					Out: i(680),
					InOut: i(681)
				}
			}, function(t, e, i) {
				t.exports = {
					In: i(682),
					Out: i(683),
					InOut: i(684)
				}
			}, function(t, e, i) {
				t.exports = i(685)
			}, function(t, e, i) {
				t.exports = {
					In: i(686),
					Out: i(687),
					InOut: i(688)
				}
			}, function(t, e, i) {
				t.exports = {
					In: i(689),
					Out: i(690),
					InOut: i(691)
				}
			}, function(t, e, i) {
				t.exports = {
					In: i(692),
					Out: i(693),
					InOut: i(694)
				}
			}, function(t, e, i) {
				t.exports = {
					In: i(695),
					Out: i(696),
					InOut: i(697)
				}
			}, function(t, e, i) {
				t.exports = i(698)
			}, function(t, e, i) {
				var n = i(0),
					s = i(33),
					r = i(315),
					o = i(2),
					a = i(6),
					h = i(7),
					u = i(170),
					l = i(1),
					c = i(175),
					d = i(164),
					f = new n({
						initialize: function(t) {
							void 0 === t && (t = {}), this.width = a(t, "width", 1024), this.height = a(t, "height", 768), this.zoom = a(t, "zoom", 1), this.resolution = a(t, "resolution", 1), this.parent = a(t, "parent", void 0), this.scaleMode = a(t, "scaleMode", 0), this.expandParent = a(t, "expandParent", !0), this.autoRound = a(t, "autoRound", !1), this.autoCenter = a(t, "autoCenter", 0), this.resizeInterval = a(t, "resizeInterval", 500), this.fullscreenTarget = a(t, "fullscreenTarget", null), this.minWidth = a(t, "minWidth", 0), this.maxWidth = a(t, "maxWidth", 0), this.minHeight = a(t, "minHeight", 0), this.maxHeight = a(t, "maxHeight", 0);
							var e = a(t, "scale", null);
							e && (this.width = a(e, "width", this.width), this.height = a(e, "height", this.height), this.zoom = a(e, "zoom", this.zoom), this.resolution = a(e, "resolution", this.resolution), this.parent = a(e, "parent", this.parent), this.scaleMode = a(e, "mode", this.scaleMode), this.expandParent = a(e, "expandParent", this.expandParent), this.autoRound = a(e, "autoRound", this.autoRound), this.autoCenter = a(e, "autoCenter", this.autoCenter), this.resizeInterval = a(e, "resizeInterval", this.resizeInterval), this.fullscreenTarget = a(e, "fullscreenTarget", this.fullscreenTarget), this.minWidth = a(e, "min.width", this.minWidth), this.maxWidth = a(e, "max.width", this.maxWidth), this.minHeight = a(e, "min.height", this.minHeight), this.maxHeight = a(e, "max.height", this.maxHeight)), this.renderType = a(t, "type", s.AUTO), this.canvas = a(t, "canvas", null), this.context = a(t, "context", null), this.canvasStyle = a(t, "canvasStyle", null), this.customEnvironment = a(t, "customEnvironment", !1), this.sceneConfig = a(t, "scene", null), this.seed = a(t, "seed", [(Date.now() * Math.random()).toString()]), u.RND = new u.RandomDataGenerator(this.seed), this.gameTitle = a(t, "title", ""), this.gameURL = a(t, "url", "https://phaser.io"), this.gameVersion = a(t, "version", ""), this.autoFocus = a(t, "autoFocus", !0), this.domCreateContainer = a(t, "dom.createContainer", !1), this.domBehindCanvas = a(t, "dom.behindCanvas", !1), this.inputKeyboard = a(t, "input.keyboard", !0), this.inputKeyboardEventTarget = a(t, "input.keyboard.target", window), this.inputKeyboardCapture = a(t, "input.keyboard.capture", []), this.inputMouse = a(t, "input.mouse", !0), this.inputMouseEventTarget = a(t, "input.mouse.target", null), this.inputMouseCapture = a(t, "input.mouse.capture", !0), this.inputTouch = a(t, "input.touch", r.input.touch), this.inputTouchEventTarget = a(t, "input.touch.target", null), this.inputTouchCapture = a(t, "input.touch.capture", !0), this.inputActivePointers = a(t, "input.activePointers", 1), this.inputSmoothFactor = a(t, "input.smoothFactor", 0), this.inputWindowEvents = a(t, "input.windowEvents", !0), this.inputGamepad = a(t, "input.gamepad", !1), this.inputGamepadEventTarget = a(t, "input.gamepad.target", window), this.disableContextMenu = a(t, "disableContextMenu", !1), this.audio = a(t, "audio"), this.hideBanner = !1 === a(t, "banner", null), this.hidePhaser = a(t, "banner.hidePhaser", !1), this.bannerTextColor = a(t, "banner.text", "#ffffff"), this.bannerBackgroundColor = a(t, "banner.background", ["#ff0000", "#ffff00", "#00ff00", "#00ffff", "#000000"]), "" === this.gameTitle && this.hidePhaser && (this.hideBanner = !0), this.fps = a(t, "fps", null);
							var i = a(t, "render", t);
							this.antialias = a(i, "antialias", !0), this.antialiasGL = a(i, "antialiasGL", !0), this.mipmapFilter = a(i, "mipmapFilter", "LINEAR"), this.desynchronized = a(i, "desynchronized", !1), this.roundPixels = a(i, "roundPixels", !1), this.pixelArt = a(i, "pixelArt", 1 !== this.zoom), this.pixelArt && (this.antialias = !1, this.roundPixels = !0), this.transparent = a(i, "transparent", !1), this.clearBeforeRender = a(i, "clearBeforeRender", !0), this.premultipliedAlpha = a(i, "premultipliedAlpha", !0), this.failIfMajorPerformanceCaveat = a(i, "failIfMajorPerformanceCaveat", !1), this.powerPreference = a(i, "powerPreference", "default"), this.batchSize = a(i, "batchSize", 2e3), this.maxLights = a(i, "maxLights", 10);
							var n = a(t, "backgroundColor", 0);
							this.backgroundColor = d(n), 0 === n && this.transparent && (this.backgroundColor.alpha = 0), this.preBoot = a(t, "callbacks.preBoot", l), this.postBoot = a(t, "callbacks.postBoot", l), this.physics = a(t, "physics", {}), this.defaultPhysicsSystem = a(this.physics, "default", !1), this.loaderBaseURL = a(t, "loader.baseURL", ""), this.loaderPath = a(t, "loader.path", ""), this.loaderMaxParallelDownloads = a(t, "loader.maxParallelDownloads", 32), this.loaderCrossOrigin = a(t, "loader.crossOrigin", void 0), this.loaderResponseType = a(t, "loader.responseType", ""), this.loaderAsync = a(t, "loader.async", !0), this.loaderUser = a(t, "loader.user", ""), this.loaderPassword = a(t, "loader.password", ""), this.loaderTimeout = a(t, "loader.timeout", 0), this.loaderWithCredentials = a(t, "loader.withCredentials", !1), this.installGlobalPlugins = [], this.installScenePlugins = [];
							var f = a(t, "plugins", null),
								p = c.DefaultScene;
							f && (Array.isArray(f) ? this.defaultPlugins = f : h(f) && (this.installGlobalPlugins = o(f, "global", []), this.installScenePlugins = o(f, "scene", []), Array.isArray(f.default) ? p = f.default : Array.isArray(f.defaultMerge) && (p = p.concat(f.defaultMerge)))), this.defaultPlugins = p;
							var g = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg";
							this.defaultImage = a(t, "images.default", g + "AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg=="), this.missingImage = a(t, "images.missing", g + "CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg=="), window && (window.FORCE_WEBGL ? this.renderType = s.WEBGL : window.FORCE_CANVAS && (this.renderType = s.CANVAS))
						}
					});
				t.exports = f
			}, function(t, e, i) {
				t.exports = {
					os: i(117),
					browser: i(118),
					features: i(169),
					input: i(730),
					audio: i(731),
					video: i(732),
					fullscreen: i(733),
					canvasFeatures: i(316)
				}
			}, function(t, e, i) {
				var n, s, r, o = i(26),
					a = {
						supportInverseAlpha: !1,
						supportNewBlendModes: !1
					};
				t.exports = (void 0 !== document && (a.supportNewBlendModes = (n = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/", s = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==", (r = new Image).onload = function() {
					var t = new Image;
					t.onload = function() {
						var e = o.create(t, 6, 1).getContext("2d");
						if (e.globalCompositeOperation = "multiply", e.drawImage(r, 0, 0), e.drawImage(t, 2, 0), !e.getImageData(2, 0, 1, 1)) return !1;
						var i = e.getImageData(2, 0, 1, 1).data;
						o.remove(t), a.supportNewBlendModes = 255 === i[0] && 0 === i[1] && 0 === i[2]
					}, t.src = n + "/wCKxvRF" + s
				}, r.src = n + "AP804Oa6" + s, !1), a.supportInverseAlpha = function() {
					var t = o.create(this, 2, 1).getContext("2d");
					t.fillStyle = "rgba(10, 20, 30, 0.5)", t.fillRect(0, 0, 1, 1);
					var e = t.getImageData(0, 0, 1, 1);
					if (null === e) return !1;
					t.putImageData(e, 1, 0);
					var i = t.getImageData(1, 0, 1, 1);
					return i.data[0] === e.data[0] && i.data[1] === e.data[1] && i.data[2] === e.data[2] && i.data[3] === e.data[3]
				}()), a)
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					return Math.atan2(n - e, i - t)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return Math.atan2(e.y - t.y, e.x - t.x)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return 0 <= (t %= 2 * Math.PI) ? t : t + 2 * Math.PI
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = t.x - e.x,
						n = t.y - e.y;
					return Math.sqrt(i * i + n * n)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					var s = t - i,
						r = e - n;
					return s * s + r * r
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return void 0 === i && (i = 1e-4), e - i < t
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return void 0 === i && (i = 1e-4), t < e + i
				}
			}, function(t, e, i) {
				var n = i(325);
				t.exports = function(t, e) {
					return n(t) / n(e) / n(t - e)
				}
			}, function(t, e) {
				t.exports = function(t) {
					if (0 === t) return 1;
					for (var e = t; --t;) e *= t;
					return e
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					return (u = 1 - t) * u * u * e + 3 * (h = 1 - (a = t)) * h * a * i + 3 * (1 - (o = t)) * o * o * n + (r = t) * r * r * s;
					var r, o, a, h, u
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					return (o = 1 - t) * o * e + 2 * (1 - (r = t)) * r * i + (s = t) * s * n;
					var s, r, o
				}
			}, function(t, e, i) {
				var n = i(161);
				t.exports = function(t, e, i) {
					return e + (i - e) * n(t, 0, 1)
				}
			}, function(t, e) {
				t.exports = function(t) {
					var e = Math.log(t) / .6931471805599453;
					return 1 << Math.ceil(e)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.ceil(t / e), n ? (i + t) / e : i + t)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = t.x,
						n = t.y;
					return t.x = i * Math.cos(e) - n * Math.sin(e), t.y = i * Math.sin(e) + n * Math.cos(e), t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return 0 < t ? Math.ceil(t) : Math.floor(t)
				}
			}, function(t, e, i) {
				var n = i(3);
				t.exports = function(t, e, i, s, r, o, a, h) {
					void 0 === h && (h = new n);
					var u = Math.sin(r),
						l = Math.cos(r),
						c = l * o,
						d = u * o,
						f = -u * a,
						p = l * a,
						g = 1 / (c * p + f * -d);
					return h.x = p * g * t + -f * g * e + (s * f - i * p) * g, h.y = c * g * e + -d * g * t + (-s * c + i * d) * g, h
				}
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t, e, i, n) {
						this.x = 0, this.y = 0, this.z = 0, this.w = 0, "object" == typeof t ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0)
					},
					clone: function() {
						return new n(this.x, this.y, this.z, this.w)
					},
					copy: function(t) {
						return this.x = t.x, this.y = t.y, this.z = t.z || 0, this.w = t.w || 0, this
					},
					equals: function(t) {
						return this.x === t.x && this.y === t.y && this.z === t.z && this.w === t.w
					},
					set: function(t, e, i, n) {
						return "object" == typeof t ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0), this
					},
					add: function(t) {
						return this.x += t.x, this.y += t.y, this.z += t.z || 0, this.w += t.w || 0, this
					},
					subtract: function(t) {
						return this.x -= t.x, this.y -= t.y, this.z -= t.z || 0, this.w -= t.w || 0, this
					},
					scale: function(t) {
						return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
					},
					length: function() {
						var t = this.x,
							e = this.y,
							i = this.z,
							n = this.w;
						return Math.sqrt(t * t + e * e + i * i + n * n)
					},
					lengthSq: function() {
						var t = this.x,
							e = this.y,
							i = this.z,
							n = this.w;
						return t * t + e * e + i * i + n * n
					},
					normalize: function() {
						var t = this.x,
							e = this.y,
							i = this.z,
							n = this.w,
							s = t * t + e * e + i * i + n * n;
						return 0 < s && (s = 1 / Math.sqrt(s), this.x = t * s, this.y = e * s, this.z = i * s, this.w = n * s), this
					},
					dot: function(t) {
						return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
					},
					lerp: function(t, e) {
						void 0 === e && (e = 0);
						var i = this.x,
							n = this.y,
							s = this.z,
							r = this.w;
						return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this.w = r + e * (t.w - r), this
					},
					multiply: function(t) {
						return this.x *= t.x, this.y *= t.y, this.z *= t.z || 1, this.w *= t.w || 1, this
					},
					divide: function(t) {
						return this.x /= t.x, this.y /= t.y, this.z /= t.z || 1, this.w /= t.w || 1, this
					},
					distance: function(t) {
						var e = t.x - this.x,
							i = t.y - this.y,
							n = t.z - this.z || 0,
							s = t.w - this.w || 0;
						return Math.sqrt(e * e + i * i + n * n + s * s)
					},
					distanceSq: function(t) {
						var e = t.x - this.x,
							i = t.y - this.y,
							n = t.z - this.z || 0,
							s = t.w - this.w || 0;
						return e * e + i * i + n * n + s * s
					},
					negate: function() {
						return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
					},
					transformMat4: function(t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							s = this.w,
							r = t.val;
						return this.x = r[0] * e + r[4] * i + r[8] * n + r[12] * s, this.y = r[1] * e + r[5] * i + r[9] * n + r[13] * s, this.z = r[2] * e + r[6] * i + r[10] * n + r[14] * s, this.w = r[3] * e + r[7] * i + r[11] * n + r[15] * s, this
					},
					transformQuat: function(t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							s = t.x,
							r = t.y,
							o = t.z,
							a = t.w,
							h = a * e + r * n - o * i,
							u = a * i + o * e - s * n,
							l = a * n + s * i - r * e,
							c = -s * e - r * i - o * n;
						return this.x = h * a + c * -s + u * -o - l * -r, this.y = u * a + c * -r + l * -s - h * -o, this.z = l * a + c * -o + h * -r - u * -s, this
					},
					reset: function() {
						return this.x = 0, this.y = 0, this.z = 0, this.w = 0, this
					}
				});
				n.prototype.sub = n.prototype.subtract, n.prototype.mul = n.prototype.multiply, n.prototype.div = n.prototype.divide, n.prototype.dist = n.prototype.distance, n.prototype.distSq = n.prototype.distanceSq, n.prototype.len = n.prototype.length, n.prototype.lenSq = n.prototype.lengthSq, t.exports = n
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t) {
						this.val = new Float32Array(9), t ? this.copy(t) : this.identity()
					},
					clone: function() {
						return new n(this)
					},
					set: function(t) {
						return this.copy(t)
					},
					copy: function(t) {
						var e = this.val,
							i = t.val;
						return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
					},
					fromMat4: function(t) {
						var e = t.val,
							i = this.val;
						return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[4], i[4] = e[5], i[5] = e[6], i[6] = e[8], i[7] = e[9], i[8] = e[10], this
					},
					fromArray: function(t) {
						var e = this.val;
						return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this
					},
					identity: function() {
						var t = this.val;
						return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, this
					},
					transpose: function() {
						var t = this.val,
							e = t[1],
							i = t[2],
							n = t[5];
						return t[1] = t[3], t[2] = t[6], t[3] = e, t[5] = t[7], t[6] = i, t[7] = n, this
					},
					invert: function() {
						var t = this.val,
							e = t[0],
							i = t[1],
							n = t[2],
							s = t[3],
							r = t[4],
							o = t[5],
							a = t[6],
							h = t[7],
							u = t[8],
							l = u * r - o * h,
							c = -u * s + o * a,
							d = h * s - r * a,
							f = e * l + i * c + n * d;
						return f ? (f = 1 / f, t[0] = l * f, t[1] = (-u * i + n * h) * f, t[2] = (o * i - n * r) * f, t[3] = c * f, t[4] = (u * e - n * a) * f, t[5] = (-o * e + n * s) * f, t[6] = d * f, t[7] = (-h * e + i * a) * f, t[8] = (r * e - i * s) * f, this) : null
					},
					adjoint: function() {
						var t = this.val,
							e = t[0],
							i = t[1],
							n = t[2],
							s = t[3],
							r = t[4],
							o = t[5],
							a = t[6],
							h = t[7],
							u = t[8];
						return t[0] = r * u - o * h, t[1] = n * h - i * u, t[2] = i * o - n * r, t[3] = o * a - s * u, t[4] = e * u - n * a, t[5] = n * s - e * o, t[6] = s * h - r * a, t[7] = i * a - e * h, t[8] = e * r - i * s, this
					},
					determinant: function() {
						var t = this.val,
							e = t[0],
							i = t[1],
							n = t[2],
							s = t[3],
							r = t[4],
							o = t[5],
							a = t[6],
							h = t[7],
							u = t[8];
						return e * (u * r - o * h) + i * (-u * s + o * a) + n * (h * s - r * a)
					},
					multiply: function(t) {
						var e = this.val,
							i = e[0],
							n = e[1],
							s = e[2],
							r = e[3],
							o = e[4],
							a = e[5],
							h = e[6],
							u = e[7],
							l = e[8],
							c = t.val,
							d = c[0],
							f = c[1],
							p = c[2],
							g = c[3],
							v = c[4],
							m = c[5],
							y = c[6],
							x = c[7],
							T = c[8];
						return e[0] = d * i + f * r + p * h, e[1] = d * n + f * o + p * u, e[2] = d * s + f * a + p * l, e[3] = g * i + v * r + m * h, e[4] = g * n + v * o + m * u, e[5] = g * s + v * a + m * l, e[6] = y * i + x * r + T * h, e[7] = y * n + x * o + T * u, e[8] = y * s + x * a + T * l, this
					},
					translate: function(t) {
						var e = this.val,
							i = t.x,
							n = t.y;
						return e[6] = i * e[0] + n * e[3] + e[6], e[7] = i * e[1] + n * e[4] + e[7], e[8] = i * e[2] + n * e[5] + e[8], this
					},
					rotate: function(t) {
						var e = this.val,
							i = e[0],
							n = e[1],
							s = e[2],
							r = e[3],
							o = e[4],
							a = e[5],
							h = Math.sin(t),
							u = Math.cos(t);
						return e[0] = u * i + h * r, e[1] = u * n + h * o, e[2] = u * s + h * a, e[3] = u * r - h * i, e[4] = u * o - h * n, e[5] = u * a - h * s, this
					},
					scale: function(t) {
						var e = this.val,
							i = t.x,
							n = t.y;
						return e[0] = i * e[0], e[1] = i * e[1], e[2] = i * e[2], e[3] = n * e[3], e[4] = n * e[4], e[5] = n * e[5], this
					},
					fromQuat: function(t) {
						var e = t.x,
							i = t.y,
							n = t.z,
							s = t.w,
							r = e + e,
							o = i + i,
							a = n + n,
							h = e * r,
							u = e * o,
							l = e * a,
							c = i * o,
							d = i * a,
							f = n * a,
							p = s * r,
							g = s * o,
							v = s * a,
							m = this.val;
						return m[0] = 1 - (c + f), m[3] = u + v, m[6] = l - g, m[1] = u - v, m[4] = 1 - (h + f), m[7] = d + p, m[2] = l + g, m[5] = d - p, m[8] = 1 - (h + c), this
					},
					normalFromMat4: function(t) {
						var e = t.val,
							i = this.val,
							n = e[0],
							s = e[1],
							r = e[2],
							o = e[3],
							a = e[4],
							h = e[5],
							u = e[6],
							l = e[7],
							c = e[8],
							d = e[9],
							f = e[10],
							p = e[11],
							g = e[12],
							v = e[13],
							m = e[14],
							y = e[15],
							x = n * h - s * a,
							T = n * u - r * a,
							w = n * l - o * a,
							E = s * u - r * h,
							_ = s * l - o * h,
							b = r * l - o * u,
							A = c * v - d * g,
							S = c * m - f * g,
							C = c * y - p * g,
							M = d * m - f * v,
							O = d * y - p * v,
							P = f * y - p * m,
							R = x * P - T * O + w * M + E * C - _ * S + b * A;
						return R ? (R = 1 / R, i[0] = (h * P - u * O + l * M) * R, i[1] = (u * C - a * P - l * S) * R, i[2] = (a * O - h * C + l * A) * R, i[3] = (r * O - s * P - o * M) * R, i[4] = (n * P - r * C + o * S) * R, i[5] = (s * C - n * O - o * A) * R, i[6] = (v * b - m * _ + y * E) * R, i[7] = (m * w - g * b - y * T) * R, i[8] = (g * _ - v * w + y * x) * R, this) : null
					}
				});
				t.exports = n
			}, function(t, e, i) {
				var n = new(i(0))({
						initialize: function(t) {
							this.val = new Float32Array(16), t ? this.copy(t) : this.identity()
						},
						clone: function() {
							return new n(this)
						},
						set: function(t) {
							return this.copy(t)
						},
						copy: function(t) {
							var e = this.val,
								i = t.val;
							return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
						},
						fromArray: function(t) {
							var e = this.val;
							return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this
						},
						zero: function() {
							var t = this.val;
							return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 0, this
						},
						xyz: function(t, e, i) {
							this.identity();
							var n = this.val;
							return n[12] = t, n[13] = e, n[14] = i, this
						},
						scaling: function(t, e, i) {
							this.zero();
							var n = this.val;
							return n[0] = t, n[5] = e, n[10] = i, n[15] = 1, this
						},
						identity: function() {
							var t = this.val;
							return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
						},
						transpose: function() {
							var t = this.val,
								e = t[1],
								i = t[2],
								n = t[3],
								s = t[6],
								r = t[7],
								o = t[11];
							return t[1] = t[4], t[2] = t[8], t[3] = t[12], t[4] = e, t[6] = t[9], t[7] = t[13], t[8] = i, t[9] = s, t[11] = t[14], t[12] = n, t[13] = r, t[14] = o, this
						},
						invert: function() {
							var t = this.val,
								e = t[0],
								i = t[1],
								n = t[2],
								s = t[3],
								r = t[4],
								o = t[5],
								a = t[6],
								h = t[7],
								u = t[8],
								l = t[9],
								c = t[10],
								d = t[11],
								f = t[12],
								p = t[13],
								g = t[14],
								v = t[15],
								m = e * o - i * r,
								y = e * a - n * r,
								x = e * h - s * r,
								T = i * a - n * o,
								w = i * h - s * o,
								E = n * h - s * a,
								_ = u * p - l * f,
								b = u * g - c * f,
								A = u * v - d * f,
								S = l * g - c * p,
								C = l * v - d * p,
								M = c * v - d * g,
								O = m * M - y * C + x * S + T * A - w * b + E * _;
							return O ? (O = 1 / O, t[0] = (o * M - a * C + h * S) * O, t[1] = (n * C - i * M - s * S) * O, t[2] = (p * E - g * w + v * T) * O, t[3] = (c * w - l * E - d * T) * O, t[4] = (a * A - r * M - h * b) * O, t[5] = (e * M - n * A + s * b) * O, t[6] = (g * x - f * E - v * y) * O, t[7] = (u * E - c * x + d * y) * O, t[8] = (r * C - o * A + h * _) * O, t[9] = (i * A - e * C - s * _) * O, t[10] = (f * w - p * x + v * m) * O, t[11] = (l * x - u * w - d * m) * O, t[12] = (o * b - r * S - a * _) * O, t[13] = (e * S - i * b + n * _) * O, t[14] = (p * y - f * T - g * m) * O, t[15] = (u * T - l * y + c * m) * O, this) : null
						},
						adjoint: function() {
							var t = this.val,
								e = t[0],
								i = t[1],
								n = t[2],
								s = t[3],
								r = t[4],
								o = t[5],
								a = t[6],
								h = t[7],
								u = t[8],
								l = t[9],
								c = t[10],
								d = t[11],
								f = t[12],
								p = t[13],
								g = t[14],
								v = t[15];
							return t[0] = o * (c * v - d * g) - l * (a * v - h * g) + p * (a * d - h * c), t[1] = -(i * (c * v - d * g) - l * (n * v - s * g) + p * (n * d - s * c)), t[2] = i * (a * v - h * g) - o * (n * v - s * g) + p * (n * h - s * a), t[3] = -(i * (a * d - h * c) - o * (n * d - s * c) + l * (n * h - s * a)), t[4] = -(r * (c * v - d * g) - u * (a * v - h * g) + f * (a * d - h * c)), t[5] = e * (c * v - d * g) - u * (n * v - s * g) + f * (n * d - s * c), t[6] = -(e * (a * v - h * g) - r * (n * v - s * g) + f * (n * h - s * a)), t[7] = e * (a * d - h * c) - r * (n * d - s * c) + u * (n * h - s * a), t[8] = r * (l * v - d * p) - u * (o * v - h * p) + f * (o * d - h * l), t[9] = -(e * (l * v - d * p) - u * (i * v - s * p) + f * (i * d - s * l)), t[10] = e * (o * v - h * p) - r * (i * v - s * p) + f * (i * h - s * o), t[11] = -(e * (o * d - h * l) - r * (i * d - s * l) + u * (i * h - s * o)), t[12] = -(r * (l * g - c * p) - u * (o * g - a * p) + f * (o * c - a * l)), t[13] = e * (l * g - c * p) - u * (i * g - n * p) + f * (i * c - n * l), t[14] = -(e * (o * g - a * p) - r * (i * g - n * p) + f * (i * a - n * o)), t[15] = e * (o * c - a * l) - r * (i * c - n * l) + u * (i * a - n * o), this
						},
						determinant: function() {
							var t = this.val,
								e = t[0],
								i = t[1],
								n = t[2],
								s = t[3],
								r = t[4],
								o = t[5],
								a = t[6],
								h = t[7],
								u = t[8],
								l = t[9],
								c = t[10],
								d = t[11],
								f = t[12],
								p = t[13],
								g = t[14],
								v = t[15];
							return (e * o - i * r) * (c * v - d * g) - (e * a - n * r) * (l * v - d * p) + (e * h - s * r) * (l * g - c * p) + (i * a - n * o) * (u * v - d * f) - (i * h - s * o) * (u * g - c * f) + (n * h - s * a) * (u * p - l * f)
						},
						multiply: function(t) {
							var e = this.val,
								i = e[0],
								n = e[1],
								s = e[2],
								r = e[3],
								o = e[4],
								a = e[5],
								h = e[6],
								u = e[7],
								l = e[8],
								c = e[9],
								d = e[10],
								f = e[11],
								p = e[12],
								g = e[13],
								v = e[14],
								m = e[15],
								y = t.val,
								x = y[0],
								T = y[1],
								w = y[2],
								E = y[3];
							return e[0] = x * i + T * o + w * l + E * p, e[1] = x * n + T * a + w * c + E * g, e[2] = x * s + T * h + w * d + E * v, e[3] = x * r + T * u + w * f + E * m, x = y[4], T = y[5], w = y[6], E = y[7], e[4] = x * i + T * o + w * l + E * p, e[5] = x * n + T * a + w * c + E * g, e[6] = x * s + T * h + w * d + E * v, e[7] = x * r + T * u + w * f + E * m, x = y[8], T = y[9], w = y[10], E = y[11], e[8] = x * i + T * o + w * l + E * p, e[9] = x * n + T * a + w * c + E * g, e[10] = x * s + T * h + w * d + E * v, e[11] = x * r + T * u + w * f + E * m, x = y[12], T = y[13], w = y[14], E = y[15], e[12] = x * i + T * o + w * l + E * p, e[13] = x * n + T * a + w * c + E * g, e[14] = x * s + T * h + w * d + E * v, e[15] = x * r + T * u + w * f + E * m, this
						},
						multiplyLocal: function(t) {
							var e = [],
								i = this.val,
								n = t.val;
							return e[0] = i[0] * n[0] + i[1] * n[4] + i[2] * n[8] + i[3] * n[12], e[1] = i[0] * n[1] + i[1] * n[5] + i[2] * n[9] + i[3] * n[13], e[2] = i[0] * n[2] + i[1] * n[6] + i[2] * n[10] + i[3] * n[14], e[3] = i[0] * n[3] + i[1] * n[7] + i[2] * n[11] + i[3] * n[15], e[4] = i[4] * n[0] + i[5] * n[4] + i[6] * n[8] + i[7] * n[12], e[5] = i[4] * n[1] + i[5] * n[5] + i[6] * n[9] + i[7] * n[13], e[6] = i[4] * n[2] + i[5] * n[6] + i[6] * n[10] + i[7] * n[14], e[7] = i[4] * n[3] + i[5] * n[7] + i[6] * n[11] + i[7] * n[15], e[8] = i[8] * n[0] + i[9] * n[4] + i[10] * n[8] + i[11] * n[12], e[9] = i[8] * n[1] + i[9] * n[5] + i[10] * n[9] + i[11] * n[13], e[10] = i[8] * n[2] + i[9] * n[6] + i[10] * n[10] + i[11] * n[14], e[11] = i[8] * n[3] + i[9] * n[7] + i[10] * n[11] + i[11] * n[15], e[12] = i[12] * n[0] + i[13] * n[4] + i[14] * n[8] + i[15] * n[12], e[13] = i[12] * n[1] + i[13] * n[5] + i[14] * n[9] + i[15] * n[13], e[14] = i[12] * n[2] + i[13] * n[6] + i[14] * n[10] + i[15] * n[14], e[15] = i[12] * n[3] + i[13] * n[7] + i[14] * n[11] + i[15] * n[15], this.fromArray(e)
						},
						translate: function(t) {
							var e = t.x,
								i = t.y,
								n = t.z,
								s = this.val;
							return s[12] = s[0] * e + s[4] * i + s[8] * n + s[12], s[13] = s[1] * e + s[5] * i + s[9] * n + s[13], s[14] = s[2] * e + s[6] * i + s[10] * n + s[14], s[15] = s[3] * e + s[7] * i + s[11] * n + s[15], this
						},
						translateXYZ: function(t, e, i) {
							var n = this.val;
							return n[12] = n[0] * t + n[4] * e + n[8] * i + n[12], n[13] = n[1] * t + n[5] * e + n[9] * i + n[13], n[14] = n[2] * t + n[6] * e + n[10] * i + n[14], n[15] = n[3] * t + n[7] * e + n[11] * i + n[15], this
						},
						scale: function(t) {
							var e = t.x,
								i = t.y,
								n = t.z,
								s = this.val;
							return s[0] = s[0] * e, s[1] = s[1] * e, s[2] = s[2] * e, s[3] = s[3] * e, s[4] = s[4] * i, s[5] = s[5] * i, s[6] = s[6] * i, s[7] = s[7] * i, s[8] = s[8] * n, s[9] = s[9] * n, s[10] = s[10] * n, s[11] = s[11] * n, this
						},
						scaleXYZ: function(t, e, i) {
							var n = this.val;
							return n[0] = n[0] * t, n[1] = n[1] * t, n[2] = n[2] * t, n[3] = n[3] * t, n[4] = n[4] * e, n[5] = n[5] * e, n[6] = n[6] * e, n[7] = n[7] * e, n[8] = n[8] * i, n[9] = n[9] * i, n[10] = n[10] * i, n[11] = n[11] * i, this
						},
						makeRotationAxis: function(t, e) {
							var i = Math.cos(e),
								n = Math.sin(e),
								s = 1 - i,
								r = t.x,
								o = t.y,
								a = t.z,
								h = s * r,
								u = s * o;
							return this.fromArray([h * r + i, h * o - n * a, h * a + n * o, 0, h * o + n * a, u * o + i, u * a - n * r, 0, h * a - n * o, u * a + n * r, s * a * a + i, 0, 0, 0, 0, 1]), this
						},
						rotate: function(t, e) {
							var i = this.val,
								n = e.x,
								s = e.y,
								r = e.z,
								o = Math.sqrt(n * n + s * s + r * r);
							if (Math.abs(o) < 1e-6) return null;
							n *= o = 1 / o, s *= o, r *= o;
							var a = Math.sin(t),
								h = Math.cos(t),
								u = 1 - h,
								l = i[0],
								c = i[1],
								d = i[2],
								f = i[3],
								p = i[4],
								g = i[5],
								v = i[6],
								m = i[7],
								y = i[8],
								x = i[9],
								T = i[10],
								w = i[11],
								E = n * n * u + h,
								_ = s * n * u + r * a,
								b = r * n * u - s * a,
								A = n * s * u - r * a,
								S = s * s * u + h,
								C = r * s * u + n * a,
								M = n * r * u + s * a,
								O = s * r * u - n * a,
								P = r * r * u + h;
							return i[0] = l * E + p * _ + y * b, i[1] = c * E + g * _ + x * b, i[2] = d * E + v * _ + T * b, i[3] = f * E + m * _ + w * b, i[4] = l * A + p * S + y * C, i[5] = c * A + g * S + x * C, i[6] = d * A + v * S + T * C, i[7] = f * A + m * S + w * C, i[8] = l * M + p * O + y * P, i[9] = c * M + g * O + x * P, i[10] = d * M + v * O + T * P, i[11] = f * M + m * O + w * P, this
						},
						rotateX: function(t) {
							var e = this.val,
								i = Math.sin(t),
								n = Math.cos(t),
								s = e[4],
								r = e[5],
								o = e[6],
								a = e[7],
								h = e[8],
								u = e[9],
								l = e[10],
								c = e[11];
							return e[4] = s * n + h * i, e[5] = r * n + u * i, e[6] = o * n + l * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = u * n - r * i, e[10] = l * n - o * i, e[11] = c * n - a * i, this
						},
						rotateY: function(t) {
							var e = this.val,
								i = Math.sin(t),
								n = Math.cos(t),
								s = e[0],
								r = e[1],
								o = e[2],
								a = e[3],
								h = e[8],
								u = e[9],
								l = e[10],
								c = e[11];
							return e[0] = s * n - h * i, e[1] = r * n - u * i, e[2] = o * n - l * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + u * n, e[10] = o * i + l * n, e[11] = a * i + c * n, this
						},
						rotateZ: function(t) {
							var e = this.val,
								i = Math.sin(t),
								n = Math.cos(t),
								s = e[0],
								r = e[1],
								o = e[2],
								a = e[3],
								h = e[4],
								u = e[5],
								l = e[6],
								c = e[7];
							return e[0] = s * n + h * i, e[1] = r * n + u * i, e[2] = o * n + l * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = u * n - r * i, e[6] = l * n - o * i, e[7] = c * n - a * i, this
						},
						fromRotationTranslation: function(t, e) {
							var i = this.val,
								n = t.x,
								s = t.y,
								r = t.z,
								o = t.w,
								a = n + n,
								h = s + s,
								u = r + r,
								l = n * a,
								c = n * h,
								d = n * u,
								f = s * h,
								p = s * u,
								g = r * u,
								v = o * a,
								m = o * h,
								y = o * u;
							return i[0] = 1 - (f + g), i[1] = c + y, i[2] = d - m, i[3] = 0, i[4] = c - y, i[5] = 1 - (l + g), i[6] = p + v, i[7] = 0, i[8] = d + m, i[9] = p - v, i[10] = 1 - (l + f), i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
						},
						fromQuat: function(t) {
							var e = this.val,
								i = t.x,
								n = t.y,
								s = t.z,
								r = t.w,
								o = i + i,
								a = n + n,
								h = s + s,
								u = i * o,
								l = i * a,
								c = i * h,
								d = n * a,
								f = n * h,
								p = s * h,
								g = r * o,
								v = r * a,
								m = r * h;
							return e[0] = 1 - (d + p), e[1] = l + m, e[2] = c - v, e[3] = 0, e[4] = l - m, e[5] = 1 - (u + p), e[6] = f + g, e[7] = 0, e[8] = c + v, e[9] = f - g, e[10] = 1 - (u + d), e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
						},
						frustum: function(t, e, i, n, s, r) {
							var o = this.val,
								a = 1 / (e - t),
								h = 1 / (n - i),
								u = 1 / (s - r);
							return o[0] = 2 * s * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 2 * s * h, o[6] = 0, o[7] = 0, o[8] = (e + t) * a, o[9] = (n + i) * h, o[10] = (r + s) * u, o[11] = -1, o[12] = 0, o[13] = 0, o[14] = r * s * 2 * u, o[15] = 0, this
						},
						perspective: function(t, e, i, n) {
							var s = this.val,
								r = 1 / Math.tan(t / 2),
								o = 1 / (i - n);
							return s[0] = r / e, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = r, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = (n + i) * o, s[11] = -1, s[12] = 0, s[13] = 0, s[14] = 2 * n * i * o, s[15] = 0, this
						},
						perspectiveLH: function(t, e, i, n) {
							var s = this.val;
							return s[0] = 2 * i / t, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = 2 * i / e, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = -n / (i - n), s[11] = 1, s[12] = 0, s[13] = 0, s[14] = i * n / (i - n), s[15] = 0, this
						},
						ortho: function(t, e, i, n, s, r) {
							var o = this.val,
								a = 0 == (a = t - e) ? a : 1 / a,
								h = 0 == (h = i - n) ? h : 1 / h,
								u = 0 == (u = s - r) ? u : 1 / u;
							return o[0] = -2 * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * h, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * u, o[11] = 0, o[12] = (t + e) * a, o[13] = (n + i) * h, o[14] = (r + s) * u, o[15] = 1, this
						},
						lookAt: function(t, e, i) {
							var n = this.val,
								s = t.x,
								r = t.y,
								o = t.z,
								a = i.x,
								h = i.y,
								u = i.z,
								l = e.x,
								c = e.y,
								d = e.z;
							if (Math.abs(s - l) < 1e-6 && Math.abs(r - c) < 1e-6 && Math.abs(o - d) < 1e-6) return this.identity();
							var f = s - l,
								p = r - c,
								g = o - d,
								v = 1 / Math.sqrt(f * f + p * p + g * g),
								m = h * (g *= v) - u * (p *= v),
								y = u * (f *= v) - a * g,
								x = a * p - h * f;
							(v = Math.sqrt(m * m + y * y + x * x)) ? (m *= v = 1 / v, y *= v, x *= v) : x = y = m = 0;
							var T = p * x - g * y,
								w = g * m - f * x,
								E = f * y - p * m;
							return (v = Math.sqrt(T * T + w * w + E * E)) ? (T *= v = 1 / v, w *= v, E *= v) : E = w = T = 0, n[0] = m, n[1] = T, n[2] = f, n[3] = 0, n[4] = y, n[5] = w, n[6] = p, n[7] = 0, n[8] = x, n[9] = E, n[10] = g, n[11] = 0, n[12] = -(m * s + y * r + x * o), n[13] = -(T * s + w * r + E * o), n[14] = -(f * s + p * r + g * o), n[15] = 1, this
						},
						yawPitchRoll: function(t, e, i) {
							this.zero(), s.zero(), r.zero();
							var n = this.val,
								o = s.val,
								a = r.val,
								h = Math.sin(i),
								u = Math.cos(i);
							return n[10] = 1, n[15] = 1, n[0] = u, n[1] = h, n[4] = -h, n[5] = u, h = Math.sin(e), u = Math.cos(e), o[0] = 1, o[15] = 1, o[5] = u, o[10] = u, o[9] = -h, o[6] = h, h = Math.sin(t), u = Math.cos(t), a[5] = 1, a[15] = 1, a[0] = u, a[2] = -h, a[8] = h, a[10] = u, this.multiplyLocal(s), this.multiplyLocal(r), this
						},
						setWorldMatrix: function(t, e, i, n, o) {
							return this.yawPitchRoll(t.y, t.x, t.z), s.scaling(i.x, i.y, i.z), r.xyz(e.x, e.y, e.z), this.multiplyLocal(s), this.multiplyLocal(r), void 0 !== n && this.multiplyLocal(n), void 0 !== o && this.multiplyLocal(o), this
						}
					}),
					s = new n,
					r = new n;
				t.exports = n
			}, function(t, e, i) {
				var n = i(0),
					s = i(174),
					r = i(335),
					o = new Int8Array([1, 2, 0]),
					a = new Float32Array([0, 0, 0]),
					h = new s(1, 0, 0),
					u = new s(0, 1, 0),
					l = new s,
					c = new r,
					d = new n({
						initialize: function(t, e, i, n) {
							"object" == typeof t ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0)
						},
						copy: function(t) {
							return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this
						},
						set: function(t, e, i, n) {
							return "object" == typeof t ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0), this
						},
						add: function(t) {
							return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
						},
						subtract: function(t) {
							return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
						},
						scale: function(t) {
							return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
						},
						length: function() {
							var t = this.x,
								e = this.y,
								i = this.z,
								n = this.w;
							return Math.sqrt(t * t + e * e + i * i + n * n)
						},
						lengthSq: function() {
							var t = this.x,
								e = this.y,
								i = this.z,
								n = this.w;
							return t * t + e * e + i * i + n * n
						},
						normalize: function() {
							var t = this.x,
								e = this.y,
								i = this.z,
								n = this.w,
								s = t * t + e * e + i * i + n * n;
							return 0 < s && (s = 1 / Math.sqrt(s), this.x = t * s, this.y = e * s, this.z = i * s, this.w = n * s), this
						},
						dot: function(t) {
							return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
						},
						lerp: function(t, e) {
							void 0 === e && (e = 0);
							var i = this.x,
								n = this.y,
								s = this.z,
								r = this.w;
							return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this.w = r + e * (t.w - r), this
						},
						rotationTo: function(t, e) {
							var i = t.x * e.x + t.y * e.y + t.z * e.z;
							return i < -.999999 ? (l.copy(h).cross(t).length() < 1e-6 && l.copy(u).cross(t), l.normalize(), this.setAxisAngle(l, Math.PI)) : .999999 < i ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1, this) : (l.copy(t).cross(e), this.x = l.x, this.y = l.y, this.z = l.z, this.w = 1 + i, this.normalize())
						},
						setAxes: function(t, e, i) {
							var n = c.val;
							return n[0] = e.x, n[3] = e.y, n[6] = e.z, n[1] = i.x, n[4] = i.y, n[7] = i.z, n[2] = -t.x, n[5] = -t.y, n[8] = -t.z, this.fromMat3(c).normalize()
						},
						identity: function() {
							return this.x = 0, this.y = 0, this.z = 0, this.w = 1, this
						},
						setAxisAngle: function(t, e) {
							e *= .5;
							var i = Math.sin(e);
							return this.x = i * t.x, this.y = i * t.y, this.z = i * t.z, this.w = Math.cos(e), this
						},
						multiply: function(t) {
							var e = this.x,
								i = this.y,
								n = this.z,
								s = this.w,
								r = t.x,
								o = t.y,
								a = t.z,
								h = t.w;
							return this.x = e * h + s * r + i * a - n * o, this.y = i * h + s * o + n * r - e * a, this.z = n * h + s * a + e * o - i * r, this.w = s * h - e * r - i * o - n * a, this
						},
						slerp: function(t, e) {
							var i = this.x,
								n = this.y,
								s = this.z,
								r = this.w,
								o = t.x,
								a = t.y,
								h = t.z,
								u = t.w,
								l = i * o + n * a + s * h + r * u;
							l < 0 && (l = -l, o = -o, a = -a, h = -h, u = -u);
							var c, d, f = 1 - e,
								p = e;
							return 1e-6 < 1 - l && (c = Math.acos(l), d = Math.sin(c), f = Math.sin((1 - e) * c) / d, p = Math.sin(e * c) / d), this.x = f * i + p * o, this.y = f * n + p * a, this.z = f * s + p * h, this.w = f * r + p * u, this
						},
						invert: function() {
							var t = this.x,
								e = this.y,
								i = this.z,
								n = this.w,
								s = t * t + e * e + i * i + n * n,
								r = s ? 1 / s : 0;
							return this.x = -t * r, this.y = -e * r, this.z = -i * r, this.w = n * r, this
						},
						conjugate: function() {
							return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
						},
						rotateX: function(t) {
							t *= .5;
							var e = this.x,
								i = this.y,
								n = this.z,
								s = this.w,
								r = Math.sin(t),
								o = Math.cos(t);
							return this.x = e * o + s * r, this.y = i * o + n * r, this.z = n * o - i * r, this.w = s * o - e * r, this
						},
						rotateY: function(t) {
							t *= .5;
							var e = this.x,
								i = this.y,
								n = this.z,
								s = this.w,
								r = Math.sin(t),
								o = Math.cos(t);
							return this.x = e * o - n * r, this.y = i * o + s * r, this.z = n * o + e * r, this.w = s * o - i * r, this
						},
						rotateZ: function(t) {
							t *= .5;
							var e = this.x,
								i = this.y,
								n = this.z,
								s = this.w,
								r = Math.sin(t),
								o = Math.cos(t);
							return this.x = e * o + i * r, this.y = i * o - e * r, this.z = n * o + s * r, this.w = s * o - n * r, this
						},
						calculateW: function() {
							var t = this.x,
								e = this.y,
								i = this.z;
							return this.w = -Math.sqrt(1 - t * t - e * e - i * i), this
						},
						fromMat3: function(t) {
							var e, i, n, s, r = t.val,
								h = r[0] + r[4] + r[8];
							return 0 < h ? (s = Math.sqrt(h + 1), this.w = .5 * s, s = .5 / s, this.x = (r[7] - r[5]) * s, this.y = (r[2] - r[6]) * s, this.z = (r[3] - r[1]) * s) : (e = 0, r[4] > r[0] && (e = 1), r[8] > r[3 * e + e] && (e = 2), i = o[e], n = o[i], s = Math.sqrt(r[3 * e + e] - r[3 * i + i] - r[3 * n + n] + 1), a[e] = .5 * s, s = .5 / s, a[i] = (r[3 * i + e] + r[3 * e + i]) * s, a[n] = (r[3 * n + e] + r[3 * e + n]) * s, this.x = a[0], this.y = a[1], this.z = a[2], this.w = (r[3 * n + i] - r[3 * i + n]) * s), this
						}
					});
				t.exports = d
			}, function(t, e, i) {
				var n = i(339),
					s = i(26),
					r = i(33),
					o = i(169);
				t.exports = function(t) {
					var e = t.config;
					if ((e.customEnvironment || e.canvas) && e.renderType === r.AUTO) throw new Error("Must set explicit renderType in custom environment");
					if (!e.customEnvironment && !e.canvas && e.renderType !== r.HEADLESS)
						if (e.renderType === r.CANVAS || e.renderType !== r.CANVAS && !o.webGL) {
							if (!o.canvas) throw new Error("Cannot create Canvas or WebGL context, aborting.");
							e.renderType = r.CANVAS
						} else e.renderType = r.WEBGL;
					e.antialias || s.disableSmoothing();
					var a, h, u = t.scale.baseSize,
						l = u.width,
						c = u.height;
					e.canvas ? (t.canvas = e.canvas, t.canvas.width = l, t.canvas.height = c) : t.canvas = s.create(t, l, c, e.renderType), e.canvasStyle && (t.canvas.style = e.canvasStyle), e.antialias || n.setCrisp(t.canvas), e.renderType !== r.HEADLESS && (a = i(505), h = i(508), e.renderType === r.WEBGL ? t.renderer = new h(t) : (t.renderer = new a(t), t.context = t.renderer.gameContext))
				}
			}, function(t, e) {
				t.exports = {
					setCrisp: function(t) {
						return ["optimizeSpeed", "-moz-crisp-edges", "-o-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "crisp-edges", "pixelated"].forEach(function(e) {
							t.style["image-rendering"] = e
						}), t.style.msInterpolationMode = "nearest-neighbor", t
					},
					setBicubic: function(t) {
						return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
					}
				}
			}, function(t, e) {
				t.exports = ["#define SHADER_NAME PHASER_TEXTURE_TINT_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler;", "", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main()", "{", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "    vec4 texel = vec4(outTint.rgb * outTint.a, outTint.a);", "    vec4 color = texture;", "", "    if (outTintEffect == 0.0)", "    {", "        //  Multiply texture tint", "        color = texture * texel;", "    }", "    else if (outTintEffect == 1.0)", "    {", "        //  Solid color + texture alpha", "        color.rgb = mix(texture.rgb, outTint.rgb * outTint.a, texture.a);", "        color.a = texture.a * texel.a;", "    }", "    else if (outTintEffect == 2.0)", "    {", "        //  Solid color, no texture", "        color = texel;", "    }", "", "    gl_FragColor = color;", "}", ""].join("\n")
			}, function(t, e) {
				t.exports = ["#define SHADER_NAME PHASER_TEXTURE_TINT_VS", "", "precision mediump float;", "", "uniform mat4 uProjectionMatrix;", "uniform mat4 uViewMatrix;", "uniform mat4 uModelMatrix;", "", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "attribute float inTintEffect;", "attribute vec4 inTint;", "", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main ()", "{", "    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(inPosition, 1.0, 1.0);", "", "    outTexCoord = inTexCoord;", "    outTint = inTint;", "    outTintEffect = inTintEffect;", "}", "", ""].join("\n")
			}, function(t, e, i) {
				var n = i(33);
				t.exports = function(t) {
					var e, i, s, r, o, a, h, u = t.config;
					u.hideBanner || (e = "WebGL", u.renderType === n.CANVAS ? e = "Canvas" : u.renderType === n.HEADLESS && (e = "Headless"), i = u.audio, h = !(s = t.device.audio).webAudio || i && i.disableWebAudio ? i && i.noAudio || !s.webAudio && !s.audioData ? "No Audio" : "HTML5 Audio" : "Web Audio", t.device.browser.ie ? window.console && console.log("Phaser v" + n.VERSION + " / https://phaser.io") : (o = [r = ""], Array.isArray(u.bannerBackgroundColor) ? (u.bannerBackgroundColor.forEach(function(t) {
						r = r.concat("%c "), o.push("background: " + t), a = t
					}), o[o.length - 1] = "color: " + u.bannerTextColor + "; background: " + a) : (r = r.concat("%c "), o.push("color: " + u.bannerTextColor + "; background: " + u.bannerBackgroundColor)), o.push("background: #fff"), u.gameTitle && (r = r.concat(u.gameTitle), u.gameVersion && (r = r.concat(" v" + u.gameVersion)), u.hidePhaser || (r = r.concat(" / "))), u.hidePhaser || (r = r.concat("Phaser v" + n.VERSION + " (" + e + " | " + h + ")")), r = r.concat(" %c " + u.gameURL), o[0] = r, console.log.apply(console, o)))
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(6),
					r = i(1),
					o = i(344),
					a = new n({
						initialize: function(t, e) {
							this.game = t, this.raf = new o, this.started = !1, this.running = !1, this.minFps = s(e, "min", 5), this.targetFps = s(e, "target", 60), this._min = 1e3 / this.minFps, this._target = 1e3 / this.targetFps, this.actualFps = this.targetFps, this.nextFpsUpdate = 0, this.framesThisSecond = 0, this.callback = r, this.forceSetTimeOut = s(e, "forceSetTimeOut", !1), this.time = 0, this.startTime = 0, this.lastTime = 0, this.frame = 0, this.inFocus = !0, this._pauseTime = 0, this._coolDown = 0, this.delta = 0, this.deltaIndex = 0, this.deltaHistory = [], this.deltaSmoothingMax = s(e, "deltaHistory", 10), this.panicMax = s(e, "panicMax", 120), this.rawDelta = 0, this.now = 0, this.smoothStep = s(e, "smoothStep", !0)
						},
						blur: function() {
							this.inFocus = !1
						},
						focus: function() {
							this.inFocus = !0, this.resetDelta()
						},
						pause: function() {
							this._pauseTime = window.performance.now()
						},
						resume: function() {
							this.resetDelta(), this.startTime += this.time - this._pauseTime
						},
						resetDelta: function() {
							var t = window.performance.now();
							this.time = t, this.lastTime = t, this.nextFpsUpdate = t + 1e3;
							for (var e = this.framesThisSecond = 0; e < this.deltaSmoothingMax; e++) this.deltaHistory[e] = Math.min(this._target, this.deltaHistory[e]);
							this.delta = 0, this.deltaIndex = 0, this._coolDown = this.panicMax
						},
						start: function(t) {
							if (this.started) return this;
							this.started = !0, this.running = !0;
							for (var e = 0; e < this.deltaSmoothingMax; e++) this.deltaHistory[e] = this._target;
							this.resetDelta(), this.startTime = window.performance.now(), this.callback = t, this.raf.start(this.step.bind(this), this.forceSetTimeOut, this._target)
						},
						step: function() {
							var t = window.performance.now(),
								e = (this.now = t) - this.lastTime;
							e < 0 && (e = 0), this.rawDelta = e;
							var i = this.deltaIndex,
								n = this.deltaHistory,
								s = this.deltaSmoothingMax,
								r = e,
								o = e;
							if (this.smoothStep) {
								(0 < this._coolDown || !this.inFocus) && (this._coolDown--, r = Math.min(r, this._target)), r > this._min && (r = n[i], r = Math.min(r, this._min)), n[i] = r, this.deltaIndex++, this.deltaIndex > s && (this.deltaIndex = 0);
								for (var a = o = 0; a < s; a++) o += n[a];
								o /= s
							}
							this.delta = o, this.time += this.rawDelta, t > this.nextFpsUpdate && (this.actualFps = .25 * this.framesThisSecond + .75 * this.actualFps, this.nextFpsUpdate = t + 1e3, this.framesThisSecond = 0), this.framesThisSecond++;
							var h = o / this._target;
							this.callback(t, o, h), this.lastTime = t, this.frame++
						},
						tick: function() {
							this.step()
						},
						sleep: function() {
							this.running && (this.raf.stop(), this.running = !1)
						},
						wake: function(t) {
							this.running || (t && (this.startTime += -this.lastTime + (this.lastTime + window.performance.now())), this.raf.start(this.step.bind(this), this.useRAF), this.running = !0, this.step())
						},
						getDuration: function() {
							return Math.round(this.lastTime - this.startTime) / 1e3
						},
						getDurationMS: function() {
							return Math.round(this.lastTime - this.startTime)
						},
						stop: function() {
							return this.running = !1, this.started = !1, this.raf.stop(), this
						},
						destroy: function() {
							this.stop(), this.callback = r, this.raf = null, this.game = null
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(0),
					s = i(1),
					r = new n({
						initialize: function() {
							this.isRunning = !1, this.callback = s, this.tick = 0, this.isSetTimeOut = !1, this.timeOutID = null, this.lastTime = 0, this.target = 0;
							var t = this;
							this.step = function e() {
								var i = window.performance.now();
								t.lastTime = t.tick, t.tick = i, t.callback(i), t.timeOutID = window.requestAnimationFrame(e)
							}, this.stepTimeout = function e() {
								var i = Date.now(),
									n = Math.min(Math.max(2 * t.target + t.tick - i, 0), t.target);
								t.lastTime = t.tick, t.tick = i, t.callback(i), t.timeOutID = window.setTimeout(e, n)
							}
						},
						start: function(t, e, i) {
							this.isRunning || (this.callback = t, this.isSetTimeOut = e, this.target = i, this.isRunning = !0, this.timeOutID = e ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step))
						},
						stop: function() {
							this.isRunning = !1, this.isSetTimeOut ? clearTimeout(this.timeOutID) : window.cancelAnimationFrame(this.timeOutID)
						},
						destroy: function() {
							this.stop(), this.callback = s
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = i(20);
				t.exports = function(t) {
					var e, i = t.events;
					void 0 !== document.hidden ? e = "visibilitychange" : ["webkit", "moz", "ms"].forEach(function(t) {
						void 0 !== document[t + "Hidden"] && (document.hidden = function() {
							return document[t + "Hidden"]
						}, e = t + "visibilitychange")
					}), e && document.addEventListener(e, function(t) {
						document.hidden || "pause" === t.type ? i.emit(n.HIDDEN) : i.emit(n.VISIBLE)
					}, !1), window.onblur = function() {
						i.emit(n.BLUR)
					}, window.onfocus = function() {
						i.emit(n.FOCUS)
					}, window.focus && t.config.autoFocus && window.focus()
				}
			}, function(t, e, i) {
				var n = i(347),
					s = i(26),
					r = i(6);
				t.exports = function(t) {
					var e = r(t, "data", []),
						i = r(t, "canvas", null),
						o = r(t, "palette", n),
						a = r(t, "pixelWidth", 1),
						h = r(t, "pixelHeight", a),
						u = r(t, "resizeCanvas", !0),
						l = r(t, "clearCanvas", !0),
						c = r(t, "preRender", null),
						d = r(t, "postRender", null),
						f = Math.floor(Math.abs(e[0].length * a)),
						p = Math.floor(Math.abs(e.length * h));
					i || (i = s.create2D(this, f, p), l = u = !1), u && (i.width = f, i.height = p);
					var g = i.getContext("2d");
					l && g.clearRect(0, 0, f, p), c && c(i, g);
					for (var v = 0; v < e.length; v++)
						for (var m = e[v], y = 0; y < m.length; y++) {
							var x = m[y];
							"." !== x && " " !== x && (g.fillStyle = o[x], g.fillRect(y * a, v * h, a, h))
						}
					return d && d(i, g), i
				}
			}, function(t, e) {
				t.exports = {
					0: "#000",
					1: "#9D9D9D",
					2: "#FFF",
					3: "#BE2633",
					4: "#E06F8B",
					5: "#493C2B",
					6: "#A46422",
					7: "#EB8931",
					8: "#F7E26B",
					9: "#2F484E",
					A: "#44891A",
					B: "#A3CE27",
					C: "#1B2632",
					D: "#005784",
					E: "#31A2F2",
					F: "#B2DCEF"
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(326),
					r = i(81),
					o = i(3),
					a = new n({
						Extends: r,
						initialize: function(t, e, i, n) {
							r.call(this, "CubicBezierCurve"), Array.isArray(t) && (n = new o(t[6], t[7]), i = new o(t[4], t[5]), e = new o(t[2], t[3]), t = new o(t[0], t[1])), this.p0 = t, this.p1 = e, this.p2 = i, this.p3 = n
						},
						getStartPoint: function(t) {
							return void 0 === t && (t = new o), t.copy(this.p0)
						},
						getResolution: function(t) {
							return t
						},
						getPoint: function(t, e) {
							void 0 === e && (e = new o);
							var i = this.p0,
								n = this.p1,
								r = this.p2,
								a = this.p3;
							return e.set(s(t, i.x, n.x, r.x, a.x), s(t, i.y, n.y, r.y, a.y))
						},
						draw: function(t, e) {
							void 0 === e && (e = 32);
							var i = this.getPoints(e);
							t.beginPath(), t.moveTo(this.p0.x, this.p0.y);
							for (var n = 1; n < i.length; n++) t.lineTo(i[n].x, i[n].y);
							return t.strokePath(), t
						},
						toJSON: function() {
							return {
								type: this.type,
								points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y, this.p3.x, this.p3.y]
							}
						}
					});
				a.fromJSON = function(t) {
					var e = t.points,
						i = new o(e[0], e[1]),
						n = new o(e[2], e[3]),
						s = new o(e[4], e[5]),
						r = new o(e[6], e[7]);
					return new a(i, n, s, r)
				}, t.exports = a
			}, function(t, e, i) {
				var n = i(0),
					s = i(81),
					r = i(39),
					o = i(6),
					a = i(173),
					h = i(3),
					u = new n({
						Extends: s,
						initialize: function(t, e, i, n, a, u, l, c) {
							var d;
							"object" == typeof t ? (t = o(d = t, "x", 0), e = o(d, "y", 0), i = o(d, "xRadius", 0), n = o(d, "yRadius", i), a = o(d, "startAngle", 0), u = o(d, "endAngle", 360), l = o(d, "clockwise", !1), c = o(d, "rotation", 0)) : (void 0 === n && (n = i), void 0 === a && (a = 0), void 0 === u && (u = 360), void 0 === l && (l = !1), void 0 === c && (c = 0)), s.call(this, "EllipseCurve"), this.p0 = new h(t, e), this._xRadius = i, this._yRadius = n, this._startAngle = r(a), this._endAngle = r(u), this._clockwise = l, this._rotation = r(c)
						},
						getStartPoint: function(t) {
							return void 0 === t && (t = new h), this.getPoint(0, t)
						},
						getResolution: function(t) {
							return 2 * t
						},
						getPoint: function(t, e) {
							void 0 === e && (e = new h);
							for (var i = 2 * Math.PI, n = this._endAngle - this._startAngle, s = Math.abs(n) < Number.EPSILON; n < 0;) n += i;
							for (; i < n;) n -= i;
							n < Number.EPSILON && (n = s ? 0 : i), this._clockwise && !s && (n === i ? n = -i : n -= i);
							var r, o, a, u, l = this._startAngle + t * n,
								c = this.p0.x + this._xRadius * Math.cos(l),
								d = this.p0.y + this._yRadius * Math.sin(l);
							return 0 !== this._rotation && (r = Math.cos(this._rotation), o = Math.sin(this._rotation), c = (a = c - this.p0.x) * r - (u = d - this.p0.y) * o + this.p0.x, d = a * o + u * r + this.p0.y), e.set(c, d)
						},
						setXRadius: function(t) {
							return this.xRadius = t, this
						},
						setYRadius: function(t) {
							return this.yRadius = t, this
						},
						setWidth: function(t) {
							return this.xRadius = t / 2, this
						},
						setHeight: function(t) {
							return this.yRadius = t / 2, this
						},
						setStartAngle: function(t) {
							return this.startAngle = t, this
						},
						setEndAngle: function(t) {
							return this.endAngle = t, this
						},
						setClockwise: function(t) {
							return this.clockwise = t, this
						},
						setRotation: function(t) {
							return this.rotation = t, this
						},
						x: {
							get: function() {
								return this.p0.x
							},
							set: function(t) {
								this.p0.x = t
							}
						},
						y: {
							get: function() {
								return this.p0.y
							},
							set: function(t) {
								this.p0.y = t
							}
						},
						xRadius: {
							get: function() {
								return this._xRadius
							},
							set: function(t) {
								this._xRadius = t
							}
						},
						yRadius: {
							get: function() {
								return this._yRadius
							},
							set: function(t) {
								this._yRadius = t
							}
						},
						startAngle: {
							get: function() {
								return a(this._startAngle)
							},
							set: function(t) {
								this._startAngle = r(t)
							}
						},
						endAngle: {
							get: function() {
								return a(this._endAngle)
							},
							set: function(t) {
								this._endAngle = r(t)
							}
						},
						clockwise: {
							get: function() {
								return this._clockwise
							},
							set: function(t) {
								this._clockwise = t
							}
						},
						angle: {
							get: function() {
								return a(this._rotation)
							},
							set: function(t) {
								this._rotation = r(t)
							}
						},
						rotation: {
							get: function() {
								return this._rotation
							},
							set: function(t) {
								this._rotation = t
							}
						},
						toJSON: function() {
							return {
								type: this.type,
								x: this.p0.x,
								y: this.p0.y,
								xRadius: this._xRadius,
								yRadius: this._yRadius,
								startAngle: a(this._startAngle),
								endAngle: a(this._endAngle),
								clockwise: this._clockwise,
								rotation: a(this._rotation)
							}
						}
					});
				u.fromJSON = function(t) {
					return new u(t)
				}, t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(81),
					r = i(176),
					o = i(11),
					a = i(3),
					h = new a,
					u = new n({
						Extends: s,
						initialize: function(t, e) {
							s.call(this, "LineCurve"), Array.isArray(t) && (e = new a(t[2], t[3]), t = new a(t[0], t[1])), this.p0 = t, this.p1 = e, this.arcLengthDivisions = 1
						},
						getBounds: function(t) {
							return void 0 === t && (t = new o), r([this.p0, this.p1], t)
						},
						getStartPoint: function(t) {
							return void 0 === t && (t = new a), t.copy(this.p0)
						},
						getResolution: function(t) {
							return void 0 === t && (t = 1), t
						},
						getPoint: function(t, e) {
							return void 0 === e && (e = new a), 1 === t ? e.copy(this.p1) : (e.copy(this.p1).subtract(this.p0).scale(t).add(this.p0), e)
						},
						getPointAt: function(t, e) {
							return this.getPoint(t, e)
						},
						getTangent: function() {
							return h.copy(this.p1).subtract(this.p0).normalize()
						},
						getUtoTmapping: function(t, e, i) {
							var n, s;
							return e ? (s = (n = this.getLengths(i))[n.length - 1], Math.min(e, s) / s) : t
						},
						draw: function(t) {
							return t.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y), t
						},
						toJSON: function() {
							return {
								type: this.type,
								points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y]
							}
						}
					});
				u.fromJSON = function(t) {
					var e = t.points,
						i = new a(e[0], e[1]),
						n = new a(e[2], e[3]);
					return new u(i, n)
				}, t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(81),
					r = i(327),
					o = i(3),
					a = new n({
						Extends: s,
						initialize: function(t, e, i) {
							s.call(this, "QuadraticBezier"), Array.isArray(t) && (i = new o(t[4], t[5]), e = new o(t[2], t[3]), t = new o(t[0], t[1])), this.p0 = t, this.p1 = e, this.p2 = i
						},
						getStartPoint: function(t) {
							return void 0 === t && (t = new o), t.copy(this.p0)
						},
						getResolution: function(t) {
							return t
						},
						getPoint: function(t, e) {
							void 0 === e && (e = new o);
							var i = this.p0,
								n = this.p1,
								s = this.p2;
							return e.set(r(t, i.x, n.x, s.x), r(t, i.y, n.y, s.y))
						},
						draw: function(t, e) {
							void 0 === e && (e = 32);
							var i = this.getPoints(e);
							t.beginPath(), t.moveTo(this.p0.x, this.p0.y);
							for (var n = 1; n < i.length; n++) t.lineTo(i[n].x, i[n].y);
							return t.strokePath(), t
						},
						toJSON: function() {
							return {
								type: this.type,
								points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y]
							}
						}
					});
				a.fromJSON = function(t) {
					var e = t.points,
						i = new o(e[0], e[1]),
						n = new o(e[2], e[3]),
						s = new o(e[4], e[5]);
					return new a(i, n, s)
				}, t.exports = a
			}, function(t, e, i) {
				var n = i(171),
					s = i(0),
					r = i(81),
					o = i(3),
					a = new s({
						Extends: r,
						initialize: function(t) {
							void 0 === t && (t = []), r.call(this, "SplineCurve"), this.points = [], this.addPoints(t)
						},
						addPoints: function(t) {
							for (var e = 0; e < t.length; e++) {
								var i = new o;
								"number" == typeof t[e] ? (i.x = t[e], i.y = t[e + 1], e++) : Array.isArray(t[e]) ? (i.x = t[e][0], i.y = t[e][1]) : (i.x = t[e].x, i.y = t[e].y), this.points.push(i)
							}
							return this
						},
						addPoint: function(t, e) {
							var i = new o(t, e);
							return this.points.push(i), i
						},
						getStartPoint: function(t) {
							return void 0 === t && (t = new o), t.copy(this.points[0])
						},
						getResolution: function(t) {
							return t * this.points.length
						},
						getPoint: function(t, e) {
							void 0 === e && (e = new o);
							var i = this.points,
								s = (i.length - 1) * t,
								r = Math.floor(s),
								a = s - r,
								h = i[0 === r ? r : r - 1],
								u = i[r],
								l = i[r > i.length - 2 ? i.length - 1 : r + 1],
								c = i[r > i.length - 3 ? i.length - 1 : r + 2];
							return e.set(n(a, h.x, u.x, l.x, c.x), n(a, h.y, u.y, l.y, c.y))
						},
						toJSON: function() {
							for (var t = [], e = 0; e < this.points.length; e++) t.push(this.points[e].x), t.push(this.points[e].y);
							return {
								type: this.type,
								points: t
							}
						}
					});
				a.fromJSON = function(t) {
					return new a(t.points)
				}, t.exports = a
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t, e, i, n) {
						e && "" !== e || (e = ["precision mediump float;", "uniform vec2 resolution;", "varying vec2 fragCoord;", "void main () {", "    vec2 uv = fragCoord / resolution.xy;", "    gl_FragColor = vec4(uv.xyx, 1.0);", "}"].join("\n")), i && "" !== i || (i = ["precision mediump float;", "uniform mat4 uProjectionMatrix;", "uniform mat4 uViewMatrix;", "uniform vec2 uResolution;", "attribute vec2 inPosition;", "varying vec2 fragCoord;", "void main () {", "gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);", "fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);", "}"].join("\n")), void 0 === n && (n = null), this.key = t, this.fragmentSrc = e, this.vertexSrc = i, this.uniforms = n
					}
				});
				t.exports = n
			}, function(t, e, i) {
				var n = i(31);
				n.ColorToRGBA = i(811), n.ComponentToHex = i(355), n.GetColor = i(165), n.GetColor32 = i(295), n.HexStringToColor = i(294), n.HSLToColor = i(812), n.HSVColorWheel = i(813), n.HSVToRGB = i(166), n.HueToComponent = i(356), n.IntegerToColor = i(297), n.IntegerToRGB = i(298), n.Interpolate = i(814), n.ObjectToColor = i(299), n.RandomRGB = i(815), n.RGBStringToColor = i(300), n.RGBToHSV = i(296), n.RGBToString = i(816), n.ValueToColor = i(164), t.exports = n
			}, function(t, e) {
				t.exports = function(t) {
					var e = t.toString(16);
					return 1 === e.length ? "0" + e : e
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return i < 0 && (i += 1), 1 < i && --i, i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
				}
			}, function(t, e, i) {
				var n = i(117);
				t.exports = function(t) {
					var e;
					"complete" !== document.readyState && "interactive" !== document.readyState ? (e = function() {
						document.removeEventListener("deviceready", e, !0), document.removeEventListener("DOMContentLoaded", e, !0), window.removeEventListener("load", e, !0), t()
					}, document.body ? n.cordova ? document.addEventListener("deviceready", e, !1) : (document.addEventListener("DOMContentLoaded", e, !0), window.addEventListener("load", e, !0)) : window.setTimeout(e, 20)) : t()
				}
			}, function(t, e, i) {
				var n = i(177);
				t.exports = function(t, e) {
					var i = window.screen,
						s = !!i && (i.orientation || i.mozOrientation || i.msOrientation);
					if (s && "string" == typeof s.type) return s.type;
					if ("string" == typeof s) return s;
					if (i) return i.height > i.width ? n.ORIENTATION.PORTRAIT : n.ORIENTATION.LANDSCAPE;
					if ("number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? n.ORIENTATION.PORTRAIT : n.ORIENTATION.LANDSCAPE;
					if (window.matchMedia) {
						if (window.matchMedia("(orientation: portrait)").matches) return n.ORIENTATION.PORTRAIT;
						if (window.matchMedia("(orientation: landscape)").matches) return n.ORIENTATION.LANDSCAPE
					}
					return t < e ? n.ORIENTATION.PORTRAIT : n.ORIENTATION.LANDSCAPE
				}
			}, function(t, e) {
				t.exports = {
					NO_CENTER: 0,
					CENTER_BOTH: 1,
					CENTER_HORIZONTALLY: 2,
					CENTER_VERTICALLY: 3
				}
			}, function(t, e) {
				t.exports = {
					LANDSCAPE: "landscape-primary",
					PORTRAIT: "portrait-primary"
				}
			}, function(t, e) {
				t.exports = {
					NONE: 0,
					WIDTH_CONTROLS_HEIGHT: 1,
					HEIGHT_CONTROLS_WIDTH: 2,
					FIT: 3,
					ENVELOP: 4,
					RESIZE: 5
				}
			}, function(t, e) {
				t.exports = {
					NO_ZOOM: 1,
					ZOOM_2X: 2,
					ZOOM_4X: 4,
					MAX_ZOOM: -1
				}
			}, function(t, e) {
				t.exports = function(t) {
					var e;
					return "" !== t && ("string" == typeof t ? e = document.getElementById(t) : t && 1 === t.nodeType && (e = t)), e || document.body
				}
			}, function(t, e) {
				t.exports = function(t) {
					var e = "";
					try {
						window.DOMParser ? e = (new DOMParser).parseFromString(t, "text/xml") : (e = new ActiveXObject("Microsoft.XMLDOM")).loadXML(t)
					} catch (t) {
						e = null
					}
					return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(179),
					r = i(10),
					o = i(54),
					a = i(20),
					h = i(366),
					u = i(367),
					l = i(368),
					c = i(369),
					d = i(29),
					f = i(333),
					p = new n({
						initialize: function(t, e) {
							this.game = t, this.scaleManager, this.canvas, this.config = e, this.enabled = !0, this.events = new r, this.isOver = !0, this.defaultCursor = "", this.keyboard = e.inputKeyboard ? new h(this) : null, this.mouse = e.inputMouse ? new u(this) : null, this.touch = e.inputTouch ? new c(this) : null, this.pointers = [], this.pointersTotal = e.inputActivePointers, e.inputTouch && 1 === this.pointersTotal && (this.pointersTotal = 2);
							for (var i = 0; i <= this.pointersTotal; i++) {
								var n = new l(this, i);
								n.smoothFactor = e.inputSmoothFactor, this.pointers.push(n)
							}
							this.mousePointer = e.inputMouse ? this.pointers[0] : null, this.activePointer = this.pointers[0], this.globalTopOnly = !0, this.time = 0, this._tempPoint = {
								x: 0,
								y: 0
							}, this._tempHitTest = [], this._tempMatrix = new d, this._tempMatrix2 = new d, this._tempSkip = !1, this.mousePointerContainer = [this.mousePointer], t.events.once(a.BOOT, this.boot, this)
						},
						boot: function() {
							this.canvas = this.game.canvas, this.scaleManager = this.game.scale, this.events.emit(o.MANAGER_BOOT), this.game.events.on(a.PRE_RENDER, this.preRender, this), this.game.events.once(a.DESTROY, this.destroy, this)
						},
						setCanvasOver: function(t) {
							this.isOver = !0, this.events.emit(o.GAME_OVER, t)
						},
						setCanvasOut: function(t) {
							this.isOver = !1, this.events.emit(o.GAME_OUT, t)
						},
						preRender: function() {
							var t = this.game.loop.now,
								e = this.game.loop.delta,
								i = this.game.scene.getScenes(!0, !0);
							this.time = t, this.events.emit(o.MANAGER_UPDATE);
							for (var n = 0; n < i.length; n++) {
								var s = i[n];
								if (s.sys.input && s.sys.input.updatePoll(t, e) && this.globalTopOnly) return
							}
						},
						setDefaultCursor: function(t) {
							this.defaultCursor = t, this.canvas.style.cursor !== t && (this.canvas.style.cursor = t)
						},
						setCursor: function(t) {
							t.cursor && (this.canvas.style.cursor = t.cursor)
						},
						resetCursor: function(t) {
							t.cursor && this.canvas && (this.canvas.style.cursor = this.defaultCursor)
						},
						addPointer: function(t) {
							void 0 === t && (t = 1);
							var e = [];
							10 < this.pointersTotal + t && (t = 10 - this.pointersTotal);
							for (var i = 0; i < t; i++) {
								var n = this.pointers.length,
									s = new l(this, n);
								s.smoothFactor = this.config.inputSmoothFactor, this.pointers.push(s), this.pointersTotal++, e.push(s)
							}
							return e
						},
						updateInputPlugins: function(t, e) {
							var i = this.game.scene.getScenes(!0, !0);
							this._tempSkip = !1;
							for (var n = 0; n < i.length; n++) {
								var s = i[n];
								if (s.sys.input && (s.sys.input.update(t, e) && this.globalTopOnly || this._tempSkip)) return
							}
						},
						onTouchStart: function(t) {
							for (var e = this.pointers, i = [], n = 0; n < t.changedTouches.length; n++)
								for (var r = t.changedTouches[n], o = 1; o < this.pointersTotal; o++) {
									var a = e[o];
									if (!a.active) {
										a.touchstart(r, t), this.activePointer = a, i.push(a);
										break
									}
								}
							this.updateInputPlugins(s.TOUCH_START, i)
						},
						onTouchMove: function(t) {
							for (var e = this.pointers, i = [], n = 0; n < t.changedTouches.length; n++)
								for (var r = t.changedTouches[n], o = 1; o < this.pointersTotal; o++) {
									var a = e[o];
									if (a.active && a.identifier === r.identifier) {
										a.touchmove(r, t), this.activePointer = a, i.push(a);
										break
									}
								}
							this.updateInputPlugins(s.TOUCH_MOVE, i)
						},
						onTouchEnd: function(t) {
							for (var e = this.pointers, i = [], n = 0; n < t.changedTouches.length; n++)
								for (var r = t.changedTouches[n], o = 1; o < this.pointersTotal; o++) {
									var a = e[o];
									if (a.active && a.identifier === r.identifier) {
										a.touchend(r, t), i.push(a);
										break
									}
								}
							this.updateInputPlugins(s.TOUCH_END, i)
						},
						onTouchCancel: function(t) {
							for (var e = this.pointers, i = [], n = 0; n < t.changedTouches.length; n++)
								for (var r = t.changedTouches[n], o = 1; o < this.pointersTotal; o++) {
									var a = e[o];
									if (a.active && a.identifier === r.identifier) {
										a.touchcancel(r, t), i.push(a);
										break
									}
								}
							this.updateInputPlugins(s.TOUCH_CANCEL, i)
						},
						onMouseDown: function(t) {
							this.mousePointer.down(t), this.mousePointer.updateMotion(), this.updateInputPlugins(s.MOUSE_DOWN, this.mousePointerContainer)
						},
						onMouseMove: function(t) {
							this.mousePointer.move(t), this.mousePointer.updateMotion(), this.updateInputPlugins(s.MOUSE_MOVE, this.mousePointerContainer)
						},
						onMouseUp: function(t) {
							this.mousePointer.up(t), this.mousePointer.updateMotion(), this.updateInputPlugins(s.MOUSE_UP, this.mousePointerContainer)
						},
						onMouseWheel: function(t) {
							this.mousePointer.wheel(t), this.updateInputPlugins(s.MOUSE_WHEEL, this.mousePointerContainer)
						},
						onPointerLockChange: function(t) {
							var e = this.mouse.locked;
							this.mousePointer.locked = e, this.events.emit(o.POINTERLOCK_CHANGE, t, e)
						},
						inputCandidate: function(t, e) {
							var i = t.input;
							if (!i || !i.enabled || !i.alwaysEnabled && !t.willRender(e)) return !1;
							var n = !0,
								s = t.parentContainer;
							if (s)
								do {
									if (!s.willRender(e)) {
										n = !1;
										break
									}
									s = s.parentContainer
								} while (s);
							return n
						},
						hitTest: function(t, e, i, n) {
							void 0 === n && (n = this._tempHitTest);
							var s = this._tempPoint,
								r = i.scrollX,
								o = i.scrollY;
							n.length = 0;
							var a = t.x,
								h = t.y;
							1 !== i.resolution && (a += i._x, h += i._y), i.getWorldPoint(a, h, s), t.worldX = s.x, t.worldY = s.y;
							for (var u = {
									x: 0,
									y: 0
								}, l = this._tempMatrix, c = this._tempMatrix2, d = 0; d < e.length; d++) {
								var p, g, v = e[d];
								this.inputCandidate(v, i) && (p = s.x + r * v.scrollFactorX - r, g = s.y + o * v.scrollFactorY - o, v.parentContainer ? (v.getWorldTransformMatrix(l, c), l.applyInverse(p, g, u)) : f(p, g, v.x, v.y, v.rotation, v.scaleX, v.scaleY, u), this.pointWithinHitArea(v, u.x, u.y) && n.push(v))
							}
							return n
						},
						pointWithinHitArea: function(t, e, i) {
							e += t.displayOriginX, i += t.displayOriginY;
							var n = t.input;
							return !(!n || !n.hitAreaCallback(n.hitArea, e, i, t) || (n.localX = e, n.localY = i, 0))
						},
						pointWithinInteractiveObject: function(t, e, i) {
							return !!t.hitArea && (e += t.gameObject.displayOriginX, i += t.gameObject.displayOriginY, t.localX = e, t.localY = i, t.hitAreaCallback(t.hitArea, e, i, t))
						},
						transformPointer: function(t, e, i, n) {
							var s = t.position,
								r = t.prevPosition;
							r.x = s.x, r.y = s.y;
							var o = this.scaleManager.transformX(e),
								a = this.scaleManager.transformY(i),
								h = t.smoothFactor;
							n && 0 !== h ? (s.x = o * h + r.x * (1 - h), s.y = a * h + r.y * (1 - h)) : (s.x = o, s.y = a)
						},
						destroy: function() {
							this.events.removeAllListeners(), this.game.events.off(a.PRE_RENDER), this.keyboard && this.keyboard.destroy(), this.mouse && this.mouse.destroy(), this.touch && this.touch.destroy();
							for (var t = 0; t < this.pointers.length; t++) this.pointers[t].destroy();
							this.pointers = [], this._tempHitTest = [], this._tempMatrix.destroy(), this.canvas = null, this.game = null
						}
					});
				t.exports = p
			}, function(t, e, i) {
				var n = i(123),
					s = i(0),
					r = i(20),
					o = i(54),
					a = i(124),
					h = i(1),
					u = new s({
						initialize: function(t) {
							this.manager = t, this.queue = [], this.preventDefault = !0, this.captures = [], this.enabled = !1, this.target, this.onKeyDown = h, this.onKeyUp = h, t.events.once(o.MANAGER_BOOT, this.boot, this)
						},
						boot: function() {
							var t = this.manager.config;
							this.enabled = t.inputKeyboard, this.target = t.inputKeyboardEventTarget, this.addCapture(t.inputKeyboardCapture), !this.target && window && (this.target = window), this.enabled && this.target && this.startListeners(), this.manager.game.events.on(r.POST_STEP, this.postUpdate, this)
						},
						startListeners: function() {
							var t = this;
							this.onKeyDown = function(e) {
								var i;
								!e.defaultPrevented && t.enabled && t.manager && (t.queue.push(e), t.manager.useQueue || t.manager.events.emit(o.MANAGER_PROCESS), i = e.altKey || e.ctrlKey || e.shiftKey || e.metaKey, t.preventDefault && !i && -1 < t.captures.indexOf(e.keyCode) && e.preventDefault())
							}, this.onKeyUp = function(e) {
								var i;
								!e.defaultPrevented && t.enabled && t.manager && (t.queue.push(e), t.manager.useQueue || t.manager.events.emit(o.MANAGER_PROCESS), i = e.altKey || e.ctrlKey || e.shiftKey || e.metaKey, t.preventDefault && !i && -1 < t.captures.indexOf(e.keyCode) && e.preventDefault())
							};
							var e = this.target;
							e && (e.addEventListener("keydown", this.onKeyDown, !1), e.addEventListener("keyup", this.onKeyUp, !1), this.enabled = !0)
						},
						stopListeners: function() {
							var t = this.target;
							t.removeEventListener("keydown", this.onKeyDown, !1), t.removeEventListener("keyup", this.onKeyUp, !1), this.enabled = !1
						},
						postUpdate: function() {
							this.queue = []
						},
						addCapture: function(t) {
							"string" == typeof t && (t = t.split(",")), Array.isArray(t) || (t = [t]);
							for (var e = this.captures, i = 0; i < t.length; i++) {
								var n = t[i];
								"string" == typeof n && (n = a[n.trim().toUpperCase()]), -1 === e.indexOf(n) && e.push(n)
							}
							this.preventDefault = 0 < e.length
						},
						removeCapture: function(t) {
							"string" == typeof t && (t = t.split(",")), Array.isArray(t) || (t = [t]);
							for (var e = this.captures, i = 0; i < t.length; i++) {
								var s = t[i];
								"string" == typeof s && (s = a[s.toUpperCase()]), n(e, s)
							}
							this.preventDefault = 0 < e.length
						},
						clearCaptures: function() {
							this.captures = [], this.preventDefault = !1
						},
						destroy: function() {
							this.stopListeners(), this.clearCaptures(), this.queue = [], this.manager.game.events.off(r.POST_RENDER, this.postUpdate, this), this.target = null, this.enabled = !1, this.manager = null
						}
					});
				t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(169),
					r = i(54),
					o = i(1),
					a = new n({
						initialize: function(t) {
							this.manager = t, this.capture = !0, this.enabled = !1, this.target, this.locked = !1, this.onMouseMove = o, this.onMouseDown = o, this.onMouseUp = o, this.onMouseDownWindow = o, this.onMouseUpWindow = o, this.onMouseOver = o, this.onMouseOut = o, this.onMouseWheel = o, this.pointerLockChange = o, t.events.once(r.MANAGER_BOOT, this.boot, this)
						},
						boot: function() {
							var t = this.manager.config;
							this.enabled = t.inputMouse, this.target = t.inputMouseEventTarget, this.capture = t.inputMouseCapture, this.target ? "string" == typeof this.target && (this.target = document.getElementById(this.target)) : this.target = this.manager.game.canvas, t.disableContextMenu && this.disableContextMenu(), this.enabled && this.target && this.startListeners()
						},
						disableContextMenu: function() {
							return document.body.addEventListener("contextmenu", function(t) {
								return t.preventDefault(), !1
							}), this
						},
						requestPointerLock: function() {
							var t;
							s.pointerLock && ((t = this.target).requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock())
						},
						releasePointerLock: function() {
							s.pointerLock && (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock())
						},
						startListeners: function() {
							var t = this,
								e = this.manager.canvas,
								i = window && window.focus && this.manager.game.config.autoFocus;
							this.onMouseMove = function(e) {
								!e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onMouseMove(e), t.capture && e.preventDefault())
							}, this.onMouseDown = function(n) {
								i && window.focus(), !n.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onMouseDown(n), t.capture && n.target === e && n.preventDefault())
							}, this.onMouseDownWindow = function(i) {
								!i.defaultPrevented && t.enabled && t.manager && t.manager.enabled && i.target !== e && t.manager.onMouseDown(i)
							}, this.onMouseUp = function(i) {
								!i.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onMouseUp(i), t.capture && i.target === e && i.preventDefault())
							}, this.onMouseUpWindow = function(i) {
								!i.defaultPrevented && t.enabled && t.manager && t.manager.enabled && i.target !== e && t.manager.onMouseUp(i)
							}, this.onMouseOver = function(e) {
								!e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && t.manager.setCanvasOver(e)
							}, this.onMouseOut = function(e) {
								!e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && t.manager.setCanvasOut(e)
							}, this.onMouseWheel = function(e) {
								!e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && t.manager.onMouseWheel(e)
							};
							var n, r, o = this.target;
							o && (r = {
								passive: !(n = {
									passive: !0
								})
							}, o.addEventListener("mousemove", this.onMouseMove, this.capture ? r : n), o.addEventListener("mousedown", this.onMouseDown, this.capture ? r : n), o.addEventListener("mouseup", this.onMouseUp, this.capture ? r : n), o.addEventListener("mouseover", this.onMouseOver, this.capture ? r : n), o.addEventListener("mouseout", this.onMouseOut, this.capture ? r : n), o.addEventListener("wheel", this.onMouseWheel, this.capture ? r : n), window && this.manager.game.config.inputWindowEvents && (window.addEventListener("mousedown", this.onMouseDownWindow, r), window.addEventListener("mouseup", this.onMouseUpWindow, r)), s.pointerLock && (this.pointerLockChange = function(e) {
								var i = t.target;
								t.locked = document.pointerLockElement === i || document.mozPointerLockElement === i || document.webkitPointerLockElement === i, t.manager.onPointerLockChange(e)
							}, document.addEventListener("pointerlockchange", this.pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this.pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this.pointerLockChange, !0)), this.enabled = !0)
						},
						stopListeners: function() {
							var t = this.target;
							t.removeEventListener("mousemove", this.onMouseMove), t.removeEventListener("mousedown", this.onMouseDown), t.removeEventListener("mouseup", this.onMouseUp), t.removeEventListener("mouseover", this.onMouseOver), t.removeEventListener("mouseout", this.onMouseOut), window && (window.removeEventListener("mousedown", this.onMouseDownWindow), window.removeEventListener("mouseup", this.onMouseUpWindow)), s.pointerLock && (document.removeEventListener("pointerlockchange", this.pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this.pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this.pointerLockChange, !0))
						},
						destroy: function() {
							this.stopListeners(), this.target = null, this.enabled = !1, this.manager = null
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(317),
					s = i(0),
					r = i(53),
					o = i(106),
					a = i(328),
					h = i(3),
					u = new s({
						initialize: function(t, e) {
							this.manager = t, this.id = e, this.event, this.downElement, this.upElement, this.camera = null, this.button = 0, this.buttons = 0, this.position = new h, this.prevPosition = new h, this.midPoint = new h(-1, -1), this.velocity = new h, this.angle = 0, this.distance = 0, this.smoothFactor = 0, this.motionFactor = .2, this.worldX = 0, this.worldY = 0, this.moveTime = 0, this.downX = 0, this.downY = 0, this.downTime = 0, this.upX = 0, this.upY = 0, this.upTime = 0, this.primaryDown = !1, this.isDown = !1, this.wasTouch = !1, this.wasCanceled = !1, this.movementX = 0, this.movementY = 0, this.identifier = 0, this.pointerId = null, this.active = 0 === e, this.locked = !1, this.deltaX = 0, this.deltaY = 0, this.deltaZ = 0
						},
						updateWorldPoint: function(t) {
							var e = this.x,
								i = this.y;
							1 !== t.resolution && (e += t._x, i += t._y);
							var n = t.getWorldPoint(e, i);
							return this.worldX = n.x, this.worldY = n.y, this
						},
						positionToCamera: function(t, e) {
							return t.getWorldPoint(this.x, this.y, e)
						},
						updateMotion: function() {
							var t, e, i, s, r = this.position.x,
								h = this.position.y,
								u = this.midPoint.x,
								l = this.midPoint.y;
							r === u && h === l || (t = a(this.motionFactor, u, r), e = a(this.motionFactor, l, h), o(t, r, .1) && (t = r), o(e, h, .1) && (e = h), this.midPoint.set(t, e), i = r - t, s = h - e, this.velocity.set(i, s), this.angle = n(t, e, r, h), this.distance = Math.sqrt(i * i + s * s))
						},
						up: function(t) {
							"buttons" in t && (this.buttons = t.buttons), this.event = t, this.button = t.button, this.upElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), 0 === t.button && (this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = t.timeStamp), this.isDown = !1, this.wasTouch = !1
						},
						down: function(t) {
							"buttons" in t && (this.buttons = t.buttons), this.event = t, this.button = t.button, this.downElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), 0 === t.button && (this.primaryDown = !0, this.downX = this.x, this.downY = this.y, this.downTime = t.timeStamp), this.isDown = !0, this.wasTouch = !1
						},
						move: function(t) {
							"buttons" in t && (this.buttons = t.buttons), this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY, !0), this.locked && (this.movementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.movementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0), this.moveTime = t.timeStamp, this.wasTouch = !1
						},
						wheel: function(t) {
							"buttons" in t && (this.buttons = t.buttons), this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.deltaX = t.deltaX, this.deltaY = t.deltaY, this.deltaZ = t.deltaZ, this.wasTouch = !1
						},
						touchstart: function(t, e) {
							t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.active = !0, this.buttons = 1, this.event = e, this.downElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.primaryDown = !0, this.downX = this.x, this.downY = this.y, this.downTime = e.timeStamp, this.isDown = !0, this.wasTouch = !0, this.wasCanceled = !1, this.updateMotion()
						},
						touchmove: function(t, e) {
							this.event = e, this.manager.transformPointer(this, t.pageX, t.pageY, !0), this.moveTime = e.timeStamp, this.wasTouch = !0, this.updateMotion()
						},
						touchend: function(t, e) {
							this.buttons = 0, this.event = e, this.upElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = e.timeStamp, this.isDown = !1, this.wasTouch = !0, this.wasCanceled = !1, this.active = !1, this.updateMotion()
						},
						touchcancel: function(t, e) {
							this.buttons = 0, this.event = e, this.upElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = e.timeStamp, this.isDown = !1, this.wasTouch = !0, this.wasCanceled = !0, this.active = !1
						},
						noButtonDown: function() {
							return 0 === this.buttons
						},
						leftButtonDown: function() {
							return !!(1 & this.buttons)
						},
						rightButtonDown: function() {
							return !!(2 & this.buttons)
						},
						middleButtonDown: function() {
							return !!(4 & this.buttons)
						},
						backButtonDown: function() {
							return !!(8 & this.buttons)
						},
						forwardButtonDown: function() {
							return !!(16 & this.buttons)
						},
						leftButtonReleased: function() {
							return 0 === this.button && !this.isDown
						},
						rightButtonReleased: function() {
							return 2 === this.button && !this.isDown
						},
						middleButtonReleased: function() {
							return 1 === this.button && !this.isDown
						},
						backButtonReleased: function() {
							return 3 === this.button && !this.isDown
						},
						forwardButtonReleased: function() {
							return 4 === this.button && !this.isDown
						},
						getDistance: function() {
							return this.isDown ? r(this.downX, this.downY, this.x, this.y) : r(this.downX, this.downY, this.upX, this.upY)
						},
						getDistanceX: function() {
							return this.isDown ? Math.abs(this.downX - this.x) : Math.abs(this.downX - this.upX)
						},
						getDistanceY: function() {
							return this.isDown ? Math.abs(this.downY - this.y) : Math.abs(this.downY - this.upY)
						},
						getDuration: function() {
							return this.isDown ? this.manager.time - this.downTime : this.upTime - this.downTime
						},
						getAngle: function() {
							return this.isDown ? n(this.downX, this.downY, this.x, this.y) : n(this.downX, this.downY, this.upX, this.upY)
						},
						getInterpolatedPosition: function(t, e) {
							void 0 === t && (t = 10), void 0 === e && (e = []);
							for (var i = this.prevPosition.x, n = this.prevPosition.y, s = this.position.x, r = this.position.y, o = 0; o < t; o++) {
								var h = 1 / t * o;
								e[o] = {
									x: a(h, i, s),
									y: a(h, n, r)
								}
							}
							return e
						},
						destroy: function() {
							this.camera = null, this.manager = null, this.position = null
						},
						x: {
							get: function() {
								return this.position.x
							},
							set: function(t) {
								this.position.x = t
							}
						},
						y: {
							get: function() {
								return this.position.y
							},
							set: function(t) {
								this.position.y = t
							}
						},
						time: {
							get: function() {
								return this.event ? this.event.timeStamp : 0
							}
						}
					});
				t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(54),
					r = i(1),
					o = new n({
						initialize: function(t) {
							this.manager = t, this.capture = !0, this.enabled = !1, this.target, this.onTouchStart = r, this.onTouchStartWindow = r, this.onTouchMove = r, this.onTouchEnd = r, this.onTouchEndWindow = r, this.onTouchCancel = r, this.onTouchCancelWindow = r, this.onTouchOver = r, this.onTouchOut = r, t.events.once(s.MANAGER_BOOT, this.boot, this)
						},
						boot: function() {
							var t = this.manager.config;
							this.enabled = t.inputTouch, this.target = t.inputTouchEventTarget, this.capture = t.inputTouchCapture, this.target || (this.target = this.manager.game.canvas), t.disableContextMenu && this.disableContextMenu(), this.enabled && this.target && this.startListeners()
						},
						disableContextMenu: function() {
							return document.body.addEventListener("contextmenu", function(t) {
								return t.preventDefault(), !1
							}), this
						},
						startListeners: function() {
							var t = this,
								e = this.manager.canvas,
								i = window && window.focus && this.manager.game.config.autoFocus;
							this.onTouchStart = function(n) {
								i && window.focus(), !n.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onTouchStart(n), t.capture && n.cancelable && n.target === e && n.preventDefault())
							}, this.onTouchStartWindow = function(i) {
								!i.defaultPrevented && t.enabled && t.manager && t.manager.enabled && i.target !== e && t.manager.onTouchStart(i)
							}, this.onTouchMove = function(e) {
								!e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onTouchMove(e), t.capture && e.cancelable && e.preventDefault())
							}, this.onTouchEnd = function(i) {
								!i.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onTouchEnd(i), t.capture && i.cancelable && i.target === e && i.preventDefault())
							}, this.onTouchEndWindow = function(i) {
								!i.defaultPrevented && t.enabled && t.manager && t.manager.enabled && i.target !== e && t.manager.onTouchEnd(i)
							}, this.onTouchCancel = function(e) {
								!e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onTouchCancel(e), t.capture && e.preventDefault())
							}, this.onTouchCancelWindow = function(e) {
								!e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && t.manager.onTouchCancel(e)
							}, this.onTouchOver = function(e) {
								!e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && t.manager.setCanvasOver(e)
							}, this.onTouchOut = function(e) {
								!e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && t.manager.setCanvasOut(e)
							};
							var n, s, r = this.target;
							r && (s = {
								passive: !(n = {
									passive: !0
								})
							}, r.addEventListener("touchstart", this.onTouchStart, this.capture ? s : n), r.addEventListener("touchmove", this.onTouchMove, this.capture ? s : n), r.addEventListener("touchend", this.onTouchEnd, this.capture ? s : n), r.addEventListener("touchcancel", this.onTouchCancel, this.capture ? s : n), r.addEventListener("touchover", this.onTouchOver, this.capture ? s : n), r.addEventListener("touchout", this.onTouchOut, this.capture ? s : n), window && this.manager.game.config.inputWindowEvents && (window.addEventListener("touchstart", this.onTouchStartWindow, s), window.addEventListener("touchend", this.onTouchEndWindow, s), window.addEventListener("touchcancel", this.onTouchCancelWindow, s)), this.enabled = !0)
						},
						stopListeners: function() {
							var t = this.target;
							t.removeEventListener("touchstart", this.onTouchStart), t.removeEventListener("touchmove", this.onTouchMove), t.removeEventListener("touchend", this.onTouchEnd), t.removeEventListener("touchcancel", this.onTouchCancel), t.removeEventListener("touchover", this.onTouchOver), t.removeEventListener("touchout", this.onTouchOut), window && (window.removeEventListener("touchstart", this.onTouchStartWindow), window.removeEventListener("touchend", this.onTouchEndWindow))
						},
						destroy: function() {
							this.stopListeners(), this.target = null, this.enabled = !1, this.manager = null
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(0),
					s = i(20),
					r = i(10),
					o = i(8),
					a = i(16),
					h = i(5),
					u = i(2),
					l = i(23),
					c = i(123),
					d = new n({
						Extends: r,
						initialize: function(t) {
							r.call(this), this.game = t, this.plugins = [], this.scenePlugins = [], this._pendingGlobal = [], this._pendingScene = [], t.isBooted ? this.boot() : t.events.once(s.BOOT, this.boot, this)
						},
						boot: function() {
							for (var t, e, i, n, r, o, a = this.game.config, h = (h = a.installGlobalPlugins).concat(this._pendingGlobal), l = 0; l < h.length; l++) t = h[l], e = u(t, "key", null), i = u(t, "plugin", null), n = u(t, "start", !1), r = u(t, "mapping", null), o = u(t, "data", null), e && (i ? this.install(e, i, n, r, o) : console.warn("Missing `plugin` for key: " + e));
							for (h = (h = a.installScenePlugins).concat(this._pendingScene), l = 0; l < h.length; l++) t = h[l], e = u(t, "key", null), i = u(t, "plugin", null), r = u(t, "mapping", null), e && (i ? this.installScenePlugin(e, i, r) : console.warn("Missing `plugin` for key: " + e));
							this._pendingGlobal = [], this._pendingScene = [], this.game.events.once(s.DESTROY, this.destroy, this)
						},
						addToScene: function(t, e, i) {
							for (var n, s = this.game, r = t.scene, o = t.settings.map, a = t.settings.isBooted, h = 0; h < e.length; h++) s[f = e[h]] ? (t[f] = s[f], o.hasOwnProperty(f) && (r[o[f]] = t[f])) : "game" === f && o.hasOwnProperty(f) && (r[o[f]] = s);
							for (var u = 0; u < i.length; u++)
								for (n = i[u], h = 0; h < n.length; h++) {
									var c, d, f = n[h];
									l.hasCore(f) && (d = new((c = l.getCore(f)).plugin)(r, this), t[c.mapping] = d, c.custom ? r[c.mapping] = d : o.hasOwnProperty(c.mapping) && (r[o[c.mapping]] = d), a && d.boot())
								}
							for (n = this.plugins, h = 0; h < n.length; h++) {
								var p = n[h];
								p.mapping && (r[p.mapping] = p.plugin)
							}
						},
						getDefaultScenePlugins: function() {
							return this.game.config.defaultPlugins.concat(this.scenePlugins)
						},
						installScenePlugin: function(t, e, i, n, s) {
							if (void 0 === s && (s = !1), "function" == typeof e) {
								if (l.hasCore(t)) {
									if (!s && l.hasCore(t)) return void console.warn("Scene Plugin key in use: " + t)
								} else l.register(t, e, i, !0), this.scenePlugins.push(t);
								var r;
								n && (r = new e(n, this), n.sys[t] = r, i && "" !== i && (n[i] = r), r.boot())
							} else console.warn("Invalid Scene Plugin: " + t)
						},
						install: function(t, e, i, n, s) {
							if (void 0 === i && (i = !1), void 0 === n && (n = null), void 0 === s && (s = null), "function" != typeof e) return console.warn("Invalid Plugin: " + t), null;
							if (l.hasCustom(t)) return console.warn("Plugin key in use: " + t), null;
							if (null !== n && (i = !0), this.game.isBooted) {
								if (l.registerCustom(t, e, n, s), i) return this.start(t)
							} else this._pendingGlobal.push({
								key: t,
								plugin: e,
								start: i,
								mapping: n,
								data: s
							});
							return null
						},
						getIndex: function(t) {
							for (var e = this.plugins, i = 0; i < e.length; i++)
								if (e[i].key === t) return i;
							return -1
						},
						getEntry: function(t) {
							var e = this.getIndex(t);
							if (-1 !== e) return this.plugins[e]
						},
						isActive: function(t) {
							var e = this.getEntry(t);
							return e && e.active
						},
						start: function(t, e) {
							void 0 === e && (e = t);
							var i = this.getEntry(e);
							return i && !i.active ? (i.active = !0, i.plugin.start()) : i = i || this.createEntry(t, e), i ? i.plugin : null
						},
						createEntry: function(t, e) {
							var i, n = l.getCustom(t);
							return n && (n = {
								key: e,
								plugin: i = new n.plugin(this),
								active: !0,
								mapping: n.mapping,
								data: n.data
							}, this.plugins.push(n), i.init(n.data), i.start()), n
						},
						stop: function(t) {
							var e = this.getEntry(t);
							return e && e.active && (e.active = !1, e.plugin.stop()), this
						},
						get: function(t, e) {
							void 0 === e && (e = !0);
							var i = this.getEntry(t);
							if (i) return i.plugin;
							var n = this.getClass(t);
							return n && e ? (i = this.createEntry(t, t)) ? i.plugin : null : n || null
						},
						getClass: function(t) {
							return l.getCustomClass(t)
						},
						removeGlobalPlugin: function(t) {
							var e = this.getEntry(t);
							e && c(this.plugins, e), l.removeCustom(t)
						},
						removeScenePlugin: function(t) {
							c(this.scenePlugins, t), l.remove(t)
						},
						registerGameObject: function(t, e, i) {
							return e && h.register(t, e), i && a.register(t, i), this
						},
						removeGameObject: function(t, e, i) {
							return void 0 === e && (e = !0), void 0 === i && (i = !0), e && h.remove(t), i && a.remove(t), this
						},
						registerFileType: function(t, e, i) {
							o.register(t, e), i && i.sys.load && (i.sys.load[t] = e)
						},
						destroy: function() {
							for (var t = 0; t < this.plugins.length; t++) this.plugins[t].plugin.destroy();
							l.destroyCustomPlugins(), this.game.noReturn && l.destroyCorePlugins(), this.game = null, this.plugins = [], this.scenePlugins = []
						}
					});
				t.exports = d
			}, function(t, e, i) {
				var n = i(177),
					s = i(0),
					r = i(10),
					o = i(92),
					a = i(20),
					h = i(869),
					u = i(363),
					l = i(358),
					c = i(1),
					d = i(11),
					f = i(372),
					p = i(93),
					g = i(3),
					v = new s({
						Extends: r,
						initialize: function(t) {
							r.call(this), this.game = t, this.canvas, this.canvasBounds = new d, this.parent = null, this.parentIsWindow = !1, this.parentSize = new f, this.gameSize = new f, this.baseSize = new f, this.displaySize = new f, this.scaleMode = n.SCALE_MODE.NONE, this.resolution = 1, this.zoom = 1, this._resetZoom = !1, this.displayScale = new g(1, 1), this.autoRound = !1, this.autoCenter = n.CENTER.NO_CENTER, this.orientation = n.ORIENTATION.LANDSCAPE, this.fullscreen, this.fullscreenTarget = null, this._createdFullscreenTarget = !1, this.dirty = !1, this.resizeInterval = 500, this._lastCheck = 0, this._checkOrientation = !1, this.listeners = {
								orientationChange: c,
								windowResize: c,
								fullScreenChange: c,
								fullScreenError: c
							}
						},
						preBoot: function() {
							this.parseConfig(this.game.config), this.game.events.once("boot", this.boot, this)
						},
						boot: function() {
							var t = this.game;
							this.canvas = t.canvas, this.fullscreen = t.device.fullscreen, this.scaleMode !== n.SCALE_MODE.RESIZE && this.displaySize.setAspectMode(this.scaleMode), this.scaleMode === n.SCALE_MODE.NONE ? this.resize(this.width, this.height) : (this.getParentBounds(), 0 < this.parentSize.width && 0 < this.parentSize.height && this.displaySize.setParent(this.parentSize), this.refresh()), t.events.on(a.PRE_STEP, this.step, this), t.events.once(a.DESTROY, this.destroy, this), this.startListeners()
						},
						parseConfig: function(t) {
							this.getParent(t), this.getParentBounds();
							var e, i, s, r, o = t.width,
								a = t.height,
								h = t.scaleMode,
								u = t.resolution,
								c = t.zoom,
								d = t.autoRound;
							"string" == typeof o && (0 === (e = this.parentSize.width) && (e = window.innerWidth), i = parseInt(o, 10) / 100, o = Math.floor(e * i)), "string" == typeof a && (0 === (s = this.parentSize.height) && (s = window.innerHeight), r = parseInt(a, 10) / 100, a = Math.floor(s * r)), this.resolution = 1, this.scaleMode = h, this.autoRound = d, this.autoCenter = t.autoCenter, this.resizeInterval = t.resizeInterval, d && (o = Math.floor(o), a = Math.floor(a)), this.gameSize.setSize(o, a), c === n.ZOOM.MAX_ZOOM && (c = this.getMaxZoom()), 1 !== (this.zoom = c) && (this._resetZoom = !0), this.baseSize.setSize(o * u, a * u), d && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), 0 < t.minWidth && this.displaySize.setMin(t.minWidth * c, t.minHeight * c), 0 < t.maxWidth && this.displaySize.setMax(t.maxWidth * c, t.maxHeight * c), this.displaySize.setSize(o, a), this.orientation = l(o, a)
						},
						getParent: function(t) {
							var e, i = t.parent;
							null !== i && (this.parent = u(i), this.parentIsWindow = this.parent === document.body, t.expandParent && t.scaleMode !== n.SCALE_MODE.NONE && (e = this.parent.getBoundingClientRect(), !this.parentIsWindow && 0 !== e.height || (document.documentElement.style.height = "100%", document.body.style.height = "100%", e = this.parent.getBoundingClientRect(), this.parentIsWindow || 0 !== e.height || (this.parent.style.overflow = "hidden", this.parent.style.width = "100%", this.parent.style.height = "100%"))), t.fullscreenTarget && !this.fullscreenTarget && (this.fullscreenTarget = u(t.fullscreenTarget)))
						},
						getParentBounds: function() {
							if (!this.parent) return !1;
							var t = this.parentSize,
								e = this.parent.getBoundingClientRect();
							this.parentIsWindow && this.game.device.os.iOS && (e.height = h(!0));
							var i = this.resolution,
								n = e.width * i,
								s = e.height * i;
							return (t.width !== n || t.height !== s) && (t.setSize(n, s), !0)
						},
						lockOrientation: function(t) {
							var e = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;
							return !!e && e.call(screen, t)
						},
						setParentSize: function(t, e) {
							return this.parentSize.setSize(t, e), this.refresh()
						},
						setGameSize: function(t, e) {
							var i = this.autoRound,
								n = this.resolution;
							i && (t = Math.floor(t), e = Math.floor(e));
							var s = this.width,
								r = this.height;
							return this.gameSize.resize(t, e), this.baseSize.resize(t * n, e * n), i && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), this.displaySize.setAspectRatio(t / e), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height, this.refresh(s, r)
						},
						resize: function(t, e) {
							var i = this.zoom,
								n = this.resolution,
								s = this.autoRound;
							s && (t = Math.floor(t), e = Math.floor(e));
							var r = this.width,
								o = this.height;
							this.gameSize.resize(t, e), this.baseSize.resize(t * n, e * n), s && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), this.displaySize.setSize(t * i * n, e * i * n), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height;
							var a = this.canvas.style,
								h = t * i,
								u = e * i;
							return s && (h = Math.floor(h), u = Math.floor(u)), h === t && u === e || (a.width = h + "px", a.height = u + "px"), this.refresh(r, o)
						},
						setZoom: function(t) {
							return this.zoom = t, this._resetZoom = !0, this.refresh()
						},
						setMaxZoom: function() {
							return this.zoom = this.getMaxZoom(), this._resetZoom = !0, this.refresh()
						},
						refresh: function(t, e) {
							void 0 === t && (t = this.width), void 0 === e && (e = this.height), this.updateScale(), this.updateBounds(), this.updateOrientation(), this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);
							var i, n, s = this.game.domContainer;
							return s && (this.baseSize.setCSS(s), i = this.canvas.style, (n = s.style).transform = "scale(" + this.displaySize.width / this.baseSize.width + "," + this.displaySize.height / this.baseSize.height + ")", n.marginLeft = i.marginLeft, n.marginTop = i.marginTop), this.emit(o.RESIZE, this.gameSize, this.baseSize, this.displaySize, this.resolution, t, e), this
						},
						updateOrientation: function() {
							var t;
							this._checkOrientation && (this._checkOrientation = !1, (t = l(this.width, this.height)) !== this.orientation && (this.orientation = t, this.emit(o.ORIENTATION_CHANGE, t)))
						},
						updateScale: function() {
							var t, e, i = this.canvas.style,
								s = this.gameSize.width,
								r = this.gameSize.height,
								o = this.zoom,
								a = this.autoRound;
							this.scaleMode === n.SCALE_MODE.NONE ? (this.displaySize.setSize(s * o * 1, r * o * 1), t = +this.displaySize.width, e = +this.displaySize.height, a && (t = Math.floor(t), e = Math.floor(e)), this._resetZoom && (i.width = t + "px", i.height = e + "px", this._resetZoom = !1)) : this.scaleMode === n.SCALE_MODE.RESIZE ? (this.displaySize.setSize(this.parentSize.width, this.parentSize.height), this.gameSize.setSize(this.displaySize.width, this.displaySize.height), this.baseSize.setSize(+this.displaySize.width, +this.displaySize.height), t = +this.displaySize.width, e = +this.displaySize.height, a && (t = Math.floor(t), e = Math.floor(e)), this.canvas.width = t, this.canvas.height = e) : (this.displaySize.setSize(this.parentSize.width, this.parentSize.height), t = +this.displaySize.width, e = +this.displaySize.height, a && (t = Math.floor(t), e = Math.floor(e)), i.width = t + "px", i.height = e + "px"), this.getParentBounds(), this.updateCenter()
						},
						getMaxZoom: function() {
							var t = p(this.parentSize.width, this.gameSize.width, 0, !0),
								e = p(this.parentSize.height, this.gameSize.height, 0, !0);
							return Math.max(Math.min(t, e), 1)
						},
						updateCenter: function() {
							var t, e, i, s, r, o, a, h = this.autoCenter;
							h !== n.CENTER.NO_CENTER && (e = (t = this.canvas).style, s = (i = t.getBoundingClientRect()).width, r = i.height, o = Math.floor((this.parentSize.width - s) / 2), a = Math.floor((this.parentSize.height - r) / 2), h === n.CENTER.CENTER_HORIZONTALLY ? a = 0 : h === n.CENTER.CENTER_VERTICALLY && (o = 0), e.marginLeft = o + "px", e.marginTop = a + "px")
						},
						updateBounds: function() {
							var t = this.canvasBounds,
								e = this.canvas.getBoundingClientRect();
							t.x = e.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0), t.y = e.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0), t.width = e.width, t.height = e.height
						},
						transformX: function(t) {
							return (t - this.canvasBounds.left) * this.displayScale.x
						},
						transformY: function(t) {
							return (t - this.canvasBounds.top) * this.displayScale.y
						},
						startFullscreen: function(t) {
							void 0 === t && (t = {
								navigationUI: "hide"
							});
							var e, i = this.fullscreen;
							i.available ? i.active || (e = this.getFullscreenTarget(), i.keyboard ? e[i.request](Element.ALLOW_KEYBOARD_INPUT) : e[i.request](t)) : this.emit(o.FULLSCREEN_UNSUPPORTED)
						},
						fullscreenSuccessHandler: function() {
							this.getParentBounds(), this.refresh(), this.emit(o.ENTER_FULLSCREEN)
						},
						fullscreenErrorHandler: function(t) {
							this.removeFullscreenTarget(), this.emit(o.FULLSCREEN_FAILED, t)
						},
						getFullscreenTarget: function() {
							var t;
							return this.fullscreenTarget || ((t = document.createElement("div")).style.margin = "0", t.style.padding = "0", t.style.width = "100%", t.style.height = "100%", this.fullscreenTarget = t, this._createdFullscreenTarget = !0), this._createdFullscreenTarget && (this.canvas.parentNode.insertBefore(this.fullscreenTarget, this.canvas), this.fullscreenTarget.appendChild(this.canvas)), this.fullscreenTarget
						},
						removeFullscreenTarget: function() {
							var t, e;
							!this._createdFullscreenTarget || (t = this.fullscreenTarget) && t.parentNode && ((e = t.parentNode).insertBefore(this.canvas, t), e.removeChild(t))
						},
						stopFullscreen: function() {
							var t = this.fullscreen;
							if (!t.available) return this.emit(o.FULLSCREEN_UNSUPPORTED), !1;
							t.active && document[t.cancel](), this.removeFullscreenTarget(), this.getParentBounds(), this.emit(o.LEAVE_FULLSCREEN), this.refresh()
						},
						toggleFullscreen: function(t) {
							this.fullscreen.active ? this.stopFullscreen() : this.startFullscreen(t)
						},
						startListeners: function() {
							var t = this,
								e = this.listeners;
							e.orientationChange = function() {
								t._checkOrientation = !0, t.dirty = !0
							}, e.windowResize = function() {
								t.dirty = !0
							}, window.addEventListener("orientationchange", e.orientationChange, !1), window.addEventListener("resize", e.windowResize, !1), this.fullscreen.available && (e.fullScreenChange = function(e) {
								return t.onFullScreenChange(e)
							}, e.fullScreenError = function(e) {
								return t.onFullScreenError(e)
							}, ["webkit", "moz", ""].forEach(function(t) {
								document.addEventListener(t + "fullscreenchange", e.fullScreenChange, !1), document.addEventListener(t + "fullscreenerror", e.fullScreenError, !1)
							}), document.addEventListener("MSFullscreenChange", e.fullScreenChange, !1), document.addEventListener("MSFullscreenError", e.fullScreenError, !1))
						},
						onFullScreenChange: function() {
							document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement ? this.fullscreenSuccessHandler() : this.stopFullscreen()
						},
						onFullScreenError: function() {
							this.removeFullscreenTarget()
						},
						step: function(t, e) {
							this.parent && (this._lastCheck += e, (this.dirty || this._lastCheck > this.resizeInterval) && (this.getParentBounds() && this.refresh(), this.dirty = !1, this._lastCheck = 0))
						},
						stopListeners: function() {
							var t = this.listeners;
							window.removeEventListener("orientationchange", t.orientationChange, !1), window.removeEventListener("resize", t.windowResize, !1), ["webkit", "moz", ""].forEach(function(e) {
								document.removeEventListener(e + "fullscreenchange", t.fullScreenChange, !1), document.removeEventListener(e + "fullscreenerror", t.fullScreenError, !1)
							}), document.removeEventListener("MSFullscreenChange", t.fullScreenChange, !1), document.removeEventListener("MSFullscreenError", t.fullScreenError, !1)
						},
						destroy: function() {
							this.removeAllListeners(), this.stopListeners(), this.game = null, this.canvas = null, this.canvasBounds = null, this.parent = null, this.fullscreenTarget = null, this.parentSize.destroy(), this.gameSize.destroy(), this.baseSize.destroy(), this.displaySize.destroy()
						},
						isFullscreen: {
							get: function() {
								return this.fullscreen.active
							}
						},
						width: {
							get: function() {
								return this.gameSize.width
							}
						},
						height: {
							get: function() {
								return this.gameSize.height
							}
						},
						isPortrait: {
							get: function() {
								return this.orientation === n.ORIENTATION.PORTRAIT
							}
						},
						isLandscape: {
							get: function() {
								return this.orientation === n.ORIENTATION.LANDSCAPE
							}
						},
						isGamePortrait: {
							get: function() {
								return this.height > this.width
							}
						},
						isGameLandscape: {
							get: function() {
								return this.width > this.height
							}
						}
					});
				t.exports = v
			}, function(t, e, i) {
				var n = i(19),
					s = i(0),
					r = i(93),
					o = i(3),
					a = new s({
						initialize: function(t, e, i, n) {
							void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = 0), void 0 === n && (n = null), this._width = t, this._height = e, this._parent = n, this.aspectMode = i, this.aspectRatio = 0 === e ? 1 : t / e, this.minWidth = 0, this.minHeight = 0, this.maxWidth = Number.MAX_VALUE, this.maxHeight = Number.MAX_VALUE, this.snapTo = new o
						},
						setAspectMode: function(t) {
							return void 0 === t && (t = 0), this.aspectMode = t, this.setSize(this._width, this._height)
						},
						setSnap: function(t, e) {
							return void 0 === t && (t = 0), void 0 === e && (e = t), this.snapTo.set(t, e), this.setSize(this._width, this._height)
						},
						setParent: function(t) {
							return this._parent = t, this.setSize(this._width, this._height)
						},
						setMin: function(t, e) {
							return void 0 === t && (t = 0), void 0 === e && (e = t), this.minWidth = n(t, 0, this.maxWidth), this.minHeight = n(e, 0, this.maxHeight), this.setSize(this._width, this._height)
						},
						setMax: function(t, e) {
							return void 0 === t && (t = Number.MAX_VALUE), void 0 === e && (e = t), this.maxWidth = n(t, this.minWidth, Number.MAX_VALUE), this.maxHeight = n(e, this.minHeight, Number.MAX_VALUE), this.setSize(this._width, this._height)
						},
						setSize: function(t, e) {
							switch (void 0 === t && (t = 0), void 0 === e && (e = t), this.aspectMode) {
								case a.NONE:
									this._width = this.getNewWidth(r(t, this.snapTo.x)), this._height = this.getNewHeight(r(e, this.snapTo.y)), this.aspectRatio = 0 === this._height ? 1 : this._width / this._height;
									break;
								case a.WIDTH_CONTROLS_HEIGHT:
									this._width = this.getNewWidth(r(t, this.snapTo.x)), this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), !1);
									break;
								case a.HEIGHT_CONTROLS_WIDTH:
									this._height = this.getNewHeight(r(e, this.snapTo.y)), this._width = this.getNewWidth(this._height * this.aspectRatio, !1);
									break;
								case a.FIT:
									this.constrain(t, e, !0);
									break;
								case a.ENVELOP:
									this.constrain(t, e, !1)
							}
							return this
						},
						setAspectRatio: function(t) {
							return this.aspectRatio = t, this.setSize(this._width, this._height)
						},
						resize: function(t, e) {
							return this._width = this.getNewWidth(r(t, this.snapTo.x)), this._height = this.getNewHeight(r(e, this.snapTo.y)), this.aspectRatio = 0 === this._height ? 1 : this._width / this._height, this
						},
						getNewWidth: function(t, e) {
							return void 0 === e && (e = !0), t = n(t, this.minWidth, this.maxWidth), e && this._parent && t > this._parent.width && (t = Math.max(this.minWidth, this._parent.width)), t
						},
						getNewHeight: function(t, e) {
							return void 0 === e && (e = !0), t = n(t, this.minHeight, this.maxHeight), e && this._parent && t > this._parent.height && (t = Math.max(this.minHeight, this._parent.height)), t
						},
						constrain: function(t, e, i) {
							void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = !0), t = this.getNewWidth(t), e = this.getNewHeight(e);
							var n = this.snapTo,
								s = 0 === e ? 1 : t / e;
							return i && this.aspectRatio > s || !i && this.aspectRatio < s ? (e = (t = r(t, n.x)) / this.aspectRatio, 0 < n.y && (t = (e = r(e, n.y)) * this.aspectRatio)) : (i && this.aspectRatio < s || !i && this.aspectRatio > s) && (t = (e = r(e, n.y)) * this.aspectRatio, 0 < n.x && (e = (t = r(t, n.x)) * (1 / this.aspectRatio))), this._width = t, this._height = e, this
						},
						fitTo: function(t, e) {
							return this.constrain(t, e, !0)
						},
						envelop: function(t, e) {
							return this.constrain(t, e, !1)
						},
						setWidth: function(t) {
							return this.setSize(t, this._height)
						},
						setHeight: function(t) {
							return this.setSize(this._width, t)
						},
						toString: function() {
							return "[{ Size (width=" + this._width + " height=" + this._height + " aspectRatio=" + this.aspectRatio + " aspectMode=" + this.aspectMode + ") }]"
						},
						setCSS: function(t) {
							t && t.style && (t.style.width = this._width + "px", t.style.height = this._height + "px")
						},
						copy: function(t) {
							return t.setAspectMode(this.aspectMode), t.aspectRatio = this.aspectRatio, t.setSize(this.width, this.height)
						},
						destroy: function() {
							this._parent = null, this.snapTo = null
						},
						width: {
							get: function() {
								return this._width
							},
							set: function(t) {
								this.setSize(t, this._height)
							}
						},
						height: {
							get: function() {
								return this._height
							},
							set: function(t) {
								this.setSize(this._width, t)
							}
						}
					});
				a.NONE = 0, a.WIDTH_CONTROLS_HEIGHT = 1, a.HEIGHT_CONTROLS_WIDTH = 2, a.FIT = 3, a.ENVELOP = 4, t.exports = a
			}, function(t, e, i) {
				var n = i(0),
					s = i(125),
					r = i(22),
					o = i(20),
					a = i(6),
					h = i(82),
					u = i(1),
					l = i(374),
					c = i(180),
					d = new n({
						initialize: function(t, e) {
							if (this.game = t, this.keys = {}, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this._data = {}, this.isProcessing = !1, this.isBooted = !1, this.customViewports = 0, e) {
								Array.isArray(e) || (e = [e]);
								for (var i = 0; i < e.length; i++) this._pending.push({
									key: "default",
									scene: e[i],
									autoStart: 0 === i,
									data: {}
								})
							}
							t.events.once(o.READY, this.bootQueue, this)
						},
						bootQueue: function() {
							if (!this.isBooted) {
								for (var t = 0; t < this._pending.length; t++) {
									var e, i, n, s = (i = this._pending[t]).key;
									(n = i.scene) instanceof l ? e = this.createSceneFromInstance(s, n) : "object" == typeof n ? e = this.createSceneFromObject(s, n) : "function" == typeof n && (e = this.createSceneFromFunction(s, n)), s = e.sys.settings.key, this.keys[s] = e, this.scenes.push(e), this._data[s] && (e.sys.settings.data = this._data[s].data, this._data[s].autoStart && (i.autoStart = !0)), (i.autoStart || e.sys.settings.active) && this._start.push(s)
								}
								for (this._pending.length = 0, this._data = {}, this.isBooted = !0, t = 0; t < this._start.length; t++) i = this._start[t], this.start(i);
								this._start.length = 0
							}
						},
						processQueue: function() {
							var t, e, i = this._pending.length,
								n = this._queue.length;
							if (0 !== i || 0 !== n) {
								if (i) {
									for (t = 0; t < i; t++) e = this._pending[t], this.add(e.key, e.scene, e.autoStart, e.data);
									for (t = 0; t < this._start.length; t++) e = this._start[t], this.start(e);
									return this._start.length = 0, void(this._pending.length = 0)
								}
								for (t = 0; t < this._queue.length; t++) this[(e = this._queue[t]).op](e.keyA, e.keyB);
								this._queue.length = 0
							}
						},
						add: function(t, e, i, n) {
							return void 0 === i && (i = !1), void 0 === n && (n = {}), this.isProcessing || !this.isBooted ? (this._pending.push({
								key: t,
								scene: e,
								autoStart: i,
								data: n
							}), this.isBooted || (this._data[t] = {
								data: n
							}), null) : (t = this.getKey(t, e), e instanceof l ? s = this.createSceneFromInstance(t, e) : "object" == typeof e ? (e.key = t, s = this.createSceneFromObject(t, e)) : "function" == typeof e && (s = this.createSceneFromFunction(t, e)), s.sys.settings.data = n, t = s.sys.settings.key, this.keys[t] = s, this.scenes.push(s), (i || s.sys.settings.active) && (this._pending.length ? this._start.push(t) : this.start(t)), s);
							var s
						},
						remove: function(t) {
							if (this.isProcessing) this._queue.push({
								op: "remove",
								keyA: t,
								keyB: null
							});
							else {
								var e = this.getScene(t);
								if (!e || e.sys.isTransitioning()) return this;
								var i = this.scenes.indexOf(e),
									n = e.sys.settings.key; - 1 < i && (delete this.keys[n], this.scenes.splice(i, 1), -1 < this._start.indexOf(n) && (i = this._start.indexOf(n), this._start.splice(i, 1)), e.sys.destroy())
							}
							return this
						},
						bootScene: function(t) {
							var e, i = t.sys,
								n = i.settings;
							i.sceneUpdate = u, t.init && (t.init.call(t, n.data), n.status = s.INIT, n.isTransition && i.events.emit(r.TRANSITION_INIT, n.transitionFrom, n.transitionDuration)), i.load && (e = i.load).reset(), e && t.preload ? (t.preload.call(t), 0 === e.list.size ? this.create(t) : (n.status = s.LOADING, e.once(h.COMPLETE, this.loadComplete, this), e.start())) : this.create(t)
						},
						loadComplete: function(t) {
							var e = t.scene;
							this.game.sound && this.game.sound.onBlurPausedSounds && this.game.sound.unlock(), this.create(e)
						},
						payloadComplete: function(t) {
							this.bootScene(t.scene)
						},
						update: function(t, e) {
							this.processQueue(), this.isProcessing = !0;
							for (var i = this.scenes.length - 1; 0 <= i; i--) {
								var n = this.scenes[i].sys;
								n.settings.status > s.START && n.settings.status <= s.RUNNING && n.step(t, e)
							}
						},
						render: function(t) {
							for (var e = 0; e < this.scenes.length; e++) {
								var i = this.scenes[e].sys;
								i.settings.visible && i.settings.status >= s.LOADING && i.settings.status < s.SLEEPING && i.render(t)
							}
							this.isProcessing = !1
						},
						create: function(t) {
							var e = t.sys,
								i = e.settings;
							t.create && (i.status = s.CREATING, t.create.call(t, i.data), i.status === s.DESTROYED) || (i.isTransition && e.events.emit(r.TRANSITION_START, i.transitionFrom, i.transitionDuration), t.update && (e.sceneUpdate = t.update), i.status = s.RUNNING, e.events.emit(r.CREATE, t))
						},
						createSceneFromFunction: function(t, e) {
							var i = new e;
							if (i instanceof l) {
								var n = i.sys.settings.key;
								if ("" !== n && (t = n), this.keys.hasOwnProperty(t)) throw new Error("Cannot add a Scene with duplicate key: " + t);
								return this.createSceneFromInstance(t, i)
							}
							return i.sys = new c(i), i.sys.settings.key = t, i.sys.init(this.game), i
						},
						createSceneFromInstance: function(t, e) {
							return "" === e.sys.settings.key && (e.sys.settings.key = t), e.sys.init(this.game), e
						},
						createSceneFromObject: function(t, e) {
							var i = new l(e),
								n = i.sys.settings.key;
							"" !== n ? t = n : i.sys.settings.key = t, i.sys.init(this.game);
							for (var s, r = ["init", "preload", "create", "update", "render"], o = 0; o < r.length; o++) {
								var h = a(e, r[o], null);
								h && (i[r[o]] = h)
							}
							if (e.hasOwnProperty("extend"))
								for (var u in e.extend) e.extend.hasOwnProperty(u) && (s = e.extend[u], "data" === u && i.hasOwnProperty("data") && "object" == typeof s ? i.data.merge(s) : "sys" !== u && (i[u] = s));
							return i
						},
						getKey: function(t, e) {
							if (t = t || "default", "function" == typeof e) return t;
							if (e instanceof l ? t = e.sys.settings.key : "object" == typeof e && e.hasOwnProperty("key") && (t = e.key), this.keys.hasOwnProperty(t)) throw new Error("Cannot add a Scene with duplicate key: " + t);
							return t
						},
						getScenes: function(t, e) {
							void 0 === t && (t = !0), void 0 === e && (e = !1);
							for (var i = [], n = this.scenes, s = 0; s < n.length; s++) {
								var r = n[s];
								r && (!t || t && r.sys.isActive()) && i.push(r)
							}
							return e ? i.reverse() : i
						},
						getScene: function(t) {
							if ("string" == typeof t) {
								if (this.keys[t]) return this.keys[t]
							} else
								for (var e = 0; e < this.scenes.length; e++)
									if (t === this.scenes[e]) return t;
							return null
						},
						isActive: function(t) {
							var e = this.getScene(t);
							return e ? e.sys.isActive() : null
						},
						isPaused: function(t) {
							var e = this.getScene(t);
							return e ? e.sys.isPaused() : null
						},
						isVisible: function(t) {
							var e = this.getScene(t);
							return e ? e.sys.isVisible() : null
						},
						isSleeping: function(t) {
							var e = this.getScene(t);
							return e ? e.sys.isSleeping() : null
						},
						pause: function(t, e) {
							var i = this.getScene(t);
							return i && i.sys.pause(e), this
						},
						resume: function(t, e) {
							var i = this.getScene(t);
							return i && i.sys.resume(e), this
						},
						sleep: function(t, e) {
							var i = this.getScene(t);
							return i && !i.sys.isTransitioning() && i.sys.sleep(e), this
						},
						wake: function(t, e) {
							var i = this.getScene(t);
							return i && i.sys.wake(e), this
						},
						run: function(t, e) {
							var i = this.getScene(t);
							if (!i) {
								for (var n = 0; n < this._pending.length; n++)
									if (this._pending[n].key === t) {
										this.queueOp("start", t, e);
										break
									} return this
							}
							i.sys.isSleeping() ? i.sys.wake(e) : i.sys.isPaused() ? i.sys.resume(e) : this.start(t, e)
						},
						start: function(t, e) {
							if (!this.isBooted) return this._data[t] = {
								autoStart: !0,
								data: e
							}, this;
							var i, n = this.getScene(t);
							if (n) {
								if (n.sys.isActive() || n.sys.isPaused()) n.sys.shutdown(), n.sys.start(e);
								else if (n.sys.start(e), n.sys.load && (i = n.sys.load), i && n.sys.settings.hasOwnProperty("pack") && (i.reset(), i.addPack({
										payload: n.sys.settings.pack
									}))) return n.sys.settings.status = s.LOADING, i.once(h.COMPLETE, this.payloadComplete, this), i.start(), this;
								this.bootScene(n)
							}
							return this
						},
						stop: function(t, e) {
							var i = this.getScene(t);
							return i && !i.sys.isTransitioning() && i.sys.shutdown(e), this
						},
						switch: function(t, e) {
							var i = this.getScene(t),
								n = this.getScene(e);
							return i && n && i !== n && (this.sleep(t), this.isSleeping(e) ? this.wake(e) : this.start(e)), this
						},
						getAt: function(t) {
							return this.scenes[t]
						},
						getIndex: function(t) {
							var e = this.getScene(t);
							return this.scenes.indexOf(e)
						},
						bringToTop: function(t) {
							var e, i;
							return this.isProcessing ? this._queue.push({
								op: "bringToTop",
								keyA: t,
								keyB: null
							}) : -1 !== (e = this.getIndex(t)) && e < this.scenes.length && (i = this.getScene(t), this.scenes.splice(e, 1), this.scenes.push(i)), this
						},
						sendToBack: function(t) {
							var e, i;
							return this.isProcessing ? this._queue.push({
								op: "sendToBack",
								keyA: t,
								keyB: null
							}) : -1 !== (e = this.getIndex(t)) && 0 < e && (i = this.getScene(t), this.scenes.splice(e, 1), this.scenes.unshift(i)), this
						},
						moveDown: function(t) {
							var e, i, n, s;
							return this.isProcessing ? this._queue.push({
								op: "moveDown",
								keyA: t,
								keyB: null
							}) : 0 < (e = this.getIndex(t)) && (i = e - 1, n = this.getScene(t), s = this.getAt(i), this.scenes[e] = s, this.scenes[i] = n), this
						},
						moveUp: function(t) {
							var e, i, n, s;
							return this.isProcessing ? this._queue.push({
								op: "moveUp",
								keyA: t,
								keyB: null
							}) : (e = this.getIndex(t)) < this.scenes.length - 1 && (i = e + 1, n = this.getScene(t), s = this.getAt(i), this.scenes[e] = s, this.scenes[i] = n), this
						},
						moveAbove: function(t, e) {
							return t === e || (this.isProcessing ? this._queue.push({
								op: "moveAbove",
								keyA: t,
								keyB: e
							}) : (i = this.getIndex(t), n = this.getIndex(e), -1 !== i && -1 !== n && (s = this.getAt(n), this.scenes.splice(n, 1), this.scenes.splice(i + 1, 0, s)))), this;
							var i, n, s
						},
						moveBelow: function(t, e) {
							return t === e || (this.isProcessing ? this._queue.push({
								op: "moveBelow",
								keyA: t,
								keyB: e
							}) : (i = this.getIndex(t), n = this.getIndex(e), -1 !== i && -1 !== n && (s = this.getAt(n), this.scenes.splice(n, 1), 0 === i ? this.scenes.unshift(s) : this.scenes.splice(i, 0, s)))), this;
							var i, n, s
						},
						queueOp: function(t, e, i) {
							return this._queue.push({
								op: t,
								keyA: e,
								keyB: i
							}), this
						},
						swapPosition: function(t, e) {
							return t === e || (this.isProcessing ? this._queue.push({
								op: "swapPosition",
								keyA: t,
								keyB: e
							}) : (i = this.getIndex(t)) !== (n = this.getIndex(e)) && -1 !== i && -1 !== n && (s = this.getAt(i), this.scenes[i] = this.scenes[n], this.scenes[n] = s)), this;
							var i, n, s
						},
						dump: function() {
							for (var t = [], e = ["pending", "init", "start", "loading", "creating", "running", "paused", "sleeping", "shutdown", "destroyed"], i = 0; i < this.scenes.length; i++) {
								var n = this.scenes[i].sys,
									r = !n.settings.visible || n.settings.status !== s.RUNNING && n.settings.status !== s.PAUSED ? "[-] " : "[*] ";
								r += n.settings.key + " (" + e[n.settings.status] + ")", t.push(r)
							}
							console.log(t.join("\n"))
						},
						destroy: function() {
							for (var t = 0; t < this.scenes.length; t++) this.scenes[t].sys.destroy();
							this.update = u, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this.game = null
						}
					});
				t.exports = d
			}, function(t, e, i) {
				var n = i(0),
					s = i(180),
					r = new n({
						initialize: function(t) {
							this.sys = new s(this, t), this.game, this.anims, this.cache, this.registry, this.sound, this.textures, this.events, this.cameras, this.add, this.make, this.scene, this.children, this.lights, this.data, this.input, this.load, this.time, this.tweens, this.physics, this.matter, this.scale, this.plugins
						},
						update: function() {}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = i(125),
					s = i(6),
					r = i(126),
					o = i(882),
					a = {
						create: function(t) {
							return "string" == typeof t ? t = {
								key: t
							} : void 0 === t && (t = {}), {
								status: n.PENDING,
								key: s(t, "key", ""),
								active: s(t, "active", !1),
								visible: s(t, "visible", !0),
								isBooted: !1,
								isTransition: !1,
								transitionFrom: null,
								transitionDuration: 0,
								transitionAllowInput: !0,
								data: {},
								pack: s(t, "pack", !1),
								cameras: s(t, "cameras", null),
								map: s(t, "map", r(o, s(t, "mapAdd", {}))),
								physics: s(t, "physics", {}),
								loader: s(t, "loader", {}),
								plugins: s(t, "plugins", !1),
								input: s(t, "input", {})
							}
						}
					};
				t.exports = a
			}, function(t, e, i) {
				var n = i(26),
					s = i(377),
					r = i(0),
					o = i(31),
					a = i(33),
					h = i(10),
					u = i(121),
					l = i(20),
					c = i(346),
					d = i(6),
					f = i(379),
					p = i(182),
					g = new r({
						Extends: h,
						initialize: function(t) {
							h.call(this), this.game = t, this.name = "TextureManager", this.list = {}, this._tempCanvas = n.create2D(this, 1, 1), this._tempContext = this._tempCanvas.getContext("2d"), this._pending = 0, t.events.once(l.BOOT, this.boot, this)
						},
						boot: function() {
							this._pending = 2, this.on(u.LOAD, this.updatePending, this), this.on(u.ERROR, this.updatePending, this), this.addBase64("__DEFAULT", this.game.config.defaultImage), this.addBase64("__MISSING", this.game.config.missingImage), this.game.events.once(l.DESTROY, this.destroy, this)
						},
						updatePending: function() {
							this._pending--, 0 === this._pending && (this.off(u.LOAD), this.off(u.ERROR), this.emit(u.READY))
						},
						checkKey: function(t) {
							return !this.exists(t) || (console.error("Texture key already in use: " + t), !1)
						},
						remove: function(t) {
							if ("string" == typeof t) {
								if (!this.exists(t)) return console.warn("No texture found matching key: " + t), this;
								t = this.get(t)
							}
							return this.list.hasOwnProperty(t.key) && (t.destroy(), this.emit(u.REMOVE, t.key)), this
						},
						removeKey: function(t) {
							return this.list.hasOwnProperty(t) && delete this.list[t], this
						},
						addBase64: function(t, e) {
							var i, n;
							return this.checkKey(t) && (i = this, (n = new Image).onerror = function() {
								i.emit(u.ERROR, t)
							}, n.onload = function() {
								var e = i.create(t, n);
								f.Image(e, 0), i.emit(u.ADD, t, e), i.emit(u.LOAD, t, e)
							}, n.src = e), this
						},
						getBase64: function(t, e, i, s) {
							void 0 === i && (i = "image/png"), void 0 === s && (s = .92);
							var r, o, a = "",
								h = this.getFrame(t, e);
							return h && (h.source.isRenderTexture || h.source.isGLTexture) ? console.warn("Cannot getBase64 from WebGL Texture") : h && (r = h.canvasData, (o = n.create2D(this, r.width, r.height)).getContext("2d").drawImage(h.source.image, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height), a = o.toDataURL(i, s), n.remove(o)), a
						},
						addImage: function(t, e, i) {
							var n = null;
							return this.checkKey(t) && (n = this.create(t, e), f.Image(n, 0), i && n.setDataSource(i), this.emit(u.ADD, t, n)), n
						},
						addGLTexture: function(t, e, i, n) {
							var s = null;
							return this.checkKey(t) && ((s = this.create(t, e, i, n)).add("__BASE", 0, 0, 0, i, n), this.emit(u.ADD, t, s)), s
						},
						addRenderTexture: function(t, e) {
							var i = null;
							return this.checkKey(t) && ((i = this.create(t, e)).add("__BASE", 0, 0, 0, e.width, e.height), this.emit(u.ADD, t, i)), i
						},
						generate: function(t, e) {
							if (this.checkKey(t)) {
								var i = n.create(this, 1, 1);
								return e.canvas = i, c(e), this.addCanvas(t, i)
							}
							return null
						},
						createCanvas: function(t, e, i) {
							if (void 0 === e && (e = 256), void 0 === i && (i = 256), this.checkKey(t)) {
								var s = n.create(this, e, i, a.CANVAS, !0);
								return this.addCanvas(t, s)
							}
							return null
						},
						addCanvas: function(t, e, i) {
							void 0 === i && (i = !1);
							var n = null;
							return i ? n = new s(this, t, e, e.width, e.height) : this.checkKey(t) && (n = new s(this, t, e, e.width, e.height), this.list[t] = n, this.emit(u.ADD, t, n)), n
						},
						addAtlas: function(t, e, i, n) {
							return Array.isArray(i.textures) || Array.isArray(i.frames) ? this.addAtlasJSONArray(t, e, i, n) : this.addAtlasJSONHash(t, e, i, n)
						},
						addAtlasJSONArray: function(t, e, i, n) {
							var s = null;
							if (this.checkKey(t)) {
								if (s = this.create(t, e), Array.isArray(i))
									for (var r = 1 === i.length, o = 0; o < s.source.length; o++) {
										var a = r ? i[0] : i[o];
										f.JSONArray(s, o, a)
									} else f.JSONArray(s, 0, i);
								n && s.setDataSource(n), this.emit(u.ADD, t, s)
							}
							return s
						},
						addAtlasJSONHash: function(t, e, i, n) {
							var s = null;
							if (this.checkKey(t)) {
								if (s = this.create(t, e), Array.isArray(i))
									for (var r = 0; r < i.length; r++) f.JSONHash(s, r, i[r]);
								else f.JSONHash(s, 0, i);
								n && s.setDataSource(n), this.emit(u.ADD, t, s)
							}
							return s
						},
						addAtlasXML: function(t, e, i, n) {
							var s = null;
							return this.checkKey(t) && (s = this.create(t, e), f.AtlasXML(s, 0, i), n && s.setDataSource(n), this.emit(u.ADD, t, s)), s
						},
						addUnityAtlas: function(t, e, i, n) {
							var s = null;
							return this.checkKey(t) && (s = this.create(t, e), f.UnityYAML(s, 0, i), n && s.setDataSource(n), this.emit(u.ADD, t, s)), s
						},
						addSpriteSheet: function(t, e, i) {
							var n, s, r = null;
							return this.checkKey(t) && (n = (r = this.create(t, e)).source[0].width, s = r.source[0].height, f.SpriteSheet(r, 0, 0, 0, n, s, i), this.emit(u.ADD, t, r)), r
						},
						addSpriteSheetFromAtlas: function(t, e) {
							if (!this.checkKey(t)) return null;
							var i = d(e, "atlas", null),
								n = d(e, "frame", null);
							if (i && n) {
								var s = this.get(i).get(n);
								if (s) {
									var r = this.create(t, s.source.image);
									return s.trimmed ? f.SpriteSheetFromAtlas(r, s, e) : f.SpriteSheet(r, 0, s.cutX, s.cutY, s.cutWidth, s.cutHeight, e), this.emit(u.ADD, t, r), r
								}
							}
						},
						create: function(t, e, i, n) {
							var s = null;
							return this.checkKey(t) && (s = new p(this, t, e, i, n), this.list[t] = s), s
						},
						exists: function(t) {
							return this.list.hasOwnProperty(t)
						},
						get: function(t) {
							return void 0 === t && (t = "__DEFAULT"), this.list[t] ? this.list[t] : t instanceof p ? t : this.list.__MISSING
						},
						cloneFrame: function(t, e) {
							if (this.list[t]) return this.list[t].get(e).clone()
						},
						getFrame: function(t, e) {
							if (this.list[t]) return this.list[t].get(e)
						},
						getTextureKeys: function() {
							var t = [];
							for (var e in this.list) "__DEFAULT" !== e && "__MISSING" !== e && t.push(e);
							return t
						},
						getPixel: function(t, e, i, n) {
							var s = this.getFrame(i, n);
							if (s) {
								t -= s.x, e -= s.y;
								var r = s.data.cut;
								if (t += r.x, e += r.y, t >= r.x && t < r.r && e >= r.y && e < r.b) {
									var a = this._tempContext;
									a.clearRect(0, 0, 1, 1), a.drawImage(s.source.image, t, e, 1, 1, 0, 0, 1, 1);
									var h = a.getImageData(0, 0, 1, 1);
									return new o(h.data[0], h.data[1], h.data[2], h.data[3])
								}
							}
							return null
						},
						getPixelAlpha: function(t, e, i, n) {
							var s = this.getFrame(i, n);
							if (s) {
								t -= s.x, e -= s.y;
								var r = s.data.cut;
								if (t += r.x, e += r.y, t >= r.x && t < r.r && e >= r.y && e < r.b) {
									var o = this._tempContext;
									return o.clearRect(0, 0, 1, 1), o.drawImage(s.source.image, t, e, 1, 1, 0, 0, 1, 1), o.getImageData(0, 0, 1, 1).data[3]
								}
							}
							return null
						},
						setTexture: function(t, e, i) {
							return this.list[e] && (t.texture = this.list[e], t.frame = t.texture.get(i)), t
						},
						renameTexture: function(t, e) {
							var i = this.get(t);
							return !(!i || t === e || (i.key = e, this.list[e] = i, delete this.list[t], 0))
						},
						each: function(t, e) {
							for (var i = [null], n = 1; n < arguments.length; n++) i.push(arguments[n]);
							for (var s in this.list) i[0] = this.list[s], t.apply(e, i)
						},
						destroy: function() {
							for (var t in this.list) this.list[t].destroy();
							this.list = {}, this.game = null, n.remove(this._tempCanvas)
						}
					});
				t.exports = g
			}, function(t, e, i) {
				var n = i(0),
					s = i(19),
					r = i(31),
					o = i(33),
					a = i(120),
					h = i(182),
					u = new n({
						Extends: h,
						initialize: function(t, e, i, n, s) {
							h.call(this, t, e, i, n, s), this.add("__BASE", 0, 0, 0, n, s), this._source = this.frames.__BASE.source, this.canvas = this._source.image, this.context = this.canvas.getContext("2d"), this.width = n, this.height = s, this.imageData = this.context.getImageData(0, 0, n, s), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.buffer, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data)
						},
						update: function() {
							return this.imageData = this.context.getImageData(0, 0, this.width, this.height), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this.manager.game.config.renderType === o.WEBGL && this.refresh(), this
						},
						draw: function(t, e, i) {
							return this.context.drawImage(i, t, e), this.update()
						},
						drawFrame: function(t, e, i, n) {
							void 0 === i && (i = 0), void 0 === n && (n = 0);
							var s = this.manager.getFrame(t, e);
							if (s) {
								var r = s.canvasData,
									o = s.cutWidth,
									a = s.cutHeight,
									h = s.source.resolution;
								return this.context.drawImage(s.source.image, r.x, r.y, o, a, i, n, o / h, a / h), this.update()
							}
							return this
						},
						setPixel: function(t, e, i, n, s, r) {
							var o;
							return void 0 === r && (r = 255), t = Math.abs(Math.floor(t)), e = Math.abs(Math.floor(e)), -1 < this.getIndex(t, e) && ((o = this.context.getImageData(t, e, 1, 1)).data[0] = i, o.data[1] = n, o.data[2] = s, o.data[3] = r, this.context.putImageData(o, t, e)), this
						},
						putData: function(t, e, i, n, s, r, o) {
							return void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = t.width), void 0 === o && (o = t.height), this.context.putImageData(t, e, i, n, s, r, o), this
						},
						getData: function(t, e, i, n) {
							return t = s(Math.floor(t), 0, this.width - 1), e = s(Math.floor(e), 0, this.height - 1), i = s(i, 1, this.width - t), n = s(n, 1, this.height - e), this.context.getImageData(t, e, i, n)
						},
						getPixel: function(t, e, i) {
							i = i || new r;
							var n, s, o, a, h, u = this.getIndex(t, e);
							return -1 < u && (s = (n = this.data)[u + 0], o = n[u + 1], a = n[u + 2], h = n[u + 3], i.setTo(s, o, a, h)), i
						},
						getPixels: function(t, e, i, n) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === n && (n = i), t = Math.abs(Math.round(t)), e = Math.abs(Math.round(e));
							for (var o = s(t, 0, this.width), a = s(t + i, 0, this.width), h = s(e, 0, this.height), u = s(e + n, 0, this.height), l = new r, c = [], d = h; d < u; d++) {
								for (var f = [], p = o; p < a; p++) l = this.getPixel(p, d, l), f.push({
									x: p,
									y: d,
									color: l.color,
									alpha: l.alphaGL
								});
								c.push(f)
							}
							return c
						},
						getIndex: function(t, e) {
							return t = Math.abs(Math.round(t)), e = Math.abs(Math.round(e)), t < this.width && e < this.height ? 4 * (t + e * this.width) : -1
						},
						refresh: function() {
							return this._source.update(), this
						},
						getCanvas: function() {
							return this.canvas
						},
						getContext: function() {
							return this.context
						},
						clear: function(t, e, i, n) {
							return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === n && (n = this.height), this.context.clearRect(t, e, i, n), this.update()
						},
						setSize: function(t, e) {
							return void 0 === e && (e = t), t === this.width && e === this.height || (this.canvas.width = t, this.canvas.height = e, this._source.width = t, this._source.height = e, this._source.isPowerOf2 = a(t, e), this.frames.__BASE.setSize(t, e, 0, 0), this.width = t, this.height = e, this.refresh()), this
						},
						destroy: function() {
							h.prototype.destroy.call(this), this._source = null, this.canvas = null, this.context = null, this.imageData = null, this.data = null, this.pixels = null, this.buffer = null
						}
					});
				t.exports = u
			}, function(t, e, i) {
				var n = i(26),
					s = i(0),
					r = i(120),
					o = i(234),
					a = new s({
						initialize: function(t, e, i, n, s) {
							void 0 === s && (s = !1);
							var a = t.manager.game;
							this.renderer = a.renderer, this.texture = t, this.source = e, this.image = e, this.compressionAlgorithm = null, this.resolution = 1, this.width = i || e.naturalWidth || e.videoWidth || e.width || 0, this.height = n || e.naturalHeight || e.videoHeight || e.height || 0, this.scaleMode = o.DEFAULT, this.isCanvas = e instanceof HTMLCanvasElement, this.isVideo = window.hasOwnProperty("HTMLVideoElement") && e instanceof HTMLVideoElement, this.isRenderTexture = "RenderTexture" === e.type, this.isGLTexture = window.hasOwnProperty("WebGLTexture") && e instanceof WebGLTexture, this.isPowerOf2 = r(this.width, this.height), this.glTexture = null, this.flipY = s, this.init(a)
						},
						init: function(t) {
							this.renderer && (this.renderer.gl ? this.isCanvas ? this.glTexture = this.renderer.createCanvasTexture(this.image, !1, this.flipY) : this.isVideo ? this.glTexture = this.renderer.createVideoTexture(this.image, !1, this.flipY) : this.isRenderTexture ? (this.image = this.source.canvas, this.glTexture = this.renderer.createTextureFromSource(null, this.width, this.height, this.scaleMode)) : this.isGLTexture ? this.glTexture = this.source : this.glTexture = this.renderer.createTextureFromSource(this.image, this.width, this.height, this.scaleMode) : this.isRenderTexture && (this.image = this.source.canvas)), t.config.antialias || this.setFilter(1)
						},
						setFilter: function(t) {
							this.renderer.gl && this.renderer.setTextureFilter(this.glTexture, t), this.scaleMode = t
						},
						setFlipY: function(t) {
							return void 0 === t && (t = !0), this.flipY = t, this
						},
						update: function() {
							var t = this.renderer.gl;
							t && this.isCanvas ? this.glTexture = this.renderer.updateCanvasTexture(this.image, this.glTexture, this.flipY) : t && this.isVideo && (this.glTexture = this.renderer.updateVideoTexture(this.image, this.glTexture, this.flipY))
						},
						destroy: function() {
							this.glTexture && this.renderer.deleteTexture(this.glTexture), this.isCanvas && n.remove(this.image), this.renderer = null, this.texture = null, this.source = null, this.image = null, this.glTexture = null
						}
					});
				t.exports = a
			}, function(t, e, i) {
				t.exports = {
					AtlasXML: i(883),
					Canvas: i(884),
					Image: i(885),
					JSONArray: i(886),
					JSONHash: i(887),
					SpriteSheet: i(888),
					SpriteSheetFromAtlas: i(889),
					UnityYAML: i(890)
				}
			}, function(t, e, i) {
				var n = i(381),
					s = i(385),
					r = i(387),
					o = {
						create: function(t) {
							var e = t.config.audio,
								i = t.device.audio;
							return new(e && e.noAudio || !i.webAudio && !i.audioData ? s : !i.webAudio || e && e.disableWebAudio ? n : r)(t)
						}
					};
				t.exports = o
			}, function(t, e, i) {
				var n = i(127),
					s = i(0),
					r = i(59),
					o = i(384),
					a = new s({
						Extends: n,
						initialize: function(t) {
							this.override = !0, this.audioPlayDelay = .1, this.loopEndOffset = .05, this.onBlurPausedSounds = [], this.locked = "ontouchstart" in window, this.lockedActionsQueue = this.locked ? [] : null, this._mute = !1, this._volume = 1, n.call(this, t)
						},
						add: function(t, e) {
							var i = new o(this, t, e);
							return this.sounds.push(i), i
						},
						unlock: function() {
							this.locked = !1;
							var t, e, i, n = this;
							this.game.cache.audio.entries.each(function(t, e) {
								for (var i = 0; i < e.length; i++)
									if ("true" === e[i].dataset.locked) return !(n.locked = !0);
								return !0
							}), this.locked && (t = !1, e = function() {
								t = !0
							}, i = function() {
								var s, r;
								t ? t = !1 : (document.body.removeEventListener("touchmove", e), document.body.removeEventListener("touchend", i), s = [], n.game.cache.audio.entries.each(function(t, e) {
									for (var i = 0; i < e.length; i++) {
										var n = e[i];
										"true" === n.dataset.locked && s.push(n)
									}
									return !0
								}), 0 !== s.length && ((r = s[s.length - 1]).oncanplaythrough = function() {
									r.oncanplaythrough = null, s.forEach(function(t) {
										t.dataset.locked = "false"
									}), n.unlocked = !0
								}, s.forEach(function(t) {
									t.load()
								})))
							}, this.once(r.UNLOCKED, function() {
								for (this.forEachActiveSound(function(t) {
										null === t.currentMarker && 0 === t.duration && (t.duration = t.tags[0].duration), t.totalDuration = t.tags[0].duration
									}); this.lockedActionsQueue.length;) {
									var t = this.lockedActionsQueue.shift();
									t.sound[t.prop].apply ? t.sound[t.prop].apply(t.sound, t.value || []) : t.sound[t.prop] = t.value
								}
							}, this), document.body.addEventListener("touchmove", e, !1), document.body.addEventListener("touchend", i, !1))
						},
						onBlur: function() {
							this.forEachActiveSound(function(t) {
								t.isPlaying && (this.onBlurPausedSounds.push(t), t.onBlur())
							})
						},
						onFocus: function() {
							this.onBlurPausedSounds.forEach(function(t) {
								t.onFocus()
							}), this.onBlurPausedSounds.length = 0
						},
						destroy: function() {
							n.prototype.destroy.call(this), this.onBlurPausedSounds.length = 0, this.onBlurPausedSounds = null
						},
						isLocked: function(t, e, i) {
							return "true" === t.tags[0].dataset.locked && (this.lockedActionsQueue.push({
								sound: t,
								prop: e,
								value: i
							}), !0)
						},
						setMute: function(t) {
							return this.mute = t, this
						},
						mute: {
							get: function() {
								return this._mute
							},
							set: function(t) {
								this._mute = t, this.forEachActiveSound(function(t) {
									t.updateMute()
								}), this.emit(r.GLOBAL_MUTE, this, t)
							}
						},
						setVolume: function(t) {
							return this.volume = t, this
						},
						volume: {
							get: function() {
								return this._volume
							},
							set: function(t) {
								this._volume = t, this.forEachActiveSound(function(t) {
									t.updateVolume()
								}), this.emit(r.GLOBAL_VOLUME, this, t)
							}
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(68);
				t.exports = function(t, e, i, s, r) {
					void 0 === s && (s = 0), void 0 === r && (r = t.length);
					var o = [];
					if (n(t, s, r))
						for (var a = s; a < r; a++) {
							var h = t[a];
							(!e || e && void 0 === i && h.hasOwnProperty(e) || e && void 0 !== i && h[e] === i) && o.push(h)
						}
					return o
				}
			}, function(t, e, i) {
				var n = i(68);
				t.exports = function(t, e, i, s, r) {
					if (void 0 === s && (s = 0), void 0 === r && (r = t.length), n(t, s, r))
						for (var o = s; o < r; o++) {
							var a = t[o];
							if (!e || e && void 0 === i && a.hasOwnProperty(e) || e && void 0 !== i && a[e] === i) return a
						}
					return null
				}
			}, function(t, e, i) {
				var n = i(128),
					s = i(0),
					r = i(59),
					o = i(19),
					a = new s({
						Extends: n,
						initialize: function(t, e, i) {
							if (void 0 === i && (i = {}), this.tags = t.game.cache.audio.get(e), !this.tags) throw new Error('There is no audio asset with key "' + e + '" in the audio cache');
							this.audio = null, this.startTime = 0, this.previousTime = 0, this.duration = this.tags[0].duration, this.totalDuration = this.tags[0].duration, n.call(this, t, e, i)
						},
						play: function(t, e) {
							return !(this.manager.isLocked(this, "play", [t, e]) || !n.prototype.play.call(this, t, e) || !this.pickAndPlayAudioTag() || (this.emit(r.PLAY, this), 0))
						},
						pause: function() {
							return !(this.manager.isLocked(this, "pause") || 0 < this.startTime || !n.prototype.pause.call(this) || (this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.stopAndReleaseAudioTag(), this.emit(r.PAUSE, this), 0))
						},
						resume: function() {
							return !(this.manager.isLocked(this, "resume") || 0 < this.startTime || !n.prototype.resume.call(this) || !this.pickAndPlayAudioTag() || (this.emit(r.RESUME, this), 0))
						},
						stop: function() {
							return !this.manager.isLocked(this, "stop") && !!n.prototype.stop.call(this) && (this.stopAndReleaseAudioTag(), this.emit(r.STOP, this), !0)
						},
						pickAndPlayAudioTag: function() {
							if (!this.pickAudioTag()) return this.reset(), !1;
							var t = this.currentConfig.seek,
								e = this.currentConfig.delay,
								i = (this.currentMarker ? this.currentMarker.start : 0) + t;
							return this.previousTime = i, this.audio.currentTime = i, this.applyConfig(), 0 === e ? (this.startTime = 0, this.audio.paused && this.playCatchPromise()) : (this.startTime = window.performance.now() + 1e3 * e, this.audio.paused || this.audio.pause()), this.resetConfig(), !0
						},
						pickAudioTag: function() {
							if (this.audio) return !0;
							for (var t = 0; t < this.tags.length; t++) {
								var e = this.tags[t];
								if ("false" === e.dataset.used) return e.dataset.used = "true", this.audio = e, !0
							}
							if (!this.manager.override) return !1;
							var i = [];
							this.manager.forEachActiveSound(function(t) {
								t.key === this.key && t.audio && i.push(t)
							}, this), i.sort(function(t, e) {
								return t.loop === e.loop ? e.seek / e.duration - t.seek / t.duration : t.loop ? 1 : -1
							});
							var n = i[0];
							return this.audio = n.audio, n.reset(), n.audio = null, n.startTime = 0, !(n.previousTime = 0)
						},
						playCatchPromise: function() {
							var t = this.audio.play();
							t && t.catch(function(t) {
								console.warn(t)
							})
						},
						stopAndReleaseAudioTag: function() {
							this.startTime = 0, this.previousTime = 0, this.audio && (this.audio.pause(), this.audio.dataset.used = "false", this.audio = null)
						},
						reset: function() {
							n.prototype.stop.call(this)
						},
						onBlur: function() {
							this.isPlaying = !1, this.isPaused = !0, this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3), this.stopAndReleaseAudioTag()
						},
						onFocus: function() {
							this.isPlaying = !0, this.isPaused = !1, this.pickAndPlayAudioTag()
						},
						update: function(t, e) {
							if (this.isPlaying)
								if (0 < this.startTime) this.startTime < t - this.manager.audioPlayDelay && (this.audio.currentTime += Math.max(0, t - this.startTime) / 1e3, this.startTime = 0, this.previousTime = this.audio.currentTime, this.playCatchPromise());
								else {
									var i = this.currentMarker ? this.currentMarker.start : 0,
										n = i + this.duration,
										s = this.audio.currentTime;
									if (this.currentConfig.loop) s >= n - this.manager.loopEndOffset ? (this.audio.currentTime = i + Math.max(0, s - n), s = this.audio.currentTime) : s < i && (this.audio.currentTime += i, s = this.audio.currentTime), s < this.previousTime && this.emit(r.LOOPED, this);
									else if (n <= s) return this.reset(), this.stopAndReleaseAudioTag(), void this.emit(r.COMPLETE, this);
									this.previousTime = s
								}
						},
						destroy: function() {
							n.prototype.destroy.call(this), this.tags = null, this.audio && this.stopAndReleaseAudioTag()
						},
						updateMute: function() {
							this.audio && (this.audio.muted = this.currentConfig.mute || this.manager.mute)
						},
						updateVolume: function() {
							this.audio && (this.audio.volume = o(this.currentConfig.volume * this.manager.volume, 0, 1))
						},
						calculateRate: function() {
							n.prototype.calculateRate.call(this), this.audio && (this.audio.playbackRate = this.totalRate)
						},
						mute: {
							get: function() {
								return this.currentConfig.mute
							},
							set: function(t) {
								this.currentConfig.mute = t, this.manager.isLocked(this, "mute", t) || (this.updateMute(), this.emit(r.MUTE, this, t))
							}
						},
						setMute: function(t) {
							return this.mute = t, this
						},
						volume: {
							get: function() {
								return this.currentConfig.volume
							},
							set: function(t) {
								this.currentConfig.volume = t, this.manager.isLocked(this, "volume", t) || (this.updateVolume(), this.emit(r.VOLUME, this, t))
							}
						},
						setVolume: function(t) {
							return this.volume = t, this
						},
						rate: {
							get: function() {
								return this.currentConfig.rate
							},
							set: function(t) {
								this.currentConfig.rate = t, this.manager.isLocked(this, r.RATE, t) || (this.calculateRate(), this.emit(r.RATE, this, t))
							}
						},
						setRate: function(t) {
							return this.rate = t, this
						},
						detune: {
							get: function() {
								return this.currentConfig.detune
							},
							set: function(t) {
								this.currentConfig.detune = t, this.manager.isLocked(this, r.DETUNE, t) || (this.calculateRate(), this.emit(r.DETUNE, this, t))
							}
						},
						setDetune: function(t) {
							return this.detune = t, this
						},
						seek: {
							get: function() {
								return this.isPlaying ? this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0) : this.isPaused ? this.currentConfig.seek : 0
							},
							set: function(t) {
								this.manager.isLocked(this, "seek", t) || 0 < this.startTime || (this.isPlaying || this.isPaused) && (t = Math.min(Math.max(0, t), this.duration), this.isPlaying ? (this.previousTime = t, this.audio.currentTime = t) : this.isPaused && (this.currentConfig.seek = t), this.emit(r.SEEK, this, t))
							}
						},
						setSeek: function(t) {
							return this.seek = t, this
						},
						loop: {
							get: function() {
								return this.currentConfig.loop
							},
							set: function(t) {
								this.currentConfig.loop = t, this.manager.isLocked(this, "loop", t) || (this.audio && (this.audio.loop = t), this.emit(r.LOOP, this, t))
							}
						},
						setLoop: function(t) {
							return this.loop = t, this
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(127),
					s = i(0),
					r = i(10),
					o = i(386),
					a = i(1),
					h = new s({
						Extends: r,
						initialize: function(t) {
							r.call(this), this.game = t, this.sounds = [], this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.pauseOnBlur = !0, this.locked = !1
						},
						add: function(t, e) {
							var i = new o(this, t, e);
							return this.sounds.push(i), i
						},
						addAudioSprite: function(t, e) {
							var i = this.add(t, e);
							return i.spritemap = {}, i
						},
						play: function(t, e) {
							return !1
						},
						playAudioSprite: function(t, e, i) {
							return !1
						},
						remove: function(t) {
							return n.prototype.remove.call(this, t)
						},
						removeByKey: function(t) {
							return n.prototype.removeByKey.call(this, t)
						},
						pauseAll: a,
						resumeAll: a,
						stopAll: a,
						update: a,
						setRate: a,
						setDetune: a,
						setMute: a,
						setVolume: a,
						forEachActiveSound: function(t, e) {
							n.prototype.forEachActiveSound.call(this, t, e)
						},
						destroy: function() {
							n.prototype.destroy.call(this)
						}
					});
				t.exports = h
			}, function(t, e, i) {
				function n() {
					return !1
				}

				function s() {
					return this
				}
				var r = i(128),
					o = i(0),
					a = i(10),
					h = i(18),
					u = new o({
						Extends: a,
						initialize: function(t, e, i) {
							void 0 === i && (i = {}), a.call(this), this.manager = t, this.key = e, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = 0, this.totalDuration = 0, this.config = h({
								mute: !1,
								volume: 1,
								rate: 1,
								detune: 0,
								seek: 0,
								loop: !1,
								delay: 0
							}, i), this.currentConfig = this.config, this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.seek = 0, this.loop = !1, this.markers = {}, this.currentMarker = null, this.pendingRemove = !1
						},
						addMarker: n,
						updateMarker: n,
						removeMarker: function() {
							return null
						},
						play: n,
						pause: n,
						resume: n,
						stop: n,
						destroy: function() {
							r.prototype.destroy.call(this)
						},
						setMute: s,
						setVolume: s,
						setRate: s,
						setDetune: s,
						setSeek: s,
						setLoop: s
					});
				t.exports = u
			}, function(t, e, i) {
				var n = i(388),
					s = i(127),
					r = i(0),
					o = i(59),
					a = i(389),
					h = new r({
						Extends: s,
						initialize: function(t) {
							this.context = this.createAudioContext(t), this.masterMuteNode = this.context.createGain(), this.masterVolumeNode = this.context.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(this.context.destination), this.destination = this.masterMuteNode, this.locked = "suspended" === this.context.state && ("ontouchstart" in window || "onclick" in window), s.call(this, t), this.locked && this.unlock()
						},
						createAudioContext: function(t) {
							var e = t.config.audio;
							return e && e.context ? (e.context.resume(), e.context) : new AudioContext
						},
						setAudioContext: function(t) {
							return this.context && this.context.close(), this.masterMuteNode && this.masterMuteNode.disconnect(), this.masterVolumeNode && this.masterVolumeNode.disconnect(), this.context = t, this.masterMuteNode = t.createGain(), this.masterVolumeNode = t.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(t.destination), this.destination = this.masterMuteNode, this
						},
						add: function(t, e) {
							var i = new a(this, t, e);
							return this.sounds.push(i), i
						},
						decodeAudio: function(t, e) {
							for (var i = Array.isArray(t) ? t : [{
									key: t,
									data: e
								}], s = this.game.cache.audio, r = i.length, a = 0; a < i.length; a++) {
								var h = i[a],
									u = h.key,
									l = h.data;
								"string" == typeof l && (l = n(l));
								var c = function(t, e) {
										s.add(t, e), this.emit(o.DECODED, t), 0 == --r && this.emit(o.DECODED_ALL)
									}.bind(this, u),
									d = function(t, e) {
										console.error("Error decoding audio: " + t + " - ", e ? e.message : ""), 0 == --r && this.emit(o.DECODED_ALL)
									}.bind(this, u);
								this.context.decodeAudioData(l, c, d)
							}
						},
						unlock: function() {
							function t() {
								e.context && e.context.resume().then(function() {
									i.removeEventListener("touchstart", t), i.removeEventListener("touchend", t), i.removeEventListener("click", t), i.removeEventListener("keydown", t), e.unlocked = !0
								}, function() {
									i.removeEventListener("touchstart", t), i.removeEventListener("touchend", t), i.removeEventListener("click", t), i.removeEventListener("keydown", t)
								})
							}
							var e = this,
								i = document.body;
							i && (i.addEventListener("touchstart", t, !1), i.addEventListener("touchend", t, !1), i.addEventListener("click", t, !1), i.addEventListener("keydown", t, !1))
						},
						onBlur: function() {
							this.locked || this.context.suspend()
						},
						onFocus: function() {
							this.locked || this.context.resume()
						},
						destroy: function() {
							var t;
							this.destination = null, this.masterVolumeNode.disconnect(), this.masterVolumeNode = null, this.masterMuteNode.disconnect(), this.masterMuteNode = null, this.game.config.audio && this.game.config.audio.context ? this.context.suspend() : (t = this).context.close().then(function() {
								t.context = null
							}), s.prototype.destroy.call(this)
						},
						setMute: function(t) {
							return this.mute = t, this
						},
						mute: {
							get: function() {
								return 0 === this.masterMuteNode.gain.value
							},
							set: function(t) {
								this.masterMuteNode.gain.setValueAtTime(t ? 0 : 1, 0), this.emit(o.GLOBAL_MUTE, this, t)
							}
						},
						setVolume: function(t) {
							return this.volume = t, this
						},
						volume: {
							get: function() {
								return this.masterVolumeNode.gain.value
							},
							set: function(t) {
								this.masterVolumeNode.gain.setValueAtTime(t, 0), this.emit(o.GLOBAL_VOLUME, this, t)
							}
						}
					});
				t.exports = h
			}, function(t, e) {
				for (var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = new Uint8Array(256), s = 0; s < i.length; s++) n[i.charCodeAt(s)] = s;
				t.exports = function(t) {
					var e, i, s, r, o = (t = t.substr(t.indexOf(",") + 1)).length,
						a = .75 * o,
						h = 0;
					"=" === t[o - 1] && (a--, "=" === t[o - 2] && a--);
					for (var u = new ArrayBuffer(a), l = new Uint8Array(u), c = 0; c < o; c += 4) e = n[t.charCodeAt(c)], i = n[t.charCodeAt(c + 1)], s = n[t.charCodeAt(c + 2)], r = n[t.charCodeAt(c + 3)], l[h++] = e << 2 | i >> 4, l[h++] = (15 & i) << 4 | s >> 2, l[h++] = (3 & s) << 6 | 63 & r;
					return u
				}
			}, function(t, e, i) {
				var n = i(128),
					s = i(0),
					r = i(59),
					o = new s({
						Extends: n,
						initialize: function(t, e, i) {
							if (void 0 === i && (i = {}), this.audioBuffer = t.game.cache.audio.get(e), !this.audioBuffer) throw new Error('There is no audio asset with key "' + e + '" in the audio cache');
							this.source = null, this.loopSource = null, this.muteNode = t.context.createGain(), this.volumeNode = t.context.createGain(), this.playTime = 0, this.startTime = 0, this.loopTime = 0, this.rateUpdates = [], this.hasEnded = !1, this.hasLooped = !1, this.muteNode.connect(this.volumeNode), this.volumeNode.connect(t.destination), this.duration = this.audioBuffer.duration, this.totalDuration = this.audioBuffer.duration, n.call(this, t, e, i)
						},
						play: function(t, e) {
							return !!n.prototype.play.call(this, t, e) && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource(), this.emit(r.PLAY, this), !0)
						},
						pause: function() {
							return !(this.manager.context.currentTime < this.startTime || !n.prototype.pause.call(this) || (this.currentConfig.seek = this.getCurrentTime(), this.stopAndRemoveBufferSource(), this.emit(r.PAUSE, this), 0))
						},
						resume: function() {
							return !(this.manager.context.currentTime < this.startTime || !n.prototype.resume.call(this) || (this.createAndStartBufferSource(), this.emit(r.RESUME, this), 0))
						},
						stop: function() {
							return !!n.prototype.stop.call(this) && (this.stopAndRemoveBufferSource(), this.emit(r.STOP, this), !0)
						},
						createAndStartBufferSource: function() {
							var t = this.currentConfig.seek,
								e = this.currentConfig.delay,
								i = this.manager.context.currentTime + e,
								n = (this.currentMarker ? this.currentMarker.start : 0) + t,
								s = this.duration - t;
							this.playTime = i - t, this.startTime = i, this.source = this.createBufferSource(), this.applyConfig(), this.source.start(Math.max(0, i), Math.max(0, n), Math.max(0, s)), this.resetConfig()
						},
						createAndStartLoopBufferSource: function() {
							var t = this.getLoopTime(),
								e = this.currentMarker ? this.currentMarker.start : 0,
								i = this.duration;
							this.loopTime = t, this.loopSource = this.createBufferSource(), this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0), this.loopSource.start(Math.max(0, t), Math.max(0, e), Math.max(0, i))
						},
						createBufferSource: function() {
							var t = this,
								e = this.manager.context.createBufferSource();
							return e.buffer = this.audioBuffer, e.connect(this.muteNode), e.onended = function(e) {
								e.target === t.source && (t.currentConfig.loop ? t.hasLooped = !0 : t.hasEnded = !0)
							}, e
						},
						stopAndRemoveBufferSource: function() {
							this.source && (this.source.stop(), this.source.disconnect(), this.source = null), this.playTime = 0, this.startTime = 0, this.stopAndRemoveLoopBufferSource()
						},
						stopAndRemoveLoopBufferSource: function() {
							this.loopSource && (this.loopSource.stop(), this.loopSource.disconnect(), this.loopSource = null), this.loopTime = 0
						},
						applyConfig: function() {
							this.rateUpdates.length = 0, this.rateUpdates.push({
								time: 0,
								rate: 1
							}), n.prototype.applyConfig.call(this)
						},
						update: function(t, e) {
							this.hasEnded ? (this.hasEnded = !1, n.prototype.stop.call(this), this.stopAndRemoveBufferSource(), this.emit(r.COMPLETE, this)) : this.hasLooped && (this.hasLooped = !1, this.source = this.loopSource, this.loopSource = null, this.playTime = this.startTime = this.loopTime, this.rateUpdates.length = 0, this.rateUpdates.push({
								time: 0,
								rate: this.totalRate
							}), this.createAndStartLoopBufferSource(), this.emit(r.LOOPED, this))
						},
						destroy: function() {
							n.prototype.destroy.call(this), this.audioBuffer = null, this.stopAndRemoveBufferSource(), this.muteNode.disconnect(), this.muteNode = null, this.volumeNode.disconnect(), this.volumeNode = null, this.rateUpdates.length = 0, this.rateUpdates = null
						},
						calculateRate: function() {
							n.prototype.calculateRate.call(this);
							var t = this.manager.context.currentTime;
							this.source && "number" == typeof this.totalRate && this.source.playbackRate.setValueAtTime(this.totalRate, t), this.isPlaying && (this.rateUpdates.push({
								time: Math.max(this.startTime, t) - this.playTime,
								rate: this.totalRate
							}), this.loopSource && (this.stopAndRemoveLoopBufferSource(), this.createAndStartLoopBufferSource()))
						},
						getCurrentTime: function() {
							for (var t = 0, e = 0; e < this.rateUpdates.length; e++) t += ((e < this.rateUpdates.length - 1 ? this.rateUpdates[e + 1].time : this.manager.context.currentTime - this.playTime) - this.rateUpdates[e].time) * this.rateUpdates[e].rate;
							return t
						},
						getLoopTime: function() {
							for (var t = 0, e = 0; e < this.rateUpdates.length - 1; e++) t += (this.rateUpdates[e + 1].time - this.rateUpdates[e].time) * this.rateUpdates[e].rate;
							var i = this.rateUpdates[this.rateUpdates.length - 1];
							return this.playTime + i.time + (this.duration - t) / i.rate
						},
						rate: {
							get: function() {
								return this.currentConfig.rate
							},
							set: function(t) {
								this.currentConfig.rate = t, this.calculateRate(), this.emit(r.RATE, this, t)
							}
						},
						setRate: function(t) {
							return this.rate = t, this
						},
						detune: {
							get: function() {
								return this.currentConfig.detune
							},
							set: function(t) {
								this.currentConfig.detune = t, this.calculateRate(), this.emit(r.DETUNE, this, t)
							}
						},
						setDetune: function(t) {
							return this.detune = t, this
						},
						mute: {
							get: function() {
								return 0 === this.muteNode.gain.value
							},
							set: function(t) {
								this.currentConfig.mute = t, this.muteNode.gain.setValueAtTime(t ? 0 : 1, 0), this.emit(r.MUTE, this, t)
							}
						},
						setMute: function(t) {
							return this.mute = t, this
						},
						volume: {
							get: function() {
								return this.volumeNode.gain.value
							},
							set: function(t) {
								this.currentConfig.volume = t, this.volumeNode.gain.setValueAtTime(t, 0), this.emit(r.VOLUME, this, t)
							}
						},
						setVolume: function(t) {
							return this.volume = t, this
						},
						seek: {
							get: function() {
								return this.isPlaying ? this.manager.context.currentTime < this.startTime ? this.startTime - this.playTime : this.getCurrentTime() : this.isPaused ? this.currentConfig.seek : 0
							},
							set: function(t) {
								this.manager.context.currentTime < this.startTime || (this.isPlaying || this.isPaused) && (t = Math.min(Math.max(0, t), this.duration), this.currentConfig.seek = t, this.isPlaying && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource()), this.emit(r.SEEK, this, t))
							}
						},
						setSeek: function(t) {
							return this.seek = t, this
						},
						loop: {
							get: function() {
								return this.currentConfig.loop
							},
							set: function(t) {
								this.currentConfig.loop = t, this.isPlaying && (this.stopAndRemoveLoopBufferSource(), t && this.createAndStartLoopBufferSource()), this.emit(r.LOOP, this, t)
							}
						},
						setLoop: function(t) {
							return this.loop = t, this
						}
					});
				t.exports = o
			}, function(t, e) {
				t.exports = function(t) {
					for (var e = t.length, i = t[0].length, n = new Array(i), s = 0; s < i; s++) {
						n[s] = new Array(e);
						for (var r = e - 1; - 1 < r; r--) n[s][r] = t[r][s]
					}
					return n
				}
			}, function(t, e) {
				function i(t, e, i) {
					var n = t[e];
					t[e] = t[i], t[i] = n
				}

				function n(t, e) {
					return t < e ? -1 : e < t ? 1 : 0
				}
				var s = function(t, e, r, o, a) {
					for (void 0 === r && (r = 0), void 0 === o && (o = t.length - 1), void 0 === a && (a = n); r < o;) {
						var h, u, l, c, d, f, p;
						600 < o - r && (h = o - r + 1, u = e - r + 1, l = Math.log(h), c = .5 * Math.exp(2 * l / 3), d = .5 * Math.sqrt(l * c * (h - c) / h) * (u - h / 2 < 0 ? -1 : 1), f = Math.max(r, Math.floor(e - u * c / h + d)), p = Math.min(o, Math.floor(e + (h - u) * c / h + d)), s(t, e, f, p, a));
						var g = t[e],
							v = r,
							m = o;
						for (i(t, r, e), 0 < a(t[o], g) && i(t, r, o); v < m;) {
							for (i(t, v, m), v++, m--; a(t[v], g) < 0;) v++;
							for (; 0 < a(t[m], g);) m--
						}
						0 === a(t[r], g) ? i(t, r, m) : i(t, ++m, o), m <= e && (r = m + 1), e <= m && (o = m - 1)
					}
				};
				t.exports = s
			}, function(t, e, i) {
				var n = i(6),
					s = i(114);
				t.exports = function(t, e, i) {
					var r, o = n(i, "max", 0),
						a = n(i, "qty", 1),
						h = n(i, "random", !1),
						u = n(i, "randomB", !1),
						l = n(i, "repeat", 0),
						c = n(i, "yoyo", !1),
						d = [];
					u && s(e), -1 === l && (l = 0 === o ? 0 : (r = t.length * e.length * a, c && (r *= 2), Math.ceil(o / r)));
					for (var f = 0; f <= l; f++) {
						var p = function(t, e, i) {
							for (var n = [], s = 0; s < t.length; s++)
								for (var r = 0; r < e.length; r++)
									for (var o = 0; o < i; o++) n.push({
										a: t[s],
										b: e[r]
									});
							return n
						}(t, e, a);
						h && s(p), d = d.concat(p), c && (p.reverse(), d = d.concat(p))
					}
					return o && d.splice(o), d
				}
			}, function(t, e, i) {
				var n = i(15);
				t.exports = function(t, e) {
					var i, s, r, o, a, h, u, l, c, d = n(e, "anims", null);
					return null === d || ("string" == typeof d ? t.anims.play(d) : "object" == typeof d && (i = t.anims, s = n(d, "key", void 0), r = n(d, "startFrame", void 0), o = n(d, "delay", 0), a = n(d, "repeat", 0), h = n(d, "repeatDelay", 0), u = n(d, "yoyo", !1), l = n(d, "play", !1), c = n(d, "delayedPlay", 0), i.setDelay(o), i.setRepeat(a), i.setRepeatDelay(h), i.setYoyo(u), l ? i.play(s, r) : 0 < c ? i.delayedPlay(c, s, r) : i.load(s))), t
				}
			}, function(t, e, i) {
				var n = i(11);
				t.exports = function(t, e, i) {
					void 0 === i && (i = new n);
					var s = Math.min(t.x, e.x),
						r = Math.min(t.y, e.y),
						o = Math.max(t.right, e.right) - s,
						a = Math.max(t.bottom, e.bottom) - r;
					return i.setTo(s, r, o, a)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(957),
					o = i(14),
					a = i(7),
					h = i(178),
					u = i(22),
					l = i(334),
					c = new n({
						Extends: o,
						Mixins: [s.AlphaSingle, s.BlendMode, s.Depth, s.Origin, s.ScrollFactor, s.Transform, s.Visible, r],
						initialize: function(t, e, i, n, s, r) {
							o.call(this, t, "DOMElement"), this.parent = t.sys.game.domContainer, this.cache = t.sys.cache.html, this.node, this.transformOnly = !1, this.skewX = 0, this.skewY = 0, this.rotate3d = new l, this.rotate3dAngle = "deg", this.width = 0, this.height = 0, this.displayWidth = 0, this.displayHeight = 0, this.handler = this.dispatchNativeEvent.bind(this), this.setPosition(e, i), "string" == typeof n ? "#" === n[0] ? this.setElement(n.substr(1), s, r) : this.createElement(n, s, r) : n && this.setElement(n, s, r), t.sys.events.on(u.SLEEP, this.handleSceneEvent, this), t.sys.events.on(u.WAKE, this.handleSceneEvent, this)
						},
						handleSceneEvent: function(t) {
							var e = this.node,
								i = e.style;
							e && (i.display = t.settings.visible ? "block" : "none")
						},
						setSkew: function(t, e) {
							return void 0 === t && (t = 0), void 0 === e && (e = t), this.skewX = t, this.skewY = e, this
						},
						setPerspective: function(t) {
							return this.parent.style.perspective = t + "px", this
						},
						perspective: {
							get: function() {
								return parseFloat(this.parent.style.perspective)
							},
							set: function(t) {
								this.parent.style.perspective = t + "px"
							}
						},
						addListener: function(t) {
							if (this.node) {
								t = t.split(" ");
								for (var e = 0; e < t.length; e++) this.node.addEventListener(t[e], this.handler, !1)
							}
							return this
						},
						removeListener: function(t) {
							if (this.node) {
								t = t.split(" ");
								for (var e = 0; e < t.length; e++) this.node.removeEventListener(t[e], this.handler)
							}
							return this
						},
						dispatchNativeEvent: function(t) {
							this.emit(t.type, t)
						},
						createElement: function(t, e, i) {
							return this.setElement(document.createElement(t), e, i)
						},
						setElement: function(t, e, i) {
							var n;
							if (this.removeElement(), "string" == typeof t ? ("#" === t[0] && (t = t.substr(1)), n = document.getElementById(t)) : "object" == typeof t && 1 === t.nodeType && (n = t), !n) return this;
							if (this.node = n, e && a(e))
								for (var s in e) n.style[s] = e[s];
							else "string" == typeof e && (n.style = e);
							return n.style.zIndex = "0", n.style.display = "inline", n.style.position = "absolute", (n.phaser = this).parent && this.parent.appendChild(n), i && (n.innerText = i), this.updateSize()
						},
						createFromCache: function(t, e) {
							var i = this.cache.get(t);
							return i && this.createFromHTML(i, e), this
						},
						createFromHTML: function(t, e) {
							void 0 === e && (e = "div"), this.removeElement();
							var i = document.createElement(e);
							return (this.node = i).style.zIndex = "0", i.style.display = "inline", i.style.position = "absolute", (i.phaser = this).parent && this.parent.appendChild(i), i.innerHTML = t, this.updateSize()
						},
						removeElement: function() {
							return this.node && (h(this.node), this.node = null), this
						},
						updateSize: function() {
							var t = this.node,
								e = t.getBoundingClientRect();
							return this.width = t.clientWidth, this.height = t.clientHeight, this.displayWidth = e.width || 0, this.displayHeight = e.height || 0, this
						},
						getChildByProperty: function(t, e) {
							if (this.node)
								for (var i = this.node.querySelectorAll("*"), n = 0; n < i.length; n++)
									if (i[n][t] === e) return i[n];
							return null
						},
						getChildByID: function(t) {
							return this.getChildByProperty("id", t)
						},
						getChildByName: function(t) {
							return this.getChildByProperty("name", t)
						},
						setClassName: function(t) {
							return this.node && (this.node.className = t, this.updateSize()), this
						},
						setText: function(t) {
							return this.node && (this.node.innerText = t, this.updateSize()), this
						},
						setHTML: function(t) {
							return this.node && (this.node.innerHTML = t, this.updateSize()), this
						},
						preUpdate: function() {
							var t = this.parentContainer,
								e = this.node;
							e && t && !t.willRender() && (e.style.display = "none")
						},
						willRender: function() {
							return !0
						},
						preDestroy: function() {
							this.removeElement(), this.scene.sys.events.off(u.SLEEP, this.handleSceneEvent, this), this.scene.sys.events.off(u.WAKE, this.handleSceneEvent, this)
						}
					});
				t.exports = c
			}, function(t, e, i) {
				var n = i(958),
					s = i(14);
				t.exports = function(t, e, i, r, o) {
					var a, h, u, l, c, d, f, p, g, v = e.node,
						m = v.style,
						y = e.scene.sys.settings;
					!(v && m && y.visible && s.RENDER_MASK === e.renderFlags) || 0 !== e.cameraFilter && e.cameraFilter & r.id || e.parentContainer && !e.parentContainer.willRender() ? v && (m.display = "none") : (a = e.parentContainer, h = r.alpha * e.alpha, a && (h *= a.alpha), u = t._tempMatrix1, l = t._tempMatrix2, c = t._tempMatrix3, f = d = 0, g = p = "0%", o ? (d = e.width * e.scaleX * e.originX, f = e.height * e.scaleY * e.originY, l.applyITRS(e.x - d, e.y - f, e.rotation, e.scaleX, e.scaleY), u.copyFrom(r.matrix), u.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x - d, l.f = e.y - f) : (d = e.width * e.originX, f = e.height * e.originY, l.applyITRS(e.x - d, e.y - f, e.rotation, e.scaleX, e.scaleY), u.copyFrom(r.matrix), p = 100 * e.originX + "%", g = 100 * e.originY + "%", l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), u.multiply(l, c), e.transformOnly || (m.display = "block", m.opacity = h, m.zIndex = e._depth, m.pointerEvents = "auto", m.mixBlendMode = n[e._blendMode]), m.transform = c.getCSSMatrix() + " skew(" + e.skewX + "rad, " + e.skewY + "rad) rotate3d(" + e.rotate3d.x + "," + e.rotate3d.y + "," + e.rotate3d.z + "," + e.rotate3d.w + e.rotate3dAngle + ")", m.transformOrigin = p + " " + g)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(14),
					o = i(962),
					a = new n({
						Extends: r,
						Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.Origin, s.ScrollFactor, s.Size, s.Texture, s.Tint, s.Transform, s.Visible, o],
						initialize: function(t) {
							r.call(this, t, "Extern")
						},
						preUpdate: function() {},
						render: function() {}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(193),
					s = i(87),
					r = i(13),
					o = i(4);
				t.exports = function(t, e, i) {
					void 0 === i && (i = new o);
					var a = s(e, 0, r.PI2);
					return n(t, a, i)
				}
			}, function(t, e, i) {
				var n = i(400),
					s = i(193),
					r = i(87),
					o = i(13);
				t.exports = function(t, e, i, a) {
					void 0 === a && (a = []), !e && 0 < i && (e = n(t) / i);
					for (var h = 0; h < e; h++) {
						var u = r(h / e, 0, o.PI2);
						a.push(s(t, u))
					}
					return a
				}
			}, function(t, e) {
				t.exports = function(t) {
					var e = t.width / 2,
						i = t.height / 2,
						n = Math.pow(e - i, 2) / Math.pow(e + i, 2);
					return Math.PI * (e + i) * (1 + 3 * n / (10 + Math.sqrt(4 - 3 * n)))
				}
			}, function(t, e, i) {
				var n = i(192),
					s = i(28);
				t.exports = function(t, e, i, r, o, a, h) {
					var u = e.commandBuffer,
						l = u.length,
						c = a || t.currentContext;
					if (0 !== l && s(t, c, e, r, o)) {
						var d, f, p, g, v, m = 0,
							y = 0,
							x = 0;
						c.beginPath();
						for (var T = 0; T < l; ++T) switch (u[T]) {
							case n.ARC:
								c.arc(u[T + 1], u[T + 2], u[T + 3], u[T + 4], u[T + 5], u[T + 6]), T += 7;
								break;
							case n.LINE_STYLE:
								v = u[T + 1], p = u[T + 2], d = u[T + 3], m = (16711680 & p) >>> 16, y = (65280 & p) >>> 8, x = 255 & p, c.strokeStyle = "rgba(" + m + "," + y + "," + x + "," + d + ")", c.lineWidth = v, T += 3;
								break;
							case n.FILL_STYLE:
								g = u[T + 1], f = u[T + 2], m = (16711680 & g) >>> 16, y = (65280 & g) >>> 8, x = 255 & g, c.fillStyle = "rgba(" + m + "," + y + "," + x + "," + f + ")", T += 2;
								break;
							case n.BEGIN_PATH:
								c.beginPath();
								break;
							case n.CLOSE_PATH:
								c.closePath();
								break;
							case n.FILL_PATH:
								h || c.fill();
								break;
							case n.STROKE_PATH:
								h || c.stroke();
								break;
							case n.FILL_RECT:
								h ? c.rect(u[T + 1], u[T + 2], u[T + 3], u[T + 4]) : c.fillRect(u[T + 1], u[T + 2], u[T + 3], u[T + 4]), T += 4;
								break;
							case n.FILL_TRIANGLE:
								c.beginPath(), c.moveTo(u[T + 1], u[T + 2]), c.lineTo(u[T + 3], u[T + 4]), c.lineTo(u[T + 5], u[T + 6]), c.closePath(), h || c.fill(), T += 6;
								break;
							case n.STROKE_TRIANGLE:
								c.beginPath(), c.moveTo(u[T + 1], u[T + 2]), c.lineTo(u[T + 3], u[T + 4]), c.lineTo(u[T + 5], u[T + 6]), c.closePath(), h || c.stroke(), T += 6;
								break;
							case n.LINE_TO:
								c.lineTo(u[T + 1], u[T + 2]), T += 2;
								break;
							case n.MOVE_TO:
								c.moveTo(u[T + 1], u[T + 2]), T += 2;
								break;
							case n.LINE_FX_TO:
								c.lineTo(u[T + 1], u[T + 2]), T += 5;
								break;
							case n.MOVE_FX_TO:
								c.moveTo(u[T + 1], u[T + 2]), T += 5;
								break;
							case n.SAVE:
								c.save();
								break;
							case n.RESTORE:
								c.restore();
								break;
							case n.TRANSLATE:
								c.translate(u[T + 1], u[T + 2]), T += 2;
								break;
							case n.SCALE:
								c.scale(u[T + 1], u[T + 2]), T += 2;
								break;
							case n.ROTATE:
								c.rotate(u[T + 1]), T += 1;
								break;
							case n.GRADIENT_FILL_STYLE:
								T += 5;
								break;
							case n.GRADIENT_LINE_STYLE:
								T += 6;
								break;
							case n.SET_TEXTURE:
								T += 2
						}
						c.restore()
					}
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(2),
					r = new n({
						initialize: function(t, e, i, n, r) {
							var o;
							"object" == typeof t ? (t = s(o = t, "x", 0), e = s(o, "y", 0), i = s(o, "power", 0), n = s(o, "epsilon", 100), r = s(o, "gravity", 50)) : (void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 100), void 0 === r && (r = 50)), this.x = t, this.y = e, this.active = !0, this._gravity = r, this._power = 0, this._epsilon = 0, this.power = i, this.epsilon = n
						},
						update: function(t, e) {
							var i, n, s = this.x - t.x,
								r = this.y - t.y,
								o = s * s + r * r;
							0 !== o && (i = Math.sqrt(o), o < this._epsilon && (o = this._epsilon), n = this._power * e / (o * i) * 100, t.velocityX += s * n, t.velocityY += r * n)
						},
						epsilon: {
							get: function() {
								return Math.sqrt(this._epsilon)
							},
							set: function(t) {
								this._epsilon = t * t
							}
						},
						power: {
							get: function() {
								return this._power / this._gravity
							},
							set: function(t) {
								this._power = t * this._gravity
							}
						},
						gravity: {
							get: function() {
								return this._gravity
							},
							set: function(t) {
								var e = this.power;
								this._gravity = t, this.power = e
							}
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = i(0),
					s = i(39),
					r = i(53),
					o = new n({
						initialize: function(t) {
							this.emitter = t, this.frame = null, this.x = 0, this.y = 0, this.velocityX = 0, this.velocityY = 0, this.accelerationX = 0, this.accelerationY = 0, this.maxVelocityX = 1e4, this.maxVelocityY = 1e4, this.bounce = 0, this.scaleX = 1, this.scaleY = 1, this.alpha = 1, this.angle = 0, this.rotation = 0, this.tint = 16777215, this.life = 1e3, this.lifeCurrent = 1e3, this.delayCurrent = 0, this.lifeT = 0, this.data = {
								tint: {
									min: 16777215,
									max: 16777215,
									current: 16777215
								},
								alpha: {
									min: 1,
									max: 1
								},
								rotate: {
									min: 0,
									max: 0
								},
								scaleX: {
									min: 1,
									max: 1
								},
								scaleY: {
									min: 1,
									max: 1
								}
							}
						},
						isAlive: function() {
							return 0 < this.lifeCurrent
						},
						resetPosition: function() {
							this.x = 0, this.y = 0
						},
						fire: function(t, e) {
							var i = this.emitter;
							this.frame = i.getFrame(), i.emitZone && i.emitZone.getPoint(this), void 0 === t ? (i.follow && (this.x += i.follow.x + i.followOffset.x), this.x += i.x.onEmit(this, "x")) : this.x += t, void 0 === e ? (i.follow && (this.y += i.follow.y + i.followOffset.y), this.y += i.y.onEmit(this, "y")) : this.y += e, this.life = i.lifespan.onEmit(this, "lifespan"), this.lifeCurrent = this.life, this.lifeT = 0;
							var n, o, a, h, u, l = i.speedX.onEmit(this, "speedX"),
								c = i.speedY ? i.speedY.onEmit(this, "speedY") : l;
							i.radial ? (n = s(i.angle.onEmit(this, "angle")), this.velocityX = Math.cos(n) * Math.abs(l), this.velocityY = Math.sin(n) * Math.abs(c)) : i.moveTo ? (o = i.moveToX.onEmit(this, "moveToX"), a = i.moveToY ? i.moveToY.onEmit(this, "moveToY") : o, h = Math.atan2(a - this.y, o - this.x), u = r(this.x, this.y, o, a) / (this.life / 1e3), this.velocityX = Math.cos(h) * u, this.velocityY = Math.sin(h) * u) : (this.velocityX = l, this.velocityY = c), i.acceleration && (this.accelerationX = i.accelerationX.onEmit(this, "accelerationX"), this.accelerationY = i.accelerationY.onEmit(this, "accelerationY")), this.maxVelocityX = i.maxVelocityX.onEmit(this, "maxVelocityX"), this.maxVelocityY = i.maxVelocityY.onEmit(this, "maxVelocityY"), this.delayCurrent = i.delay.onEmit(this, "delay"), this.scaleX = i.scaleX.onEmit(this, "scaleX"), this.scaleY = i.scaleY ? i.scaleY.onEmit(this, "scaleY") : this.scaleX, this.angle = i.rotate.onEmit(this, "rotate"), this.rotation = s(this.angle), this.bounce = i.bounce.onEmit(this, "bounce"), this.alpha = i.alpha.onEmit(this, "alpha"), this.tint = i.tint.onEmit(this, "tint")
						},
						computeVelocity: function(t, e, i, n) {
							var s = this.velocityX,
								r = this.velocityY,
								o = this.accelerationX,
								a = this.accelerationY,
								h = this.maxVelocityX,
								u = this.maxVelocityY;
							s += t.gravityX * i, r += t.gravityY * i, o && (s += o * i), a && (r += a * i), h < s ? s = h : s < -h && (s = -h), u < r ? r = u : r < -u && (r = -u), this.velocityX = s, this.velocityY = r;
							for (var l = 0; l < n.length; l++) n[l].update(this, e, i)
						},
						checkBounds: function(t) {
							var e = t.bounds,
								i = -this.bounce;
							this.x < e.x && t.collideLeft ? (this.x = e.x, this.velocityX *= i) : this.x > e.right && t.collideRight && (this.x = e.right, this.velocityX *= i), this.y < e.y && t.collideTop ? (this.y = e.y, this.velocityY *= i) : this.y > e.bottom && t.collideBottom && (this.y = e.bottom, this.velocityY *= i)
						},
						update: function(t, e, i) {
							if (0 < this.delayCurrent) return this.delayCurrent -= t, !1;
							var n = this.emitter,
								r = 1 - this.lifeCurrent / this.life;
							return this.lifeT = r, this.computeVelocity(n, t, e, i), this.x += this.velocityX * e, this.y += this.velocityY * e, n.bounds && this.checkBounds(n), n.deathZone && n.deathZone.willKill(this) ? !(this.lifeCurrent = 0) : (this.scaleX = n.scaleX.onUpdate(this, "scaleX", r, this.scaleX), n.scaleY ? this.scaleY = n.scaleY.onUpdate(this, "scaleY", r, this.scaleY) : this.scaleY = this.scaleX, this.angle = n.rotate.onUpdate(this, "rotate", r, this.angle), this.rotation = s(this.angle), this.alpha = n.alpha.onUpdate(this, "alpha", r, this.alpha), this.tint = n.tint.onUpdate(this, "tint", r, this.tint), this.lifeCurrent -= t, this.lifeCurrent <= 0)
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(52),
					s = i(0),
					r = i(12),
					o = i(405),
					a = i(406),
					h = i(974),
					u = i(2),
					l = i(185),
					c = i(407),
					d = i(108),
					f = i(403),
					p = i(408),
					g = i(11),
					v = i(131),
					m = i(3),
					y = i(58),
					x = new s({
						Mixins: [r.BlendMode, r.Mask, r.ScrollFactor, r.Visible],
						initialize: function(t, e) {
							this.manager = t, this.texture = t.texture, this.frames = [t.defaultFrame], this.defaultFrame = t.defaultFrame, this.configFastMap = ["active", "blendMode", "collideBottom", "collideLeft", "collideRight", "collideTop", "deathCallback", "deathCallbackScope", "emitCallback", "emitCallbackScope", "follow", "frequency", "gravityX", "gravityY", "maxParticles", "name", "on", "particleBringToTop", "particleClass", "radial", "timeScale", "trackVisible", "visible"], this.configOpMap = ["accelerationX", "accelerationY", "angle", "alpha", "bounce", "delay", "lifespan", "maxVelocityX", "maxVelocityY", "moveToX", "moveToY", "quantity", "rotate", "scaleX", "scaleY", "speedX", "speedY", "tint", "x", "y"], this.name = "", this.particleClass = f, this.x = new h(e, "x", 0, !0), this.y = new h(e, "y", 0, !0), this.radial = !0, this.gravityX = 0, this.gravityY = 0, this.acceleration = !1, this.accelerationX = new h(e, "accelerationX", 0, !0), this.accelerationY = new h(e, "accelerationY", 0, !0), this.maxVelocityX = new h(e, "maxVelocityX", 1e4, !0), this.maxVelocityY = new h(e, "maxVelocityY", 1e4, !0), this.speedX = new h(e, "speedX", 0, !0), this.speedY = new h(e, "speedY", 0, !0), this.moveTo = !1, this.moveToX = new h(e, "moveToX", 0, !0), this.moveToY = new h(e, "moveToY", 0, !0), this.bounce = new h(e, "bounce", 0, !0), this.scaleX = new h(e, "scaleX", 1), this.scaleY = new h(e, "scaleY", 1), this.tint = new h(e, "tint", 4294967295), this.alpha = new h(e, "alpha", 1), this.lifespan = new h(e, "lifespan", 1e3, !0), this.angle = new h(e, "angle", {
								min: 0,
								max: 360
							}, !0), this.rotate = new h(e, "rotate", 0), this.emitCallback = null, this.emitCallbackScope = null, this.deathCallback = null, this.deathCallbackScope = null, this.maxParticles = 0, this.quantity = new h(e, "quantity", 1, !0), this.delay = new h(e, "delay", 0, !0), this.frequency = 0, this.on = !0, this.particleBringToTop = !0, this.timeScale = 1, this.emitZone = null, this.deathZone = null, this.bounds = null, this.collideLeft = !0, this.collideRight = !0, this.collideTop = !0, this.collideBottom = !0, this.active = !0, this.visible = !0, this.blendMode = n.NORMAL, this.follow = null, this.followOffset = new m, this.trackVisible = !1, this.currentFrame = 0, this.randomFrame = !0, this.frameQuantity = 1, this.dead = [], this.alive = [], this._counter = 0, this._frameCounter = 0, e && this.fromJSON(e)
						},
						fromJSON: function(t) {
							if (!t) return this;
							var e, i = 0,
								n = "";
							for (i = 0; i < this.configFastMap.length; i++) n = this.configFastMap[i], d(t, n) && (this[n] = u(t, n));
							for (i = 0; i < this.configOpMap.length; i++) n = this.configOpMap[i], d(t, n) && this[n].loadConfig(t);
							return this.acceleration = 0 !== this.accelerationX.propertyValue || 0 !== this.accelerationY.propertyValue, this.moveTo = 0 !== this.moveToX.propertyValue || 0 !== this.moveToY.propertyValue, d(t, "speed") && (this.speedX.loadConfig(t, "speed"), this.speedY = null), (c(t, ["speedX", "speedY"]) || this.moveTo) && (this.radial = !1), d(t, "scale") && (this.scaleX.loadConfig(t, "scale"), this.scaleY = null), d(t, "callbackScope") && (e = u(t, "callbackScope", null), this.emitCallbackScope = e, this.deathCallbackScope = e), d(t, "emitZone") && this.setEmitZone(t.emitZone), d(t, "deathZone") && this.setDeathZone(t.deathZone), d(t, "bounds") && this.setBounds(t.bounds), d(t, "followOffset") && this.followOffset.setFromObject(u(t, "followOffset", 0)), d(t, "frame") && this.setFrame(t.frame), this
						},
						toJSON: function(t) {
							void 0 === t && (t = {});
							var e = 0,
								i = "";
							for (e = 0; e < this.configFastMap.length; e++) t[i = this.configFastMap[e]] = this[i];
							for (e = 0; e < this.configOpMap.length; e++) this[i = this.configOpMap[e]] && (t[i] = this[i].toJSON());
							return this.speedY || (delete t.speedX, t.speed = this.speedX.toJSON()), this.scaleY || (delete t.scaleX, t.scale = this.scaleX.toJSON()), t
						},
						startFollow: function(t, e, i, n) {
							return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = !1), this.follow = t, this.followOffset.set(e, i), this.trackVisible = n, this
						},
						stopFollow: function() {
							return this.follow = null, this.followOffset.set(0, 0), this.trackVisible = !1, this
						},
						getFrame: function() {
							if (1 === this.frames.length) return this.defaultFrame;
							if (this.randomFrame) return l(this.frames);
							var t = this.frames[this.currentFrame];
							return this._frameCounter++, this._frameCounter === this.frameQuantity && (this._frameCounter = 0, this.currentFrame = y(this.currentFrame + 1, 0, this._frameLength)), t
						},
						setFrame: function(t, e, i) {
							void 0 === e && (e = !0), void 0 === i && (i = 1), this.randomFrame = e, this.frameQuantity = i, this.currentFrame = 0, this._frameCounter = 0;
							var n, s, r = typeof t;
							return Array.isArray(t) || "string" == r || "number" == r ? this.manager.setEmitterFrames(t, this) : "object" == r && ((t = u(n = t, "frames", null)) && this.manager.setEmitterFrames(t, this), s = u(n, "cycle", !1), this.randomFrame = !s, this.frameQuantity = u(n, "quantity", i)), this._frameLength = this.frames.length, 1 === this._frameLength && (this.frameQuantity = 1, this.randomFrame = !1), this
						},
						setRadial: function(t) {
							return void 0 === t && (t = !0), this.radial = t, this
						},
						setPosition: function(t, e) {
							return this.x.onChange(t), this.y.onChange(e), this
						},
						setBounds: function(t, e, i, n) {
							var s;
							return "object" == typeof t && (t = (s = t).x, e = s.y, i = d(s, "w") ? s.w : s.width, n = d(s, "h") ? s.h : s.height), this.bounds ? this.bounds.setTo(t, e, i, n) : this.bounds = new g(t, e, i, n), this
						},
						setSpeedX: function(t) {
							return this.speedX.onChange(t), this.radial = !1, this
						},
						setSpeedY: function(t) {
							return this.speedY && (this.speedY.onChange(t), this.radial = !1), this
						},
						setSpeed: function(t) {
							return this.speedX.onChange(t), this.speedY = null, this.radial = !0, this
						},
						setScaleX: function(t) {
							return this.scaleX.onChange(t), this
						},
						setScaleY: function(t) {
							return this.scaleY.onChange(t), this
						},
						setScale: function(t) {
							return this.scaleX.onChange(t), this.scaleY = null, this
						},
						setGravityX: function(t) {
							return this.gravityX = t, this
						},
						setGravityY: function(t) {
							return this.gravityY = t, this
						},
						setGravity: function(t, e) {
							return this.gravityX = t, this.gravityY = e, this
						},
						setAlpha: function(t) {
							return this.alpha.onChange(t), this
						},
						setTint: function(t) {
							return this.tint.onChange(t), this
						},
						setEmitterAngle: function(t) {
							return this.angle.onChange(t), this
						},
						setAngle: function(t) {
							return this.angle.onChange(t), this
						},
						setLifespan: function(t) {
							return this.lifespan.onChange(t), this
						},
						setQuantity: function(t) {
							return this.quantity.onChange(t), this
						},
						setFrequency: function(t, e) {
							return this.frequency = t, this._counter = 0, e && this.quantity.onChange(e), this
						},
						setEmitZone: function(t) {
							if (void 0 === t) this.emitZone = null;
							else {
								var e = u(t, "type", "random"),
									i = u(t, "source", null);
								switch (e) {
									case "random":
										this.emitZone = new p(i);
										break;
									case "edge":
										var n = u(t, "quantity", 1),
											s = u(t, "stepRate", 0),
											r = u(t, "yoyo", !1),
											o = u(t, "seamless", !0);
										this.emitZone = new a(i, n, s, r, o)
								}
							}
							return this
						},
						setDeathZone: function(t) {
							var e, i, n;
							return void 0 === t ? this.deathZone = null : (e = u(t, "type", "onEnter"), (i = u(t, "source", null)) && "function" == typeof i.contains && (n = "onEnter" === e, this.deathZone = new o(i, n))), this
						},
						reserve: function(t) {
							for (var e = this.dead, i = 0; i < t; i++) e.push(new this.particleClass(this));
							return this
						},
						getAliveParticleCount: function() {
							return this.alive.length
						},
						getDeadParticleCount: function() {
							return this.dead.length
						},
						getParticleCount: function() {
							return this.getAliveParticleCount() + this.getDeadParticleCount()
						},
						atLimit: function() {
							return 0 < this.maxParticles && this.getParticleCount() === this.maxParticles
						},
						onParticleEmit: function(t, e) {
							return void 0 === t ? (this.emitCallback = null, this.emitCallbackScope = null) : "function" == typeof t && (this.emitCallback = t, e && (this.emitCallbackScope = e)), this
						},
						onParticleDeath: function(t, e) {
							return void 0 === t ? (this.deathCallback = null, this.deathCallbackScope = null) : "function" == typeof t && (this.deathCallback = t, e && (this.deathCallbackScope = e)), this
						},
						killAll: function() {
							for (var t = this.dead, e = this.alive; 0 < e.length;) t.push(e.pop());
							return this
						},
						forEachAlive: function(t, e) {
							for (var i = this.alive, n = i.length, s = 0; s < n; ++s) t.call(e, i[s], this);
							return this
						},
						forEachDead: function(t, e) {
							for (var i = this.dead, n = i.length, s = 0; s < n; ++s) t.call(e, i[s], this);
							return this
						},
						start: function() {
							return this.on = !0, this._counter = 0, this
						},
						stop: function() {
							return this.on = !1, this
						},
						pause: function() {
							return this.active = !1, this
						},
						resume: function() {
							return this.active = !0, this
						},
						remove: function() {
							return this.manager.removeEmitter(this), this
						},
						depthSort: function() {
							return v.inplace(this.alive, this.depthSortCallback), this
						},
						flow: function(t, e) {
							return void 0 === e && (e = 1), this.frequency = t, this.quantity.onChange(e), this.start()
						},
						explode: function(t, e, i) {
							return this.frequency = -1, this.emitParticle(t, e, i)
						},
						emitParticleAt: function(t, e, i) {
							return this.emitParticle(i, t, e)
						},
						emitParticle: function(t, e, i) {
							if (!this.atLimit()) {
								void 0 === t && (t = this.quantity.onEmit());
								for (var n = this.dead, s = 0; s < t; s++) {
									var r = n.pop();
									if ((r = r || new this.particleClass(this)).fire(e, i), this.particleBringToTop ? this.alive.push(r) : this.alive.unshift(r), this.emitCallback && this.emitCallback.call(this.emitCallbackScope, r, this), this.atLimit()) break
								}
								return r
							}
						},
						preUpdate: function(t, e) {
							var i = (e *= this.timeScale) / 1e3;
							this.trackVisible && (this.visible = this.follow.visible);
							var n = this.manager.getProcessors(),
								s = this.alive,
								r = this.dead,
								o = 0,
								a = [],
								h = s.length;
							for (o = 0; o < h; o++) {
								var u = s[o];
								u.update(e, i, n) && a.push({
									index: o,
									particle: u
								})
							}
							if (0 < (h = a.length)) {
								var l = this.deathCallback,
									c = this.deathCallbackScope;
								for (o = h - 1; 0 <= o; o--) {
									var d = a[o];
									s.splice(d.index, 1), r.push(d.particle), l && l.call(c, d.particle), d.particle.resetPosition()
								}
							}
							this.on && (0 === this.frequency ? this.emitParticle() : 0 < this.frequency && (this._counter -= e, this._counter <= 0 && (this.emitParticle(), this._counter = this.frequency - Math.abs(this._counter))))
						},
						depthSortCallback: function(t, e) {
							return t.y - e.y
						}
					});
				t.exports = x
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t, e) {
						this.source = t, this.killOnEnter = e
					},
					willKill: function(t) {
						var e = this.source.contains(t.x, t.y);
						return e && this.killOnEnter || !e && !this.killOnEnter
					}
				});
				t.exports = n
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t, e, i, n, s) {
						void 0 === n && (n = !1), void 0 === s && (s = !0), this.source = t, this.points = [], this.quantity = e, this.stepRate = i, this.yoyo = n, this.counter = -1, this.seamless = s, this._length = 0, this._direction = 0, this.updateSource()
					},
					updateSource: function() {
						var t, e;
						this.points = this.source.getPoints(this.quantity, this.stepRate), this.seamless && (t = this.points[0], e = this.points[this.points.length - 1], t.x === e.x && t.y === e.y && this.points.pop());
						var i = this._length;
						return this._length = this.points.length, this._length < i && this.counter > this._length && (this.counter = this._length - 1), this
					},
					changeSource: function(t) {
						return this.source = t, this.updateSource()
					},
					getPoint: function(t) {
						0 === this._direction ? (this.counter++, this.counter >= this._length && (this.yoyo ? (this._direction = 1, this.counter = this._length - 1) : this.counter = 0)) : (this.counter--, -1 === this.counter && (this.yoyo ? (this._direction = 0, this.counter = 0) : this.counter = this._length - 1));
						var e = this.points[this.counter];
						e && (t.x = e.x, t.y = e.y)
					}
				});
				t.exports = n
			}, function(t, e) {
				t.exports = function(t, e) {
					for (var i = 0; i < e.length; i++)
						if (t.hasOwnProperty(e[i])) return !0;
					return !1
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(3),
					r = new n({
						initialize: function(t) {
							this.source = t, this._tempVec = new s
						},
						getPoint: function(t) {
							var e = this._tempVec;
							this.source.getRandomPoint(e), t.x = e.x, t.y = e.y
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(75),
					o = new n({
						Extends: r,
						Mixins: [s.PathFollower],
						initialize: function(t, e, i, n, s, o) {
							r.call(this, t, i, n, s, o), this.path = e
						},
						preUpdate: function(t, e) {
							this.anims.update(t, e), this.pathUpdate(t)
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(1e3),
					s = i(0),
					r = i(39),
					o = i(66),
					a = i(65),
					h = i(13),
					u = i(30),
					l = new s({
						Extends: u,
						Mixins: [n],
						initialize: function(t, e, i, n, s, r, o, h, l) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === s && (s = 0), void 0 === r && (r = 360), void 0 === o && (o = !1), u.call(this, t, "Arc", new a(0, 0, n)), this._startAngle = s, this._endAngle = r, this._anticlockwise = o, this._iterations = .01, this.setPosition(e, i);
							var c = 2 * this.geom.radius;
							this.setSize(c, c), void 0 !== h && this.setFillStyle(h, l), this.updateDisplayOrigin(), this.updateData()
						},
						iterations: {
							get: function() {
								return this._iterations
							},
							set: function(t) {
								this._iterations = t, this.updateData()
							}
						},
						radius: {
							get: function() {
								return this.geom.radius
							},
							set: function(t) {
								var e = 2 * (this.geom.radius = t);
								this.setSize(e, e), this.updateDisplayOrigin(), this.updateData()
							}
						},
						startAngle: {
							get: function() {
								return this._startAngle
							},
							set: function(t) {
								this._startAngle = t, this.updateData()
							}
						},
						endAngle: {
							get: function() {
								return this._endAngle
							},
							set: function(t) {
								this._endAngle = t, this.updateData()
							}
						},
						anticlockwise: {
							get: function() {
								return this._anticlockwise
							},
							set: function(t) {
								this._anticlockwise = t, this.updateData()
							}
						},
						setRadius: function(t) {
							return this.radius = t, this
						},
						setIterations: function(t) {
							return void 0 === t && (t = .01), this.iterations = t, this
						},
						setStartAngle: function(t, e) {
							return this._startAngle = t, void 0 !== e && (this._anticlockwise = e), this.updateData()
						},
						setEndAngle: function(t, e) {
							return this._endAngle = t, void 0 !== e && (this._anticlockwise = e), this.updateData()
						},
						updateData: function() {
							var t = this._iterations,
								e = t,
								i = this.geom.radius,
								n = r(this._startAngle),
								s = r(this._endAngle),
								a = i,
								u = i;
							s -= n, this._anticlockwise ? s < -h.PI2 ? s = -h.PI2 : 0 < s && (s = -h.PI2 + s % h.PI2) : s > h.PI2 ? s = h.PI2 : s < 0 && (s = h.PI2 + s % h.PI2);
							for (var l, c = [a + Math.cos(n) * i, u + Math.sin(n) * i]; e < 1;) l = s * e + n, c.push(a + Math.cos(l) * i, u + Math.sin(l) * i), e += t;
							return l = s + n, c.push(a + Math.cos(l) * i, u + Math.sin(l) * i), c.push(a + Math.cos(n) * i, u + Math.sin(n) * i), this.pathIndexes = o(c), this.pathData = c, this
						}
					});
				t.exports = l
			}, function(t, e, i) {
				var n = i(0),
					s = i(1003),
					r = i(66),
					o = i(11),
					a = i(30),
					h = new n({
						Extends: a,
						Mixins: [s],
						initialize: function(t, e, i, n, s, r) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), a.call(this, t, "Curve", n), this._smoothness = 32, this._curveBounds = new o, this.closePath = !1, this.setPosition(e, i), void 0 !== s && this.setFillStyle(s, r), this.updateData()
						},
						smoothness: {
							get: function() {
								return this._smoothness
							},
							set: function(t) {
								this._smoothness = t, this.updateData()
							}
						},
						setSmoothness: function(t) {
							return this._smoothness = t, this.updateData()
						},
						updateData: function() {
							var t = this._curveBounds,
								e = this._smoothness;
							this.geom.getBounds(t, e), this.setSize(t.width, t.height), this.updateDisplayOrigin();
							for (var i = [], n = this.geom.getPoints(e), s = 0; s < n.length; s++) i.push(n[s].x, n[s].y);
							return i.push(n[0].x, n[0].y), this.pathIndexes = r(i), this.pathData = i, this
						}
					});
				t.exports = h
			}, function(t, e, i) {
				var n = i(0),
					s = i(66),
					r = i(1006),
					o = i(95),
					a = i(30),
					h = new n({
						Extends: a,
						Mixins: [r],
						initialize: function(t, e, i, n, s, r, h) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === s && (s = 128), a.call(this, t, "Ellipse", new o(n / 2, s / 2, n, s)), this._smoothness = 64, this.setPosition(e, i), this.width = n, this.height = s, void 0 !== r && this.setFillStyle(r, h), this.updateDisplayOrigin(), this.updateData()
						},
						smoothness: {
							get: function() {
								return this._smoothness
							},
							set: function(t) {
								this._smoothness = t, this.updateData()
							}
						},
						setSize: function(t, e) {
							return this.geom.setSize(t, e), this.updateData()
						},
						setSmoothness: function(t) {
							return this._smoothness = t, this.updateData()
						},
						updateData: function() {
							for (var t = [], e = this.geom.getPoints(this._smoothness), i = 0; i < e.length; i++) t.push(e[i].x, e[i].y);
							return t.push(e[0].x, e[0].y), this.pathIndexes = s(t), this.pathData = t, this
						}
					});
				t.exports = h
			}, function(t, e, i) {
				var n = i(0),
					s = i(30),
					r = i(1009),
					o = new n({
						Extends: s,
						Mixins: [r],
						initialize: function(t, e, i, n, r, o, a, h, u, l, c) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === r && (r = 128), void 0 === o && (o = 32), void 0 === a && (a = 32), s.call(this, t, "Grid", null), this.cellWidth = o, this.cellHeight = a, this.showCells = !0, this.outlineFillColor = 0, this.outlineFillAlpha = 0, this.showOutline = !0, this.showAltCells = !1, this.altFillColor, this.altFillAlpha, this.setPosition(e, i), this.setSize(n, r), void 0 !== h && this.setFillStyle(h, u), void 0 !== l && this.setOutlineStyle(l, c), this.updateDisplayOrigin()
						},
						setFillStyle: function(t, e) {
							return void 0 === e && (e = 1), void 0 === t ? this.showCells = !1 : (this.fillColor = t, this.fillAlpha = e, this.showCells = !0), this
						},
						setAltFillStyle: function(t, e) {
							return void 0 === e && (e = 1), void 0 === t ? this.showAltCells = !1 : (this.altFillColor = t, this.altFillAlpha = e, this.showAltCells = !0), this
						},
						setOutlineStyle: function(t, e) {
							return void 0 === e && (e = 1), void 0 === t ? this.showOutline = !1 : (this.outlineFillColor = t, this.outlineFillAlpha = e, this.showOutline = !0), this
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(1012),
					s = i(0),
					r = i(30),
					o = new s({
						Extends: r,
						Mixins: [n],
						initialize: function(t, e, i, n, s, o, a, h) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 48), void 0 === s && (s = 32), void 0 === o && (o = 15658734), void 0 === a && (a = 10066329), void 0 === h && (h = 13421772), r.call(this, t, "IsoBox", null), this.projection = 4, this.fillTop = o, this.fillLeft = a, this.fillRight = h, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isFilled = !0, this.setPosition(e, i), this.setSize(n, s), this.updateDisplayOrigin()
						},
						setProjection: function(t) {
							return this.projection = t, this
						},
						setFaces: function(t, e, i) {
							return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), this.showTop = t, this.showLeft = e, this.showRight = i, this
						},
						setFillStyle: function(t, e, i) {
							return this.fillTop = t, this.fillLeft = e, this.fillRight = i, this.isFilled = !0, this
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(0),
					s = i(1015),
					r = i(30),
					o = new n({
						Extends: r,
						Mixins: [s],
						initialize: function(t, e, i, n, s, o, a, h, u) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 48), void 0 === s && (s = 32), void 0 === o && (o = !1), void 0 === a && (a = 15658734), void 0 === h && (h = 10066329), void 0 === u && (u = 13421772), r.call(this, t, "IsoTriangle", null), this.projection = 4, this.fillTop = a, this.fillLeft = h, this.fillRight = u, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isReversed = o, this.isFilled = !0, this.setPosition(e, i), this.setSize(n, s), this.updateDisplayOrigin()
						},
						setProjection: function(t) {
							return this.projection = t, this
						},
						setReversed: function(t) {
							return this.isReversed = t, this
						},
						setFaces: function(t, e, i) {
							return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), this.showTop = t, this.showLeft = e, this.showRight = i, this
						},
						setFillStyle: function(t, e, i) {
							return this.fillTop = t, this.fillLeft = e, this.fillRight = i, this.isFilled = !0, this
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(0),
					s = i(30),
					r = i(56),
					o = i(1018),
					a = new n({
						Extends: s,
						Mixins: [o],
						initialize: function(t, e, i, n, o, a, h, u, l) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === o && (o = 0), void 0 === a && (a = 128), void 0 === h && (h = 0), s.call(this, t, "Line", new r(n, o, a, h));
							var c = this.geom.right - this.geom.left,
								d = this.geom.bottom - this.geom.top;
							this.lineWidth = 1, this._startWidth = 1, this._endWidth = 1, this.setPosition(e, i), this.setSize(c, d), void 0 !== u && this.setStrokeStyle(1, u, l), this.updateDisplayOrigin()
						},
						setLineWidth: function(t, e) {
							return void 0 === e && (e = t), this._startWidth = t, this._endWidth = e, this.lineWidth = t, this
						},
						setTo: function(t, e, i, n) {
							return this.geom.setTo(t, e, i, n), this
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(1021),
					s = i(0),
					r = i(66),
					o = i(418),
					a = i(201),
					h = i(30),
					u = i(421),
					l = new s({
						Extends: h,
						Mixins: [n],
						initialize: function(t, e, i, n, s, r) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), h.call(this, t, "Polygon", new a(n));
							var u = o(this.geom);
							this.setPosition(e, i), this.setSize(u.width, u.height), void 0 !== s && this.setFillStyle(s, r), this.updateDisplayOrigin(), this.updateData()
						},
						smooth: function(t) {
							void 0 === t && (t = 1);
							for (var e = 0; e < t; e++) u(this.geom);
							return this.updateData()
						},
						updateData: function() {
							for (var t = [], e = this.geom.points, i = 0; i < e.length; i++) t.push(e[i].x, e[i].y);
							return t.push(e[0].x, e[0].y), this.pathIndexes = r(t), this.pathData = t, this
						}
					});
				t.exports = l
			}, function(t, e, i) {
				var n = i(11);
				t.exports = function(t, e) {
					void 0 === e && (e = new n);
					for (var i, s = 1 / 0, r = 1 / 0, o = -s, a = -r, h = 0; h < t.points.length; h++) i = t.points[h], s = Math.min(s, i.x), r = Math.min(r, i.y), o = Math.max(o, i.x), a = Math.max(a, i.y);
					return e.x = s, e.y = r, e.width = o - s, e.height = a - r, e
				}
			}, function(t, e, i) {
				var n = i(57),
					s = i(56),
					r = i(420);
				t.exports = function(t, e, i, o) {
					void 0 === o && (o = []);
					var a = t.points,
						h = r(t);
					!e && 0 < i && (e = h / i);
					for (var u = 0; u < e; u++)
						for (var l = h * (u / e), c = 0, d = 0; d < a.length; d++) {
							var f = a[d],
								p = a[(d + 1) % a.length],
								g = new s(f.x, f.y, p.x, p.y),
								v = n(g);
							if (!(l < c || c + v < l)) {
								var m = g.getPoint((l - c) / v);
								o.push(m);
								break
							}
							c += v
						}
					return o
				}
			}, function(t, e, i) {
				var n = i(57),
					s = i(56);
				t.exports = function(t) {
					for (var e = t.points, i = 0, r = 0; r < e.length; r++) {
						var o = e[r],
							a = e[(r + 1) % e.length],
							h = new s(o.x, o.y, a.x, a.y);
						i += n(h)
					}
					return i
				}
			}, function(t, e) {
				function i(t, e) {
					return t[0] = e[0], t[1] = e[1], t
				}
				t.exports = function(t) {
					for (var e = [], n = t.points, s = 0; s < n.length; s++) e.push([n[s].x, n[s].y]);
					var r = [];
					for (0 < e.length && r.push(i([0, 0], e[0])), s = 0; s < e.length - 1; s++) {
						var o = e[s],
							a = e[s + 1],
							h = o[0],
							u = o[1],
							l = a[0],
							c = a[1];
						r.push([.85 * h + .15 * l, .85 * u + .15 * c]), r.push([.15 * h + .85 * l, .15 * u + .85 * c])
					}
					return 1 < e.length && r.push(i([0, 0], e[e.length - 1])), t.setTo(r)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(11),
					r = i(30),
					o = i(1024),
					a = new n({
						Extends: r,
						Mixins: [o],
						initialize: function(t, e, i, n, o, a, h) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === o && (o = 128), r.call(this, t, "Rectangle", new s(0, 0, n, o)), this.setPosition(e, i), this.setSize(n, o), void 0 !== a && this.setFillStyle(a, h), this.updateDisplayOrigin(), this.updateData()
						},
						updateData: function() {
							var t = [],
								e = this.geom,
								i = this._tempLine;
							return e.getLineA(i), t.push(i.x1, i.y1, i.x2, i.y2), e.getLineB(i), t.push(i.x2, i.y2), e.getLineC(i), t.push(i.x2, i.y2), e.getLineD(i), t.push(i.x2, i.y2), this.pathData = t, this
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(1027),
					s = i(0),
					r = i(66),
					o = i(30),
					a = new s({
						Extends: o,
						Mixins: [n],
						initialize: function(t, e, i, n, s, r, a, h) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 5), void 0 === s && (s = 32), void 0 === r && (r = 64), o.call(this, t, "Star", null), this._points = n, this._innerRadius = s, this._outerRadius = r, this.setPosition(e, i), this.setSize(2 * r, 2 * r), void 0 !== a && this.setFillStyle(a, h), this.updateDisplayOrigin(), this.updateData()
						},
						setPoints: function(t) {
							return this._points = t, this.updateData()
						},
						setInnerRadius: function(t) {
							return this._innerRadius = t, this.updateData()
						},
						setOuterRadius: function(t) {
							return this._outerRadius = t, this.updateData()
						},
						points: {
							get: function() {
								return this._points
							},
							set: function(t) {
								this._points = t, this.updateData()
							}
						},
						innerRadius: {
							get: function() {
								return this._innerRadius
							},
							set: function(t) {
								this._innerRadius = t, this.updateData()
							}
						},
						outerRadius: {
							get: function() {
								return this._outerRadius
							},
							set: function(t) {
								this._outerRadius = t, this.updateData()
							}
						},
						updateData: function() {
							var t = [],
								e = this._points,
								i = this._innerRadius,
								n = this._outerRadius,
								s = Math.PI / 2 * 3,
								o = Math.PI / e,
								a = n,
								h = n;
							t.push(a, h + -n);
							for (var u = 0; u < e; u++) t.push(a + Math.cos(s) * n, h + Math.sin(s) * n), s += o, t.push(a + Math.cos(s) * i, h + Math.sin(s) * i), s += o;
							return t.push(a, h + -n), this.pathIndexes = r(t), this.pathData = t, this
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(0),
					s = i(30),
					r = i(71),
					o = i(1030),
					a = new n({
						Extends: s,
						Mixins: [o],
						initialize: function(t, e, i, n, o, a, h, u, l, c, d) {
							void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === o && (o = 128), void 0 === a && (a = 64), void 0 === h && (h = 0), void 0 === u && (u = 128), void 0 === l && (l = 128), s.call(this, t, "Triangle", new r(n, o, a, h, u, l));
							var f = this.geom.right - this.geom.left,
								p = this.geom.bottom - this.geom.top;
							this.setPosition(e, i), this.setSize(f, p), void 0 !== c && this.setFillStyle(c, d), this.updateDisplayOrigin(), this.updateData()
						},
						setTo: function(t, e, i, n, s, r) {
							return this.geom.setTo(t, e, i, n, s, r), this.updateData()
						},
						updateData: function() {
							var t = [],
								e = this.geom,
								i = this._tempLine;
							return e.getLineA(i), t.push(i.x1, i.y1, i.x2, i.y2), e.getLineB(i), t.push(i.x2, i.y2), e.getLineC(i), t.push(i.x2, i.y2), this.pathData = t, this
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(4),
					s = i(57);
				t.exports = function(t, e, i) {
					void 0 === i && (i = new n);
					var r = t.getLineA(),
						o = t.getLineB(),
						a = t.getLineC();
					if (e <= 0 || 1 <= e) return i.x = r.x1, i.y = r.y1, i;
					var h = s(r),
						u = s(o),
						l = s(a),
						c = (h + u + l) * e,
						d = 0;
					return c < h ? (d = c / h, i.x = r.x1 + (r.x2 - r.x1) * d, i.y = r.y1 + (r.y2 - r.y1) * d) : h + u < c ? (d = (c -= h + u) / l, i.x = a.x1 + (a.x2 - a.x1) * d, i.y = a.y1 + (a.y2 - a.y1) * d) : (d = (c -= h) / u, i.x = o.x1 + (o.x2 - o.x1) * d, i.y = o.y1 + (o.y2 - o.y1) * d), i
				}
			}, function(t, e, i) {
				var n = i(57),
					s = i(4);
				t.exports = function(t, e, i, r) {
					void 0 === r && (r = []);
					var o = t.getLineA(),
						a = t.getLineB(),
						h = t.getLineC(),
						u = n(o),
						l = n(a),
						c = n(h),
						d = u + l + c;
					!e && 0 < i && (e = d / i);
					for (var f = 0; f < e; f++) {
						var p = d * (f / e),
							g = 0,
							v = new s;
						p < u ? (g = p / u, v.x = o.x1 + (o.x2 - o.x1) * g, v.y = o.y1 + (o.y2 - o.y1) * g) : u + l < p ? (g = (p -= u + l) / c, v.x = h.x1 + (h.x2 - h.x1) * g, v.y = h.y1 + (h.y2 - h.y1) * g) : (g = (p -= u) / l, v.x = a.x1 + (a.x2 - a.x1) * g, v.y = a.y1 + (a.y2 - a.y1) * g), r.push(v)
					}
					return r
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					if (!t || "number" == typeof t) return !1;
					if (t.hasOwnProperty(e)) return t[e] = i, !0;
					if (-1 === e.indexOf(".")) return !1;
					for (var n = e.split("."), s = t, r = t, o = 0; o < n.length; o++) {
						if (!s.hasOwnProperty(n[o])) return !1;
						s = (r = s)[n[o]]
					}
					return r[n[n.length - 1]] = i, !0
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(9),
					r = new n({
						initialize: function(t, e, i, n, s, r, o) {
							this.x = t, this.y = e, this.radius = i, this.r = n, this.g = s, this.b = r, this.intensity = o, this.scrollFactorX = 1, this.scrollFactorY = 1
						},
						set: function(t, e, i, n, s, r, o) {
							return this.x = t, this.y = e, this.radius = i, this.r = n, this.g = s, this.b = r, this.intensity = o, this.scrollFactorX = 1, this.scrollFactorY = 1, this
						},
						setScrollFactor: function(t, e) {
							return void 0 === t && (t = 1), void 0 === e && (e = t), this.scrollFactorX = t, this.scrollFactorY = e, this
						},
						setColor: function(t) {
							var e = s.getFloatsFromUintRGB(t);
							return this.r = e[0], this.g = e[1], this.b = e[2], this
						},
						setIntensity: function(t) {
							return this.intensity = t, this
						},
						setPosition: function(t, e) {
							return this.x = t, this.y = e, this
						},
						setRadius: function(t) {
							return this.radius = t, this
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = i(0),
					s = i(428),
					r = i(9),
					o = new n({
						initialize: function() {
							this.lightPool = [], this.lights = [], this.culledLights = [], this.ambientColor = {
								r: .1,
								g: .1,
								b: .1
							}, this.active = !1, this.maxLights = -1
						},
						enable: function() {
							return -1 === this.maxLights && (this.maxLights = this.scene.sys.game.renderer.config.maxLights), this.active = !0, this
						},
						disable: function() {
							return this.active = !1, this
						},
						cull: function(t) {
							for (var e = this.lights, i = this.culledLights, n = e.length, s = t.x + t.width / 2, r = t.y + t.height / 2, o = (t.width + t.height) / 2, a = {
									x: 0,
									y: 0
								}, h = t.matrix, u = this.systems.game.config.height, l = i.length = 0; l < n && i.length < this.maxLights; l++) {
								var c = e[l];
								h.transformPoint(c.x, c.y, a);
								var d = s - (a.x - t.scrollX * c.scrollFactorX * t.zoom),
									f = r - (u - (a.y - t.scrollY * c.scrollFactorY * t.zoom));
								Math.sqrt(d * d + f * f) < c.radius + o && i.push(e[l])
							}
							return i
						},
						forEachLight: function(t) {
							if (t) {
								for (var e = this.lights, i = e.length, n = 0; n < i; ++n) t(e[n]);
								return this
							}
						},
						setAmbientColor: function(t) {
							var e = r.getFloatsFromUintRGB(t);
							return this.ambientColor.r = e[0], this.ambientColor.g = e[1], this.ambientColor.b = e[2], this
						},
						getMaxVisibleLights: function() {
							return 10
						},
						getLightCount: function() {
							return this.lights.length
						},
						addLight: function(t, e, i, n, o) {
							var a, h = null;
							return t = void 0 === t ? 0 : t, e = void 0 === e ? 0 : e, n = void 0 === n ? 16777215 : n, i = void 0 === i ? 100 : i, o = void 0 === o ? 1 : o, a = r.getFloatsFromUintRGB(n), h = null, 0 < this.lightPool.length ? (h = this.lightPool.pop()).set(t, e, i, a[0], a[1], a[2], o) : h = new s(t, e, i, a[0], a[1], a[2], o), this.lights.push(h), h
						},
						removeLight: function(t) {
							var e = this.lights.indexOf(t);
							return 0 <= e && (this.lightPool.push(t), this.lights.splice(e, 1)), this
						},
						shutdown: function() {
							for (; 0 < this.lights.length;) this.lightPool.push(this.lights.pop());
							this.ambientColor = {
								r: .1,
								g: .1,
								b: .1
							}, this.culledLights.length = 0, this.lights.length = 0
						},
						destroy: function() {
							this.shutdown()
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(47),
					s = i(18)(!1, s = {
						Circle: i(1090),
						Ellipse: i(1100),
						Intersects: i(431),
						Line: i(1119),
						Point: i(1141),
						Polygon: i(1155),
						Rectangle: i(444),
						Triangle: i(1186)
					}, n);
				t.exports = s
			}, function(t, e, i) {
				t.exports = {
					CircleToCircle: i(205),
					CircleToRectangle: i(206),
					GetCircleToCircle: i(1110),
					GetCircleToRectangle: i(1111),
					GetLineToCircle: i(207),
					GetLineToRectangle: i(209),
					GetRectangleIntersection: i(1112),
					GetRectangleToRectangle: i(1113),
					GetRectangleToTriangle: i(1114),
					GetTriangleToCircle: i(1115),
					GetTriangleToLine: i(436),
					GetTriangleToTriangle: i(1116),
					LineToCircle: i(208),
					LineToLine: i(84),
					LineToRectangle: i(432),
					PointToLine: i(440),
					PointToLineSegment: i(1117),
					RectangleToRectangle: i(135),
					RectangleToTriangle: i(433),
					RectangleToValues: i(1118),
					TriangleToCircle: i(435),
					TriangleToLine: i(437),
					TriangleToTriangle: i(438)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = t.x1,
						n = t.y1,
						s = t.x2,
						r = t.y2,
						o = e.x,
						a = e.y,
						h = e.right,
						u = e.bottom,
						l = 0;
					if (o <= i && i <= h && a <= n && n <= u || o <= s && s <= h && a <= r && r <= u) return !0;
					if (i < o && o <= s) {
						if (a < (l = n + (r - n) * (o - i) / (s - i)) && l <= u) return !0
					} else if (h < i && s <= h && a <= (l = n + (r - n) * (h - i) / (s - i)) && l <= u) return !0;
					if (n < a && a <= r) {
						if (o <= (l = i + (s - i) * (a - n) / (r - n)) && l <= h) return !0
					} else if (u < n && r <= u && o <= (l = i + (s - i) * (u - n) / (r - n)) && l <= h) return !0;
					return !1
				}
			}, function(t, e, i) {
				var n = i(84),
					s = i(48),
					r = i(210),
					o = i(434);
				t.exports = function(t, e) {
					if (e.left > t.right || e.right < t.left || e.top > t.bottom || e.bottom < t.top) return !1;
					var i = e.getLineA(),
						a = e.getLineB(),
						h = e.getLineC();
					if (s(t, i.x1, i.y1) || s(t, i.x2, i.y2)) return !0;
					if (s(t, a.x1, a.y1) || s(t, a.x2, a.y2)) return !0;
					if (s(t, h.x1, h.y1) || s(t, h.x2, h.y2)) return !0;
					var u = t.getLineA(),
						l = t.getLineB(),
						c = t.getLineC(),
						d = t.getLineD();
					if (n(i, u) || n(i, l) || n(i, c) || n(i, d)) return !0;
					if (n(a, u) || n(a, l) || n(a, c) || n(a, d)) return !0;
					if (n(h, u) || n(h, l) || n(h, c) || n(h, d)) return !0;
					var f = o(t);
					return 0 < r(e, f, !0).length
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return void 0 === e && (e = []), e.push({
						x: t.x,
						y: t.y
					}), e.push({
						x: t.right,
						y: t.y
					}), e.push({
						x: t.right,
						y: t.bottom
					}), e.push({
						x: t.x,
						y: t.bottom
					}), e
				}
			}, function(t, e, i) {
				var n = i(208),
					s = i(83);
				t.exports = function(t, e) {
					return !(t.left > e.right || t.right < e.left || t.top > e.bottom || t.bottom < e.top || !s(t, e.x, e.y) && !n(t.getLineA(), e) && !n(t.getLineB(), e) && !n(t.getLineC(), e))
				}
			}, function(t, e, i) {
				var n = i(4),
					s = i(437),
					r = i(84);
				t.exports = function(t, e, i) {
					if (void 0 === i && (i = []), s(t, e))
						for (var o = t.getLineA(), a = t.getLineB(), h = t.getLineC(), u = [new n, new n, new n], l = [r(o, e, u[0]), r(a, e, u[1]), r(h, e, u[2])], c = 0; c < 3; c++) l[c] && i.push(u[c]);
					return i
				}
			}, function(t, e, i) {
				var n = i(83),
					s = i(84);
				t.exports = function(t, e) {
					return !!(n(t, e.getPointA()) || n(t, e.getPointB()) || s(t.getLineA(), e) || s(t.getLineB(), e) || s(t.getLineC(), e))
				}
			}, function(t, e, i) {
				var n = i(210),
					s = i(439),
					r = i(84);
				t.exports = function(t, e) {
					if (t.left > e.right || t.right < e.left || t.top > e.bottom || t.bottom < e.top) return !1;
					var i = t.getLineA(),
						o = t.getLineB(),
						a = t.getLineC(),
						h = e.getLineA(),
						u = e.getLineB(),
						l = e.getLineC();
					if (r(i, h) || r(i, u) || r(i, l)) return !0;
					if (r(o, h) || r(o, u) || r(o, l)) return !0;
					if (r(a, h) || r(a, u) || r(a, l)) return !0;
					var c = s(t);
					return 0 < n(e, c, !0).length || (c = s(e), 0 < n(t, c, !0).length)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return void 0 === e && (e = []), e.push({
						x: t.x1,
						y: t.y1
					}), e.push({
						x: t.x2,
						y: t.y2
					}), e.push({
						x: t.x3,
						y: t.y3
					}), e
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					void 0 === i && (i = 1);
					var n = e.x1,
						s = e.y1,
						r = e.x2,
						o = e.y2,
						a = t.x,
						h = t.y,
						u = (r - n) * (r - n) + (o - s) * (o - s);
					if (0 == u) return !1;
					var l = ((a - n) * (r - n) + (h - s) * (o - s)) / u;
					if (l < 0) return Math.sqrt((n - a) * (n - a) + (s - h) * (s - h)) <= i;
					if (0 <= l && l <= 1) {
						var c = ((s - h) * (r - n) - (n - a) * (o - s)) / u;
						return Math.abs(c) * Math.sqrt(u) <= i
					}
					return Math.sqrt((r - a) * (r - a) + (o - h) * (o - h)) <= i
				}
			}, function(t, e, i) {
				var n = i(13),
					s = i(58),
					r = i(85);
				t.exports = function(t) {
					var e = r(t) - n.TAU;
					return s(e, -Math.PI, Math.PI)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return Math.sqrt(t.x * t.x + t.y * t.y)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.x * t.x + t.y * t.y
				}
			}, function(t, e, i) {
				var n = i(11);
				n.Area = i(1160), n.Ceil = i(1161), n.CeilAll = i(1162), n.CenterOn = i(168), n.Clone = i(1163), n.Contains = i(48), n.ContainsPoint = i(1164), n.ContainsRect = i(445), n.CopyFrom = i(1165), n.Decompose = i(434), n.Equals = i(1166), n.FitInside = i(1167), n.FitOutside = i(1168), n.Floor = i(1169), n.FloorAll = i(1170), n.FromPoints = i(176), n.FromXY = i(1171), n.GetAspectRatio = i(212), n.GetCenter = i(1172), n.GetPoint = i(152), n.GetPoints = i(274), n.GetSize = i(1173), n.Inflate = i(1174), n.Intersection = i(1175), n.MarchingAnts = i(285), n.MergePoints = i(1176), n.MergeRect = i(1177), n.MergeXY = i(1178), n.Offset = i(1179), n.OffsetPoint = i(1180), n.Overlaps = i(1181), n.Perimeter = i(112), n.PerimeterPoint = i(1182), n.Random = i(155), n.RandomOutside = i(1183), n.SameDimensions = i(1184), n.Scale = i(1185), n.Union = i(394), t.exports = n
			}, function(t, e) {
				t.exports = function(t, e) {
					return !(e.width * e.height > t.width * t.height) && e.x > t.x && e.x < t.right && e.right > t.x && e.right < t.right && e.y > t.y && e.y < t.bottom && e.bottom > t.y && e.bottom < t.bottom
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e) {
					return void 0 === e && (e = new n), e.x = (t.x1 + t.x2 + t.x3) / 3, e.y = (t.y1 + t.y2 + t.y3) / 3, e
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return t.x1 += e, t.y1 += i, t.x2 += e, t.y2 += i, t.x3 += e, t.y3 += i, t
				}
			}, function(t, e, i) {
				var n = i(4);

				function s(t, e, i, n) {
					var s = t - i,
						r = e - n,
						o = s * s + r * r;
					return Math.sqrt(o)
				}
				t.exports = function(t, e) {
					void 0 === e && (e = new n);
					var i = t.x1,
						r = t.y1,
						o = t.x2,
						a = t.y2,
						h = t.x3,
						u = t.y3,
						l = s(h, u, o, a),
						c = s(i, r, h, u),
						d = s(o, a, i, r),
						f = l + c + d;
					return e.x = (i * l + o * c + h * d) / f, e.y = (r * l + a * c + u * d) / f, e
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return {
						gameObject: t,
						enabled: !0,
						alwaysEnabled: !1,
						draggable: !1,
						dropZone: !1,
						cursor: !1,
						target: null,
						camera: null,
						hitArea: e,
						hitAreaCallback: i,
						hitAreaDebug: null,
						customHitArea: !1,
						localX: 0,
						localY: 0,
						dragState: 0,
						dragStartX: 0,
						dragStartY: 0,
						dragStartXGlobal: 0,
						dragStartYGlobal: 0,
						dragX: 0,
						dragY: 0
					}
				}
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t, e) {
						this.pad = t, this.events = t.events, this.index = e, this.value = 0, this.threshold = .1
					},
					update: function(t) {
						this.value = t
					},
					getValue: function() {
						return Math.abs(this.value) < this.threshold ? 0 : this.value
					},
					destroy: function() {
						this.pad = null, this.events = null
					}
				});
				t.exports = n
			}, function(t, e, i) {
				var n = i(0),
					s = i(214),
					r = new n({
						initialize: function(t, e) {
							this.pad = t, this.events = t.manager, this.index = e, this.value = 0, this.threshold = 1, this.pressed = !1
						},
						update: function(t) {
							this.value = t;
							var e = this.pad,
								i = this.index;
							t >= this.threshold ? this.pressed || (this.pressed = !0, this.events.emit(s.BUTTON_DOWN, e, this, t), this.pad.emit(s.GAMEPAD_BUTTON_DOWN, i, t, this)) : this.pressed && (this.pressed = !1, this.events.emit(s.BUTTON_UP, e, this, t), this.pad.emit(s.GAMEPAD_BUTTON_UP, i, t, this))
						},
						destroy: function() {
							this.pad = null, this.events = null
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = i(450),
					s = i(451),
					r = i(0),
					o = i(10),
					a = i(3),
					h = new r({
						Extends: o,
						initialize: function(t, e) {
							o.call(this), this.manager = t, this.pad = e, this.id = e.id, this.index = e.index;
							for (var i = [], r = 0; r < e.buttons.length; r++) i.push(new s(this, r));
							this.buttons = i;
							var h = [];
							for (r = 0; r < e.axes.length; r++) h.push(new n(this, r));
							this.axes = h, this.vibration = e.vibrationActuator;
							var u = {
								value: 0,
								pressed: !1
							};
							this._LCLeft = i[14] ? i[14] : u, this._LCRight = i[15] ? i[15] : u, this._LCTop = i[12] ? i[12] : u, this._LCBottom = i[13] ? i[13] : u, this._RCLeft = i[2] ? i[2] : u, this._RCRight = i[1] ? i[1] : u, this._RCTop = i[3] ? i[3] : u, this._RCBottom = i[0] ? i[0] : u, this._FBLeftTop = i[4] ? i[4] : u, this._FBLeftBottom = i[6] ? i[6] : u, this._FBRightTop = i[5] ? i[5] : u, this._FBRightBottom = i[7] ? i[7] : u;
							var l = {
								value: 0
							};
							this._HAxisLeft = h[0] ? h[0] : l, this._VAxisLeft = h[1] ? h[1] : l, this._HAxisRight = h[2] ? h[2] : l, this._VAxisRight = h[3] ? h[3] : l, this.leftStick = new a, this.rightStick = new a
						},
						getAxisTotal: function() {
							return this.axes.length
						},
						getAxisValue: function(t) {
							return this.axes[t].getValue()
						},
						setAxisThreshold: function(t) {
							for (var e = 0; e < this.axes.length; e++) this.axes[e].threshold = t
						},
						getButtonTotal: function() {
							return this.buttons.length
						},
						getButtonValue: function(t) {
							return this.buttons[t].value
						},
						isButtonDown: function(t) {
							return this.buttons[t].pressed
						},
						update: function(t) {
							for (var e = this.buttons, i = t.buttons, n = e.length, s = 0; s < n; s++) e[s].update(i[s].value);
							var r = this.axes,
								o = t.axes;
							n = r.length;
							for (s = 0; s < n; s++) r[s].update(o[s]);
							2 <= n && (this.leftStick.set(r[0].getValue(), r[1].getValue()), 4 <= n && this.rightStick.set(r[2].getValue(), r[3].getValue()))
						},
						destroy: function() {
							var t;
							for (this.removeAllListeners(), this.manager = null, this.pad = null, t = 0; t < this.buttons.length; t++) this.buttons[t].destroy();
							for (t = 0; t < this.axes.length; t++) this.axes[t].destroy();
							this.buttons = [], this.axes = []
						},
						connected: {
							get: function() {
								return this.pad.connected
							}
						},
						timestamp: {
							get: function() {
								return this.pad.timestamp
							}
						},
						left: {
							get: function() {
								return this._LCLeft.pressed
							}
						},
						right: {
							get: function() {
								return this._LCRight.pressed
							}
						},
						up: {
							get: function() {
								return this._LCTop.pressed
							}
						},
						down: {
							get: function() {
								return this._LCBottom.pressed
							}
						},
						A: {
							get: function() {
								return this._RCBottom.pressed
							}
						},
						Y: {
							get: function() {
								return this._RCTop.pressed
							}
						},
						X: {
							get: function() {
								return this._RCLeft.pressed
							}
						},
						B: {
							get: function() {
								return this._RCRight.pressed
							}
						},
						L1: {
							get: function() {
								return this._FBLeftTop.value
							}
						},
						L2: {
							get: function() {
								return this._FBLeftBottom.value
							}
						},
						R1: {
							get: function() {
								return this._FBRightTop.value
							}
						},
						R2: {
							get: function() {
								return this._FBRightBottom.value
							}
						}
					});
				t.exports = h
			}, function(t, e, i) {
				var n = i(0),
					s = i(10),
					r = i(137),
					o = new n({
						Extends: s,
						initialize: function(t, e) {
							s.call(this), this.plugin = t, this.keyCode = e, this.originalEvent = void 0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.metaKey = !1, this.location = 0, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.emitOnRepeat = !1, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1
						},
						setEmitOnRepeat: function(t) {
							return this.emitOnRepeat = t, this
						},
						onDown: function(t) {
							this.originalEvent = t, this.enabled && (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.metaKey = t.metaKey, this.location = t.location, this.repeats++, this.isDown ? this.emitOnRepeat && this.emit(r.DOWN, this, t) : (this.isDown = !0, this.isUp = !1, this.timeDown = t.timeStamp, this.duration = 0, this._justDown = !0, this._justUp = !1, this.emit(r.DOWN, this, t)))
						},
						onUp: function(t) {
							this.originalEvent = t, this.enabled && (this.isDown = !1, this.isUp = !0, this.timeUp = t.timeStamp, this.duration = this.timeUp - this.timeDown, this.repeats = 0, this._justDown = !1, this._justUp = !0, this._tick = -1, this.emit(r.UP, this, t))
						},
						reset: function() {
							return this.preventDefault = !0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.metaKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1, this
						},
						getDuration: function() {
							return this.isDown ? this.plugin.game.loop.time - this.timeDown : 0
						},
						destroy: function() {
							this.removeAllListeners(), this.originalEvent = null, this.plugin = null
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(0),
					s = i(137),
					r = i(2),
					o = i(1225),
					a = i(1227),
					h = new n({
						initialize: function(t, e, i) {
							if (void 0 === i && (i = {}), e.length < 2) return !1;
							this.manager = t, this.enabled = !0, this.keyCodes = [];
							for (var n = 0; n < e.length; n++) {
								var h = e[n];
								"string" == typeof h ? this.keyCodes.push(h.toUpperCase().charCodeAt(0)) : "number" == typeof h ? this.keyCodes.push(h) : h.hasOwnProperty("keyCode") && this.keyCodes.push(h.keyCode)
							}
							this.current = this.keyCodes[0], this.index = 0, this.size = this.keyCodes.length, this.timeLastMatched = 0, this.matched = !1, this.timeMatched = 0, this.resetOnWrongKey = r(i, "resetOnWrongKey", !0), this.maxKeyDelay = r(i, "maxKeyDelay", 0), this.resetOnMatch = r(i, "resetOnMatch", !1), this.deleteOnMatch = r(i, "deleteOnMatch", !1);
							var u = this;
							this.onKeyDown = function(t) {
								!u.matched && u.enabled && o(t, u) && (u.manager.emit(s.COMBO_MATCH, u, t), u.resetOnMatch ? a(u) : u.deleteOnMatch && u.destroy())
							}, this.manager.on(s.ANY_KEY_DOWN, this.onKeyDown)
						},
						progress: {
							get: function() {
								return this.index / this.size
							}
						},
						destroy: function() {
							this.enabled = !1, this.keyCodes = [], this.manager.off(s.ANY_KEY_DOWN, this.onKeyDown), this.manager = null
						}
					});
				t.exports = h
			}, function(t, e, i) {
				var n = i(215);
				t.exports = function(t, e) {
					var i = n(e, t.xhrSettings),
						s = new XMLHttpRequest;
					if (s.open("GET", t.src, i.async, i.user, i.password), s.responseType = t.xhrSettings.responseType, s.timeout = i.timeout, i.headers)
						for (var r in i.headers) s.setRequestHeader(r, i.headers[r]);
					return i.header && i.headerValue && s.setRequestHeader(i.header, i.headerValue), i.requestedWith && s.setRequestHeader("X-Requested-With", i.requestedWith), i.overrideMimeType && s.overrideMimeType(i.overrideMimeType), i.withCredentials && (s.withCredentials = !0), s.onload = t.onLoad.bind(t, s), s.onerror = t.onError.bind(t, s), s.onprogress = t.onProgress.bind(t), s.send(), s
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(457),
					u = i(7),
					l = new n({
						Extends: r,
						initialize: function(t, e, i, n, s) {
							var o;
							u(e) && (e = a(o = e, "key"), n = a(o, "xhrSettings"), s = a(o, "context", s));
							var h = {
								type: "audio",
								cache: t.cacheManager.audio,
								extension: i.type,
								responseType: "arraybuffer",
								key: e,
								url: i.url,
								xhrSettings: n,
								config: {
									context: s
								}
							};
							r.call(this, t, h)
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING;
							var t = this;
							this.config.context.decodeAudioData(this.xhrLoader.response, function(e) {
								t.data = e, t.onProcessComplete()
							}, function(e) {
								console.error("Error decoding audio: " + t.key + " - ", e ? e.message : null), t.onProcessError()
							}), this.config.context = null
						}
					});
				l.create = function(t, e, i, n, s) {
					var r = t.systems.game,
						o = r.config.audio,
						c = r.device.audio;
					u(e) && (i = a(e, "url", []), n = a(e, "config", {}));
					var d = l.getAudioURL(r, i);
					return d ? !c.webAudio || o && o.disableWebAudio ? new h(t, e, d, n) : new l(t, e, d, s, r.sound.context) : null
				}, l.getAudioURL = function(t, e) {
					Array.isArray(e) || (e = [e]);
					for (var i = 0; i < e.length; i++) {
						var n = a(e[i], "url", e[i]);
						if (0 === n.indexOf("blob:") || 0 === n.indexOf("data:")) return {
							url: n,
							type: ""
						};
						var s = n.match(/\.([a-zA-Z0-9]+)($|\?)/);
						s = a(e[i], "type", s ? s[1] : "").toLowerCase();
						if (t.device.audio[s]) return {
							url: n,
							type: s
						}
					}
					return null
				}, o.register("audio", function(t, e, i, n) {
					var s, r = this.systems.game,
						o = r.config.audio,
						a = r.device.audio;
					if (o && o.noAudio || !a.webAudio && !a.audioData) return this;
					if (Array.isArray(t))
						for (var h = 0; h < t.length; h++)(s = l.create(this, t[h])) && this.addFile(s);
					else(s = l.create(this, t, e, i, n)) && this.addFile(s);
					return this
				}), t.exports = l
			}, function(t, e, i) {
				var n = i(0),
					s = i(82),
					r = i(21),
					o = i(2),
					a = i(138),
					h = i(7),
					u = new n({
						Extends: r,
						initialize: function(t, e, i, n) {
							var s;
							h(e) && (e = o(s = e, "key"), n = o(s, "config", n));
							var a = {
								type: "audio",
								cache: t.cacheManager.audio,
								extension: i.type,
								key: e,
								url: i.url,
								config: n
							};
							r.call(this, t, a), this.locked = "ontouchstart" in window, this.loaded = !1, this.filesLoaded = 0, this.filesTotal = 0
						},
						onLoad: function() {
							this.loaded || (this.loaded = !0, this.loader.nextFile(this, !0))
						},
						onError: function() {
							for (var t = 0; t < this.data.length; t++) {
								var e = this.data[t];
								e.oncanplaythrough = null, e.onerror = null
							}
							this.loader.nextFile(this, !1)
						},
						onProgress: function(t) {
							var e = t.target;
							e.oncanplaythrough = null, e.onerror = null, this.filesLoaded++, this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1), this.loader.emit(s.FILE_PROGRESS, this, this.percentComplete), this.filesLoaded === this.filesTotal && this.onLoad()
						},
						load: function() {
							this.data = [];
							var t = this.config && this.config.instances || 1;
							this.filesTotal = t, this.filesLoaded = 0;
							for (var e = this.percentComplete = 0; e < t; e++) {
								var i = new Audio;
								i.dataset || (i.dataset = {}), i.dataset.name = this.key + ("0" + e).slice(-2), i.dataset.used = "false", this.locked ? i.dataset.locked = "true" : (i.dataset.locked = "false", i.preload = "auto", i.oncanplaythrough = this.onProgress.bind(this), i.onerror = this.onError.bind(this)), this.data.push(i)
							}
							for (e = 0; e < this.data.length; e++)(i = this.data[e]).src = a(this, this.loader.baseURL), this.locked || i.load();
							this.locked && setTimeout(this.onLoad.bind(this))
						}
					});
				t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = new n({
						Extends: r,
						initialize: function(t, e, i, n) {
							var s, o = "js";
							h(e) && (e = a(s = e, "key"), i = a(s, "url"), n = a(s, "xhrSettings"), o = a(s, "extension", o));
							var u = {
								type: "script",
								cache: !1,
								extension: o,
								responseType: "text",
								key: e,
								url: i,
								xhrSettings: n
							};
							r.call(this, t, u)
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING, this.data = document.createElement("script"), this.data.language = "javascript", this.data.type = "text/javascript", this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete()
						}
					});
				o.register("script", function(t, e, i) {
					if (Array.isArray(t))
						for (var n = 0; n < t.length; n++) this.addFile(new u(this, t[n]));
					else this.addFile(new u(this, t, e, i));
					return this
				}), t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = new n({
						Extends: r,
						initialize: function(t, e, i, n) {
							var s, o = "txt";
							h(e) && (e = a(s = e, "key"), i = a(s, "url"), n = a(s, "xhrSettings"), o = a(s, "extension", o));
							var u = {
								type: "text",
								cache: t.cacheManager.text,
								extension: o,
								responseType: "text",
								key: e,
								url: i,
								xhrSettings: n
							};
							r.call(this, t, u)
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete()
						}
					});
				o.register("text", function(t, e, i) {
					if (Array.isArray(t))
						for (var n = 0; n < t.length; n++) this.addFile(new u(this, t[n]));
					else this.addFile(new u(this, t, e, i));
					return this
				}), t.exports = u
			}, function(t, e, i) {
				var n = i(461),
					s = i(140),
					r = i(0),
					o = i(50),
					a = i(462),
					h = i(463),
					u = new r({
						initialize: function(t) {
							this.world = t, this.scene = t.scene, this.sys = t.scene.sys
						},
						collider: function(t, e, i, n, s) {
							return this.world.addCollider(t, e, i, n, s)
						},
						overlap: function(t, e, i, n, s) {
							return this.world.addOverlap(t, e, i, n, s)
						},
						existing: function(t, e) {
							var i = e ? o.STATIC_BODY : o.DYNAMIC_BODY;
							return this.world.enableBody(t, i), t
						},
						staticImage: function(t, e, i, s) {
							var r = new n(this.scene, t, e, i, s);
							return this.sys.displayList.add(r), this.world.enableBody(r, o.STATIC_BODY), r
						},
						image: function(t, e, i, s) {
							var r = new n(this.scene, t, e, i, s);
							return this.sys.displayList.add(r), this.world.enableBody(r, o.DYNAMIC_BODY), r
						},
						staticSprite: function(t, e, i, n) {
							var r = new s(this.scene, t, e, i, n);
							return this.sys.displayList.add(r), this.sys.updateList.add(r), this.world.enableBody(r, o.STATIC_BODY), r
						},
						sprite: function(t, e, i, n) {
							var r = new s(this.scene, t, e, i, n);
							return this.sys.displayList.add(r), this.sys.updateList.add(r), this.world.enableBody(r, o.DYNAMIC_BODY), r
						},
						staticGroup: function(t, e) {
							return this.sys.updateList.add(new h(this.world, this.world.scene, t, e))
						},
						group: function(t, e) {
							return this.sys.updateList.add(new a(this.world, this.world.scene, t, e))
						},
						destroy: function() {
							this.world = null, this.scene = null, this.sys = null
						}
					});
				t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(217),
					r = i(107),
					o = new n({
						Extends: r,
						Mixins: [s.Acceleration, s.Angular, s.Bounce, s.Debug, s.Drag, s.Enable, s.Friction, s.Gravity, s.Immovable, s.Mass, s.Size, s.Velocity],
						initialize: function(t, e, i, n, s) {
							r.call(this, t, e, i, n, s), this.body = null
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(140),
					s = i(0),
					r = i(50),
					o = i(2),
					a = i(97),
					h = i(7),
					u = new s({
						Extends: a,
						initialize: function(t, e, i, s) {
							var u;
							i || s ? h(i) ? (s = i, i = null, s.internalCreateCallback = this.createCallbackHandler, s.internalRemoveCallback = this.removeCallbackHandler) : Array.isArray(i) && h(i[0]) ? (s = i[0], u = this, i.forEach(function(t) {
								t.internalCreateCallback = u.createCallbackHandler, t.internalRemoveCallback = u.removeCallbackHandler
							}), i = null) : s = {
								internalCreateCallback: this.createCallbackHandler,
								internalRemoveCallback: this.removeCallbackHandler
							} : s = {
								internalCreateCallback: this.createCallbackHandler,
								internalRemoveCallback: this.removeCallbackHandler
							}, this.world = t, s.classType = o(s, "classType", n), this.physicsType = r.DYNAMIC_BODY, this.defaults = {
								setCollideWorldBounds: o(s, "collideWorldBounds", !1),
								setBoundsRectangle: o(s, "customBoundsRectangle", null),
								setAccelerationX: o(s, "accelerationX", 0),
								setAccelerationY: o(s, "accelerationY", 0),
								setAllowDrag: o(s, "allowDrag", !0),
								setAllowGravity: o(s, "allowGravity", !0),
								setAllowRotation: o(s, "allowRotation", !0),
								setBounceX: o(s, "bounceX", 0),
								setBounceY: o(s, "bounceY", 0),
								setDragX: o(s, "dragX", 0),
								setDragY: o(s, "dragY", 0),
								setEnable: o(s, "enable", !0),
								setGravityX: o(s, "gravityX", 0),
								setGravityY: o(s, "gravityY", 0),
								setFrictionX: o(s, "frictionX", 0),
								setFrictionY: o(s, "frictionY", 0),
								setVelocityX: o(s, "velocityX", 0),
								setVelocityY: o(s, "velocityY", 0),
								setAngularVelocity: o(s, "angularVelocity", 0),
								setAngularAcceleration: o(s, "angularAcceleration", 0),
								setAngularDrag: o(s, "angularDrag", 0),
								setMass: o(s, "mass", 1),
								setImmovable: o(s, "immovable", !1)
							}, a.call(this, e, i, s), this.type = "PhysicsGroup"
						},
						createCallbackHandler: function(t) {
							t.body || this.world.enableBody(t, r.DYNAMIC_BODY);
							var e = t.body;
							for (var i in this.defaults) e[i](this.defaults[i])
						},
						removeCallbackHandler: function(t) {
							t.body && this.world.disableBody(t)
						},
						setVelocity: function(t, e, i) {
							void 0 === i && (i = 0);
							for (var n = this.getChildren(), s = 0; s < n.length; s++) n[s].body.velocity.set(t + s * i, e + s * i);
							return this
						},
						setVelocityX: function(t, e) {
							void 0 === e && (e = 0);
							for (var i = this.getChildren(), n = 0; n < i.length; n++) i[n].body.velocity.x = t + n * e;
							return this
						},
						setVelocityY: function(t, e) {
							void 0 === e && (e = 0);
							for (var i = this.getChildren(), n = 0; n < i.length; n++) i[n].body.velocity.y = t + n * e;
							return this
						}
					});
				t.exports = u
			}, function(t, e, i) {
				var n = i(140),
					s = i(0),
					r = i(50),
					o = i(2),
					a = i(97),
					h = i(7),
					u = new s({
						Extends: a,
						initialize: function(t, e, i, s) {
							i || s ? h(i) ? (s = i, i = null, s.internalCreateCallback = this.createCallbackHandler, s.internalRemoveCallback = this.removeCallbackHandler, s.createMultipleCallback = this.createMultipleCallbackHandler, s.classType = o(s, "classType", n)) : Array.isArray(i) && h(i[0]) ? (s = i, i = null, s.forEach(function(t) {
								t.internalCreateCallback = this.createCallbackHandler, t.internalRemoveCallback = this.removeCallbackHandler, t.createMultipleCallback = this.createMultipleCallbackHandler, t.classType = o(t, "classType", n)
							})) : s = {
								internalCreateCallback: this.createCallbackHandler,
								internalRemoveCallback: this.removeCallbackHandler
							} : s = {
								internalCreateCallback: this.createCallbackHandler,
								internalRemoveCallback: this.removeCallbackHandler,
								createMultipleCallback: this.createMultipleCallbackHandler,
								classType: n
							}, this.world = t, this.physicsType = r.STATIC_BODY, a.call(this, e, i, s), this.type = "StaticPhysicsGroup"
						},
						createCallbackHandler: function(t) {
							t.body || this.world.enableBody(t, r.STATIC_BODY)
						},
						removeCallbackHandler: function(t) {
							t.body && this.world.disableBody(t)
						},
						createMultipleCallbackHandler: function() {
							this.refresh()
						},
						refresh: function() {
							for (var t = this.children.entries, e = 0; e < t.length; e++) t[e].body.reset();
							return this
						}
					});
				t.exports = u
			}, function(t, e) {
				t.exports = function(t, e, i, n, s, r, o) {
					void 0 === r && (r = !0), void 0 === o && (o = !1);
					var a, h, u, l = [],
						c = [],
						d = t.treeMinMax;
					return d.minX = e, d.minY = i, d.maxX = e + n, d.maxY = i + s, o && (c = t.staticTree.search(d)), r && t.useTree ? l = t.tree.search(d) : r && (a = t.bodies, h = {
						position: {
							x: e,
							y: i
						},
						left: e,
						top: i,
						right: e + n,
						bottom: i + s,
						isCircle: !1
					}, u = t.intersects, a.iterate(function(t) {
						u(t, h) && l.push(t)
					})), c.concat(l)
				}
			}, function(t, e, i) {
				var n = i(318),
					s = i(466),
					r = i(19),
					o = i(0),
					a = i(467),
					h = i(50),
					u = i(53),
					l = i(10),
					c = i(218),
					d = i(106),
					f = i(322),
					p = i(323),
					g = i(468),
					v = i(469),
					m = i(6),
					y = i(13),
					x = i(186),
					T = i(1284),
					w = i(11),
					E = i(470),
					_ = i(1285),
					b = i(1290),
					A = i(1291),
					S = i(133),
					C = i(472),
					M = i(471),
					O = i(29),
					P = i(3),
					R = i(58),
					L = new o({
						Extends: l,
						initialize: function(t, e) {
							l.call(this), this.scene = t, this.bodies = new S, this.staticBodies = new S, this.pendingDestroy = new S, this.colliders = new x, this.gravity = new P(m(e, "gravity.x", 0), m(e, "gravity.y", 0)), this.bounds = new w(m(e, "x", 0), m(e, "y", 0), m(e, "width", t.sys.scale.width), m(e, "height", t.sys.scale.height)), this.checkCollision = {
								up: m(e, "checkCollision.up", !0),
								down: m(e, "checkCollision.down", !0),
								left: m(e, "checkCollision.left", !0),
								right: m(e, "checkCollision.right", !0)
							}, this.fps = m(e, "fps", 60), this.fixedStep = !0, this._elapsed = 0, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this.stepsLastFrame = 0, this.timeScale = m(e, "timeScale", 1), this.OVERLAP_BIAS = m(e, "overlapBias", 4), this.TILE_BIAS = m(e, "tileBias", 16), this.forceX = m(e, "forceX", !1), this.isPaused = m(e, "isPaused", !1), this._total = 0, this.drawDebug = m(e, "debug", !1), this.debugGraphic, this.defaults = {
								debugShowBody: m(e, "debugShowBody", !0),
								debugShowStaticBody: m(e, "debugShowStaticBody", !0),
								debugShowVelocity: m(e, "debugShowVelocity", !0),
								bodyDebugColor: m(e, "debugBodyColor", 16711935),
								staticBodyDebugColor: m(e, "debugStaticBodyColor", 255),
								velocityDebugColor: m(e, "debugVelocityColor", 65280)
							}, this.maxEntries = m(e, "maxEntries", 16), this.useTree = m(e, "useTree", !0), this.tree = new E(this.maxEntries), this.staticTree = new E(this.maxEntries), this.treeMinMax = {
								minX: 0,
								minY: 0,
								maxX: 0,
								maxY: 0
							}, this._tempMatrix = new O, this._tempMatrix2 = new O, this.drawDebug && this.createDebugGraphic()
						},
						enable: function(t, e) {
							void 0 === e && (e = h.DYNAMIC_BODY), Array.isArray(t) || (t = [t]);
							for (var i = 0; i < t.length; i++) {
								var n = t[i];
								if (n.isParent)
									for (var s = n.getChildren(), r = 0; r < s.length; r++) {
										var o = s[r];
										o.isParent ? this.enable(o, e) : this.enableBody(o, e)
									} else this.enableBody(n, e)
							}
						},
						enableBody: function(t, e) {
							return void 0 === e && (e = h.DYNAMIC_BODY), t.body || (e === h.DYNAMIC_BODY ? t.body = new s(this, t) : e === h.STATIC_BODY && (t.body = new C(this, t))), this.add(t.body), t
						},
						add: function(t) {
							return t.physicsType === h.DYNAMIC_BODY ? this.bodies.set(t) : t.physicsType === h.STATIC_BODY && (this.staticBodies.set(t), this.staticTree.insert(t)), t.enable = !0, t
						},
						disable: function(t) {
							Array.isArray(t) || (t = [t]);
							for (var e = 0; e < t.length; e++) {
								var i = t[e];
								if (i.isParent)
									for (var n = i.getChildren(), s = 0; s < n.length; s++) {
										var r = n[s];
										r.isParent ? this.disable(r) : this.disableBody(r.body)
									} else this.disableBody(i.body)
							}
						},
						disableBody: function(t) {
							this.remove(t), t.enable = !1
						},
						remove: function(t) {
							t.physicsType === h.DYNAMIC_BODY ? (this.tree.remove(t), this.bodies.delete(t)) : t.physicsType === h.STATIC_BODY && (this.staticBodies.delete(t), this.staticTree.remove(t))
						},
						createDebugGraphic: function() {
							var t = this.scene.sys.add.graphics({
								x: 0,
								y: 0
							});
							return t.setDepth(Number.MAX_VALUE), this.debugGraphic = t, this.drawDebug = !0, t
						},
						setBounds: function(t, e, i, n, s, r, o, a) {
							return this.bounds.setTo(t, e, i, n), void 0 !== s && this.setBoundsCollision(s, r, o, a), this
						},
						setBoundsCollision: function(t, e, i, n) {
							return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === n && (n = !0), this.checkCollision.left = t, this.checkCollision.right = e, this.checkCollision.up = i, this.checkCollision.down = n, this
						},
						pause: function() {
							return this.isPaused = !0, this.emit(c.PAUSE), this
						},
						resume: function() {
							return this.isPaused = !1, this.emit(c.RESUME), this
						},
						addCollider: function(t, e, i, n, s) {
							void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i);
							var r = new a(this, !1, t, e, i, n, s);
							return this.colliders.add(r), r
						},
						addOverlap: function(t, e, i, n, s) {
							void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i);
							var r = new a(this, !0, t, e, i, n, s);
							return this.colliders.add(r), r
						},
						removeCollider: function(t) {
							return this.colliders.remove(t), this
						},
						setFPS: function(t) {
							return this.fps = t, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this
						},
						update: function(t, e) {
							if (!this.isPaused && 0 !== this.bodies.size) {
								var i, n = this._frameTime,
									s = this._frameTimeMS * this.timeScale;
								this._elapsed += e;
								var r = this.bodies.entries,
									o = this._elapsed >= s;
								for (this.fixedStep || (n = .001 * e, o = !0, this._elapsed = 0), h = 0; h < r.length; h++)(i = r[h]).enable && i.preUpdate(o, n);
								if (o) {
									this._elapsed -= s, this.stepsLastFrame = 1, this.useTree && (this.tree.clear(), this.tree.load(r));
									for (var a = this.colliders.update(), h = 0; h < a.length; h++) {
										var u = a[h];
										u.active && u.update()
									}
									this.emit(c.WORLD_STEP)
								}
								for (; this._elapsed >= s;) this._elapsed -= s, this.step(n)
							}
						},
						step: function(t) {
							for (var e, i = this.bodies.entries, n = i.length, s = 0; s < n; s++)(e = i[s]).enable && e.update(t);
							this.useTree && (this.tree.clear(), this.tree.load(i));
							var r = this.colliders.update();
							for (s = 0; s < r.length; s++) {
								var o = r[s];
								o.active && o.update()
							}
							this.emit(c.WORLD_STEP), this.stepsLastFrame++
						},
						postUpdate: function() {
							var t, e = (o = this.bodies.entries).length,
								i = this.bodies,
								n = this.staticBodies;
							if (this.stepsLastFrame)
								for (l = this.stepsLastFrame = 0; l < e; l++)(t = o[l]).enable && t.postUpdate();
							if (this.drawDebug) {
								var s = this.debugGraphic;
								for (s.clear(), l = 0; l < e; l++)(t = o[l]).willDrawDebug() && t.drawDebug(s);
								for (e = (o = n.entries).length, l = 0; l < e; l++)(t = o[l]).willDrawDebug() && t.drawDebug(s)
							}
							var r = this.pendingDestroy;
							if (0 < r.size) {
								for (var o, a = this.tree, u = this.staticTree, l = (e = (o = r.entries).length, 0); l < e; l++)(t = o[l]).physicsType === h.DYNAMIC_BODY ? (a.remove(t), i.delete(t)) : t.physicsType === h.STATIC_BODY && (u.remove(t), n.delete(t)), t.world = void 0, t.gameObject = void 0;
								r.clear()
							}
						},
						updateMotion: function(t, e) {
							t.allowRotation && this.computeAngularVelocity(t, e), this.computeVelocity(t, e)
						},
						computeAngularVelocity: function(t, e) {
							var i = t.angularVelocity,
								n = t.angularAcceleration,
								s = t.angularDrag,
								o = t.maxAngular;
							n ? i += n * e : t.allowDrag && s && (f(i - (s *= e), 0, .1) ? i -= s : p(i + s, 0, .1) ? i += s : i = 0);
							var a = (i = r(i, -o, o)) - t.angularVelocity;
							t.angularVelocity += a, t.rotation += t.angularVelocity * e
						},
						computeVelocity: function(t, e) {
							var i = t.velocity.x,
								n = t.acceleration.x,
								s = t.drag.x,
								o = t.maxVelocity.x,
								a = t.velocity.y,
								h = t.acceleration.y,
								u = t.drag.y,
								l = t.maxVelocity.y,
								c = t.speed,
								g = t.maxSpeed,
								v = t.allowDrag,
								m = t.useDamping;
							t.allowGravity && (i += (this.gravity.x + t.gravity.x) * e, a += (this.gravity.y + t.gravity.y) * e), n ? i += n * e : v && s && (m ? (i *= s, c = Math.sqrt(i * i + a * a), d(c, 0, .001) && (i = 0)) : f(i - (s *= e), 0, .01) ? i -= s : p(i + s, 0, .01) ? i += s : i = 0), h ? a += h * e : v && u && (m ? (a *= u, c = Math.sqrt(i * i + a * a), d(c, 0, .001) && (a = 0)) : f(a - (u *= e), 0, .01) ? a -= u : p(a + u, 0, .01) ? a += u : a = 0), i = r(i, -o, o), a = r(a, -l, l), t.velocity.set(i, a), -1 < g && g < c && (t.velocity.normalize().scale(g), c = g), t.speed = c
						},
						separate: function(t, e, i, n, s, r) {
							if (!r && !t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1;
							if (i && !1 === i.call(n, t.gameObject, e.gameObject)) return !1;
							if (t.isCircle && e.isCircle) return this.separateCircle(t, e, s);
							if (t.isCircle !== e.isCircle) {
								var o = t.isCircle ? e : t,
									a = t.isCircle ? t : e,
									h = o.x,
									u = o.y,
									l = o.right,
									d = o.bottom,
									f = a.center;
								if ((f.y < u || f.y > d) && (f.x < h || f.x > l)) return this.separateCircle(t, e, s)
							}
							var p = !1,
								g = !1;
							s ? (p = b(t, e, s, this.OVERLAP_BIAS), g = A(t, e, s, this.OVERLAP_BIAS)) : this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (p = b(t, e, s, this.OVERLAP_BIAS), this.intersects(t, e) && (g = A(t, e, s, this.OVERLAP_BIAS))) : (g = A(t, e, s, this.OVERLAP_BIAS), this.intersects(t, e) && (p = b(t, e, s, this.OVERLAP_BIAS)));
							var v = p || g;
							return v && (s ? (t.onOverlap || e.onOverlap) && this.emit(c.OVERLAP, t.gameObject, e.gameObject, t, e) : (t.onCollide || e.onCollide) && this.emit(c.COLLIDE, t.gameObject, e.gameObject, t, e)), v
						},
						separateCircle: function(t, e, i, s) {
							t.updateCenter(), e.updateCenter(), g(t, e, !1, s), v(t, e, !1, s);
							var r, o, a = 0;
							if (t.isCircle !== e.isCircle ? (r = {
									x: e.isCircle ? t.position.x : e.position.x,
									y: e.isCircle ? t.position.y : e.position.y,
									right: e.isCircle ? t.right : e.right,
									bottom: e.isCircle ? t.bottom : e.bottom
								}, (o = {
									x: t.isCircle ? t.center.x : e.center.x,
									y: t.isCircle ? t.center.y : e.center.y,
									radius: t.isCircle ? t.halfWidth : e.halfWidth
								}).y < r.y ? o.x < r.x ? a = u(o.x, o.y, r.x, r.y) - o.radius : r.right < o.x && (a = u(o.x, o.y, r.right, r.y) - o.radius) : r.bottom < o.y && (o.x < r.x ? a = u(o.x, o.y, r.x, r.bottom) - o.radius : r.right < o.x && (a = u(o.x, o.y, r.right, r.bottom) - o.radius)), a *= -1) : a = t.halfWidth + e.halfWidth - u(t.center.x, t.center.y, e.center.x, e.center.y), i || 0 === a || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== a && (t.onOverlap || e.onOverlap) && this.emit(c.OVERLAP, t.gameObject, e.gameObject, t, e), 0 !== a;
							var h = t.center.x - e.center.x,
								l = t.center.y - e.center.y,
								d = Math.sqrt(Math.pow(h, 2) + Math.pow(l, 2)),
								f = (e.center.x - t.center.x) / d || 0,
								p = (e.center.y - t.center.y) / d || 0,
								m = 2 * (t.velocity.x * f + t.velocity.y * p - e.velocity.x * f - e.velocity.y * p) / (t.mass + e.mass);
							(t.immovable || e.immovable) && (m *= 2), t.immovable || (t.velocity.x = t.velocity.x - m / t.mass * f, t.velocity.y = t.velocity.y - m / t.mass * p), e.immovable || (e.velocity.x = e.velocity.x + m / e.mass * f, e.velocity.y = e.velocity.y + m / e.mass * p), t.immovable || e.immovable || (a /= 2);
							var x = n(t.center, e.center),
								T = (a + y.EPSILON) * Math.cos(x),
								w = (a + y.EPSILON) * Math.sin(x);
							return t.immovable || (t.x -= T, t.y -= w, t.updateCenter()), e.immovable || (e.x += T, e.y += w, e.updateCenter()), t.velocity.x *= t.bounce.x, t.velocity.y *= t.bounce.y, e.velocity.x *= e.bounce.x, e.velocity.y *= e.bounce.y, (t.onCollide || e.onCollide) && this.emit(c.COLLIDE, t.gameObject, e.gameObject, t, e), !0
						},
						intersects: function(t, e) {
							return t !== e && (t.isCircle || e.isCircle ? t.isCircle ? e.isCircle ? u(t.center.x, t.center.y, e.center.x, e.center.y) <= t.halfWidth + e.halfWidth : this.circleBodyIntersects(t, e) : this.circleBodyIntersects(e, t) : !(t.right <= e.position.x || t.bottom <= e.position.y || t.position.x >= e.right || t.position.y >= e.bottom))
						},
						circleBodyIntersects: function(t, e) {
							var i = r(t.center.x, e.left, e.right),
								n = r(t.center.y, e.top, e.bottom);
							return (t.center.x - i) * (t.center.x - i) + (t.center.y - n) * (t.center.y - n) <= t.halfWidth * t.halfWidth
						},
						overlap: function(t, e, i, n, s) {
							return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.collideObjects(t, e, i, n, s, !0)
						},
						collide: function(t, e, i, n, s) {
							return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.collideObjects(t, e, i, n, s, !1)
						},
						collideObjects: function(t, e, i, n, s, r) {
							var o;
							t.isParent && void 0 === t.physicsType && (t = t.children.entries), e && e.isParent && void 0 === e.physicsType && (e = e.children.entries);
							var a = Array.isArray(t),
								h = Array.isArray(e);
							if (this._total = 0, a || h)
								if (!a && h)
									for (o = 0; o < e.length; o++) this.collideHandler(t, e[o], i, n, s, r);
								else if (a && !h)
								if (e)
									for (o = 0; o < t.length; o++) this.collideHandler(t[o], e, i, n, s, r);
								else
									for (o = 0; o < t.length; o++)
										for (var u = t[o], l = o + 1; l < t.length; l++) o !== l && this.collideHandler(u, t[l], i, n, s, r);
							else
								for (o = 0; o < t.length; o++)
									for (l = 0; l < e.length; l++) this.collideHandler(t[o], e[l], i, n, s, r);
							else this.collideHandler(t, e, i, n, s, r);
							return 0 < this._total
						},
						collideHandler: function(t, e, i, n, s, r) {
							if (void 0 === e && t.isParent) return this.collideGroupVsGroup(t, t, i, n, s, r);
							if (!t || !e) return !1;
							if (t.body) {
								if (e.body) return this.collideSpriteVsSprite(t, e, i, n, s, r);
								if (e.isParent) return this.collideSpriteVsGroup(t, e, i, n, s, r);
								if (e.isTilemap) return this.collideSpriteVsTilemapLayer(t, e, i, n, s, r)
							} else if (t.isParent) {
								if (e.body) return this.collideSpriteVsGroup(e, t, i, n, s, r);
								if (e.isParent) return this.collideGroupVsGroup(t, e, i, n, s, r);
								if (e.isTilemap) return this.collideGroupVsTilemapLayer(t, e, i, n, s, r)
							} else if (t.isTilemap) {
								if (e.body) return this.collideSpriteVsTilemapLayer(e, t, i, n, s, r);
								if (e.isParent) return this.collideGroupVsTilemapLayer(e, t, i, n, s, r)
							}
						},
						collideSpriteVsSprite: function(t, e, i, n, s, r) {
							return !(!t.body || !e.body || (this.separate(t.body, e.body, n, s, r) && (i && i.call(s, t, e), this._total++), 0))
						},
						collideSpriteVsGroup: function(t, e, i, n, s, r) {
							var o, a = t.body;
							if (0 !== e.length && a && a.enable && !a.checkCollision.none)
								if (this.useTree || e.physicsType === h.STATIC_BODY) {
									var u = this.treeMinMax;
									u.minX = a.left, u.minY = a.top, u.maxX = a.right, u.maxY = a.bottom;
									for (var l = e.physicsType === h.DYNAMIC_BODY ? this.tree.search(u) : this.staticTree.search(u), c = l.length, d = 0; d < c; d++) a !== (o = l[d]) && o.enable && !o.checkCollision.none && e.contains(o.gameObject) && this.separate(a, o, n, s, r, !0) && (i && i.call(s, a.gameObject, o.gameObject), this._total++)
								} else {
									var f = e.getChildren(),
										p = e.children.entries.indexOf(t);
									for (c = f.length, d = 0; d < c; d++)(o = f[d].body) && d !== p && o.enable && this.separate(a, o, n, s, r) && (i && i.call(s, a.gameObject, o.gameObject), this._total++)
								}
						},
						collideGroupVsTilemapLayer: function(t, e, i, n, s, r) {
							var o = t.getChildren();
							if (0 === o.length) return !1;
							for (var a = !1, h = 0; h < o.length; h++) o[h].body && this.collideSpriteVsTilemapLayer(o[h], e, i, n, s, r) && (a = !0);
							return a
						},
						collideTiles: function(t, e, i, n, s) {
							return !(!t.body.enable || 0 === e.length) && this.collideSpriteVsTilesHandler(t, e, i, n, s, !1, !1)
						},
						overlapTiles: function(t, e, i, n, s) {
							return !(!t.body.enable || 0 === e.length) && this.collideSpriteVsTilesHandler(t, e, i, n, s, !0, !1)
						},
						collideSpriteVsTilemapLayer: function(t, e, i, n, s, r) {
							var o = t.body;
							if (!o.enable || o.checkCollision.none) return !1;
							var a, h = o.position.x,
								u = o.position.y,
								l = o.width,
								c = o.height,
								d = e.layer;
							d.tileWidth > d.baseTileWidth && (h -= a = (d.tileWidth - d.baseTileWidth) * e.scaleX, l += a), d.tileHeight > d.baseTileHeight && (c += (d.tileHeight - d.baseTileHeight) * e.scaleY);
							var f = e.getTilesWithinWorldXY(h, u, l, c);
							return 0 !== f.length && this.collideSpriteVsTilesHandler(t, f, i, n, s, r, !0)
						},
						collideSpriteVsTilesHandler: function(t, e, i, n, s, r, o) {
							for (var a, h, u = t.body, l = {
									left: 0,
									right: 0,
									top: 0,
									bottom: 0
								}, d = !1, f = 0; f < e.length; f++) h = (a = e[f]).tilemapLayer, l.left = h.tileToWorldX(a.x), l.top = h.tileToWorldY(a.y), a.baseHeight !== a.height && (l.top -= (a.height - a.baseHeight) * h.scaleY), l.right = l.left + a.width * h.scaleX, l.bottom = l.top + a.height * h.scaleY, M(l, u) && (!n || n.call(s, t, a)) && T(a, t) && (r || _(f, u, a, l, h, this.TILE_BIAS, o)) && (this._total++, d = !0, i && i.call(s, t, a), r && u.onOverlap ? this.emit(c.TILE_OVERLAP, t, a, u) : u.onCollide && this.emit(c.TILE_COLLIDE, t, a, u));
							return d
						},
						collideGroupVsGroup: function(t, e, i, n, s, r) {
							if (0 !== t.length && 0 !== e.length)
								for (var o = t.getChildren(), a = 0; a < o.length; a++) this.collideSpriteVsGroup(o[a], e, i, n, s, r)
						},
						wrap: function(t, e) {
							t.body ? this.wrapObject(t, e) : t.getChildren ? this.wrapArray(t.getChildren(), e) : Array.isArray(t) ? this.wrapArray(t, e) : this.wrapObject(t, e)
						},
						wrapArray: function(t, e) {
							for (var i = 0; i < t.length; i++) this.wrapObject(t[i], e)
						},
						wrapObject: function(t, e) {
							void 0 === e && (e = 0), t.x = R(t.x, this.bounds.left - e, this.bounds.right + e), t.y = R(t.y, this.bounds.top - e, this.bounds.bottom + e)
						},
						shutdown: function() {
							this.tree.clear(), this.staticTree.clear(), this.bodies.clear(), this.staticBodies.clear(), this.colliders.destroy(), this.removeAllListeners()
						},
						destroy: function() {
							this.shutdown(), this.scene = null
						}
					});
				t.exports = L
			}, function(t, e, i) {
				var n = i(0),
					s = i(50),
					r = i(218),
					o = i(173),
					a = i(11),
					h = i(48),
					u = i(3),
					l = new n({
						initialize: function(t, e) {
							var i = e.displayWidth ? e.displayWidth : 64,
								n = e.displayHeight ? e.displayHeight : 64;
							this.world = t, this.gameObject = e, this.transform = {
								x: e.x,
								y: e.y,
								rotation: e.angle,
								scaleX: e.scaleX,
								scaleY: e.scaleY,
								displayOriginX: e.displayOriginX,
								displayOriginY: e.displayOriginY
							}, this.debugShowBody = t.defaults.debugShowBody, this.debugShowVelocity = t.defaults.debugShowVelocity, this.debugBodyColor = t.defaults.bodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new u, this.position = new u(e.x - e.scaleX * e.displayOriginX, e.y - e.scaleY * e.displayOriginY), this.prev = this.position.clone(), this.prevFrame = this.position.clone(), this.allowRotation = !0, this.rotation = e.angle, this.preRotation = e.angle, this.width = i, this.height = n, this.sourceWidth = i, this.sourceHeight = n, e.frame && (this.sourceWidth = e.frame.realWidth, this.sourceHeight = e.frame.realHeight), this.halfWidth = Math.abs(i / 2), this.halfHeight = Math.abs(n / 2), this.center = new u(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = new u, this.newVelocity = new u, this.deltaMax = new u, this.acceleration = new u, this.allowDrag = !0, this.drag = new u, this.allowGravity = !0, this.gravity = new u, this.bounce = new u, this.worldBounce = null, this.customBoundsRectangle = t.bounds, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.maxVelocity = new u(1e4, 1e4), this.maxSpeed = -1, this.friction = new u(1, 0), this.useDamping = !1, this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = s.FACING_NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
								none: !1,
								up: !0,
								down: !0,
								left: !0,
								right: !0
							}, this.touching = {
								none: !0,
								up: !1,
								down: !1,
								left: !1,
								right: !1
							}, this.wasTouching = {
								none: !0,
								up: !1,
								down: !1,
								left: !1,
								right: !1
							}, this.blocked = {
								none: !0,
								up: !1,
								down: !1,
								left: !1,
								right: !1
							}, this.syncBounds = !1, this.physicsType = s.DYNAMIC_BODY, this._sx = e.scaleX, this._sy = e.scaleY, this._dx = 0, this._dy = 0, this._tx = 0, this._ty = 0, this._bounds = new a
						},
						updateBounds: function() {
							var t, e = this.gameObject,
								i = this.transform;
							e.parentContainer ? (t = e.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2), i.x = t.tx, i.y = t.ty, i.rotation = o(t.rotation), i.scaleX = t.scaleX, i.scaleY = t.scaleY) : (i.x = e.x, i.y = e.y, i.rotation = e.angle, i.scaleX = e.scaleX, i.scaleY = e.scaleY), i.displayOriginX = e.displayOriginX, i.displayOriginY = e.displayOriginY;
							var n, s, r, a = !1;
							this.syncBounds ? (n = e.getBounds(this._bounds), this.width = n.width, this.height = n.height, a = !0) : (s = Math.abs(i.scaleX), r = Math.abs(i.scaleY), this._sx === s && this._sy === r || (this.width = this.sourceWidth * s, this.height = this.sourceHeight * r, this._sx = s, this._sy = r, a = !0)), a && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter())
						},
						updateCenter: function() {
							this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
						},
						updateFromGameObject: function() {
							this.updateBounds();
							var t = this.transform;
							this.position.x = t.x + t.scaleX * (this.offset.x - t.displayOriginX), this.position.y = t.y + t.scaleY * (this.offset.y - t.displayOriginY), this.updateCenter()
						},
						resetFlags: function() {
							var t = this.wasTouching,
								e = this.touching,
								i = this.blocked;
							t.none = e.none, t.up = e.up, t.down = e.down, t.left = e.left, t.right = e.right, e.none = !0, e.up = !1, e.down = !1, e.left = !1, e.right = !1, i.none = !0, i.up = !1, i.down = !1, i.left = !1, i.right = !1, this.overlapR = 0, this.overlapX = 0, this.overlapY = 0, this.embedded = !1
						},
						preUpdate: function(t, e) {
							t && this.resetFlags(), this.updateFromGameObject(), this.rotation = this.transform.rotation, this.preRotation = this.rotation, this.moves && (this.prev.x = this.position.x, this.prev.y = this.position.y, this.prevFrame.x = this.position.x, this.prevFrame.y = this.position.y), t && this.update(e)
						},
						update: function(t) {
							var e, i;
							this.prev.x = this.position.x, this.prev.y = this.position.y, this.moves && (this.world.updateMotion(this, t), e = this.velocity.x, i = this.velocity.y, this.newVelocity.set(e * t, i * t), this.position.add(this.newVelocity), this.updateCenter(), this.angle = Math.atan2(i, e), this.speed = Math.sqrt(e * e + i * i), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.world.emit(r.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.position.x - this.prev.x, this._dy = this.position.y - this.prev.y
						},
						postUpdate: function() {
							var t, e, i = this.position.x - this.prevFrame.x,
								n = this.position.y - this.prevFrame.y;
							this.moves && (0 !== (t = this.deltaMax.x) && 0 !== i && (i < 0 && i < -t ? i = -t : 0 < i && t < i && (i = t)), 0 !== (e = this.deltaMax.y) && 0 !== n && (n < 0 && n < -e ? n = -e : 0 < n && e < n && (n = e)), this.gameObject.x += i, this.gameObject.y += n), i < 0 ? this.facing = s.FACING_LEFT : 0 < i && (this.facing = s.FACING_RIGHT), n < 0 ? this.facing = s.FACING_UP : 0 < n && (this.facing = s.FACING_DOWN), this.allowRotation && (this.gameObject.angle += this.deltaZ()), this._tx = i, this._ty = n
						},
						setBoundsRectangle: function(t) {
							return this.customBoundsRectangle = t || this.world.bounds, this
						},
						checkWorldBounds: function() {
							var t = this.position,
								e = this.customBoundsRectangle,
								i = this.world.checkCollision,
								n = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
								s = this.worldBounce ? -this.worldBounce.y : -this.bounce.y,
								r = !1;
							return t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= n, r = this.blocked.left = !0) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= n, r = this.blocked.right = !0), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= s, r = this.blocked.up = !0) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= s, r = this.blocked.down = !0), r && (this.blocked.none = !1), r
						},
						setOffset: function(t, e) {
							return void 0 === e && (e = t), this.offset.set(t, e), this.updateCenter(), this
						},
						setSize: function(t, e, i) {
							void 0 === i && (i = !0);
							var n, s, r = this.gameObject;
							return !t && r.frame && (t = r.frame.realWidth), !e && r.frame && (e = r.frame.realHeight), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter(), i && r.getCenter && (n = (r.width - t) / 2, s = (r.height - e) / 2, this.offset.set(n, s)), this.isCircle = !1, this.radius = 0, this
						},
						setCircle: function(t, e, i) {
							return void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), 0 < t ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(e, i), this.updateCenter()) : this.isCircle = !1, this
						},
						reset: function(t, e) {
							this.stop();
							var i = this.gameObject;
							i.setPosition(t, e), i.getTopLeft ? i.getTopLeft(this.position) : this.position.set(t, e), this.prev.copy(this.position), this.prevFrame.copy(this.position), this.rotation = i.angle, this.preRotation = i.angle, this.updateBounds(), this.updateCenter()
						},
						stop: function() {
							return this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this
						},
						getBounds: function(t) {
							return t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom, t
						},
						hitTest: function(t, e) {
							return this.isCircle ? 0 < this.radius && t >= this.left && t <= this.right && e >= this.top && e <= this.bottom && (this.center.x - t) * (this.center.x - t) + (this.center.y - e) * (this.center.y - e) <= this.radius * this.radius : h(this, t, e)
						},
						onFloor: function() {
							return this.blocked.down
						},
						onCeiling: function() {
							return this.blocked.up
						},
						onWall: function() {
							return this.blocked.left || this.blocked.right
						},
						deltaAbsX: function() {
							return 0 < this._dx ? this._dx : -this._dx
						},
						deltaAbsY: function() {
							return 0 < this._dy ? this._dy : -this._dy
						},
						deltaX: function() {
							return this._dx
						},
						deltaY: function() {
							return this._dy
						},
						deltaXFinal: function() {
							return this._tx
						},
						deltaYFinal: function() {
							return this._ty
						},
						deltaZ: function() {
							return this.rotation - this.preRotation
						},
						destroy: function() {
							this.enable = !1, this.world && this.world.pendingDestroy.set(this)
						},
						drawDebug: function(t) {
							var e = this.position,
								i = e.x + this.halfWidth,
								n = e.y + this.halfHeight;
							this.debugShowBody && (t.lineStyle(t.defaultStrokeWidth, this.debugBodyColor), this.isCircle ? t.strokeCircle(i, n, this.width / 2) : (this.checkCollision.up && t.lineBetween(e.x, e.y, e.x + this.width, e.y), this.checkCollision.right && t.lineBetween(e.x + this.width, e.y, e.x + this.width, e.y + this.height), this.checkCollision.down && t.lineBetween(e.x, e.y + this.height, e.x + this.width, e.y + this.height), this.checkCollision.left && t.lineBetween(e.x, e.y, e.x, e.y + this.height))), this.debugShowVelocity && (t.lineStyle(t.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1), t.lineBetween(i, n, i + this.velocity.x / 2, n + this.velocity.y / 2))
						},
						willDrawDebug: function() {
							return this.debugShowBody || this.debugShowVelocity
						},
						setCollideWorldBounds: function(t, e, i) {
							void 0 === t && (t = !0), this.collideWorldBounds = t;
							var n = void 0 !== e,
								s = void 0 !== i;
							return (n || s) && (this.worldBounce || (this.worldBounce = new u), n && (this.worldBounce.x = e), s && (this.worldBounce.y = i)), this
						},
						setVelocity: function(t, e) {
							return this.velocity.set(t, e), t = this.velocity.x, e = this.velocity.y, this.speed = Math.sqrt(t * t + e * e), this
						},
						setVelocityX: function(t) {
							this.velocity.x = t;
							var e = this.velocity.y;
							return this.speed = Math.sqrt(t * t + e * e), this
						},
						setVelocityY: function(t) {
							this.velocity.y = t;
							var e = this.velocity.x;
							return this.speed = Math.sqrt(e * e + t * t), this
						},
						setMaxVelocity: function(t, e) {
							return this.maxVelocity.set(t, e), this
						},
						setMaxSpeed: function(t) {
							return this.maxSpeed = t, this
						},
						setBounce: function(t, e) {
							return this.bounce.set(t, e), this
						},
						setBounceX: function(t) {
							return this.bounce.x = t, this
						},
						setBounceY: function(t) {
							return this.bounce.y = t, this
						},
						setAcceleration: function(t, e) {
							return this.acceleration.set(t, e), this
						},
						setAccelerationX: function(t) {
							return this.acceleration.x = t, this
						},
						setAccelerationY: function(t) {
							return this.acceleration.y = t, this
						},
						setAllowDrag: function(t) {
							return void 0 === t && (t = !0), this.allowDrag = t, this
						},
						setAllowGravity: function(t) {
							return void 0 === t && (t = !0), this.allowGravity = t, this
						},
						setAllowRotation: function(t) {
							return void 0 === t && (t = !0), this.allowRotation = t, this
						},
						setDrag: function(t, e) {
							return this.drag.set(t, e), this
						},
						setDragX: function(t) {
							return this.drag.x = t, this
						},
						setDragY: function(t) {
							return this.drag.y = t, this
						},
						setGravity: function(t, e) {
							return this.gravity.set(t, e), this
						},
						setGravityX: function(t) {
							return this.gravity.x = t, this
						},
						setGravityY: function(t) {
							return this.gravity.y = t, this
						},
						setFriction: function(t, e) {
							return this.friction.set(t, e), this
						},
						setFrictionX: function(t) {
							return this.friction.x = t, this
						},
						setFrictionY: function(t) {
							return this.friction.y = t, this
						},
						setAngularVelocity: function(t) {
							return this.angularVelocity = t, this
						},
						setAngularAcceleration: function(t) {
							return this.angularAcceleration = t, this
						},
						setAngularDrag: function(t) {
							return this.angularDrag = t, this
						},
						setMass: function(t) {
							return this.mass = t, this
						},
						setImmovable: function(t) {
							return void 0 === t && (t = !0), this.immovable = t, this
						},
						setEnable: function(t) {
							return void 0 === t && (t = !0), this.enable = t, this
						},
						x: {
							get: function() {
								return this.position.x
							},
							set: function(t) {
								this.position.x = t
							}
						},
						y: {
							get: function() {
								return this.position.y
							},
							set: function(t) {
								this.position.y = t
							}
						},
						left: {
							get: function() {
								return this.position.x
							}
						},
						right: {
							get: function() {
								return this.position.x + this.width
							}
						},
						top: {
							get: function() {
								return this.position.y
							}
						},
						bottom: {
							get: function() {
								return this.position.y + this.height
							}
						}
					});
				t.exports = l
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t, e, i, n, s, r, o) {
						this.world = t, this.name = "", this.active = !0, this.overlapOnly = e, this.object1 = i, this.object2 = n, this.collideCallback = s, this.processCallback = r, this.callbackContext = o
					},
					setName: function(t) {
						return this.name = t, this
					},
					update: function() {
						this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly)
					},
					destroy: function() {
						this.world.removeCollider(this), this.active = !1, this.world = null, this.object1 = null, this.object2 = null, this.collideCallback = null, this.processCallback = null, this.callbackContext = null
					}
				});
				t.exports = n
			}, function(t, e, i) {
				var n = i(50);
				t.exports = function(t, e, i, s) {
					var r = 0,
						o = t.deltaAbsX() + e.deltaAbsX() + s;
					return 0 === t._dx && 0 === e._dx ? (t.embedded = !0, e.embedded = !0) : t._dx > e._dx ? o < (r = t.right - e.x) && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? r = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0, e.physicsType === n.STATIC_BODY && (t.blocked.none = !1, t.blocked.right = !0), t.physicsType === n.STATIC_BODY && (e.blocked.none = !1, e.blocked.left = !0)) : t._dx < e._dx && (o < -(r = t.x - e.width - e.x) && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? r = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0, e.physicsType === n.STATIC_BODY && (t.blocked.none = !1, t.blocked.left = !0), t.physicsType === n.STATIC_BODY && (e.blocked.none = !1, e.blocked.right = !0))), t.overlapX = r, e.overlapX = r
				}
			}, function(t, e, i) {
				var n = i(50);
				t.exports = function(t, e, i, s) {
					var r = 0,
						o = t.deltaAbsY() + e.deltaAbsY() + s;
					return 0 === t._dy && 0 === e._dy ? (t.embedded = !0, e.embedded = !0) : t._dy > e._dy ? o < (r = t.bottom - e.y) && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? r = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0, e.physicsType === n.STATIC_BODY && (t.blocked.none = !1, t.blocked.down = !0), t.physicsType === n.STATIC_BODY && (e.blocked.none = !1, e.blocked.up = !0)) : t._dy < e._dy && (o < -(r = t.y - e.bottom) && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? r = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0, e.physicsType === n.STATIC_BODY && (t.blocked.none = !1, t.blocked.up = !0), t.physicsType === n.STATIC_BODY && (e.blocked.none = !1, e.blocked.down = !0))), t.overlapY = r, e.overlapY = r
				}
			}, function(t, e, i) {
				var n = i(391);

				function s(t) {
					if (!(this instanceof s)) return new s(t);
					this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear()
				}

				function r(t, e) {
					o(t, 0, t.children.length, e, t)
				}

				function o(t, e, i, n, s) {
					(s = s || p(null)).minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0;
					for (var r, o = e; o < i; o++) r = t.children[o], a(s, t.leaf ? n(r) : r);
					return s
				}

				function a(t, e) {
					return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t
				}

				function h(t, e) {
					return t.minX - e.minX
				}

				function u(t, e) {
					return t.minY - e.minY
				}

				function l(t) {
					return (t.maxX - t.minX) * (t.maxY - t.minY)
				}

				function c(t) {
					return t.maxX - t.minX + (t.maxY - t.minY)
				}

				function d(t, e) {
					return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY
				}

				function f(t, e) {
					return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY
				}

				function p(t) {
					return {
						children: t,
						height: 1,
						leaf: !0,
						minX: 1 / 0,
						minY: 1 / 0,
						maxX: -1 / 0,
						maxY: -1 / 0
					}
				}

				function g(t, e, i, s, r) {
					for (var o, a = [e, i]; a.length;)(i = a.pop()) - (e = a.pop()) <= s || (o = e + Math.ceil((i - e) / s / 2) * s, n(t, o, e, i, r), a.push(e, o, o, i))
				}
				s.prototype = {
					all: function() {
						return this._all(this.data, [])
					},
					search: function(t) {
						var e = this.data,
							i = [],
							n = this.toBBox;
						if (!f(t, e)) return i;
						for (var s, r, o, a, h = []; e;) {
							for (s = 0, r = e.children.length; s < r; s++) o = e.children[s], f(t, a = e.leaf ? n(o) : o) && (e.leaf ? i.push(o) : d(t, a) ? this._all(o, i) : h.push(o));
							e = h.pop()
						}
						return i
					},
					collides: function(t) {
						var e = this.data,
							i = this.toBBox;
						if (!f(t, e)) return !1;
						for (var n, s, r, o, a = []; e;) {
							for (n = 0, s = e.children.length; n < s; n++)
								if (r = e.children[n], f(t, o = e.leaf ? i(r) : r)) {
									if (e.leaf || d(t, o)) return !0;
									a.push(r)
								} e = a.pop()
						}
						return !1
					},
					load: function(t) {
						if (!t || !t.length) return this;
						if (t.length < this._minEntries) {
							for (var e = 0, i = t.length; e < i; e++) this.insert(t[e]);
							return this
						}
						var n, s = this._build(t.slice(), 0, t.length - 1, 0);
						return this.data.children.length ? this.data.height === s.height ? this._splitRoot(this.data, s) : (this.data.height < s.height && (n = this.data, this.data = s, s = n), this._insert(s, this.data.height - s.height - 1, !0)) : this.data = s, this
					},
					insert: function(t) {
						return t && this._insert(t, this.data.height - 1), this
					},
					clear: function() {
						return this.data = p([]), this
					},
					remove: function(t, e) {
						if (!t) return this;
						for (var i, n, s, r, o = this.data, a = this.toBBox(t), h = [], u = []; o || h.length;) {
							if (o || (o = h.pop(), n = h[h.length - 1], i = u.pop(), r = !0), o.leaf && -1 !== (s = function(t, e, i) {
									if (!i) return e.indexOf(t);
									for (var n = 0; n < e.length; n++)
										if (i(t, e[n])) return n;
									return -1
								}(t, o.children, e))) return o.children.splice(s, 1), h.push(o), this._condense(h), this;
							r || o.leaf || !d(o, a) ? n ? (i++, o = n.children[i], r = !1) : o = null : (h.push(o), u.push(i), i = 0, o = (n = o).children[0])
						}
						return this
					},
					toBBox: function(t) {
						return {
							minX: t.left,
							minY: t.top,
							maxX: t.right,
							maxY: t.bottom
						}
					},
					compareMinX: function(t, e) {
						return t.left - e.left
					},
					compareMinY: function(t, e) {
						return t.top - e.top
					},
					toJSON: function() {
						return this.data
					},
					fromJSON: function(t) {
						return this.data = t, this
					},
					_all: function(t, e) {
						for (var i = []; t;) t.leaf ? e.push.apply(e, t.children) : i.push.apply(i, t.children), t = i.pop();
						return e
					},
					_build: function(t, e, i, n) {
						var s, o = i - e + 1,
							a = this._maxEntries;
						if (o <= a) return r(s = p(t.slice(e, i + 1)), this.toBBox), s;
						n || (n = Math.ceil(Math.log(o) / Math.log(a)), a = Math.ceil(o / Math.pow(a, n - 1))), (s = p([])).leaf = !1, s.height = n;
						var h, u, l, c, d = Math.ceil(o / a),
							f = d * Math.ceil(Math.sqrt(a));
						for (g(t, e, i, f, this.compareMinX), h = e; h <= i; h += f)
							for (g(t, h, l = Math.min(h + f - 1, i), d, this.compareMinY), u = h; u <= l; u += d) c = Math.min(u + d - 1, l), s.children.push(this._build(t, u, c, n - 1));
						return r(s, this.toBBox), s
					},
					_chooseSubtree: function(t, e, i, n) {
						for (var s, r, o, a, h, u, c, d, f, p; n.push(e), !e.leaf && n.length - 1 !== i;) {
							for (c = d = 1 / 0, s = 0, r = e.children.length; s < r; s++) h = l(o = e.children[s]), f = t, p = o, (u = (Math.max(p.maxX, f.maxX) - Math.min(p.minX, f.minX)) * (Math.max(p.maxY, f.maxY) - Math.min(p.minY, f.minY)) - h) < d ? (d = u, c = h < c ? h : c, a = o) : u === d && h < c && (c = h, a = o);
							e = a || e.children[0]
						}
						return e
					},
					_insert: function(t, e, i) {
						var n = this.toBBox,
							s = i ? t : n(t),
							r = [],
							o = this._chooseSubtree(s, this.data, e, r);
						for (o.children.push(t), a(o, s); 0 <= e && r[e].children.length > this._maxEntries;) this._split(r, e), e--;
						this._adjustParentBBoxes(s, r, e)
					},
					_split: function(t, e) {
						var i = t[e],
							n = i.children.length,
							s = this._minEntries;
						this._chooseSplitAxis(i, s, n);
						var o = this._chooseSplitIndex(i, s, n),
							a = p(i.children.splice(o, i.children.length - o));
						a.height = i.height, a.leaf = i.leaf, r(i, this.toBBox), r(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(i, a)
					},
					_splitRoot: function(t, e) {
						this.data = p([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, r(this.data, this.toBBox)
					},
					_chooseSplitIndex: function(t, e, i) {
						for (var n, s, r, a, h, u, c, d, f, p, g, v, m = h = 1 / 0, y = e; y <= i - e; y++) c = n = o(t, 0, y, this.toBBox), d = s = o(t, y, i, this.toBBox), void 0, f = Math.max(c.minX, d.minX), p = Math.max(c.minY, d.minY), g = Math.min(c.maxX, d.maxX), v = Math.min(c.maxY, d.maxY), r = Math.max(0, g - f) * Math.max(0, v - p), a = l(n) + l(s), r < m ? (m = r, u = y, h = a < h ? a : h) : r === m && a < h && (h = a, u = y);
						return u
					},
					_chooseSplitAxis: function(t, e, i) {
						var n = t.leaf ? this.compareMinX : h,
							s = t.leaf ? this.compareMinY : u;
						this._allDistMargin(t, e, i, n) < this._allDistMargin(t, e, i, s) && t.children.sort(n)
					},
					_allDistMargin: function(t, e, i, n) {
						t.children.sort(n);
						for (var s, r = this.toBBox, h = o(t, 0, e, r), u = o(t, i - e, i, r), l = c(h) + c(u), d = e; d < i - e; d++) s = t.children[d], a(h, t.leaf ? r(s) : s), l += c(h);
						for (d = i - e - 1; e <= d; d--) s = t.children[d], a(u, t.leaf ? r(s) : s), l += c(u);
						return l
					},
					_adjustParentBBoxes: function(t, e, i) {
						for (var n = i; 0 <= n; n--) a(e[n], t)
					},
					_condense: function(t) {
						for (var e, i = t.length - 1; 0 <= i; i--) 0 === t[i].children.length ? 0 < i ? (e = t[i - 1].children).splice(e.indexOf(t[i]), 1) : this.clear() : r(t[i], this.toBBox)
					}
				}, t.exports = s
			}, function(t, e) {
				t.exports = function(t, e) {
					return !(e.right <= t.left || e.bottom <= t.top || e.position.x >= t.right || e.position.y >= t.bottom)
				}
			}, function(t, e, i) {
				var n = i(55),
					s = i(0),
					r = i(50),
					o = i(48),
					a = i(3),
					h = new s({
						initialize: function(t, e) {
							var i = e.displayWidth ? e.displayWidth : 64,
								n = e.displayHeight ? e.displayHeight : 64;
							this.world = t, this.gameObject = e, this.debugShowBody = t.defaults.debugShowStaticBody, this.debugBodyColor = t.defaults.staticBodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new a, this.position = new a(e.x - i * e.originX, e.y - n * e.originY), this.width = i, this.height = n, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center = new a(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = a.ZERO, this.allowGravity = !1, this.gravity = a.ZERO, this.bounce = a.ZERO, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.mass = 1, this.immovable = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
								none: !1,
								up: !0,
								down: !0,
								left: !0,
								right: !0
							}, this.touching = {
								none: !0,
								up: !1,
								down: !1,
								left: !1,
								right: !1
							}, this.wasTouching = {
								none: !0,
								up: !1,
								down: !1,
								left: !1,
								right: !1
							}, this.blocked = {
								none: !0,
								up: !1,
								down: !1,
								left: !1,
								right: !1
							}, this.physicsType = r.STATIC_BODY, this._dx = 0, this._dy = 0
						},
						setGameObject: function(t, e) {
							return t && t !== this.gameObject && (this.gameObject.body = null, (t.body = this).gameObject = t), e && this.updateFromGameObject(), this
						},
						updateFromGameObject: function() {
							this.world.staticTree.remove(this);
							var t = this.gameObject;
							return t.getTopLeft(this.position), this.width = t.displayWidth, this.height = t.displayHeight, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.world.staticTree.insert(this), this
						},
						setOffset: function(t, e) {
							return void 0 === e && (e = t), this.world.staticTree.remove(this), this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(t, e), this.position.x += this.offset.x, this.position.y += this.offset.y, this.updateCenter(), this.world.staticTree.insert(this), this
						},
						setSize: function(t, e, i) {
							void 0 === i && (i = !0);
							var n, s, r = this.gameObject;
							return !t && r.frame && (t = r.frame.realWidth), !e && r.frame && (e = r.frame.realHeight), this.world.staticTree.remove(this), this.width = t, this.height = e, this.halfWidth = Math.floor(t / 2), this.halfHeight = Math.floor(e / 2), i && r.getCenter && (n = r.displayWidth / 2, s = r.displayHeight / 2, this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(n - this.halfWidth, s - this.halfHeight), this.position.x += this.offset.x, this.position.y += this.offset.y), this.updateCenter(), this.isCircle = !1, this.radius = 0, this.world.staticTree.insert(this), this
						},
						setCircle: function(t, e, i) {
							return void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), 0 < t ? (this.world.staticTree.remove(this), this.isCircle = !0, this.radius = t, this.width = 2 * t, this.height = 2 * t, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(e, i), this.updateCenter(), this.world.staticTree.insert(this)) : this.isCircle = !1, this
						},
						updateCenter: function() {
							this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
						},
						reset: function(t, e) {
							var i = this.gameObject;
							void 0 === t && (t = i.x), void 0 === e && (e = i.y), this.world.staticTree.remove(this), i.setPosition(t, e), i.getTopLeft(this.position), this.updateCenter(), this.world.staticTree.insert(this)
						},
						stop: function() {
							return this
						},
						getBounds: function(t) {
							return t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom, t
						},
						hitTest: function(t, e) {
							return (this.isCircle ? n : o)(this, t, e)
						},
						postUpdate: function() {},
						deltaAbsX: function() {
							return 0
						},
						deltaAbsY: function() {
							return 0
						},
						deltaX: function() {
							return 0
						},
						deltaY: function() {
							return 0
						},
						deltaZ: function() {
							return 0
						},
						destroy: function() {
							this.enable = !1, this.world.pendingDestroy.set(this)
						},
						drawDebug: function(t) {
							var e = this.position,
								i = e.x + this.halfWidth,
								n = e.y + this.halfHeight;
							this.debugShowBody && (t.lineStyle(t.defaultStrokeWidth, this.debugBodyColor, 1), this.isCircle ? t.strokeCircle(i, n, this.width / 2) : t.strokeRect(e.x, e.y, this.width, this.height))
						},
						willDrawDebug: function() {
							return this.debugShowBody
						},
						setMass: function(t) {
							return t <= 0 && (t = .1), this.mass = t, this
						},
						x: {
							get: function() {
								return this.position.x
							},
							set: function(t) {
								this.world.staticTree.remove(this), this.position.x = t, this.world.staticTree.insert(this)
							}
						},
						y: {
							get: function() {
								return this.position.y
							},
							set: function(t) {
								this.world.staticTree.remove(this), this.position.y = t, this.world.staticTree.insert(this)
							}
						},
						left: {
							get: function() {
								return this.position.x
							}
						},
						right: {
							get: function() {
								return this.position.x + this.width
							}
						},
						top: {
							get: function() {
								return this.position.y
							}
						},
						bottom: {
							get: function() {
								return this.position.y + this.height
							}
						}
					});
				t.exports = h
			}, , function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t) {
						this.pluginManager = t, this.game = t.game
					},
					init: function() {},
					start: function() {},
					stop: function() {},
					destroy: function() {
						this.pluginManager = null, this.game = null, this.scene = null, this.systems = null
					}
				});
				t.exports = n
			}, function(t, e, i) {
				var n = i(24);
				t.exports = function(t, e, i, s, r, o, a) {
					for (var h = n(i, s, r, o, null, a), u = 0; u < h.length; u++) h[u] && h[u].index === t && (h[u].index = e)
				}
			}, function(t, e, i) {
				var n = i(101);
				t.exports = function(t, e, i) {
					if (n(t, e, i)) {
						var s = i.data[e][t];
						return null !== s && -1 < s.index
					}
					return !1
				}
			}, function(t, e, i) {
				var n = i(74),
					s = i(101),
					r = i(220);
				t.exports = function(t, e, i, o, a) {
					if (void 0 === i && (i = !1), void 0 === o && (o = !0), !s(t, e, a)) return null;
					var h = a.data[e][t];
					return h ? (a.data[e][t] = i ? null : new n(a, -1, t, e, h.width, h.height), o && h && h.collides && r(t, e, a), h) : null
				}
			}, function(t, e, i) {
				var n = i(32),
					s = i(223),
					r = i(479),
					o = i(480),
					a = i(491);
				t.exports = function(t, e, i, h, u, l) {
					var c;
					switch (e) {
						case n.ARRAY_2D:
							c = s(t, i, h, u, l);
							break;
						case n.CSV:
							c = r(t, i, h, u, l);
							break;
						case n.TILED_JSON:
							c = o(t, i, l);
							break;
						case n.WELTMEISTER:
							c = a(t, i, l);
							break;
						default:
							console.warn("Unrecognized tilemap data format: " + e), c = null
					}
					return c
				}
			}, function(t, e, i) {
				var n = i(32),
					s = i(223);
				t.exports = function(t, e, i, r, o) {
					var a = e.trim().split("\n").map(function(t) {
							return t.split(",")
						}),
						h = s(t, a, i, r, o);
					return h.format = n.CSV, h
				}
			}, function(t, e, i) {
				var n = i(32),
					s = i(103),
					r = i(481),
					o = i(483),
					a = i(484),
					h = i(487),
					u = i(489),
					l = i(490);
				t.exports = function(t, e, i) {
					if ("orthogonal" !== e.orientation) return console.warn("Only orthogonal map types are supported in this version of Phaser"), null;
					var c = new s({
						width: e.width,
						height: e.height,
						name: t,
						tileWidth: e.tilewidth,
						tileHeight: e.tileheight,
						orientation: e.orientation,
						format: n.TILED_JSON,
						version: e.version,
						properties: e.properties,
						renderOrder: e.renderorder,
						infinite: e.infinite
					});
					c.layers = r(e, i), c.images = o(e);
					var d = a(e);
					return c.tilesets = d.tilesets, c.imageCollections = d.imageCollections, c.objects = h(e), c.tiles = u(c), l(c), c
				}
			}, function(t, e, i) {
				var n = i(482),
					s = i(2),
					r = i(102),
					o = i(224),
					a = i(74),
					h = i(225);
				t.exports = function(t, e) {
					for (var i = s(t, "infinite", !1), u = [], l = [], c = h(t); c.i < c.layers.length || 0 < l.length;)
						if (c.i >= c.layers.length) {
							if (l.length < 1) {
								console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
								break
							}
							c = l.pop()
						} else {
							var d, f = c.layers[c.i];
							if (c.i++, "tilelayer" === f.type)
								if (f.compression) console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + f.name + "'");
								else {
									if (f.encoding && "base64" === f.encoding) {
										if (f.chunks)
											for (var p = 0; p < f.chunks.length; p++) f.chunks[p].data = n(f.chunks[p].data);
										f.data && (f.data = n(f.data)), delete f.encoding
									}
									var g, v, m = [],
										y = 0;
									if (i) {
										for (var x = s(f, "startx", 0) + f.x, T = s(f, "starty", 0) + f.y, w = new r({
												name: c.name + f.name,
												x: c.x + s(f, "offsetx", 0) + x * t.tilewidth,
												y: c.y + s(f, "offsety", 0) + T * t.tileheight,
												width: f.width,
												height: f.height,
												tileWidth: t.tilewidth,
												tileHeight: t.tileheight,
												alpha: c.opacity * f.opacity,
												visible: c.visible && f.visible,
												properties: s(f, "properties", [])
											}), E = 0; E < f.height; E++) {
											m.push([null]);
											for (var _ = 0; _ < f.width; _++) m[E][_] = null
										}
										for (E = 0, k = f.chunks.length; E < k; E++)
											for (var b = f.chunks[E], A = b.x - x, S = b.y - T, C = 0, M = 0, O = b.data.length; M < O; M++) {
												var P, R = y + A,
													L = C + S;
												0 < (P = o(b.data[M])).gid ? ((g = new a(w, P.gid, R, L, t.tilewidth, t.tileheight)).rotation = P.rotation, g.flipX = P.flipped, m[L][R] = g) : (v = e ? null : new a(w, -1, R, L, t.tilewidth, t.tileheight), m[L][R] = v), ++y === b.width && (C++, y = 0)
											}
									} else {
										w = new r({
											name: c.name + f.name,
											x: c.x + s(f, "offsetx", 0) + f.x,
											y: c.y + s(f, "offsety", 0) + f.y,
											width: f.width,
											height: f.height,
											tileWidth: t.tilewidth,
											tileHeight: t.tileheight,
											alpha: c.opacity * f.opacity,
											visible: c.visible && f.visible,
											properties: s(f, "properties", [])
										});
										for (var D = [], F = 0, k = f.data.length; F < k; F++) 0 < (P = o(f.data[F])).gid ? ((g = new a(w, P.gid, y, m.length, t.tilewidth, t.tileheight)).rotation = P.rotation, g.flipX = P.flipped, D.push(g)) : (v = e ? null : new a(w, -1, y, m.length, t.tilewidth, t.tileheight), D.push(v)), ++y === f.width && (m.push(D), y = 0, D = [])
									}
									w.data = m, u.push(w)
								}
							else "group" === f.type && (d = h(t, f, c), l.push(c), c = d)
						} return u
				}
			}, function(t, e) {
				t.exports = function(t) {
					for (var e = window.atob(t), i = e.length, n = new Array(i / 4), s = 0; s < i; s += 4) n[s / 4] = (e.charCodeAt(s) | e.charCodeAt(s + 1) << 8 | e.charCodeAt(s + 2) << 16 | e.charCodeAt(s + 3) << 24) >>> 0;
					return n
				}
			}, function(t, e, i) {
				var n = i(2),
					s = i(225);
				t.exports = function(t) {
					for (var e = [], i = [], r = s(t); r.i < r.layers.length || 0 < i.length;)
						if (r.i >= r.layers.length) {
							if (i.length < 1) {
								console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
								break
							}
							r = i.pop()
						} else {
							var o, a, h, u = r.layers[r.i];
							r.i++, "imagelayer" === u.type ? (o = n(u, "offsetx", 0) + n(u, "startx", 0), a = n(u, "offsety", 0) + n(u, "starty", 0), e.push({
								name: r.name + u.name,
								image: u.image,
								x: r.x + o + u.x,
								y: r.y + a + u.y,
								alpha: r.opacity * u.opacity,
								visible: r.visible && u.visible,
								properties: n(u, "properties", {})
							})) : "group" === u.type && (h = s(t, u, r), i.push(r), r = h)
						} return e
				}
			}, function(t, e, i) {
				var n = i(104),
					s = i(485),
					r = i(226);
				t.exports = function(t) {
					for (var e, i = [], o = [], a = null, h = 0; h < t.tilesets.length; h++) {
						var u = t.tilesets[h];
						if (u.source) console.warn("Phaser can't load external tilesets. Use the Embed Tileset button and then export the map again.");
						else if (u.image) {
							var l = new n(u.name, u.firstgid, u.tilewidth, u.tileheight, u.margin, u.spacing);
							if (1 < t.version) {
								if (Array.isArray(u.tiles)) {
									for (var c = {}, d = {}, f = 0; f < u.tiles.length; f++) {
										var p, g, v = u.tiles[f];
										v.properties && (p = {}, v.properties.forEach(function(t) {
											p[t.name] = t.value
										}), d[v.id] = p), v.objectgroup && (c[v.id] = {
											objectgroup: v.objectgroup
										}, v.objectgroup.objects && (g = v.objectgroup.objects.map(function(t) {
											return r(t)
										}), c[v.id].objectgroup.objects = g)), v.animation && (c.hasOwnProperty(v.id) ? c[v.id].animation = v.animation : c[v.id] = {
											animation: v.animation
										})
									}
									l.tileData = c, l.tileProperties = d
								}
							} else if (u.tileproperties && (l.tileProperties = u.tileproperties), u.tiles)
								for (e in l.tileData = u.tiles, l.tileData) {
									var m, y = l.tileData[e].objectgroup;
									y && y.objects && (m = y.objects.map(function(t) {
										return r(t)
									}), l.tileData[e].objectgroup.objects = m)
								}
							l.updateTileData(u.imagewidth, u.imageheight), i.push(l)
						} else {
							var x = new s(u.name, u.firstgid, u.tilewidth, u.tileheight, u.margin, u.spacing, u.properties);
							for (e in u.tiles) {
								var T = u.tiles[e].image,
									w = u.firstgid + parseInt(e, 10);
								x.addImage(w, T)
							}
							o.push(x)
						}
						a && (a.lastgid = u.firstgid - 1), a = u
					}
					return {
						tilesets: i,
						imageCollections: o
					}
				}
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t, e, i, n, s, r, o) {
						(void 0 === i || i <= 0) && (i = 32), (void 0 === n || n <= 0) && (n = 32), void 0 === s && (s = 0), void 0 === r && (r = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | n, this.imageMargin = 0 | s, this.imageSpacing = 0 | r, this.properties = o || {}, this.images = [], this.total = 0
					},
					containsImageIndex: function(t) {
						return t >= this.firstgid && t < this.firstgid + this.total
					},
					addImage: function(t, e) {
						return this.images.push({
							gid: t,
							image: e
						}), this.total++, this
					}
				});
				t.exports = n
			}, function(t, e, i) {
				var n = i(108);
				t.exports = function(t, e) {
					for (var i = {}, s = 0; s < e.length; s++) {
						var r = e[s];
						n(t, r) && (i[r] = t[r])
					}
					return i
				}
			}, function(t, e, i) {
				var n = i(2),
					s = i(226),
					r = i(488),
					o = i(225);
				t.exports = function(t) {
					for (var e = [], i = [], a = o(t); a.i < a.layers.length || 0 < i.length;)
						if (a.i >= a.layers.length) {
							if (i.length < 1) {
								console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
								break
							}
							a = i.pop()
						} else {
							var h, u = a.layers[a.i];
							if (a.i++, u.opacity *= a.opacity, u.visible = a.visible && u.visible, "objectgroup" === u.type) {
								u.name = a.name + u.name;
								for (var l = a.x + n(u, "startx", 0) + n(u, "offsetx", 0), c = a.y + n(u, "starty", 0) + n(u, "offsety", 0), d = [], f = 0; f < u.objects.length; f++) {
									var p = s(u.objects[f], l, c);
									d.push(p)
								}
								var g = new r(u);
								g.objects = d, e.push(g)
							} else "group" === u.type && (h = o(t, u, a), i.push(a), a = h)
						} return e
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(2),
					r = new n({
						initialize: function(t) {
							void 0 === t && (t = {}), this.name = s(t, "name", "object layer"), this.opacity = s(t, "opacity", 1), this.properties = s(t, "properties", {}), this.propertyTypes = s(t, "propertytypes", {}), this.type = s(t, "type", "objectgroup"), this.visible = s(t, "visible", !0), this.objects = s(t, "objects", [])
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = i(104);
				t.exports = function(t) {
					for (var e = [], i = 0; i < t.imageCollections.length; i++)
						for (var s = t.imageCollections[i], r = s.images, o = 0; o < r.length; o++) {
							var a, h = r[o];
							(a = new n(h.image, h.gid, s.imageWidth, s.imageHeight, 0, 0)).updateTileData(s.imageWidth, s.imageHeight), t.tilesets.push(a)
						}
					for (i = 0; i < t.tilesets.length; i++)
						for (var u = (a = t.tilesets[i]).tileMargin, l = a.tileMargin, c = 0, d = 0, f = 0, p = a.firstgid; p < a.firstgid + a.total && (e[p] = [u, l, i], u += a.tileWidth + a.tileSpacing, ++c !== a.total) && (++d !== a.columns || (u = a.tileMargin, l += a.tileHeight + a.tileSpacing, d = 0, ++f !== a.rows)); p++);
					return e
				}
			}, function(t, e, i) {
				var n = i(18);
				t.exports = function(t) {
					for (var e, i, s, r, o, a = 0; a < t.layers.length; a++) {
						e = t.layers[a];
						for (var h = 0; h < e.data.length; h++) {
							o = e.data[h];
							for (var u = 0; u < o.length; u++) null === (i = o[u]) || i.index < 0 || (s = t.tiles[i.index][2], r = t.tilesets[s], i.width = r.tileWidth, i.height = r.tileHeight, r.tileProperties && r.tileProperties[i.index - r.firstgid] && (i.properties = n(i.properties, r.tileProperties[i.index - r.firstgid])))
						}
					}
				}
			}, function(t, e, i) {
				var n = i(32),
					s = i(103),
					r = i(492),
					o = i(493);
				t.exports = function(t, e, i) {
					if (0 === e.layer.length) return console.warn("No layers found in the Weltmeister map: " + t), null;
					for (var a = 0, h = 0, u = 0; u < e.layer.length; u++) e.layer[u].width > a && (a = e.layer[u].width), e.layer[u].height > h && (h = e.layer[u].height);
					var l = new s({
						width: a,
						height: h,
						name: t,
						tileWidth: e.layer[0].tilesize,
						tileHeight: e.layer[0].tilesize,
						format: n.WELTMEISTER
					});
					return l.layers = r(e, i), l.tilesets = o(e), l
				}
			}, function(t, e, i) {
				var n = i(102),
					s = i(74);
				t.exports = function(t, e) {
					for (var i = [], r = 0; r < t.layer.length; r++) {
						for (var o = t.layer[r], a = new n({
								name: o.name,
								width: o.width,
								height: o.height,
								tileWidth: o.tilesize,
								tileHeight: o.tilesize,
								visible: 1 === o.visible
							}), h = [], u = [], l = 0; l < o.data.length; l++) {
							for (var c = 0; c < o.data[l].length; c++) {
								var d = o.data[l][c] - 1,
									f = -1 < d ? new s(a, d, c, l, o.tilesize, o.tilesize) : e ? null : new s(a, -1, c, l, o.tilesize, o.tilesize);
								h.push(f)
							}
							u.push(h), h = []
						}
						a.data = u, i.push(a)
					}
					return i
				}
			}, function(t, e, i) {
				var n = i(104);
				t.exports = function(t) {
					for (var e = [], i = [], s = 0; s < t.layer.length; s++) {
						var r = t.layer[s],
							o = r.tilesetName;
						"" !== o && -1 === i.indexOf(o) && (i.push(o), e.push(new n(o, 0, r.tilesize, r.tilesize, 0, 0)))
					}
					return e
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(39),
					r = i(495),
					o = i(18),
					a = i(32),
					h = i(102),
					u = i(331),
					l = i(80),
					c = i(496),
					d = i(74),
					f = i(141),
					p = i(104),
					g = new n({
						initialize: function(t, e) {
							this.scene = t, this.tileWidth = e.tileWidth, this.tileHeight = e.tileHeight, this.width = e.width, this.height = e.height, this.orientation = e.orientation, this.renderOrder = e.renderOrder, this.format = e.format, this.version = e.version, this.properties = e.properties, this.widthInPixels = e.widthInPixels, this.heightInPixels = e.heightInPixels, this.imageCollections = e.imageCollections, this.images = e.images, this.layers = e.layers, this.tilesets = e.tilesets, this.objects = e.objects, this.currentLayerIndex = 0
						},
						setRenderOrder: function(t) {
							var e = ["right-down", "left-down", "right-up", "left-up"];
							return "number" == typeof t && (t = e[t]), -1 < e.indexOf(t) && (this.renderOrder = t), this
						},
						addTilesetImage: function(t, e, i, n, s, r, o) {
							if (void 0 === t) return null;
							if (null == e && (e = t), !this.scene.sys.textures.exists(e)) return console.warn("Invalid Tileset Image: " + e), null;
							var h = this.scene.sys.textures.get(e),
								u = this.getTilesetIndex(t);
							if (null === u && this.format === a.TILED_JSON) return console.warn("No data found for Tileset: " + t), null;
							var l = this.tilesets[u];
							return l ? (l.setTileSize(i, n), l.setSpacing(s, r), l.setImage(h)) : (void 0 === i && (i = this.tileWidth), void 0 === n && (n = this.tileHeight), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), (l = new p(t, o, i, n, s, r)).setImage(h), this.tilesets.push(l)), l
						},
						convertLayerToStatic: function(t) {
							if (null === (t = this.getLayer(t))) return null;
							var e = t.tilemapLayer;
							if (!(e && e instanceof r)) return null;
							var i = new c(e.scene, e.tilemap, e.layerIndex, e.tileset, e.x, e.y);
							return this.scene.sys.displayList.add(i), e.destroy(), i
						},
						copy: function(t, e, i, n, s, r, o, a) {
							return a = this.getLayer(a), this._isStaticCall(a, "copy") ? this : null !== a ? (f.Copy(t, e, i, n, s, r, o, a), this) : null
						},
						createBlankDynamicLayer: function(t, e, i, n, s, o, a, u) {
							if (void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = this.width), void 0 === o && (o = this.height), void 0 === a && (a = this.tileWidth), void 0 === u && (u = this.tileHeight), null !== this.getLayerIndex(t)) return console.warn("Invalid Tilemap Layer ID: " + t), null;
							for (var l, c = new h({
									name: t,
									tileWidth: a,
									tileHeight: u,
									width: s,
									height: o
								}), f = 0; f < o; f++) {
								l = [];
								for (var p = 0; p < s; p++) l.push(new d(c, -1, p, f, a, u, this.tileWidth, this.tileHeight));
								c.data.push(l)
							}
							this.layers.push(c), this.currentLayerIndex = this.layers.length - 1;
							var g = new r(this.scene, this, this.currentLayerIndex, e, i, n);
							return g.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(g), g
						},
						createDynamicLayer: function(t, e, i, n) {
							var s = this.getLayerIndex(t);
							if (null === s) return console.warn("Invalid Tilemap Layer ID: " + t), "string" == typeof t && console.warn("Valid tilelayer names:\n\t" + this.getTileLayerNames().join(",\n\t")), null;
							var o = this.layers[s];
							if (o.tilemapLayer) return console.warn("Tilemap Layer ID already exists:" + t), null;
							this.currentLayerIndex = s, void 0 === i && (i = o.x), void 0 === n && (n = o.y);
							var a = new r(this.scene, this, s, e, i, n);
							return a.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(a), a
						},
						createFromObjects: function(t, e, i, n) {
							void 0 === i && (i = {}), void 0 === n && (n = this.scene);
							var r = this.getObjectLayer(t);
							if (!r) return console.warn("Cannot create from object. Invalid objectgroup name given: " + t), "string" == typeof layerID && console.warn("Valid objectgroup names:\n\t" + this.getObjectLayerNames().join(",\n\t")), null;
							for (var a = r.objects, h = [], l = 0; l < a.length; l++) {
								var c = !1,
									d = a[l];
								if ((void 0 !== d.gid && "number" == typeof e && d.gid === e || void 0 !== d.id && "number" == typeof e && d.id === e || void 0 !== d.name && "string" == typeof e && d.name === e) && (c = !0), c) {
									var f = o({}, i, d.properties);
									f.x = d.x, f.y = d.y;
									var p = n.make.sprite(f);
									p.name = d.name, d.width && (p.displayWidth = d.width), d.height && (p.displayHeight = d.height);
									var g, v = {
										x: p.originX * d.width,
										y: (p.originY - 1) * d.height
									};
									for (var m in d.rotation && (g = s(d.rotation), u(v, g), p.rotation = g), p.x += v.x, p.y += v.y, void 0 === d.flippedHorizontal && void 0 === d.flippedVertical || p.setFlip(d.flippedHorizontal, d.flippedVertical), d.visible || (p.visible = !1), d.properties) p.hasOwnProperty(m) || p.setData(m, d.properties[m]);
									h.push(p)
								}
							}
							return h
						},
						createFromTiles: function(t, e, i, n, s, r) {
							return null === (r = this.getLayer(r)) ? null : f.CreateFromTiles(t, e, i, n, s, r)
						},
						createStaticLayer: function(t, e, i, n) {
							var s = this.getLayerIndex(t);
							if (null === s) return console.warn("Invalid Tilemap Layer ID: " + t), "string" == typeof t && console.warn("Valid tilelayer names:\n\t" + this.getTileLayerNames().join(",\n\t")), null;
							if (this.layers[s].tilemapLayer) return console.warn("Tilemap Layer ID already exists:" + t), null;
							this.currentLayerIndex = s, void 0 === i && this.layers[s].x && (i = this.layers[s].x), void 0 === n && this.layers[s].y && (n = this.layers[s].y);
							var r = new c(this.scene, this, s, e, i, n);
							return r.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(r), r
						},
						destroy: function() {
							this.removeAllLayers(), this.tilesets.length = 0, this.objects.length = 0, this.scene = void 0
						},
						fill: function(t, e, i, n, s, r, o) {
							return null === (o = this.getLayer(o)) ? null : (this._isStaticCall(o, "fill") || f.Fill(t, e, i, n, s, r, o), this)
						},
						filterObjects: function(t, e, i) {
							if ("string" == typeof t) {
								var n = t;
								if (!(t = this.getObjectLayer(t))) return console.warn("No object layer found with the name: " + n), null
							}
							return t.objects.filter(e, i)
						},
						filterTiles: function(t, e, i, n, s, r, o, a) {
							return null === (a = this.getLayer(a)) ? null : f.FilterTiles(t, e, i, n, s, r, o, a)
						},
						findByIndex: function(t, e, i, n) {
							return null === (n = this.getLayer(n)) ? null : f.FindByIndex(t, e, i, n)
						},
						findObject: function(t, e, i) {
							if ("string" == typeof t) {
								var n = t;
								if (!(t = this.getObjectLayer(t))) return console.warn("No object layer found with the name: " + n), null
							}
							return t.objects.find(e, i) || null
						},
						findTile: function(t, e, i, n, s, r, o, a) {
							return null === (a = this.getLayer(a)) ? null : f.FindTile(t, e, i, n, s, r, o, a)
						},
						forEachTile: function(t, e, i, n, s, r, o, a) {
							return null === (a = this.getLayer(a)) ? null : (f.ForEachTile(t, e, i, n, s, r, o, a), this)
						},
						getImageIndex: function(t) {
							return this.getIndex(this.images, t)
						},
						getImageLayerNames: function() {
							return this.images && Array.isArray(this.images) ? this.images.map(function(t) {
								return t.name
							}) : []
						},
						getIndex: function(t, e) {
							for (var i = 0; i < t.length; i++)
								if (t[i].name === e) return i;
							return null
						},
						getLayer: function(t) {
							var e = this.getLayerIndex(t);
							return null !== e ? this.layers[e] : null
						},
						getObjectLayer: function(t) {
							var e = this.getIndex(this.objects, t);
							return null !== e ? this.objects[e] : null
						},
						getObjectLayerNames: function() {
							return this.objects && Array.isArray(this.objects) ? this.objects.map(function(t) {
								return t.name
							}) : []
						},
						getLayerIndex: function(t) {
							return void 0 === t ? this.currentLayerIndex : "string" == typeof t ? this.getLayerIndexByName(t) : "number" == typeof t && t < this.layers.length ? t : t instanceof c || t instanceof r ? t.layerIndex : null
						},
						getLayerIndexByName: function(t) {
							return this.getIndex(this.layers, t)
						},
						getTileAt: function(t, e, i, n) {
							return null === (n = this.getLayer(n)) ? null : f.GetTileAt(t, e, i, n)
						},
						getTileAtWorldXY: function(t, e, i, n, s) {
							return null === (s = this.getLayer(s)) ? null : f.GetTileAtWorldXY(t, e, i, n, s)
						},
						getTileLayerNames: function() {
							return this.layers && Array.isArray(this.layers) ? this.layers.map(function(t) {
								return t.name
							}) : []
						},
						getTilesWithin: function(t, e, i, n, s, r) {
							return null === (r = this.getLayer(r)) ? null : f.GetTilesWithin(t, e, i, n, s, r)
						},
						getTilesWithinShape: function(t, e, i, n) {
							return null === (n = this.getLayer(n)) ? null : f.GetTilesWithinShape(t, e, i, n)
						},
						getTilesWithinWorldXY: function(t, e, i, n, s, r, o) {
							return null === (o = this.getLayer(o)) ? null : f.GetTilesWithinWorldXY(t, e, i, n, s, r, o)
						},
						getTileset: function(t) {
							var e = this.getIndex(this.tilesets, t);
							return null !== e ? this.tilesets[e] : null
						},
						getTilesetIndex: function(t) {
							return this.getIndex(this.tilesets, t)
						},
						hasTileAt: function(t, e, i) {
							return null === (i = this.getLayer(i)) ? null : f.HasTileAt(t, e, i)
						},
						hasTileAtWorldXY: function(t, e, i, n) {
							return null === (n = this.getLayer(n)) ? null : f.HasTileAtWorldXY(t, e, i, n)
						},
						layer: {
							get: function() {
								return this.layers[this.currentLayerIndex]
							},
							set: function(t) {
								this.setLayer(t)
							}
						},
						putTileAt: function(t, e, i, n, s) {
							return s = this.getLayer(s), this._isStaticCall(s, "putTileAt") || null === s ? null : f.PutTileAt(t, e, i, n, s)
						},
						putTileAtWorldXY: function(t, e, i, n, s, r) {
							return r = this.getLayer(r), this._isStaticCall(r, "putTileAtWorldXY") || null === r ? null : f.PutTileAtWorldXY(t, e, i, n, s, r)
						},
						putTilesAt: function(t, e, i, n, s) {
							return s = this.getLayer(s), this._isStaticCall(s, "putTilesAt") ? this : null === s ? null : (f.PutTilesAt(t, e, i, n, s), this)
						},
						randomize: function(t, e, i, n, s, r) {
							return r = this.getLayer(r), this._isStaticCall(r, "randomize") ? this : null === r ? null : (f.Randomize(t, e, i, n, s, r), this)
						},
						calculateFacesAt: function(t, e, i) {
							return null === (i = this.getLayer(i)) ? null : (f.CalculateFacesAt(t, e, i), this)
						},
						calculateFacesWithin: function(t, e, i, n, s) {
							return null === (s = this.getLayer(s)) ? null : (f.CalculateFacesWithin(t, e, i, n, s), this)
						},
						removeLayer: function(t) {
							var e = this.getLayerIndex(t);
							if (null === e) return null;
							l(this.layers, e);
							for (var i = e; i < this.layers.length; i++) this.layers[i].tilemapLayer && this.layers[i].tilemapLayer.layerIndex--;
							return this.currentLayerIndex === e && (this.currentLayerIndex = 0), this
						},
						destroyLayer: function(t) {
							var e = this.getLayerIndex(t);
							return null !== e ? ((t = this.layers[e]).destroy(), l(this.layers, e), this.currentLayerIndex === e && (this.currentLayerIndex = 0), this) : null
						},
						removeAllLayers: function() {
							for (var t = this.layers, e = 0; e < t.length; e++) t[e].tilemapLayer && t[e].tilemapLayer.destroy(!1);
							return t.length = 0, this.currentLayerIndex = 0, this
						},
						removeTile: function(t, e, i) {
							void 0 === e && (e = -1), void 0 === i && (i = !0);
							var n = [];
							Array.isArray(t) || (t = [t]);
							for (var s = 0; s < t.length; s++) {
								var r = t[s];
								n.push(this.removeTileAt(r.x, r.y, !0, i, r.tilemapLayer)), -1 < e && this.putTileAt(e, r.x, r.y, i, r.tilemapLayer)
							}
							return n
						},
						removeTileAt: function(t, e, i, n, s) {
							return s = this.getLayer(s), this._isStaticCall(s, "removeTileAt") || null === s ? null : f.RemoveTileAt(t, e, i, n, s)
						},
						removeTileAtWorldXY: function(t, e, i, n, s, r) {
							return r = this.getLayer(r), this._isStaticCall(r, "removeTileAtWorldXY") || null === r ? null : f.RemoveTileAtWorldXY(t, e, i, n, s, r)
						},
						renderDebug: function(t, e, i) {
							return null === (i = this.getLayer(i)) ? null : (f.RenderDebug(t, e, i), this)
						},
						renderDebugFull: function(t, e) {
							for (var i = this.layers, n = 0; n < i.length; n++) f.RenderDebug(t, e, i[n]);
							return this
						},
						replaceByIndex: function(t, e, i, n, s, r, o) {
							return o = this.getLayer(o), this._isStaticCall(o, "replaceByIndex") ? this : null === o ? null : (f.ReplaceByIndex(t, e, i, n, s, r, o), this)
						},
						setCollision: function(t, e, i, n, s) {
							return null === (n = this.getLayer(n)) ? null : (f.SetCollision(t, e, i, n, s), this)
						},
						setCollisionBetween: function(t, e, i, n, s) {
							return null === (s = this.getLayer(s)) ? null : (f.SetCollisionBetween(t, e, i, n, s), this)
						},
						setCollisionByProperty: function(t, e, i, n) {
							return null === (n = this.getLayer(n)) ? null : (f.SetCollisionByProperty(t, e, i, n), this)
						},
						setCollisionByExclusion: function(t, e, i, n) {
							return null === (n = this.getLayer(n)) ? null : (f.SetCollisionByExclusion(t, e, i, n), this)
						},
						setCollisionFromCollisionGroup: function(t, e, i) {
							return null === (i = this.getLayer(i)) ? null : (f.SetCollisionFromCollisionGroup(t, e, i), this)
						},
						setTileIndexCallback: function(t, e, i, n) {
							return null === (n = this.getLayer(n)) ? null : (f.SetTileIndexCallback(t, e, i, n), this)
						},
						setTileLocationCallback: function(t, e, i, n, s, r, o) {
							return null === (o = this.getLayer(o)) ? null : (f.SetTileLocationCallback(t, e, i, n, s, r, o), this)
						},
						setLayer: function(t) {
							var e = this.getLayerIndex(t);
							return null !== e && (this.currentLayerIndex = e), this
						},
						setBaseTileSize: function(t, e) {
							this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e;
							for (var i = 0; i < this.layers.length; i++) {
								this.layers[i].baseTileWidth = t, this.layers[i].baseTileHeight = e;
								for (var n = this.layers[i].data, s = this.layers[i].width, r = this.layers[i].height, o = 0; o < r; o++)
									for (var a = 0; a < s; a++) {
										var h = n[o][a];
										null !== h && h.setSize(void 0, void 0, t, e)
									}
							}
							return this
						},
						setLayerTileSize: function(t, e, i) {
							if (null === (i = this.getLayer(i))) return this;
							i.tileWidth = t, i.tileHeight = e;
							for (var n = i.data, s = i.width, r = i.height, o = 0; o < r; o++)
								for (var a = 0; a < s; a++) {
									var h = n[o][a];
									null !== h && h.setSize(t, e)
								}
							return this
						},
						shuffle: function(t, e, i, n, s) {
							return s = this.getLayer(s), this._isStaticCall(s, "shuffle") ? this : null === s ? null : (f.Shuffle(t, e, i, n, s), this)
						},
						swapByIndex: function(t, e, i, n, s, r, o) {
							return o = this.getLayer(o), this._isStaticCall(o, "swapByIndex") ? this : null === o ? null : (f.SwapByIndex(t, e, i, n, s, r, o), this)
						},
						tileToWorldX: function(t, e, i) {
							return null === (i = this.getLayer(i)) ? null : f.TileToWorldX(t, e, i)
						},
						tileToWorldY: function(t, e, i) {
							return null === (i = this.getLayer(i)) ? null : f.TileToWorldY(t, e, i)
						},
						tileToWorldXY: function(t, e, i, n, s) {
							return null === (s = this.getLayer(s)) ? null : f.TileToWorldXY(t, e, i, n, s)
						},
						weightedRandomize: function(t, e, i, n, s, r) {
							return r = this.getLayer(r), this._isStaticCall(r, "weightedRandomize") ? this : null === r ? null : (f.WeightedRandomize(t, e, i, n, s, r), this)
						},
						worldToTileX: function(t, e, i, n) {
							return null === (n = this.getLayer(n)) ? null : f.WorldToTileX(t, e, i, n)
						},
						worldToTileY: function(t, e, i, n) {
							return null === (n = this.getLayer(n)) ? null : f.WorldToTileY(t, e, i, n)
						},
						worldToTileXY: function(t, e, i, n, s, r) {
							return null === (r = this.getLayer(r)) ? null : f.WorldToTileXY(t, e, i, n, s, r)
						},
						_isStaticCall: function(t, e) {
							return t.tilemapLayer instanceof c && (console.warn(e + ": You cannot change the tiles in a static tilemap layer"), !0)
						}
					});
				t.exports = g
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(1345),
					o = i(14),
					a = i(141),
					h = new n({
						Extends: o,
						Mixins: [s.Alpha, s.BlendMode, s.ComputedSize, s.Depth, s.Flip, s.GetBounds, s.Origin, s.Pipeline, s.Transform, s.Visible, s.ScrollFactor, r],
						initialize: function(t, e, i, n, s, r) {
							o.call(this, t, "DynamicTilemapLayer"), this.isTilemap = !0, this.tilemap = e, this.layerIndex = i, this.layer = e.layers[i], (this.layer.tilemapLayer = this).tileset = [], this.culledTiles = [], this.skipCull = !1, this.tilesDrawn = 0, this.tilesTotal = this.layer.width * this.layer.height, this.cullPaddingX = 1, this.cullPaddingY = 1, this.cullCallback = a.CullTiles, this._renderOrder = 0, this.gidMap = [], this.setTilesets(n), this.setAlpha(this.layer.alpha), this.setPosition(s, r), this.setOrigin(), this.setSize(e.tileWidth * this.layer.width, e.tileHeight * this.layer.height), this.initPipeline("TextureTintPipeline")
						},
						setTilesets: function(t) {
							var e = [],
								i = [],
								n = this.tilemap;
							Array.isArray(t) || (t = [t]);
							for (var s = 0; s < t.length; s++) {
								var r = t[s];
								if ("string" == typeof r && (r = n.getTileset(r)), r) {
									i.push(r);
									for (var o = r.firstgid, a = 0; a < r.total; a++) e[o + a] = r
								}
							}
							this.gidMap = e, this.tileset = i
						},
						setRenderOrder: function(t) {
							return "string" == typeof t && (t = ["right-down", "left-down", "right-up", "left-up"].indexOf(t)), 0 <= t && t < 4 && (this._renderOrder = t), this
						},
						calculateFacesAt: function(t, e) {
							return a.CalculateFacesAt(t, e, this.layer), this
						},
						calculateFacesWithin: function(t, e, i, n) {
							return a.CalculateFacesWithin(t, e, i, n, this.layer), this
						},
						createFromTiles: function(t, e, i, n, s) {
							return a.CreateFromTiles(t, e, i, n, s, this.layer)
						},
						cull: function(t) {
							return this.cullCallback(this.layer, t, this.culledTiles, this._renderOrder)
						},
						copy: function(t, e, i, n, s, r, o) {
							return a.Copy(t, e, i, n, s, r, o, this.layer), this
						},
						destroy: function(t) {
							void 0 === t && (t = !0), this.tilemap && (this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0), t && this.tilemap.removeLayer(this), this.tilemap = void 0, this.layer = void 0, this.culledTiles.length = 0, this.cullCallback = null, this.gidMap = [], this.tileset = [], o.prototype.destroy.call(this))
						},
						fill: function(t, e, i, n, s, r) {
							return a.Fill(t, e, i, n, s, r, this.layer), this
						},
						filterTiles: function(t, e, i, n, s, r, o) {
							return a.FilterTiles(t, e, i, n, s, r, o, this.layer)
						},
						findByIndex: function(t, e, i) {
							return a.FindByIndex(t, e, i, this.layer)
						},
						findTile: function(t, e, i, n, s, r, o) {
							return a.FindTile(t, e, i, n, s, r, o, this.layer)
						},
						forEachTile: function(t, e, i, n, s, r, o) {
							return a.ForEachTile(t, e, i, n, s, r, o, this.layer), this
						},
						getTileAt: function(t, e, i) {
							return a.GetTileAt(t, e, i, this.layer)
						},
						getTileAtWorldXY: function(t, e, i, n) {
							return a.GetTileAtWorldXY(t, e, i, n, this.layer)
						},
						getTilesWithin: function(t, e, i, n, s) {
							return a.GetTilesWithin(t, e, i, n, s, this.layer)
						},
						getTilesWithinShape: function(t, e, i) {
							return a.GetTilesWithinShape(t, e, i, this.layer)
						},
						getTilesWithinWorldXY: function(t, e, i, n, s, r) {
							return a.GetTilesWithinWorldXY(t, e, i, n, s, r, this.layer)
						},
						hasTileAt: function(t, e) {
							return a.HasTileAt(t, e, this.layer)
						},
						hasTileAtWorldXY: function(t, e, i) {
							return a.HasTileAtWorldXY(t, e, i, this.layer)
						},
						putTileAt: function(t, e, i, n) {
							return a.PutTileAt(t, e, i, n, this.layer)
						},
						putTileAtWorldXY: function(t, e, i, n, s) {
							return a.PutTileAtWorldXY(t, e, i, n, s, this.layer)
						},
						putTilesAt: function(t, e, i, n) {
							return a.PutTilesAt(t, e, i, n, this.layer), this
						},
						randomize: function(t, e, i, n, s) {
							return a.Randomize(t, e, i, n, s, this.layer), this
						},
						removeTileAt: function(t, e, i, n) {
							return a.RemoveTileAt(t, e, i, n, this.layer)
						},
						removeTileAtWorldXY: function(t, e, i, n, s) {
							return a.RemoveTileAtWorldXY(t, e, i, n, s, this.layer)
						},
						renderDebug: function(t, e) {
							return a.RenderDebug(t, e, this.layer), this
						},
						replaceByIndex: function(t, e, i, n, s, r) {
							return a.ReplaceByIndex(t, e, i, n, s, r, this.layer), this
						},
						setSkipCull: function(t) {
							return void 0 === t && (t = !0), this.skipCull = t, this
						},
						setCullPadding: function(t, e) {
							return void 0 === t && (t = 1), void 0 === e && (e = 1), this.cullPaddingX = t, this.cullPaddingY = e, this
						},
						setCollision: function(t, e, i, n) {
							return a.SetCollision(t, e, i, this.layer, n), this
						},
						setCollisionBetween: function(t, e, i, n) {
							return a.SetCollisionBetween(t, e, i, n, this.layer), this
						},
						setCollisionByProperty: function(t, e, i) {
							return a.SetCollisionByProperty(t, e, i, this.layer), this
						},
						setCollisionByExclusion: function(t, e, i) {
							return a.SetCollisionByExclusion(t, e, i, this.layer), this
						},
						setCollisionFromCollisionGroup: function(t, e) {
							return a.SetCollisionFromCollisionGroup(t, e, this.layer), this
						},
						setTileIndexCallback: function(t, e, i) {
							return a.SetTileIndexCallback(t, e, i, this.layer), this
						},
						setTileLocationCallback: function(t, e, i, n, s, r) {
							return a.SetTileLocationCallback(t, e, i, n, s, r, this.layer), this
						},
						shuffle: function(t, e, i, n) {
							return a.Shuffle(t, e, i, n, this.layer), this
						},
						swapByIndex: function(t, e, i, n, s, r) {
							return a.SwapByIndex(t, e, i, n, s, r, this.layer), this
						},
						tileToWorldX: function(t, e) {
							return a.TileToWorldX(t, e, this.layer)
						},
						tileToWorldY: function(t, e) {
							return a.TileToWorldY(t, e, this.layer)
						},
						tileToWorldXY: function(t, e, i, n) {
							return a.TileToWorldXY(t, e, i, n, this.layer)
						},
						weightedRandomize: function(t, e, i, n, s) {
							return a.WeightedRandomize(t, e, i, n, s, this.layer), this
						},
						worldToTileX: function(t, e, i) {
							return a.WorldToTileX(t, e, i, this.layer)
						},
						worldToTileY: function(t, e, i) {
							return a.WorldToTileY(t, e, i, this.layer)
						},
						worldToTileXY: function(t, e, i, n, s) {
							return a.WorldToTileXY(t, e, i, n, s, this.layer)
						}
					});
				t.exports = h
			}, function(t, e, i) {
				var n = i(0),
					s = i(12),
					r = i(20),
					o = i(14),
					a = i(1348),
					h = i(141),
					u = i(29),
					l = i(9),
					c = new n({
						Extends: o,
						Mixins: [s.Alpha, s.BlendMode, s.ComputedSize, s.Depth, s.Flip, s.GetBounds, s.Origin, s.Pipeline, s.Transform, s.Visible, s.ScrollFactor, a],
						initialize: function(t, e, i, n, s, a) {
							o.call(this, t, "StaticTilemapLayer"), this.isTilemap = !0, this.tilemap = e, this.layerIndex = i, this.layer = e.layers[i], (this.layer.tilemapLayer = this).tileset = [], this.culledTiles = [], this.skipCull = !1, this.tilesDrawn = 0, this.tilesTotal = this.layer.width * this.layer.height, this.cullPaddingX = 1, this.cullPaddingY = 1, this.cullCallback = h.CullTiles, this.renderer = t.sys.game.renderer, this.vertexBuffer = [], this.bufferData = [], this.vertexViewF32 = [], this.vertexViewU32 = [], this.dirty = [], this.vertexCount = [], this._renderOrder = 0, this._tempMatrix = new u, this.gidMap = [], this.setTilesets(n), this.setAlpha(this.layer.alpha), this.setPosition(s, a), this.setOrigin(), this.setSize(e.tileWidth * this.layer.width, e.tileHeight * this.layer.height), this.updateVBOData(), this.initPipeline("TextureTintPipeline"), t.sys.game.events.on(r.CONTEXT_RESTORED, function() {
								this.updateVBOData()
							}, this)
						},
						setTilesets: function(t) {
							var e = [],
								i = [],
								n = this.tilemap;
							Array.isArray(t) || (t = [t]);
							for (var s = 0; s < t.length; s++) {
								var r = t[s];
								if ("string" == typeof r && (r = n.getTileset(r)), r) {
									i.push(r);
									for (var o = r.firstgid, a = 0; a < r.total; a++) e[o + a] = r
								}
							}
							this.gidMap = e, this.tileset = i
						},
						updateVBOData: function() {
							for (var t = 0; t < this.tileset.length; t++) this.dirty[t] = !0, this.vertexCount[t] = 0, this.vertexBuffer[t] = null, this.bufferData[t] = null, this.vertexViewF32[t] = null, this.vertexViewU32[t] = null;
							return this
						},
						upload: function(t, e) {
							var i = this.renderer,
								n = i.gl,
								s = i.pipelines.TextureTintPipeline;
							if (this.dirty[e]) {
								var r, o, a, h = this.tileset[e],
									u = this.layer.width,
									l = this.layer.height,
									c = h.image.source[0].width,
									d = h.image.source[0].height,
									f = this.layer.data,
									p = this._renderOrder,
									g = h.firstgid,
									v = h.firstgid + h.total,
									m = this.vertexBuffer[e],
									y = this.bufferData[e],
									x = -1,
									T = u * l * s.vertexSize * 6;
								if (this.vertexCount[e] = 0, null === y && (y = new ArrayBuffer(T), this.bufferData[e] = y, this.vertexViewF32[e] = new Float32Array(y), this.vertexViewU32[e] = new Uint32Array(y)), 0 === p)
									for (o = 0; o < l; o++)
										for (a = 0; a < u; a++) !(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e));
								else if (1 === p)
									for (o = 0; o < l; o++)
										for (a = u - 1; 0 <= a; a--) !(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e));
								else if (2 === p)
									for (o = l - 1; 0 <= o; o--)
										for (a = 0; a < u; a++) !(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e));
								else if (3 === p)
									for (o = l - 1; 0 <= o; o--)
										for (a = u - 1; 0 <= a; a--) !(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e));
								this.dirty[e] = !1, null === m ? (m = i.createVertexBuffer(y, n.STATIC_DRAW), this.vertexBuffer[e] = m) : (i.setVertexBuffer(m), n.bufferSubData(n.ARRAY_BUFFER, 0, y))
							}
							return this
						},
						batchTile: function(t, e, i, n, s, r, o) {
							var a = i.getTileTextureCoordinates(e.index);
							if (!a) return t;
							var h = i.tileWidth,
								u = i.tileHeight,
								c = h / 2,
								d = u / 2,
								f = a.x / n,
								p = a.y / s,
								g = (a.x + h) / n,
								v = (a.y + u) / s,
								m = this._tempMatrix,
								y = -c,
								x = -d;
							e.flipX && (h *= -1, y += i.tileWidth), e.flipY && (u *= -1, x += i.tileHeight);
							var T = y + h,
								w = x + u;
							m.applyITRS(c + e.pixelX, d + e.pixelY, e.rotation, 1, 1);
							var E = l.getTintAppendFloatAlpha(16777215, r.alpha * this.alpha * e.alpha),
								_ = m.getX(y, x),
								b = m.getY(y, x),
								A = m.getX(y, w),
								S = m.getY(y, w),
								C = m.getX(T, w),
								M = m.getY(T, w),
								O = m.getX(T, x),
								P = m.getY(T, x);
							r.roundPixels && (_ = Math.round(_), b = Math.round(b), A = Math.round(A), S = Math.round(S), C = Math.round(C), M = Math.round(M), O = Math.round(O), P = Math.round(P));
							var R = this.vertexViewF32[o],
								L = this.vertexViewU32[o];
							return R[++t] = _, R[++t] = b, R[++t] = f, R[++t] = p, R[++t] = 0, L[++t] = E, R[++t] = A, R[++t] = S, R[++t] = f, R[++t] = v, R[++t] = 0, L[++t] = E, R[++t] = C, R[++t] = M, R[++t] = g, R[++t] = v, R[++t] = 0, L[++t] = E, R[++t] = _, R[++t] = b, R[++t] = f, R[++t] = p, R[++t] = 0, L[++t] = E, R[++t] = C, R[++t] = M, R[++t] = g, R[++t] = v, R[++t] = 0, L[++t] = E, R[++t] = O, R[++t] = P, R[++t] = g, R[++t] = p, R[++t] = 0, L[++t] = E, this.vertexCount[o] += 6, t
						},
						setRenderOrder: function(t) {
							if ("string" == typeof t && (t = ["right-down", "left-down", "right-up", "left-up"].indexOf(t)), 0 <= t && t < 4) {
								this._renderOrder = t;
								for (var e = 0; e < this.tileset.length; e++) this.dirty[e] = !0
							}
							return this
						},
						calculateFacesAt: function(t, e) {
							return h.CalculateFacesAt(t, e, this.layer), this
						},
						calculateFacesWithin: function(t, e, i, n) {
							return h.CalculateFacesWithin(t, e, i, n, this.layer), this
						},
						createFromTiles: function(t, e, i, n, s) {
							return h.CreateFromTiles(t, e, i, n, s, this.layer)
						},
						cull: function(t) {
							return this.cullCallback(this.layer, t, this.culledTiles)
						},
						setSkipCull: function(t) {
							return void 0 === t && (t = !0), this.skipCull = t, this
						},
						setCullPadding: function(t, e) {
							return void 0 === t && (t = 1), void 0 === e && (e = 1), this.cullPaddingX = t, this.cullPaddingY = e, this
						},
						findByIndex: function(t, e, i) {
							return h.FindByIndex(t, e, i, this.layer)
						},
						findTile: function(t, e, i, n, s, r, o) {
							return h.FindTile(t, e, i, n, s, r, o, this.layer)
						},
						filterTiles: function(t, e, i, n, s, r, o) {
							return h.FilterTiles(t, e, i, n, s, r, o, this.layer)
						},
						forEachTile: function(t, e, i, n, s, r, o) {
							return h.ForEachTile(t, e, i, n, s, r, o, this.layer), this
						},
						getTileAt: function(t, e, i) {
							return h.GetTileAt(t, e, i, this.layer)
						},
						getTileAtWorldXY: function(t, e, i, n) {
							return h.GetTileAtWorldXY(t, e, i, n, this.layer)
						},
						getTilesWithin: function(t, e, i, n, s) {
							return h.GetTilesWithin(t, e, i, n, s, this.layer)
						},
						getTilesWithinWorldXY: function(t, e, i, n, s, r) {
							return h.GetTilesWithinWorldXY(t, e, i, n, s, r, this.layer)
						},
						getTilesWithinShape: function(t, e, i) {
							return h.GetTilesWithinShape(t, e, i, this.layer)
						},
						hasTileAt: function(t, e) {
							return h.HasTileAt(t, e, this.layer)
						},
						hasTileAtWorldXY: function(t, e, i) {
							return h.HasTileAtWorldXY(t, e, i, this.layer)
						},
						renderDebug: function(t, e) {
							return h.RenderDebug(t, e, this.layer), this
						},
						setCollision: function(t, e, i, n) {
							return h.SetCollision(t, e, i, this.layer, n), this
						},
						setCollisionBetween: function(t, e, i, n) {
							return h.SetCollisionBetween(t, e, i, n, this.layer), this
						},
						setCollisionByProperty: function(t, e, i) {
							return h.SetCollisionByProperty(t, e, i, this.layer), this
						},
						setCollisionByExclusion: function(t, e, i) {
							return h.SetCollisionByExclusion(t, e, i, this.layer), this
						},
						setTileIndexCallback: function(t, e, i) {
							return h.SetTileIndexCallback(t, e, i, this.layer), this
						},
						setCollisionFromCollisionGroup: function(t, e) {
							return h.SetCollisionFromCollisionGroup(t, e, this.layer), this
						},
						setTileLocationCallback: function(t, e, i, n, s, r) {
							return h.SetTileLocationCallback(t, e, i, n, s, r, this.layer), this
						},
						tileToWorldX: function(t, e) {
							return h.TileToWorldX(t, e, this.layer)
						},
						tileToWorldY: function(t, e) {
							return h.TileToWorldY(t, e, this.layer)
						},
						tileToWorldXY: function(t, e, i, n) {
							return h.TileToWorldXY(t, e, i, n, this.layer)
						},
						worldToTileX: function(t, e, i) {
							return h.WorldToTileX(t, e, i, this.layer)
						},
						worldToTileY: function(t, e, i) {
							return h.WorldToTileY(t, e, i, this.layer)
						},
						worldToTileXY: function(t, e, i, n, s) {
							return h.WorldToTileXY(t, e, i, n, s, this.layer)
						},
						destroy: function(t) {
							if (void 0 === t && (t = !0), this.tilemap) {
								this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0), t && this.tilemap.removeLayer(this), this.tilemap = void 0, this.layer = void 0, this.culledTiles.length = 0, this.cullCallback = null;
								for (var e = 0; e < this.tileset.length; e++) this.dirty[e] = !0, this.vertexCount[e] = 0, this.vertexBuffer[e] = null, this.bufferData[e] = null, this.vertexViewF32[e] = null, this.vertexViewU32[e] = null;
								this.gidMap = [], this.tileset = [], o.prototype.destroy.call(this)
							}
						}
					});
				t.exports = c
			}, function(t, e, i) {
				var n = i(0),
					s = i(2),
					r = new n({
						initialize: function(t) {
							this.delay = 0, this.repeat = 0, this.repeatCount = 0, this.loop = !1, this.callback, this.callbackScope, this.args, this.timeScale = 1, this.startAt = 0, this.elapsed = 0, this.paused = !1, this.hasDispatched = !1, this.reset(t)
						},
						reset: function(t) {
							return this.delay = s(t, "delay", 0), this.repeat = s(t, "repeat", 0), this.loop = s(t, "loop", !1), this.callback = s(t, "callback", void 0), this.callbackScope = s(t, "callbackScope", this.callback), this.args = s(t, "args", []), this.timeScale = s(t, "timeScale", 1), this.startAt = s(t, "startAt", 0), this.paused = s(t, "paused", !1), this.elapsed = this.startAt, this.hasDispatched = !1, this.repeatCount = -1 === this.repeat || this.loop ? 999999999999 : this.repeat, this
						},
						getProgress: function() {
							return this.elapsed / this.delay
						},
						getOverallProgress: function() {
							if (0 < this.repeat) {
								var t = this.delay + this.delay * this.repeat;
								return (this.elapsed + this.delay * (this.repeat - this.repeatCount)) / t
							}
							return this.getProgress()
						},
						getRepeatCount: function() {
							return this.repeatCount
						},
						getElapsed: function() {
							return this.elapsed
						},
						getElapsedSeconds: function() {
							return .001 * this.elapsed
						},
						remove: function(t) {
							void 0 === t && (t = !1), this.elapsed = this.delay, this.hasDispatched = !t, this.repeatCount = 0
						},
						destroy: function() {
							this.callback = void 0, this.callbackScope = void 0, this.args = []
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = i(1357);
				t.exports = function(t) {
					var e, i = [];
					if (t.hasOwnProperty("props"))
						for (e in t.props) "_" !== e.substr(0, 1) && i.push({
							key: e,
							value: t.props[e]
						});
					else
						for (e in t) - 1 === n.indexOf(e) && "_" !== e.substr(0, 1) && i.push({
							key: e,
							value: t[e]
						});
					return i
				}
			}, function(t, e, i) {
				var n = i(6);
				t.exports = function(t) {
					var e = n(t, "tweens", null);
					return null === e ? [] : ("function" == typeof e && (e = e.call()), Array.isArray(e) || (e = [e]), e)
				}
			}, function(t, e, i) {
				var n = i(230),
					s = i(15),
					r = i(88),
					o = i(69),
					a = i(145),
					h = i(6),
					u = i(229),
					l = i(231),
					c = i(233);
				t.exports = function(t, e, i) {
					void 0 === i && (i = n);
					var d = h(e, "from", 0),
						f = h(e, "to", 1),
						p = [{
							value: d
						}],
						g = a(e, "delay", i.delay),
						v = a(e, "duration", i.duration),
						m = h(e, "easeParams", i.easeParams),
						y = o(h(e, "ease", i.ease), m),
						x = a(e, "hold", i.hold),
						T = a(e, "repeat", i.repeat),
						w = a(e, "repeatDelay", i.repeatDelay),
						E = r(e, "yoyo", i.yoyo),
						_ = [],
						b = u("value", f),
						A = c(p[0], 0, "value", b.getEnd, b.getStart, b.getActive, y, g, v, E, x, T, w, !1, !1);
					A.start = d, A.current = d, A.to = f, _.push(A);
					var S = new l(t, _, p);
					S.offset = s(e, "offset", null), S.completeDelay = s(e, "completeDelay", 0), S.loop = Math.round(s(e, "loop", 0)), S.loopDelay = Math.round(s(e, "loopDelay", 0)), S.paused = r(e, "paused", !1), S.useFrames = r(e, "useFrames", !1);
					for (var C = h(e, "callbackScope", S), M = [S, null], O = l.TYPES, P = 0; P < O.length; P++) {
						var R, L, D = O[P],
							F = h(e, D, !1);
						F && (R = h(e, D + "Scope", C), L = h(e, D + "Params", []), S.setCallback(D, F, M.concat(L), R))
					}
					return S
				}
			}, function(t, e, i) {
				var n = i(69),
					s = i(6),
					r = i(13);
				t.exports = function(t, e) {
					void 0 === e && (e = {});
					var i = s(e, "start", 0),
						o = s(e, "ease", null),
						a = s(e, "grid", null),
						h = s(e, "from", 0),
						u = "first" === h,
						l = "center" === h,
						c = "last" === h,
						d = "number" == typeof h,
						f = Array.isArray(t),
						p = f ? parseFloat(t[0]) : parseFloat(t),
						g = f ? parseFloat(t[1]) : 0,
						v = Math.max(p, g);
					if (f && (i += p), a) {
						var m, y, x = a[0],
							T = a[1],
							w = 0,
							E = 0,
							_ = [];
						c ? (w = x - 1, E = T - 1) : d ? (w = h % x, E = Math.floor(h / x)) : l && (w = (x - 1) / 2, E = (T - 1) / 2);
						for (var b = r.MIN_SAFE_INTEGER, A = 0; A < T; A++) {
							_[A] = [];
							for (var S = 0; S < x; S++) {
								m = w - S, y = E - A;
								var C = Math.sqrt(m * m + y * y);
								b < C && (b = C), _[A][S] = C
							}
						}
					}
					var M = o ? n(o) : null;
					return a ? function(t, e, n, s) {
						var r, o = 0,
							a = s % x,
							h = Math.floor(s / x);
						return 0 <= a && a < x && 0 <= h && h < T && (o = _[h][a]), (f ? (r = g - p, M ? o / b * r * M(o / b) : o / b * r) : M ? o * p * M(o / b) : o * p) + i
					} : function(t, e, n, s, r) {
						var o, a;
						return r--, u ? o = s : l ? o = Math.abs(r / 2 - s) : c ? o = r - s : d && (o = Math.abs(h - s)), (f ? (a = l ? (g - p) / r * (2 * o) : (g - p) / r * o, M ? a * M(o / r) : a) : M ? r * v * M(o / r) : o * p) + i
					}
				}
			}, function(t, e, i) {
				var n = i(67),
					s = i(230),
					r = i(15),
					o = i(88),
					a = i(69),
					h = i(145),
					u = i(228),
					l = i(499),
					c = i(6),
					d = i(503),
					f = i(146);
				t.exports = function(t, e) {
					var i = new d(t);
					i.completeDelay = r(e, "completeDelay", 0), i.loop = Math.round(r(e, "loop", 0)), i.loopDelay = Math.round(r(e, "loopDelay", 0)), i.paused = o(e, "paused", !1), i.useFrames = o(e, "useFrames", !1);
					var p, g, v = c(e, "callbackScope", i),
						m = [i],
						y = c(e, "onStart", !1);
					y && (p = c(e, "onStartScope", v), g = c(e, "onStartParams", []), i.setCallback("onStart", y, m.concat(g), p));
					var x, T, w = c(e, "onUpdate", !1);
					w && (x = c(e, "onUpdateScope", v), T = c(e, "onUpdateParams", []), i.setCallback("onUpdate", w, m.concat(T), x));
					var E, _, b = c(e, "onLoop", !1);
					b && (E = c(e, "onLoopScope", v), _ = c(e, "onLoopParams", []), i.setCallback("onLoop", b, m.concat(_), E));
					var A, S, C = c(e, "onYoyo", !1);
					C && (A = c(e, "onYoyoScope", v), S = c(e, "onYoyoParams", []), i.setCallback("onYoyo", C, m.concat(null, S), A));
					var M, O, P = c(e, "onComplete", !1);
					P && (M = c(e, "onCompleteScope", v), O = c(e, "onCompleteParams", []), i.setCallback("onComplete", P, m.concat(O), M));
					var R = l(e);
					if (0 === R.length) return i.paused = !0, i;
					var L = n(s);
					L.targets = u(e);
					var D = r(e, "totalDuration", 0);
					L.duration = 0 < D ? Math.floor(D / R.length) : h(e, "duration", L.duration), L.delay = h(e, "delay", L.delay), L.easeParams = c(e, "easeParams", L.easeParams), L.ease = a(c(e, "ease", L.ease), L.easeParams), L.hold = h(e, "hold", L.hold), L.repeat = h(e, "repeat", L.repeat), L.repeatDelay = h(e, "repeatDelay", L.repeatDelay), L.yoyo = o(e, "yoyo", L.yoyo), L.flipX = o(e, "flipX", L.flipX), L.flipY = o(e, "flipY", L.flipY);
					for (var F = 0; F < R.length; F++) i.queue(f(i, R[F], L));
					return i
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(10),
					r = i(232),
					o = i(146),
					a = i(89),
					h = new n({
						Extends: s,
						initialize: function(t) {
							s.call(this), this.manager = t, this.isTimeline = !0, this.data = [], this.totalData = 0, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.completeDelay = 0, this.countdown = 0, this.state = a.PENDING_ADD, this._pausedState = a.PENDING_ADD, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = {
								onComplete: null,
								onLoop: null,
								onStart: null,
								onUpdate: null,
								onYoyo: null
							}, this.callbackScope
						},
						dispatchTimelineEvent: function(t, e) {
							this.emit(t, this), e && e.func.apply(e.scope, e.params)
						},
						setTimeScale: function(t) {
							return this.timeScale = t, this
						},
						getTimeScale: function() {
							return this.timeScale
						},
						isPlaying: function() {
							return this.state === a.ACTIVE
						},
						add: function(t) {
							return this.queue(o(this, t))
						},
						queue: function(t) {
							return this.isPlaying() || (t.parent = this, t.parentIsTimeline = !0, this.data.push(t), this.totalData = this.data.length), this
						},
						hasOffset: function(t) {
							return null !== t.offset
						},
						isOffsetAbsolute: function(t) {
							return "number" == typeof t
						},
						isOffsetRelative: function(t) {
							if ("string" == typeof t) {
								var e = t[0];
								if ("-" === e || "+" === e) return !0
							}
							return !1
						},
						getRelativeOffset: function(t, e) {
							var i = t[0],
								n = parseFloat(t.substr(2)),
								s = e;
							switch (i) {
								case "+":
									s += n;
									break;
								case "-":
									s -= n
							}
							return Math.max(0, s)
						},
						calcDuration: function() {
							for (var t = 0, e = 0, i = 0, n = 0; n < this.totalData; n++) {
								var s = this.data[n];
								s.init(), this.hasOffset(s) ? this.isOffsetAbsolute(s.offset) ? (s.calculatedOffset = s.offset, 0 === s.offset && (i = 0)) : this.isOffsetRelative(s.offset) && (s.calculatedOffset = this.getRelativeOffset(s.offset, t)) : s.calculatedOffset = i, t = s.totalDuration + s.calculatedOffset, e += s.totalDuration, i += s.totalDuration
							}
							this.duration = e, this.loopCounter = -1 === this.loop ? 999999999999 : this.loop, 0 < this.loopCounter ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay
						},
						init: function() {
							return this.calcDuration(), this.progress = 0, this.totalProgress = 0, !this.paused || (this.state = a.PAUSED, !1)
						},
						resetTweens: function(t) {
							for (var e = 0; e < this.totalData; e++) this.data[e].play(t)
						},
						setCallback: function(t, e, i, n) {
							return -1 !== h.TYPES.indexOf(t) && (this.callbacks[t] = {
								func: e,
								scope: n,
								params: i
							}), this
						},
						makeActive: function(t) {
							return this.manager.makeActive(t)
						},
						play: function() {
							if (this.state !== a.ACTIVE) {
								if (this.paused) return this.paused = !1, void this.manager.makeActive(this);
								this.resetTweens(!1), this.state = a.ACTIVE, this.dispatchTimelineEvent(r.TIMELINE_START, this.callbacks.onStart)
							}
						},
						nextState: function() {
							0 < this.loopCounter ? (this.elapsed = 0, this.progress = 0, this.loopCounter--, this.resetTweens(!0), 0 < this.loopDelay ? (this.countdown = this.loopDelay, this.state = a.LOOP_DELAY) : (this.state = a.ACTIVE, this.dispatchTimelineEvent(r.TIMELINE_LOOP, this.callbacks.onLoop))) : 0 < this.completeDelay ? (this.state = a.COMPLETE_DELAY, this.countdown = this.completeDelay) : (this.state = a.PENDING_REMOVE, this.dispatchTimelineEvent(r.TIMELINE_COMPLETE, this.callbacks.onComplete))
						},
						update: function(t, e) {
							if (this.state !== a.PAUSED) {
								switch (this.useFrames && (e = +this.manager.timeScale), e *= this.timeScale, this.elapsed += e, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += e, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) {
									case a.ACTIVE:
										for (var i = this.totalData, n = 0; n < this.totalData; n++) this.data[n].update(t, e) && i--;
										this.dispatchTimelineEvent(r.TIMELINE_UPDATE, this.callbacks.onUpdate), 0 === i && this.nextState();
										break;
									case a.LOOP_DELAY:
										this.countdown -= e, this.countdown <= 0 && (this.state = a.ACTIVE, this.dispatchTimelineEvent(r.TIMELINE_LOOP, this.callbacks.onLoop));
										break;
									case a.COMPLETE_DELAY:
										this.countdown -= e, this.countdown <= 0 && (this.state = a.PENDING_REMOVE, this.dispatchTimelineEvent(r.TIMELINE_COMPLETE, this.callbacks.onComplete))
								}
								return this.state === a.PENDING_REMOVE
							}
						},
						stop: function() {
							this.state = a.PENDING_REMOVE
						},
						pause: function() {
							if (this.state !== a.PAUSED) return this.paused = !0, this._pausedState = this.state, this.state = a.PAUSED, this.emit(r.TIMELINE_PAUSE, this), this
						},
						resume: function() {
							return this.state === a.PAUSED && (this.paused = !1, this.state = this._pausedState, this.emit(r.TIMELINE_RESUME, this)), this
						},
						hasTarget: function(t) {
							for (var e = 0; e < this.data.length; e++)
								if (this.data[e].hasTarget(t)) return !0;
							return !1
						},
						destroy: function() {
							for (var t = 0; t < this.data.length; t++) this.data[t].stop()
						}
					});
				h.TYPES = ["onStart", "onUpdate", "onLoop", "onComplete", "onYoyo"], t.exports = h
			}, function(t, e, i) {
				var n = i(151),
					s = i(0),
					r = i(111),
					o = new s({
						initialize: function(t) {
							this.parent = t, this.animationManager = t.scene.sys.anims, this.animationManager.once(r.REMOVE_ANIMATION, this.remove, this), this.isPlaying = !1, this.currentAnim = null, this.currentFrame = null, this.nextAnim = null, this.nextAnimsQueue = [], this._timeScale = 1, this.frameRate = 0, this.duration = 0, this.msPerFrame = 0, this.skipMissedFrames = !0, this._delay = 0, this._repeat = 0, this._repeatDelay = 0, this._yoyo = !1, this.forward = !0, this._reverse = !1, this.accumulator = 0, this.nextTick = 0, this.repeatCounter = 0, this.pendingRepeat = !1, this._paused = !1, this._wasPlaying = !1, this._pendingStop = 0, this._pendingStopValue
						},
						chain: function(t) {
							return t instanceof n && (t = t.key), null === this.nextAnim ? this.nextAnim = t : this.nextAnimsQueue.push(t), this.parent
						},
						setDelay: function(t) {
							return void 0 === t && (t = 0), this._delay = t, this.parent
						},
						getDelay: function() {
							return this._delay
						},
						delayedPlay: function(t, e, i) {
							return this.play(e, !0, i), this.nextTick += t, this.parent
						},
						getCurrentKey: function() {
							if (this.currentAnim) return this.currentAnim.key
						},
						load: function(t, e) {
							return void 0 === e && (e = 0), this.isPlaying && this.stop(), this.animationManager.load(this, t, e), this.parent
						},
						pause: function(t) {
							return this._paused || (this._paused = !0, this._wasPlaying = this.isPlaying, this.isPlaying = !1), void 0 !== t && this.updateFrame(t), this.parent
						},
						resume: function(t) {
							return this._paused && (this._paused = !1, this.isPlaying = this._wasPlaying), void 0 !== t && this.updateFrame(t), this.parent
						},
						isPaused: {
							get: function() {
								return this._paused
							}
						},
						play: function(t, e, i) {
							return void 0 === e && (e = !1), void 0 === i && (i = 0), t instanceof n && (t = t.key), e && this.isPlaying && this.currentAnim.key === t ? this.parent : (this.forward = !0, this._reverse = !1, this._paused = !1, this._wasPlaying = !0, this._startAnimation(t, i))
						},
						playReverse: function(t, e, i) {
							return void 0 === e && (e = !1), void 0 === i && (i = 0), t instanceof n && (t = t.key), e && this.isPlaying && this.currentAnim.key === t ? this.parent : (this.forward = !1, this._reverse = !0, this._startAnimation(t, i))
						},
						_startAnimation: function(t, e) {
							this.load(t, e);
							var i = this.currentAnim,
								n = this.parent;
							if (!i) return n;
							this.repeatCounter = -1 === this._repeat ? Number.MAX_VALUE : this._repeat, i.getFirstTick(this), this.isPlaying = !0, this.pendingRepeat = !1, i.showOnStart && (n.visible = !0);
							var s = this.currentFrame;
							return i.emit(r.ANIMATION_START, i, s, n), n.emit(r.SPRITE_ANIMATION_KEY_START + t, i, s, n), n.emit(r.SPRITE_ANIMATION_START, i, s, n), n
						},
						reverse: function() {
							return this.isPlaying && (this._reverse = !this._reverse, this.forward = !this.forward), this.parent
						},
						getProgress: function() {
							var t = this.currentFrame.progress;
							return this.forward || (t = 1 - t), t
						},
						setProgress: function(t) {
							return this.forward || (t = 1 - t), this.setCurrentFrame(this.currentAnim.getFrameByProgress(t)), this.parent
						},
						remove: function(t, e) {
							void 0 === e && (e = this.currentAnim), this.isPlaying && e.key === this.currentAnim.key && (this.stop(), this.setCurrentFrame(this.currentAnim.frames[0]))
						},
						getRepeat: function() {
							return this._repeat
						},
						setRepeat: function(t) {
							return this._repeat = t, this.repeatCounter = -1 === t ? Number.MAX_VALUE : t, this.parent
						},
						getRepeatDelay: function() {
							return this._repeatDelay
						},
						setRepeatDelay: function(t) {
							return this._repeatDelay = t, this.parent
						},
						restart: function(t) {
							void 0 === t && (t = !1);
							var e = this.currentAnim;
							e.getFirstTick(this, t), this.forward = !0, this.isPlaying = !0, this.pendingRepeat = !1, this._paused = !1, this.updateFrame(e.frames[0]);
							var i = this.parent,
								n = this.currentFrame;
							return e.emit(r.ANIMATION_RESTART, e, n, i), i.emit(r.SPRITE_ANIMATION_KEY_RESTART + e.key, e, n, i), i.emit(r.SPRITE_ANIMATION_RESTART, e, n, i), this.parent
						},
						stop: function() {
							this._pendingStop = 0, this.isPlaying = !1;
							var t, e = this.parent,
								i = this.currentAnim,
								n = this.currentFrame;
							return i && (i.emit(r.ANIMATION_COMPLETE, i, n, e), e.emit(r.SPRITE_ANIMATION_KEY_COMPLETE + i.key, i, n, e), e.emit(r.SPRITE_ANIMATION_COMPLETE, i, n, e)), this.nextAnim && (t = this.nextAnim, this.nextAnim = 0 < this.nextAnimsQueue.length ? this.nextAnimsQueue.shift() : null, this.play(t)), e
						},
						stopAfterDelay: function(t) {
							return this._pendingStop = 1, this._pendingStopValue = t, this.parent
						},
						stopOnRepeat: function() {
							return this._pendingStop = 2, this.parent
						},
						stopOnFrame: function(t) {
							return this._pendingStop = 3, this._pendingStopValue = t, this.parent
						},
						setTimeScale: function(t) {
							return void 0 === t && (t = 1), this._timeScale = t, this.parent
						},
						getTimeScale: function() {
							return this._timeScale
						},
						getTotalFrames: function() {
							return this.currentAnim.frames.length
						},
						update: function(t, e) {
							if (this.currentAnim && this.isPlaying && !this.currentAnim.paused) {
								if (this.accumulator += e * this._timeScale, 1 === this._pendingStop && (this._pendingStopValue -= e, this._pendingStopValue <= 0)) return this.currentAnim.completeAnimation(this);
								this.accumulator >= this.nextTick && this.currentAnim.setFrame(this)
							}
						},
						setCurrentFrame: function(t) {
							var e = this.parent;
							return this.currentFrame = t, e.texture = t.frame.texture, e.frame = t.frame, e.isCropped && e.frame.updateCropUVs(e._crop, e.flipX, e.flipY), e.setSizeToFrame(), e._originComponent && (t.frame.customPivot ? e.setOrigin(t.frame.pivotX, t.frame.pivotY) : e.updateDisplayOrigin()), e
						},
						updateFrame: function(t) {
							var e, i = this.setCurrentFrame(t);
							this.isPlaying && (t.setAlpha && (i.alpha = t.alpha), e = this.currentAnim, i.emit(r.SPRITE_ANIMATION_KEY_UPDATE + e.key, e, t, i), i.emit(r.SPRITE_ANIMATION_UPDATE, e, t, i), 3 === this._pendingStop && this._pendingStopValue === t && this.currentAnim.completeAnimation(this))
						},
						nextFrame: function() {
							return this.currentAnim && this.currentAnim.nextFrame(this), this.parent
						},
						previousFrame: function() {
							return this.currentAnim && this.currentAnim.previousFrame(this), this.parent
						},
						setYoyo: function(t) {
							return void 0 === t && (t = !1), this._yoyo = t, this.parent
						},
						getYoyo: function() {
							return this._yoyo
						},
						destroy: function() {
							this.animationManager.off(r.REMOVE_ANIMATION, this.remove, this), this.animationManager = null, this.parent = null, this.nextAnimsQueue.length = 0, this.currentAnim = null, this.currentFrame = null
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(506),
					s = i(40),
					r = i(0),
					o = i(33),
					a = i(507),
					h = i(92),
					u = i(29),
					l = new r({
						initialize: function(t) {
							this.game = t, this.type = o.CANVAS, this.drawCount = 0, this.width = 0, this.height = 0, this.config = {
								clearBeforeRender: t.config.clearBeforeRender,
								backgroundColor: t.config.backgroundColor,
								resolution: t.config.resolution,
								antialias: t.config.antialias,
								roundPixels: t.config.roundPixels
							}, this.gameCanvas = t.canvas;
							var e = {
								alpha: t.config.transparent,
								desynchronized: t.config.desynchronized
							};
							this.gameContext = this.game.config.context ? this.game.config.context : this.gameCanvas.getContext("2d", e), this.currentContext = this.gameContext, this.antialias = t.config.antialias, this.blendModes = a(), this.snapshotState = {
								x: 0,
								y: 0,
								width: 1,
								height: 1,
								getPixel: !1,
								callback: null,
								type: "image/png",
								encoder: .92
							}, this._tempMatrix1 = new u, this._tempMatrix2 = new u, this._tempMatrix3 = new u, this._tempMatrix4 = new u, this.init()
						},
						init: function() {
							this.game.scale.on(h.RESIZE, this.onResize, this);
							var t = this.game.scale.baseSize;
							this.resize(t.width, t.height)
						},
						onResize: function(t, e) {
							e.width === this.width && e.height === this.height || this.resize(e.width, e.height)
						},
						resize: function(t, e) {
							this.width = t, this.height = e
						},
						resetTransform: function() {
							this.currentContext.setTransform(1, 0, 0, 1, 0, 0)
						},
						setBlendMode: function(t) {
							return this.currentContext.globalCompositeOperation = t, this
						},
						setContext: function(t) {
							return this.currentContext = t || this.gameContext, this
						},
						setAlpha: function(t) {
							return this.currentContext.globalAlpha = t, this
						},
						preRender: function() {
							var t = this.gameContext,
								e = this.config,
								i = this.width,
								n = this.height;
							t.globalAlpha = 1, t.globalCompositeOperation = "source-over", t.setTransform(1, 0, 0, 1, 0, 0), e.clearBeforeRender && t.clearRect(0, 0, i, n), e.transparent || (t.fillStyle = e.backgroundColor.rgba, t.fillRect(0, 0, i, n)), t.save(), this.drawCount = 0
						},
						render: function(t, e, i, n) {
							var r = e.list,
								o = r.length,
								a = n._cx,
								h = n._cy,
								u = n._cw,
								l = n._ch,
								c = n.renderToTexture ? n.context : t.sys.context;
							c.save(), this.game.scene.customViewports && (c.beginPath(), c.rect(a, h, u, l), c.clip()), this.currentContext = c;
							var d = n.mask;
							d && d.preRenderCanvas(this, null, n._maskCamera), n.transparent || (c.fillStyle = n.backgroundColor.rgba, c.fillRect(a, h, u, l)), c.globalAlpha = n.alpha, c.globalCompositeOperation = "source-over", this.drawCount += r.length, n.renderToTexture && n.emit(s.PRE_RENDER, n), n.matrix.copyToContext(c);
							for (var f = 0; f < o; f++) {
								var p = r[f];
								p.willRender(n) && (p.mask && p.mask.preRenderCanvas(this, p, n), p.renderCanvas(this, p, i, n), p.mask && p.mask.postRenderCanvas(this, p, n))
							}
							c.setTransform(1, 0, 0, 1, 0, 0), c.globalCompositeOperation = "source-over", c.globalAlpha = 1, n.flashEffect.postRenderCanvas(c), n.fadeEffect.postRenderCanvas(c), n.dirty = !1, d && d.postRenderCanvas(this), c.restore(), n.renderToTexture && (n.emit(s.POST_RENDER, n), n.renderToGame && t.sys.context.drawImage(n.canvas, a, h))
						},
						postRender: function() {
							this.gameContext.restore();
							var t = this.snapshotState;
							t.callback && (n(this.gameCanvas, t), t.callback = null)
						},
						snapshotCanvas: function(t, e, i, s, r, o, a, h, u) {
							void 0 === i && (i = !1), this.snapshotArea(s, r, o, a, e, h, u);
							var l = this.snapshotState;
							return l.getPixel = i, n(this.canvas, l), l.callback = null, this
						},
						snapshot: function(t, e, i) {
							return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, t, e, i)
						},
						snapshotArea: function(t, e, i, n, s, r, o) {
							var a = this.snapshotState;
							return a.callback = s, a.type = r, a.encoder = o, a.getPixel = !1, a.x = t, a.y = e, a.width = Math.min(i, this.gameCanvas.width), a.height = Math.min(n, this.gameCanvas.height), this
						},
						snapshotPixel: function(t, e, i) {
							return this.snapshotArea(t, e, 1, 1, i), this.snapshotState.getPixel = !0, this
						},
						batchSprite: function(t, e, i, n) {
							var s, r, o, a, h, u, l, c, d, f, p, g, v, m, y, x, T, w, E = i.alpha * t.alpha;
							0 != E && (s = this.currentContext, r = this._tempMatrix1, o = this._tempMatrix2, a = this._tempMatrix3, u = (h = e.canvasData).x, l = h.y, c = e.cutWidth, d = e.cutHeight, f = e.customPivot, p = e.source.resolution, g = t.displayOriginX, v = t.displayOriginY, m = -g + e.x, y = -v + e.y, t.isCropped && ((x = t._crop).flipX === t.flipX && x.flipY === t.flipY || e.updateCropUVs(x, t.flipX, t.flipY), c = x.cw, d = x.ch, u = x.cx, l = x.cy, m = -g + x.x, y = -v + x.y, t.flipX && (0 <= m ? m = -(m + c) : m < 0 && (m = Math.abs(m) - c)), t.flipY && (0 <= y ? y = -(y + d) : y < 0 && (y = Math.abs(y) - d))), w = T = 1, t.flipX && (f || (m += -e.realWidth + 2 * g), T = -1), t.flipY && (f || (y += -e.realHeight + 2 * v), w = -1), o.applyITRS(t.x, t.y, t.rotation, t.scaleX * T, t.scaleY * w), r.copyFrom(i.matrix), n ? (r.multiplyWithOffset(n, -i.scrollX * t.scrollFactorX, -i.scrollY * t.scrollFactorY), o.e = t.x, o.f = t.y) : (o.e -= i.scrollX * t.scrollFactorX, o.f -= i.scrollY * t.scrollFactorY), r.multiply(o, a), s.save(), a.setToContext(s), s.globalCompositeOperation = this.blendModes[t.blendMode], s.globalAlpha = E, s.imageSmoothingEnabled = !(!this.antialias || e.source.scaleMode), t.mask && t.mask.preRenderCanvas(this, t, i), s.drawImage(e.source.image, u, l, c, d, m, y, c / p, d / p), t.mask && t.mask.postRenderCanvas(this, t, i), s.restore())
						},
						destroy: function() {
							this.gameCanvas = null, this.gameContext = null, this.game = null
						}
					});
				t.exports = l
			}, function(t, e, i) {
				var n = i(26),
					s = i(31),
					r = i(2);
				t.exports = function(t, e) {
					var i, o, a, h, u = r(e, "callback"),
						l = r(e, "type", "image/png"),
						c = r(e, "encoder", .92),
						d = Math.abs(Math.round(r(e, "x", 0))),
						f = Math.abs(Math.round(r(e, "y", 0))),
						p = r(e, "width", t.width),
						g = r(e, "height", t.height);
					r(e, "getPixel", !1) ? (i = t.getContext("2d").getImageData(d, f, 1, 1).data, u.call(null, new s(i[0], i[1], i[2], i[3] / 255))) : 0 !== d || 0 !== f || p !== t.width || g !== t.height ? ((o = n.createWebGL(this, p, g)).getContext("2d").drawImage(t, d, f, p, g, 0, 0, p, g), (a = new Image).onerror = function() {
						u.call(null), n.remove(o)
					}, a.onload = function() {
						u.call(null, a), n.remove(o)
					}, a.src = o.toDataURL(l, c)) : ((h = new Image).onerror = function() {
						u.call(null)
					}, h.onload = function() {
						u.call(null, h)
					}, h.src = t.toDataURL(l, c))
				}
			}, function(t, e, i) {
				var n = i(52),
					s = i(316);
				t.exports = function() {
					var t = [],
						e = s.supportNewBlendModes,
						i = "source-over";
					return t[n.NORMAL] = i, t[n.ADD] = "lighter", t[n.MULTIPLY] = e ? "multiply" : i, t[n.SCREEN] = e ? "screen" : i, t[n.OVERLAY] = e ? "overlay" : i, t[n.DARKEN] = e ? "darken" : i, t[n.LIGHTEN] = e ? "lighten" : i, t[n.COLOR_DODGE] = e ? "color-dodge" : i, t[n.COLOR_BURN] = e ? "color-burn" : i, t[n.HARD_LIGHT] = e ? "hard-light" : i, t[n.SOFT_LIGHT] = e ? "soft-light" : i, t[n.DIFFERENCE] = e ? "difference" : i, t[n.EXCLUSION] = e ? "exclusion" : i, t[n.HUE] = e ? "hue" : i, t[n.SATURATION] = e ? "saturation" : i, t[n.COLOR] = e ? "color" : i, t[n.LUMINOSITY] = e ? "luminosity" : i, t[n.ERASE] = "destination-out", t[n.SOURCE_IN] = "source-in", t[n.SOURCE_OUT] = "source-out", t[n.SOURCE_ATOP] = "source-atop", t[n.DESTINATION_OVER] = "destination-over", t[n.DESTINATION_IN] = "destination-in", t[n.DESTINATION_OUT] = "destination-out", t[n.DESTINATION_ATOP] = "destination-atop", t[n.LIGHTER] = "lighter", t[n.COPY] = "copy", t[n.XOR] = "xor", t
				}
			}, function(t, e, i) {
				var n = i(91),
					s = i(40),
					r = i(0),
					o = i(33),
					a = i(20),
					h = i(120),
					u = i(1),
					l = i(92),
					c = i(80),
					d = i(121),
					f = i(29),
					p = i(9),
					g = i(509),
					v = i(510),
					m = i(511),
					y = i(237),
					x = i(512),
					T = new r({
						initialize: function(t) {
							var e = t.config,
								i = {
									alpha: e.transparent,
									desynchronized: e.desynchronized,
									depth: !1,
									antialias: e.antialiasGL,
									premultipliedAlpha: e.premultipliedAlpha,
									stencil: !0,
									failIfMajorPerformanceCaveat: e.failIfMajorPerformanceCaveat,
									powerPreference: e.powerPreference
								};
							this.config = {
								clearBeforeRender: e.clearBeforeRender,
								antialias: e.antialias,
								backgroundColor: e.backgroundColor,
								contextCreation: i,
								resolution: e.resolution,
								roundPixels: e.roundPixels,
								maxTextures: e.maxTextures,
								maxTextureSize: e.maxTextureSize,
								batchSize: e.batchSize,
								maxLights: e.maxLights,
								mipmapFilter: e.mipmapFilter
							}, this.game = t, this.type = o.WEBGL, this.width = 0, this.height = 0, this.canvas = t.canvas, this.blendModes = [], this.nativeTextures = [], this.contextLost = !1, this.pipelines = null, this.snapshotState = {
								x: 0,
								y: 0,
								width: 1,
								height: 1,
								getPixel: !1,
								callback: null,
								type: "image/png",
								encoder: .92,
								isFramebuffer: !1,
								bufferWidth: 0,
								bufferHeight: 0
							}, this.currentActiveTextureUnit = 0, this.currentTextures = new Array(16), this.currentFramebuffer = null, this.currentPipeline = null, this.currentProgram = null, this.currentVertexBuffer = null, this.currentIndexBuffer = null, this.currentBlendMode = 1 / 0, this.currentScissorEnabled = !1, this.currentScissor = null, this.scissorStack = [], this.contextLostHandler = u, this.contextRestoredHandler = u, this.gl = null, this.supportedExtensions = null, this.extensions = {}, this.glFormats = [], this.compression = {
								ETC1: !1,
								PVRTC: !1,
								S3TC: !1
							}, this.drawingBufferHeight = 0, this.blankTexture = null, this.defaultCamera = new n(0, 0, 0, 0), this._tempMatrix1 = new f, this._tempMatrix2 = new f, this._tempMatrix3 = new f, this._tempMatrix4 = new f, this.maskCount = 0, this.maskStack = [], this.currentMask = {
								mask: null,
								camera: null
							}, this.currentCameraMask = {
								mask: null,
								camera: null
							}, this.glFuncMap = null, this.currentType = "", this.newType = !1, this.nextTypeMatch = !1, this.mipmapFilter = null, this.init(this.config)
						},
						init: function(t) {
							var e = this.game,
								i = this.canvas,
								n = t.backgroundColor,
								s = e.config.context ? e.config.context : i.getContext("webgl", t.contextCreation) || i.getContext("experimental-webgl", t.contextCreation);
							if (!s || s.isContextLost()) throw this.contextLost = !0, new Error("WebGL unsupported");
							this.gl = s;
							var r = this;
							this.contextLostHandler = function(t) {
								r.contextLost = !0, r.game.events.emit(a.CONTEXT_LOST, r), t.preventDefault()
							}, this.contextRestoredHandler = function() {
								r.contextLost = !1, r.init(r.config), r.game.events.emit(a.CONTEXT_RESTORED, r)
							}, i.addEventListener("webglcontextlost", this.contextLostHandler, !1), i.addEventListener("webglcontextrestored", this.contextRestoredHandler, !1), e.context = s;
							for (var h = 0; h <= 27; h++) this.blendModes.push({
								func: [s.ONE, s.ONE_MINUS_SRC_ALPHA],
								equation: s.FUNC_ADD
							});
							this.blendModes[1].func = [s.ONE, s.DST_ALPHA], this.blendModes[2].func = [s.DST_COLOR, s.ONE_MINUS_SRC_ALPHA], this.blendModes[3].func = [s.ONE, s.ONE_MINUS_SRC_COLOR], this.blendModes[17] = {
								func: [s.ZERO, s.ONE_MINUS_SRC_ALPHA],
								equation: s.FUNC_REVERSE_SUBTRACT
							}, this.glFormats[0] = s.BYTE, this.glFormats[1] = s.SHORT, this.glFormats[2] = s.UNSIGNED_BYTE, this.glFormats[3] = s.UNSIGNED_SHORT, this.glFormats[4] = s.FLOAT, this.glFuncMap = {
								mat2: {
									func: s.uniformMatrix2fv,
									length: 1,
									matrix: !0
								},
								mat3: {
									func: s.uniformMatrix3fv,
									length: 1,
									matrix: !0
								},
								mat4: {
									func: s.uniformMatrix4fv,
									length: 1,
									matrix: !0
								},
								"1f": {
									func: s.uniform1f,
									length: 1
								},
								"1fv": {
									func: s.uniform1fv,
									length: 1
								},
								"1i": {
									func: s.uniform1i,
									length: 1
								},
								"1iv": {
									func: s.uniform1iv,
									length: 1
								},
								"2f": {
									func: s.uniform2f,
									length: 2
								},
								"2fv": {
									func: s.uniform2fv,
									length: 1
								},
								"2i": {
									func: s.uniform2i,
									length: 2
								},
								"2iv": {
									func: s.uniform2iv,
									length: 1
								},
								"3f": {
									func: s.uniform3f,
									length: 3
								},
								"3fv": {
									func: s.uniform3fv,
									length: 1
								},
								"3i": {
									func: s.uniform3i,
									length: 3
								},
								"3iv": {
									func: s.uniform3iv,
									length: 1
								},
								"4f": {
									func: s.uniform4f,
									length: 4
								},
								"4fv": {
									func: s.uniform4fv,
									length: 1
								},
								"4i": {
									func: s.uniform4i,
									length: 4
								},
								"4iv": {
									func: s.uniform4iv,
									length: 1
								}
							};
							var u = s.getSupportedExtensions();
							t.maxTextures || (t.maxTextures = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS)), t.maxTextureSize || (t.maxTextureSize = s.getParameter(s.MAX_TEXTURE_SIZE));
							var l = "WEBGL_compressed_texture_",
								c = "WEBKIT_" + l;
							this.compression.ETC1 = s.getExtension(l + "etc1") || s.getExtension(c + "etc1"), this.compression.PVRTC = s.getExtension(l + "pvrtc") || s.getExtension(c + "pvrtc"), this.compression.S3TC = s.getExtension(l + "s3tc") || s.getExtension(c + "s3tc"), this.supportedExtensions = u, s.disable(s.DEPTH_TEST), s.disable(s.CULL_FACE), s.enable(s.BLEND), s.clearColor(n.redGL, n.greenGL, n.blueGL, n.alphaGL), this.mipmapFilter = s[t.mipmapFilter];
							for (var f = 0; f < this.currentTextures.length; ++f) this.currentTextures[f] = null;
							return this.pipelines = {}, this.addPipeline("TextureTintPipeline", new y({
								game: e,
								renderer: this
							})), this.addPipeline("TextureTintStripPipeline", new x({
								game: e,
								renderer: this
							})), this.addPipeline("BitmapMaskPipeline", new v({
								game: e,
								renderer: this
							})), this.addPipeline("Light2D", new m({
								game: e,
								renderer: this,
								maxLights: t.maxLights
							})), this.setBlendMode(o.BlendModes.NORMAL), e.textures.once(d.READY, this.boot, this), this
						},
						boot: function() {
							for (var t in this.pipelines) this.pipelines[t].boot();
							var e = this.game.textures.getFrame("__DEFAULT");
							this.pipelines.TextureTintPipeline.currentFrame = e, this.blankTexture = e;
							var i = this.gl;
							i.bindFramebuffer(i.FRAMEBUFFER, null), i.enable(i.SCISSOR_TEST), this.setPipeline(this.pipelines.TextureTintPipeline), this.game.scale.on(l.RESIZE, this.onResize, this);
							var n = this.game.scale.baseSize;
							this.resize(n.width, n.height, this.game.scale.resolution)
						},
						onResize: function(t, e, i, n) {
							e.width === this.width && e.height === this.height && n === this.resolution || this.resize(e.width, e.height, n)
						},
						resize: function(t, e, i) {
							var n = this.gl,
								s = this.pipelines;
							for (var r in this.width = t, this.height = e, this.resolution = i, n.viewport(0, 0, t, e), s) s[r].resize(t, e, i);
							return this.drawingBufferHeight = n.drawingBufferHeight, n.scissor(0, n.drawingBufferHeight - e, t, e), this.defaultCamera.setSize(t, e), this
						},
						hasExtension: function(t) {
							return !!this.supportedExtensions && this.supportedExtensions.indexOf(t)
						},
						getExtension: function(t) {
							return this.hasExtension(t) ? (t in this.extensions || (this.extensions[t] = this.gl.getExtension(t)), this.extensions[t]) : null
						},
						flush: function() {
							this.currentPipeline && this.currentPipeline.flush()
						},
						hasPipeline: function(t) {
							return t in this.pipelines
						},
						getPipeline: function(t) {
							return this.hasPipeline(t) ? this.pipelines[t] : null
						},
						removePipeline: function(t) {
							return delete this.pipelines[t], this
						},
						addPipeline: function(t, e) {
							return this.hasPipeline(t) ? console.warn("Pipeline exists: " + t) : this.pipelines[t] = e, e.name = t, this.pipelines[t].resize(this.width, this.height, this.config.resolution), e
						},
						pushScissor: function(t, e, i, n, s) {
							void 0 === s && (s = this.drawingBufferHeight);
							var r = [t, e, i, n];
							return this.scissorStack.push(r), this.setScissor(t, e, i, n, s), this.currentScissor = r
						},
						setScissor: function(t, e, i, n, s) {
							void 0 === s && (s = this.drawingBufferHeight);
							var r, o, a, h, u = this.gl,
								l = this.currentScissor,
								c = 0 < i && 0 < n;
							l && c && (r = l[0], o = l[1], a = l[2], h = l[3], c = r !== t || o !== e || a !== i || h !== n), c && (this.flush(), u.scissor(t, s - e - n, i, n))
						},
						popScissor: function() {
							var t = this.scissorStack;
							t.pop();
							var e = t[t.length - 1];
							e && this.setScissor(e[0], e[1], e[2], e[3]), this.currentScissor = e
						},
						setPipeline: function(t, e) {
							return this.currentPipeline === t && this.currentPipeline.vertexBuffer === this.currentVertexBuffer && this.currentPipeline.program === this.currentProgram || (this.flush(), this.currentPipeline = t, this.currentPipeline.bind()), this.currentPipeline.onBind(e), this.currentPipeline
						},
						hasActiveStencilMask: function() {
							var t = this.currentMask.mask,
								e = this.currentCameraMask.mask;
							return t && t.isStencil || e && e.isStencil
						},
						rebindPipeline: function(t) {
							var e = this.gl;
							e.disable(e.DEPTH_TEST), e.disable(e.CULL_FACE), this.hasActiveStencilMask() ? e.clear(e.DEPTH_BUFFER_BIT) : (e.disable(e.STENCIL_TEST), e.clear(e.DEPTH_BUFFER_BIT | e.STENCIL_BUFFER_BIT)), e.viewport(0, 0, this.width, this.height), this.setBlendMode(0, !0), e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, this.blankTexture.glTexture), this.currentActiveTextureUnit = 0, this.currentTextures[0] = this.blankTexture.glTexture, this.currentPipeline = t, this.currentPipeline.bind(), this.currentPipeline.onBind()
						},
						clearPipeline: function() {
							this.flush(), this.currentPipeline = null, this.currentProgram = null, this.currentVertexBuffer = null, this.currentIndexBuffer = null, this.setBlendMode(0, !0)
						},
						setBlendMode: function(t, e) {
							void 0 === e && (e = !1);
							var i = this.gl,
								n = this.blendModes[t];
							return !!(e || t !== o.BlendModes.SKIP_CHECK && this.currentBlendMode !== t) && (this.flush(), i.enable(i.BLEND), i.blendEquation(n.equation), 2 < n.func.length ? i.blendFuncSeparate(n.func[0], n.func[1], n.func[2], n.func[3]) : i.blendFunc(n.func[0], n.func[1]), this.currentBlendMode = t, !0)
						},
						addBlendMode: function(t, e) {
							return this.blendModes.push({
								func: t,
								equation: e
							}) - 1
						},
						updateBlendMode: function(t, e, i) {
							return this.blendModes[t] && (this.blendModes[t].func = e, i && (this.blendModes[t].equation = i)), this
						},
						removeBlendMode: function(t) {
							return 17 < t && this.blendModes[t] && this.blendModes.splice(t, 1), this
						},
						setBlankTexture: function(t) {
							void 0 === t && (t = !1), !t && 0 === this.currentActiveTextureUnit && this.currentTextures[0] || this.setTexture2D(this.blankTexture.glTexture, 0)
						},
						setTexture2D: function(t, e, i) {
							void 0 === i && (i = !0);
							var n = this.gl;
							return t !== this.currentTextures[e] && (i && this.flush(), this.currentActiveTextureUnit !== e && (n.activeTexture(n.TEXTURE0 + e), this.currentActiveTextureUnit = e), n.bindTexture(n.TEXTURE_2D, t), this.currentTextures[e] = t), this
						},
						setFramebuffer: function(t, e) {
							void 0 === e && (e = !1);
							var i = this.gl,
								n = this.width,
								s = this.height;
							return t !== this.currentFramebuffer && (t && t.renderTexture ? (n = t.renderTexture.width, s = t.renderTexture.height) : this.flush(), i.bindFramebuffer(i.FRAMEBUFFER, t), i.viewport(0, 0, n, s), e && (t ? (this.drawingBufferHeight = s, this.pushScissor(0, 0, n, s)) : (this.drawingBufferHeight = this.height, this.popScissor())), this.currentFramebuffer = t), this
						},
						setProgram: function(t) {
							var e = this.gl;
							return t !== this.currentProgram && (this.flush(), e.useProgram(t), this.currentProgram = t), this
						},
						setVertexBuffer: function(t) {
							var e = this.gl;
							return t !== this.currentVertexBuffer && (this.flush(), e.bindBuffer(e.ARRAY_BUFFER, t), this.currentVertexBuffer = t), this
						},
						setIndexBuffer: function(t) {
							var e = this.gl;
							return t !== this.currentIndexBuffer && (this.flush(), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t), this.currentIndexBuffer = t), this
						},
						createTextureFromSource: function(t, e, i, n) {
							var s = this.gl,
								r = s.NEAREST,
								a = s.NEAREST,
								u = s.CLAMP_TO_EDGE;
							e = t ? t.width : e, i = t ? t.height : i;
							var l = h(e, i);
							return l && (u = s.REPEAT), n === o.ScaleModes.LINEAR && this.config.antialias && (r = l ? this.mipmapFilter : s.LINEAR, a = s.LINEAR), t || "number" != typeof e || "number" != typeof i ? this.createTexture2D(0, r, a, u, u, s.RGBA, t) : this.createTexture2D(0, r, a, u, u, s.RGBA, null, e, i)
						},
						createTexture2D: function(t, e, i, n, s, r, o, a, u, l, c, d) {
							l = null == l || l, void 0 === c && (c = !1), void 0 === d && (d = !1);
							var f = this.gl,
								p = f.createTexture();
							return this.setTexture2D(p, 0), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, e), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, i), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, s), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, n), f.pixelStorei(f.UNPACK_PREMULTIPLY_ALPHA_WEBGL, l), f.pixelStorei(f.UNPACK_FLIP_Y_WEBGL, d), null == o ? f.texImage2D(f.TEXTURE_2D, t, r, a, u, 0, r, f.UNSIGNED_BYTE, null) : (c || (a = o.width, u = o.height), f.texImage2D(f.TEXTURE_2D, t, r, r, f.UNSIGNED_BYTE, o)), h(a, u) && f.generateMipmap(f.TEXTURE_2D), this.setTexture2D(null, 0), p.isAlphaPremultiplied = l, p.isRenderTexture = !1, p.width = a, p.height = u, this.nativeTextures.push(p), p
						},
						createFramebuffer: function(t, e, i, n) {
							var s, r, o = this.gl,
								a = o.createFramebuffer();
							if (this.setFramebuffer(a), n && (r = o.createRenderbuffer(), o.bindRenderbuffer(o.RENDERBUFFER, r), o.renderbufferStorage(o.RENDERBUFFER, o.DEPTH_STENCIL, t, e), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.DEPTH_STENCIL_ATTACHMENT, o.RENDERBUFFER, r)), i.isRenderTexture = !0, i.isAlphaPremultiplied = !1, o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, i, 0), (s = o.checkFramebufferStatus(o.FRAMEBUFFER)) === o.FRAMEBUFFER_COMPLETE) return a.renderTexture = i, this.setFramebuffer(null), a;
							throw new Error("Framebuffer incomplete. Framebuffer status: " + {
								36054: "Incomplete Attachment",
								36055: "Missing Attachment",
								36057: "Incomplete Dimensions",
								36061: "Framebuffer Unsupported"
							} [s])
						},
						createProgram: function(t, e) {
							var i = this.gl,
								n = i.createProgram(),
								s = i.createShader(i.VERTEX_SHADER),
								r = i.createShader(i.FRAGMENT_SHADER);
							if (i.shaderSource(s, t), i.shaderSource(r, e), i.compileShader(s), i.compileShader(r), !i.getShaderParameter(s, i.COMPILE_STATUS)) throw new Error("Failed to compile Vertex Shader:\n" + i.getShaderInfoLog(s));
							if (!i.getShaderParameter(r, i.COMPILE_STATUS)) throw new Error("Failed to compile Fragment Shader:\n" + i.getShaderInfoLog(r));
							if (i.attachShader(n, s), i.attachShader(n, r), i.linkProgram(n), !i.getProgramParameter(n, i.LINK_STATUS)) throw new Error("Failed to link program:\n" + i.getProgramInfoLog(n));
							return n
						},
						createVertexBuffer: function(t, e) {
							var i = this.gl,
								n = i.createBuffer();
							return this.setVertexBuffer(n), i.bufferData(i.ARRAY_BUFFER, t, e), this.setVertexBuffer(null), n
						},
						createIndexBuffer: function(t, e) {
							var i = this.gl,
								n = i.createBuffer();
							return this.setIndexBuffer(n), i.bufferData(i.ELEMENT_ARRAY_BUFFER, t, e), this.setIndexBuffer(null), n
						},
						deleteTexture: function(t) {
							var e = this.nativeTextures.indexOf(t);
							return -1 !== e && c(this.nativeTextures, e), this.gl.deleteTexture(t), this.currentTextures[0] !== t || this.game.pendingDestroy || this.setBlankTexture(!0), this
						},
						deleteFramebuffer: function(t) {
							return this.gl.deleteFramebuffer(t), this
						},
						deleteProgram: function(t) {
							return this.gl.deleteProgram(t), this
						},
						deleteBuffer: function(t) {
							return this.gl.deleteBuffer(t), this
						},
						preRenderCamera: function(t) {
							var e, i = t._cx,
								n = t._cy,
								r = t._cw,
								o = t._ch,
								a = this.pipelines.TextureTintPipeline,
								h = t.backgroundColor;
							t.renderToTexture ? (this.flush(), this.pushScissor(i, n, r, -o), this.setFramebuffer(t.framebuffer), (e = this.gl).clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), a.projOrtho(i, r + i, n, o + n, -1e3, 1e3), t.mask && (this.currentCameraMask.mask = t.mask, this.currentCameraMask.camera = t._maskCamera, t.mask.preRenderWebGL(this, t, t._maskCamera)), 0 < h.alphaGL && a.drawFillRect(i, n, r + i, o + n, p.getTintFromFloats(h.redGL, h.greenGL, h.blueGL, 1), h.alphaGL), t.emit(s.PRE_RENDER, t)) : (this.pushScissor(i, n, r, o), t.mask && (this.currentCameraMask.mask = t.mask, this.currentCameraMask.camera = t._maskCamera, t.mask.preRenderWebGL(this, t, t._maskCamera)), 0 < h.alphaGL && a.drawFillRect(i, n, r, o, p.getTintFromFloats(h.redGL, h.greenGL, h.blueGL, 1), h.alphaGL))
						},
						getCurrentStencilMask: function() {
							var t = null,
								e = this.maskStack,
								i = this.currentCameraMask;
							return 0 < e.length ? t = e[e.length - 1] : i.mask && i.mask.isStencil && (t = i), t
						},
						postRenderCamera: function(t) {
							this.setPipeline(this.pipelines.TextureTintPipeline);
							var e, i = this.pipelines.TextureTintPipeline;
							t.flashEffect.postRenderWebGL(i, p.getTintFromFloats), t.fadeEffect.postRenderWebGL(i, p.getTintFromFloats), t.dirty = !1, this.popScissor(), t.renderToTexture && (i.flush(), this.setFramebuffer(null), t.emit(s.POST_RENDER, t), t.renderToGame && (i.projOrtho(0, i.width, i.height, 0, -1e3, 1e3), e = p.getTintAppendFloatAlpha, (t.pipeline ? t.pipeline : i).batchTexture(t, t.glTexture, t.width, t.height, t.x, t.y, t.width, t.height, t.zoom, t.zoom, t.rotation, t.flipX, !t.flipY, 1, 1, 0, 0, 0, 0, t.width, t.height, e(t._tintTL, t._alphaTL), e(t._tintTR, t._alphaTR), e(t._tintBL, t._alphaBL), e(t._tintBR, t._alphaBR), t._isTinted && t.tintFill, 0, 0, this.defaultCamera, null)), this.setBlankTexture(!0)), t.mask && (this.currentCameraMask.mask = null, t.mask.postRenderWebGL(this, t._maskCamera))
						},
						preRender: function() {
							if (!this.contextLost) {
								var t, e = this.gl,
									i = this.pipelines;
								for (var n in e.bindFramebuffer(e.FRAMEBUFFER, null), this.config.clearBeforeRender && (t = this.config.backgroundColor, e.clearColor(t.redGL, t.greenGL, t.blueGL, t.alphaGL), e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT | e.STENCIL_BUFFER_BIT)), e.enable(e.SCISSOR_TEST), i) i[n].onPreRender();
								this.currentScissor = [0, 0, this.width, this.height], this.scissorStack = [this.currentScissor], this.game.scene.customViewports && e.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height), this.currentMask.mask = null, this.currentCameraMask.mask = null, this.maskStack.length = 0, this.setPipeline(this.pipelines.TextureTintPipeline)
							}
						},
						render: function(t, e, i, n) {
							if (!this.contextLost) {
								var s = e.list,
									r = s.length,
									a = this.pipelines;
								for (var h in a) a[h].onRender(t, n);
								if (this.preRenderCamera(n), 0 === r) return this.setBlendMode(o.BlendModes.NORMAL), void this.postRenderCamera(n);
								this.currentType = "";
								for (var u = this.currentMask, l = 0; l < r; l++) {
									var c, d, f = s[l];
									f.willRender(n) && (f.blendMode !== this.currentBlendMode && this.setBlendMode(f.blendMode), c = f.mask, (u = this.currentMask).mask && u.mask !== c && u.mask.postRenderWebGL(this, u.camera), c && u.mask !== c && c.preRenderWebGL(this, f, n), (d = f.type) !== this.currentType && (this.newType = !0, this.currentType = d), this.nextTypeMatch = l < r - 1 && s[l + 1].type === this.currentType, f.renderWebGL(this, f, i, n), this.newType = !1)
								}(u = this.currentMask).mask && u.mask.postRenderWebGL(this, u.camera), this.setBlendMode(o.BlendModes.NORMAL), this.postRenderCamera(n)
							}
						},
						postRender: function() {
							if (!this.contextLost) {
								this.flush();
								var t = this.snapshotState;
								t.callback && (g(this.canvas, t), t.callback = null);
								var e = this.pipelines;
								for (var i in e) e[i].onPostRender()
							}
						},
						snapshot: function(t, e, i) {
							return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, t, e, i)
						},
						snapshotArea: function(t, e, i, n, s, r, o) {
							var a = this.snapshotState;
							return a.callback = s, a.type = r, a.encoder = o, a.getPixel = !1, a.x = t, a.y = e, a.width = Math.min(i, this.gl.drawingBufferWidth), a.height = Math.min(n, this.gl.drawingBufferHeight), this
						},
						snapshotPixel: function(t, e, i) {
							return this.snapshotArea(t, e, 1, 1, i), this.snapshotState.getPixel = !0, this
						},
						snapshotFramebuffer: function(t, e, i, n, s, r, o, a, h, u, l) {
							void 0 === s && (s = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = e), void 0 === h && (h = i);
							var c = this.currentFramebuffer;
							this.snapshotArea(r, o, a, h, n, u, l);
							var d = this.snapshotState;
							return d.getPixel = s, d.isFramebuffer = !0, d.bufferWidth = e, d.bufferHeight = i, this.setFramebuffer(t), g(this.canvas, d), this.setFramebuffer(c), d.callback = null, d.isFramebuffer = !1, this
						},
						canvasToTexture: function(t, e, i, n) {
							return void 0 === i && (i = !1), void 0 === n && (n = !1), e ? this.updateCanvasTexture(t, e, n) : this.createCanvasTexture(t, i, n)
						},
						createCanvasTexture: function(t, e, i) {
							void 0 === e && (e = !1), void 0 === i && (i = !1);
							var n = this.gl,
								s = n.NEAREST,
								r = n.NEAREST,
								o = t.width,
								a = t.height,
								u = n.CLAMP_TO_EDGE,
								l = h(o, a);
							return !e && l && (u = n.REPEAT), this.config.antialias && (s = l ? this.mipmapFilter : n.LINEAR, r = n.LINEAR), this.createTexture2D(0, s, r, u, u, n.RGBA, t, o, a, !0, !1, i)
						},
						updateCanvasTexture: function(t, e, i) {
							void 0 === i && (i = !1);
							var n = this.gl,
								s = t.width,
								r = t.height;
							return 0 < s && 0 < r && (this.setTexture2D(e, 0), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, i), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, t), e.width = s, e.height = r, this.setTexture2D(null, 0)), e
						},
						createVideoTexture: function(t, e, i) {
							void 0 === e && (e = !1), void 0 === i && (i = !1);
							var n = this.gl,
								s = n.NEAREST,
								r = n.NEAREST,
								o = t.videoWidth,
								a = t.videoHeight,
								u = n.CLAMP_TO_EDGE,
								l = h(o, a);
							return !e && l && (u = n.REPEAT), this.config.antialias && (s = l ? this.mipmapFilter : n.LINEAR, r = n.LINEAR), this.createTexture2D(0, s, r, u, u, n.RGBA, t, o, a, !0, !0, i)
						},
						updateVideoTexture: function(t, e, i) {
							void 0 === i && (i = !1);
							var n = this.gl,
								s = t.videoWidth,
								r = t.videoHeight;
							return 0 < s && 0 < r && (this.setTexture2D(e, 0), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, i), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, t), e.width = s, e.height = r, this.setTexture2D(null, 0)), e
						},
						setTextureFilter: function(t, e) {
							var i = this.gl,
								n = [i.LINEAR, i.NEAREST][e];
							return this.setTexture2D(t, 0), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, n), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, n), this.setTexture2D(null, 0), this
						},
						setFloat1: function(t, e, i) {
							return this.setProgram(t), this.gl.uniform1f(this.gl.getUniformLocation(t, e), i), this
						},
						setFloat2: function(t, e, i, n) {
							return this.setProgram(t), this.gl.uniform2f(this.gl.getUniformLocation(t, e), i, n), this
						},
						setFloat3: function(t, e, i, n, s) {
							return this.setProgram(t), this.gl.uniform3f(this.gl.getUniformLocation(t, e), i, n, s), this
						},
						setFloat4: function(t, e, i, n, s, r) {
							return this.setProgram(t), this.gl.uniform4f(this.gl.getUniformLocation(t, e), i, n, s, r), this
						},
						setFloat1v: function(t, e, i) {
							return this.setProgram(t), this.gl.uniform1fv(this.gl.getUniformLocation(t, e), i), this
						},
						setFloat2v: function(t, e, i) {
							return this.setProgram(t), this.gl.uniform2fv(this.gl.getUniformLocation(t, e), i), this
						},
						setFloat3v: function(t, e, i) {
							return this.setProgram(t), this.gl.uniform3fv(this.gl.getUniformLocation(t, e), i), this
						},
						setFloat4v: function(t, e, i) {
							return this.setProgram(t), this.gl.uniform4fv(this.gl.getUniformLocation(t, e), i), this
						},
						setInt1: function(t, e, i) {
							return this.setProgram(t), this.gl.uniform1i(this.gl.getUniformLocation(t, e), i), this
						},
						setInt2: function(t, e, i, n) {
							return this.setProgram(t), this.gl.uniform2i(this.gl.getUniformLocation(t, e), i, n), this
						},
						setInt3: function(t, e, i, n, s) {
							return this.setProgram(t), this.gl.uniform3i(this.gl.getUniformLocation(t, e), i, n, s), this
						},
						setInt4: function(t, e, i, n, s, r) {
							return this.setProgram(t), this.gl.uniform4i(this.gl.getUniformLocation(t, e), i, n, s, r), this
						},
						setMatrix2: function(t, e, i, n) {
							return this.setProgram(t), this.gl.uniformMatrix2fv(this.gl.getUniformLocation(t, e), i, n), this
						},
						setMatrix3: function(t, e, i, n) {
							return this.setProgram(t), this.gl.uniformMatrix3fv(this.gl.getUniformLocation(t, e), i, n), this
						},
						setMatrix4: function(t, e, i, n) {
							return this.setProgram(t), this.gl.uniformMatrix4fv(this.gl.getUniformLocation(t, e), i, n), this
						},
						getMaxTextures: function() {
							return this.config.maxTextures
						},
						getMaxTextureSize: function() {
							return this.config.maxTextureSize
						},
						destroy: function() {
							for (var t = 0; t < this.nativeTextures.length; t++) this.gl.deleteTexture(this.nativeTextures[t]);
							for (var e in this.nativeTextures = [], this.pipelines) this.pipelines[e].destroy(), delete this.pipelines[e];
							this.defaultCamera.destroy(), this.currentMask = null, this.currentCameraMask = null, this.canvas.removeEventListener("webglcontextlost", this.contextLostHandler, !1), this.canvas.removeEventListener("webglcontextrestored", this.contextRestoredHandler, !1), this.game = null, this.gl = null, this.canvas = null, this.maskStack = [], this.contextLost = !0, this.extensions = {}
						}
					});
				t.exports = T
			}, function(t, e, i) {
				var n = i(26),
					s = i(31),
					r = i(2);
				t.exports = function(t, e) {
					var i = t.getContext("experimental-webgl"),
						o = r(e, "callback"),
						a = r(e, "type", "image/png"),
						h = r(e, "encoder", .92),
						u = r(e, "x", 0),
						l = r(e, "y", 0),
						c = r(e, "getPixel", !1),
						d = r(e, "isFramebuffer", !1),
						f = d ? r(e, "bufferWidth", 1) : i.drawingBufferWidth,
						p = d ? r(e, "bufferHeight", 1) : i.drawingBufferHeight;
					if (c) {
						var g = new Uint8Array(4),
							v = d ? l : p - l;
						i.readPixels(u, v, 1, 1, i.RGBA, i.UNSIGNED_BYTE, g), o.call(null, new s(g[0], g[1], g[2], g[3] / 255))
					} else {
						var m = r(e, "width", f),
							y = r(e, "height", p),
							x = m * y * 4,
							T = new Uint8Array(x);
						i.readPixels(u, p - l - y, m, y, i.RGBA, i.UNSIGNED_BYTE, T);
						for (var w = n.createWebGL(this, m, y), E = w.getContext("2d"), _ = E.getImageData(0, 0, m, y), b = _.data, A = 0; A < y; A++)
							for (var S = 0; S < m; S++) {
								var C = 4 * ((y - A) * m + S),
									M = d ? x - 4 * (A * m + (m - S)) : 4 * (A * m + S);
								b[0 + M] = T[0 + C], b[1 + M] = T[1 + C], b[2 + M] = T[2 + C], b[3 + M] = T[3 + C]
							}
						E.putImageData(_, 0, 0);
						var O = new Image;
						O.onerror = function() {
							o.call(null), n.remove(w)
						}, O.onload = function() {
							o.call(null, O), n.remove(w)
						}, O.src = w.toDataURL(a, h)
					}
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(786),
					r = i(787),
					o = i(147),
					a = new n({
						Extends: o,
						initialize: function(t) {
							o.call(this, {
								game: t.game,
								renderer: t.renderer,
								gl: t.renderer.gl,
								topology: t.topology ? t.topology : t.renderer.gl.TRIANGLES,
								vertShader: t.vertShader ? t.vertShader : r,
								fragShader: t.fragShader ? t.fragShader : s,
								vertexCapacity: t.vertexCapacity ? t.vertexCapacity : 3,
								vertexSize: t.vertexSize ? t.vertexSize : 2 * Float32Array.BYTES_PER_ELEMENT,
								vertices: new Float32Array([-1, 1, -1, -7, 7, 1]).buffer,
								attributes: [{
									name: "inPosition",
									size: 2,
									type: t.renderer.gl.FLOAT,
									normalized: !1,
									offset: 0
								}]
							}), this.vertexViewF32 = new Float32Array(this.vertexData), this.maxQuads = 1, this.resolutionDirty = !0
						},
						onBind: function() {
							o.prototype.onBind.call(this);
							var t = this.renderer,
								e = this.program;
							return this.resolutionDirty && (t.setFloat2(e, "uResolution", this.width, this.height), t.setInt1(e, "uMainSampler", 0), t.setInt1(e, "uMaskSampler", 1), this.resolutionDirty = !1), this
						},
						resize: function(t, e, i) {
							return o.prototype.resize.call(this, t, e, i), this.resolutionDirty = !0, this
						},
						beginMask: function(t, e, i) {
							var n = this.renderer,
								s = this.gl;
							t.bitmapMask && s && (n.flush(), t.prevFramebuffer = n.currentFramebuffer, n.setFramebuffer(t.mainFramebuffer), s.disable(s.STENCIL_TEST), s.clearColor(0, 0, 0, 0), s.clear(s.COLOR_BUFFER_BIT), n.currentCameraMask.mask !== t && (n.currentMask.mask = t, n.currentMask.camera = i))
						},
						endMask: function(t, e) {
							var i, n = this.gl,
								s = this.renderer,
								r = t.bitmapMask;
							r && n && (s.flush(), s.setFramebuffer(t.maskFramebuffer), n.clearColor(0, 0, 0, 0), n.clear(n.COLOR_BUFFER_BIT), s.setBlendMode(0, !0), r.renderWebGL(s, r, 0, e), s.flush(), s.setFramebuffer(t.prevFramebuffer), (i = s.getCurrentStencilMask()) ? (n.enable(n.STENCIL_TEST), i.mask.applyStencil(s, i.camera, !0)) : s.currentMask.mask = null, s.setPipeline(this), n.activeTexture(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, t.maskTexture), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, t.mainTexture), n.uniform1i(n.getUniformLocation(this.program, "uInvertMaskAlpha"), t.invertAlpha), n.drawArrays(this.topology, 0, 3))
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(0),
					s = i(788),
					r = i(237),
					o = 10,
					a = new n({
						Extends: r,
						initialize: function(t) {
							o = t.maxLights, t.fragShader = s.replace("%LIGHT_COUNT%", o.toString()), r.call(this, t), this.defaultNormalMap, this.inverseRotationMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1])
						},
						boot: function() {
							this.defaultNormalMap = this.game.textures.getFrame("__DEFAULT")
						},
						onBind: function(t) {
							r.prototype.onBind.call(this);
							var e = this.renderer,
								i = this.program;
							return this.mvpUpdate(), e.setInt1(i, "uNormSampler", 1), e.setFloat2(i, "uResolution", this.width, this.height), t && this.setNormalMap(t), this
						},
						onRender: function(t, e) {
							this.active = !1;
							var i = t.sys.lights;
							if (!i || i.lights.length <= 0 || !i.active) return this;
							var n = i.cull(e),
								s = Math.min(n.length, o);
							if (0 === s) return this;
							this.active = !0;
							for (var r = this.renderer, a = this.program, h = e.matrix, u = {
									x: 0,
									y: 0
								}, l = r.height, c = 0; c < o; ++c) r.setFloat1(a, "uLights[" + c + "].radius", 0);
							for (r.setFloat4(a, "uCamera", e.x, e.y, e.rotation, e.zoom), r.setFloat3(a, "uAmbientLightColor", i.ambientColor.r, i.ambientColor.g, i.ambientColor.b), c = 0; c < s; ++c) {
								var d = n[c],
									f = "uLights[" + c + "].";
								h.transformPoint(d.x, d.y, u), r.setFloat2(a, f + "position", u.x - e.scrollX * d.scrollFactorX * e.zoom, l - (u.y - e.scrollY * d.scrollFactorY * e.zoom)), r.setFloat3(a, f + "color", d.r, d.g, d.b), r.setFloat1(a, f + "intensity", d.intensity), r.setFloat1(a, f + "radius", d.radius)
							}
							return this.currentNormalMapRotation = null, this
						},
						batchTexture: function(t, e, i, n, s, r, o, a, h, u, l, c, d, f, p, g, v, m, y, x, T, w, E, _, b, A, S, C, M, O) {
							var P, R, L, D, F, k, I, B, Y, N, X, U, z, G, W, V, H, j, K, q, J, Z, Q, $, tt;
							this.active && (this.renderer.setPipeline(this), t.displayTexture ? P = t.displayTexture.dataSource[t.displayFrame.sourceIndex] : t.texture ? P = t.texture.dataSource[t.frame.sourceIndex] : t.tileset && (P = Array.isArray(t.tileset) ? t.tileset[0].image.dataSource[0] : t.tileset.image.dataSource[0]), P ? (this.setTexture2D(P.glTexture, 1), this.setNormalMapRotation(l), R = this._tempMatrix1, L = this._tempMatrix2, D = this._tempMatrix3, F = m / i + S, k = y / n + C, I = (m + x) / i + S, B = (y + T) / n + C, U = o, z = a, Y = -g, N = -v, t.isCropped && (U = (X = t._crop).width, z = X.height, o = X.width, a = X.height, G = m = X.x, W = y = X.y, c && (G = x - X.x - X.width), d && !e.isRenderTexture && (W = T - X.y - X.height), F = G / i + S, k = W / n + C, I = (G + X.width) / i + S, B = (W + X.height) / n + C, Y = -g + m, N = -v + y), c && (U *= -1, Y += o), (d ^= e.isRenderTexture ? 1 : 0) && (z *= -1, N += a), V = Y + U, H = N + z, L.applyITRS(s, r, l, h, u), R.copyFrom(M.matrix), O ? (R.multiplyWithOffset(O, -M.scrollX * f, -M.scrollY * p), L.e = s, L.f = r) : (L.e -= M.scrollX * f, L.f -= M.scrollY * p), R.multiply(L, D), j = D.getX(Y, N), K = D.getY(Y, N), q = D.getX(Y, H), J = D.getY(Y, H), Z = D.getX(V, H), Q = D.getY(V, H), $ = D.getX(V, N), tt = D.getY(V, N), M.roundPixels && (j = Math.round(j), K = Math.round(K), q = Math.round(q), J = Math.round(J), Z = Math.round(Z), Q = Math.round(Q), $ = Math.round($), tt = Math.round(tt)), this.setTexture2D(e, 0), this.batchQuad(j, K, q, J, Z, Q, $, tt, F, k, I, B, w, E, _, b, A, e, 0)) : console.warn("Normal map missing or invalid"))
						},
						setNormalMap: function(t) {
							var e;
							this.active && t && (t.texture && (e = t.texture.dataSource[t.frame.sourceIndex]), e = e || this.defaultNormalMap, this.setTexture2D(e.glTexture, 1), this.renderer.setPipeline(t.defaultPipeline))
						},
						setNormalMapRotation: function(t) {
							var e, i, n, s;
							t === this.currentNormalMapRotation && 0 !== this.batches.length || (0 < this.batches.length && this.flush(), e = this.inverseRotationMatrix, t ? (i = -t, n = Math.cos(i), s = Math.sin(i), e[1] = s, e[3] = -s, e[0] = e[4] = n) : (e[0] = e[4] = 1, e[1] = e[3] = 0), this.renderer.setMatrix3(this.program, "uInverseRotationMatrix", !1, e), this.currentNormalMapRotation = t)
						},
						batchSprite: function(t, e, i) {
							var n;
							!this.active || (n = t.texture.dataSource[t.frame.sourceIndex]) && (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), this.setNormalMapRotation(t.rotation), r.prototype.batchSprite.call(this, t, e, i))
						}
					});
				a.LIGHT_COUNT = o, t.exports = a
			}, function(t, e, i) {
				var n = i(0),
					s = i(2),
					r = i(238),
					o = i(340),
					a = i(341),
					h = i(29),
					u = i(147),
					l = new n({
						Extends: u,
						Mixins: [r],
						initialize: function(t) {
							var e = t.renderer.config;
							u.call(this, {
								game: t.game,
								renderer: t.renderer,
								gl: t.renderer.gl,
								topology: t.renderer.gl.TRIANGLE_STRIP,
								vertShader: s(t, "vertShader", a),
								fragShader: s(t, "fragShader", o),
								vertexCapacity: s(t, "vertexCapacity", 6 * e.batchSize),
								vertexSize: s(t, "vertexSize", 5 * Float32Array.BYTES_PER_ELEMENT + 4 * Uint8Array.BYTES_PER_ELEMENT),
								attributes: [{
									name: "inPosition",
									size: 2,
									type: t.renderer.gl.FLOAT,
									normalized: !1,
									offset: 0
								}, {
									name: "inTexCoord",
									size: 2,
									type: t.renderer.gl.FLOAT,
									normalized: !1,
									offset: 2 * Float32Array.BYTES_PER_ELEMENT
								}, {
									name: "inTintEffect",
									size: 1,
									type: t.renderer.gl.FLOAT,
									normalized: !1,
									offset: 4 * Float32Array.BYTES_PER_ELEMENT
								}, {
									name: "inTint",
									size: 4,
									type: t.renderer.gl.UNSIGNED_BYTE,
									normalized: !0,
									offset: 5 * Float32Array.BYTES_PER_ELEMENT
								}]
							}), this.vertexViewF32 = new Float32Array(this.vertexData), this.vertexViewU32 = new Uint32Array(this.vertexData), this.maxQuads = e.batchSize, this.batches = [], this._tempMatrix1 = new h, this._tempMatrix2 = new h, this._tempMatrix3 = new h, this.mvpInit()
						},
						onBind: function() {
							return u.prototype.onBind.call(this), this.mvpUpdate(), this
						},
						resize: function(t, e, i) {
							return u.prototype.resize.call(this, t, e, i), this.projOrtho(0, this.width, this.height, 0, -1e3, 1e3), this
						},
						setTexture2D: function(t, e) {
							return void 0 === t && (t = this.renderer.blankTexture.glTexture), void 0 === e && (e = 0), this.requireTextureBatch(t, e) && this.pushBatch(t, e), this
						},
						requireTextureBatch: function(t, e) {
							var i = this.batches,
								n = i.length;
							return !(0 < n && (0 < e ? i[n - 1].textures[e - 1] : i[n - 1].texture) === t)
						},
						pushBatch: function(t, e) {
							var i;
							0 === e ? this.batches.push({
								first: this.vertexCount,
								texture: t,
								textures: []
							}) : ((i = [])[e - 1] = t, this.batches.push({
								first: this.vertexCount,
								texture: null,
								textures: i
							}))
						},
						flush: function() {
							if (this.flushLocked) return this;
							this.flushLocked = !0;
							var t, e, i, n = this.gl,
								s = this.vertexCount,
								r = this.topology,
								o = this.vertexSize,
								a = this.renderer,
								h = this.batches,
								u = h.length,
								l = 0,
								c = null;
							if (0 === u || 0 === s) return this.flushLocked = !1, this;
							n.bufferSubData(n.ARRAY_BUFFER, 0, this.bytes.subarray(0, s * o));
							for (var d = 0; d < u - 1; d++) {
								if (c = h[d], t = h[d + 1], 0 < c.textures.length) {
									for (e = 0; e < c.textures.length; ++e)(i = c.textures[e]) && a.setTexture2D(i, 1 + e, !1);
									n.activeTexture(n.TEXTURE0)
								}
								l = t.first - c.first, null === c.texture || l <= 0 || (a.setTexture2D(c.texture, 0, !1), n.drawArrays(r, c.first, l))
							}
							if (0 < (c = h[u - 1]).textures.length) {
								for (e = 0; e < c.textures.length; ++e)(i = c.textures[e]) && a.setTexture2D(i, 1 + e, !1);
								n.activeTexture(n.TEXTURE0)
							}
							return l = s - c.first, c.texture && 0 < l && (a.setTexture2D(c.texture, 0, !1), n.drawArrays(r, c.first, l)), this.vertexCount = 0, h.length = 0, this.flushLocked = !1, this
						}
					});
				t.exports = l
			}, , , , , function(t, e) {
				var i = function() {
					return this
				}();
				try {
					i = i || new Function("return this")()
				} catch (t) {
					"object" == typeof window && (i = window)
				}
				t.exports = i
			}, function(t, e, i) {
				i(519), i(520), i(521), i(522), i(523), i(524), i(525), i(526)
			}, function(t, e) {
				Array.prototype.forEach || (Array.prototype.forEach = function(t) {
					"use strict";
					if (null == this) throw new TypeError;
					var e = Object(this),
						i = e.length >>> 0;
					if ("function" != typeof t) throw new TypeError;
					for (var n = 2 <= arguments.length ? arguments[1] : void 0, s = 0; s < i; s++) s in e && t.call(n, e[s], s, e)
				})
			}, function(t, e) {
				Array.isArray || (Array.isArray = function(t) {
					return "[object Array]" === Object.prototype.toString.call(t)
				})
			}, function(t, e) {
				function i(t) {
					t && (t.setTargetAtTime || (t.setTargetAtTime = t.setTargetValueAtTime))
				}
				window.hasOwnProperty("webkitAudioContext") && !window.hasOwnProperty("AudioContext") && (window.AudioContext = webkitAudioContext, AudioContext.prototype.hasOwnProperty("createGain") || (AudioContext.prototype.createGain = AudioContext.prototype.createGainNode), AudioContext.prototype.hasOwnProperty("createDelay") || (AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode), AudioContext.prototype.hasOwnProperty("createScriptProcessor") || (AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode), AudioContext.prototype.hasOwnProperty("createPeriodicWave") || (AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable), AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain, AudioContext.prototype.createGain = function() {
					var t = this.internal_createGain();
					return i(t.gain), t
				}, AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay, AudioContext.prototype.createDelay = function(t) {
					var e = t ? this.internal_createDelay(t) : this.internal_createDelay();
					return i(e.delayTime), e
				}, AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource, AudioContext.prototype.createBufferSource = function() {
					var t = this.internal_createBufferSource();
					return t.start ? (t.internal_start = t.start, t.start = function(e, i, n) {
						void 0 !== n ? t.internal_start(e || 0, i, n) : t.internal_start(e || 0, i || 0)
					}) : t.start = function(t, e, i) {
						e || i ? this.noteGrainOn(t || 0, e, i) : this.noteOn(t || 0)
					}, t.stop ? (t.internal_stop = t.stop, t.stop = function(e) {
						t.internal_stop(e || 0)
					}) : t.stop = function(t) {
						this.noteOff(t || 0)
					}, i(t.playbackRate), t
				}, AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor, AudioContext.prototype.createDynamicsCompressor = function() {
					var t = this.internal_createDynamicsCompressor();
					return i(t.threshold), i(t.knee), i(t.ratio), i(t.reduction), i(t.attack), i(t.release), t
				}, AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter, AudioContext.prototype.createBiquadFilter = function() {
					var t = this.internal_createBiquadFilter();
					return i(t.frequency), i(t.detune), i(t.Q), i(t.gain), t
				}, AudioContext.prototype.hasOwnProperty("createOscillator") && (AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator, AudioContext.prototype.createOscillator = function() {
					var t = this.internal_createOscillator();
					return t.start ? (t.internal_start = t.start, t.start = function(e) {
						t.internal_start(e || 0)
					}) : t.start = function(t) {
						this.noteOn(t || 0)
					}, t.stop ? (t.internal_stop = t.stop, t.stop = function(e) {
						t.internal_stop(e || 0)
					}) : t.stop = function(t) {
						this.noteOff(t || 0)
					}, t.setPeriodicWave || (t.setPeriodicWave = t.setWaveTable), i(t.frequency), i(t.detune), t
				})), window.hasOwnProperty("webkitOfflineAudioContext") && !window.hasOwnProperty("OfflineAudioContext") && (window.OfflineAudioContext = webkitOfflineAudioContext)
			}, function(t, e) {
				window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {})
			}, function(t, e) {
				Math.trunc || (Math.trunc = function(t) {
					return t < 0 ? Math.ceil(t) : Math.floor(t)
				})
			}, function(t, e) {
				var i;
				"performance" in window == 0 && (window.performance = {}), Date.now = Date.now || function() {
					return (new Date).getTime()
				}, "now" in window.performance == 0 && (i = Date.now(), performance.timing && performance.timing.navigationStart && (i = performance.timing.navigationStart), window.performance.now = function() {
					return Date.now() - i
				})
			}, function(t, e) {
				for (var i = Date.now(), n = ["ms", "moz", "webkit", "o"], s = 0; s < n.length && !window.requestAnimationFrame; s++) window.requestAnimationFrame = window[n[s] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[n[s] + "CancelAnimationFrame"] || window[n[s] + "CancelRequestAnimationFrame"];
				window.requestAnimationFrame || (window.requestAnimationFrame = function(t) {
					if ("function" != typeof t) throw new TypeError(t + "is not a function");
					var e = Date.now(),
						n = 16 + i - e;
					return n < 0 && (n = 0), i = e, setTimeout(function() {
						i = Date.now(), t(performance.now())
					}, n)
				}), window.cancelAnimationFrame || (window.cancelAnimationFrame = function(t) {
					clearTimeout(t)
				})
			}, function(t, e) {
				var i;
				"function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array && ((i = function(t) {
					var e = new Array;
					window[t] = function(t) {
						if ("number" == typeof t) {
							Array.call(this, t), this.length = t;
							for (var e = 0; e < this.length; e++) this[e] = 0
						} else
							for (Array.call(this, t.length), this.length = t.length, e = 0; e < this.length; e++) this[e] = t[e]
					}, window[t].prototype = e, window[t].constructor = window[t]
				})("Float32Array"), i("Uint32Array"), i("Uint16Array"), i("Int16Array"), i("ArrayBuffer"))
			}, function(t, e, i) {
				var n = i(242);
				t.exports = function(t, e, i, s) {
					for (var r = t[0], o = 1; o < t.length; o++) {
						var a = t[o];
						n(a, r, e, i, s), r = a
					}
					return t
				}
			}, function(t, e, i) {
				var n = i(38);
				t.exports = function(t, e, i, s, r) {
					return n(t, "angle", e, i, s, r)
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					for (var n = 0; n < t.length; n++) {
						var s = t[n];
						e.call(i, s)
					}
					return t
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					void 0 === i && (i = 0);
					for (var n = i; n < t.length; n++) {
						var s = t[n],
							r = !0;
						for (var o in e) s[o] !== e[o] && (r = !1);
						if (r) return s
					}
					return null
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					void 0 === i && (i = 0);
					for (var n = i; n < t.length; n++) {
						var s = t[n],
							r = !0;
						for (var o in e) s[o] !== e[o] && (r = !1);
						if (r) return s
					}
					return null
				}
			}, function(t, e, i) {
				var n = i(255),
					s = i(105),
					r = i(2),
					o = i(1),
					a = new(i(110))({
						sys: {
							queueDepthSort: o,
							events: {
								once: o
							}
						}
					}, 0, 0, 1, 1);
				t.exports = function(t, e) {
					void 0 === e && (e = {});
					var i = e.hasOwnProperty("width"),
						o = e.hasOwnProperty("height"),
						h = r(e, "width", -1),
						u = r(e, "height", -1),
						l = r(e, "cellWidth", 1),
						c = r(e, "cellHeight", l),
						d = r(e, "position", s.TOP_LEFT),
						f = r(e, "x", 0),
						p = r(e, "y", 0),
						g = 0,
						v = 0,
						m = h * l,
						y = u * c;
					a.setPosition(f, p), a.setSize(l, c);
					for (var x = 0; x < t.length; x++)
						if (n(t[x], a, d), i && -1 === h) a.x += l;
						else if (o && -1 === u) a.y += c;
					else if (g += l, a.x += l, g === m && (g = 0, v += c, a.x = f, a.y += c, v === y)) break;
					return t
				}
			}, function(t, e, i) {
				var n = i(19),
					s = {
						_alpha: 1,
						_alphaTL: 1,
						_alphaTR: 1,
						_alphaBL: 1,
						_alphaBR: 1,
						clearAlpha: function() {
							return this.setAlpha(1)
						},
						setAlpha: function(t, e, i, s) {
							return void 0 === t && (t = 1), void 0 === e ? this.alpha = t : (this._alphaTL = n(t, 0, 1), this._alphaTR = n(e, 0, 1), this._alphaBL = n(i, 0, 1), this._alphaBR = n(s, 0, 1)), this
						},
						alpha: {
							get: function() {
								return this._alpha
							},
							set: function(t) {
								var e = n(t, 0, 1);
								this._alpha = e, this._alphaTL = e, this._alphaTR = e, this._alphaBL = e, 0 === (this._alphaBR = e) ? this.renderFlags &= -3 : this.renderFlags |= 2
							}
						},
						alphaTopLeft: {
							get: function() {
								return this._alphaTL
							},
							set: function(t) {
								var e = n(t, 0, 1);
								0 !== (this._alphaTL = e) && (this.renderFlags |= 2)
							}
						},
						alphaTopRight: {
							get: function() {
								return this._alphaTR
							},
							set: function(t) {
								var e = n(t, 0, 1);
								0 !== (this._alphaTR = e) && (this.renderFlags |= 2)
							}
						},
						alphaBottomLeft: {
							get: function() {
								return this._alphaBL
							},
							set: function(t) {
								var e = n(t, 0, 1);
								0 !== (this._alphaBL = e) && (this.renderFlags |= 2)
							}
						},
						alphaBottomRight: {
							get: function() {
								return this._alphaBR
							},
							set: function(t) {
								var e = n(t, 0, 1);
								0 !== (this._alphaBR = e) && (this.renderFlags |= 2)
							}
						}
					};
				t.exports = s
			}, function(t, e) {
				t.exports = "add"
			}, function(t, e) {
				t.exports = "complete"
			}, function(t, e) {
				t.exports = "repeat"
			}, function(t, e) {
				t.exports = "restart"
			}, function(t, e) {
				t.exports = "start"
			}, function(t, e) {
				t.exports = "pauseall"
			}, function(t, e) {
				t.exports = "remove"
			}, function(t, e) {
				t.exports = "resumeall"
			}, function(t, e) {
				t.exports = "animationcomplete"
			}, function(t, e) {
				t.exports = "animationcomplete-"
			}, function(t, e) {
				t.exports = "animationrepeat-"
			}, function(t, e) {
				t.exports = "animationrestart-"
			}, function(t, e) {
				t.exports = "animationstart-"
			}, function(t, e) {
				t.exports = "animationupdate-"
			}, function(t, e) {
				t.exports = "animationrepeat"
			}, function(t, e) {
				t.exports = "animationrestart"
			}, function(t, e) {
				t.exports = "animationstart"
			}, function(t, e) {
				t.exports = "animationupdate"
			}, function(t, e) {
				t.exports = {
					width: 0,
					height: 0,
					displayWidth: {
						get: function() {
							return this.scaleX * this.width
						},
						set: function(t) {
							this.scaleX = t / this.width
						}
					},
					displayHeight: {
						get: function() {
							return this.scaleY * this.height
						},
						set: function(t) {
							this.scaleY = t / this.height
						}
					},
					setSize: function(t, e) {
						return this.width = t, this.height = e, this
					},
					setDisplaySize: function(t, e) {
						return this.displayWidth = t, this.displayHeight = e, this
					}
				}
			}, function(t, e) {
				t.exports = {
					texture: null,
					frame: null,
					isCropped: !1,
					setCrop: function(t, e, i, n) {
						return void 0 === t ? this.isCropped = !1 : this.frame && ("number" == typeof t ? this.frame.setCropUVs(this._crop, t, e, i, n, this.flipX, this.flipY) : this.frame.setCropUVs(this._crop, t.x, t.y, t.width, t.height, this.flipX, this.flipY), this.isCropped = !0), this
					},
					resetCropObject: function() {
						return {
							u0: 0,
							v0: 0,
							u1: 0,
							v1: 0,
							width: 0,
							height: 0,
							x: 0,
							y: 0,
							flipX: !1,
							flipY: !1,
							cx: 0,
							cy: 0,
							cw: 0,
							ch: 0
						}
					}
				}
			}, function(t, e) {
				t.exports = {
					flipX: !1,
					flipY: !1,
					toggleFlipX: function() {
						return this.flipX = !this.flipX, this
					},
					toggleFlipY: function() {
						return this.flipY = !this.flipY, this
					},
					setFlipX: function(t) {
						return this.flipX = t, this
					},
					setFlipY: function(t) {
						return this.flipY = t, this
					},
					setFlip: function(t, e) {
						return this.flipX = t, this.flipY = e, this
					},
					resetFlip: function() {
						return this.flipX = !1, this.flipY = !1, this
					}
				}
			}, function(t, e, i) {
				var n = i(11),
					s = i(276),
					r = i(3),
					o = {
						prepareBoundsOutput: function(t, e) {
							return void 0 === e && (e = !1), 0 !== this.rotation && s(t, this.x, this.y, this.rotation), e && this.parentContainer && this.parentContainer.getBoundsTransformMatrix().transformPoint(t.x, t.y, t), t
						},
						getCenter: function(t) {
							return void 0 === t && (t = new r), t.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, t
						},
						getTopLeft: function(t, e) {
							return (t = t || new r).x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(t, e)
						},
						getTopCenter: function(t, e) {
							return (t = t || new r).x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(t, e)
						},
						getTopRight: function(t, e) {
							return (t = t || new r).x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(t, e)
						},
						getLeftCenter: function(t, e) {
							return (t = t || new r).x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(t, e)
						},
						getRightCenter: function(t, e) {
							return (t = t || new r).x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(t, e)
						},
						getBottomLeft: function(t, e) {
							return (t = t || new r).x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(t, e)
						},
						getBottomCenter: function(t, e) {
							return (t = t || new r).x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(t, e)
						},
						getBottomRight: function(t, e) {
							return (t = t || new r).x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(t, e)
						},
						getBounds: function(t) {
							var e, i, s, r, o, a, h, u, l;
							return void 0 === t && (t = new n), this.parentContainer ? (l = this.parentContainer.getBoundsTransformMatrix(), this.getTopLeft(t), l.transformPoint(t.x, t.y, t), e = t.x, i = t.y, this.getTopRight(t), l.transformPoint(t.x, t.y, t), s = t.x, r = t.y, this.getBottomLeft(t), l.transformPoint(t.x, t.y, t), o = t.x, a = t.y, this.getBottomRight(t), l.transformPoint(t.x, t.y, t)) : (this.getTopLeft(t), e = t.x, i = t.y, this.getTopRight(t), s = t.x, r = t.y, this.getBottomLeft(t), o = t.x, a = t.y, this.getBottomRight(t)), h = t.x, u = t.y, t.x = Math.min(e, s, o, h), t.y = Math.min(i, r, a, u), t.width = Math.max(e, s, o, h) - t.x, t.height = Math.max(i, r, a, u) - t.y, t
						}
					};
				t.exports = o
			}, function(t, e) {
				t.exports = "blur"
			}, function(t, e) {
				t.exports = "boot"
			}, function(t, e) {
				t.exports = "contextlost"
			}, function(t, e) {
				t.exports = "contextrestored"
			}, function(t, e) {
				t.exports = "destroy"
			}, function(t, e) {
				t.exports = "focus"
			}, function(t, e) {
				t.exports = "hidden"
			}, function(t, e) {
				t.exports = "pause"
			}, function(t, e) {
				t.exports = "postrender"
			}, function(t, e) {
				t.exports = "poststep"
			}, function(t, e) {
				t.exports = "prerender"
			}, function(t, e) {
				t.exports = "prestep"
			}, function(t, e) {
				t.exports = "ready"
			}, function(t, e) {
				t.exports = "resume"
			}, function(t, e) {
				t.exports = "step"
			}, function(t, e) {
				t.exports = "visible"
			}, function(t, e) {
				t.exports = {
					_originComponent: !0,
					originX: .5,
					originY: .5,
					_displayOriginX: 0,
					_displayOriginY: 0,
					displayOriginX: {
						get: function() {
							return this._displayOriginX
						},
						set: function(t) {
							this._displayOriginX = t, this.originX = t / this.width
						}
					},
					displayOriginY: {
						get: function() {
							return this._displayOriginY
						},
						set: function(t) {
							this._displayOriginY = t, this.originY = t / this.height
						}
					},
					setOrigin: function(t, e) {
						return void 0 === t && (t = .5), void 0 === e && (e = t), this.originX = t, this.originY = e, this.updateDisplayOrigin()
					},
					setOriginFromFrame: function() {
						return this.frame && this.frame.customPivot ? (this.originX = this.frame.pivotX, this.originY = this.frame.pivotY, this.updateDisplayOrigin()) : this.setOrigin()
					},
					setDisplayOrigin: function(t, e) {
						return void 0 === t && (t = 0), void 0 === e && (e = t), this.displayOriginX = t, this.displayOriginY = e, this
					},
					updateDisplayOrigin: function() {
						return this._displayOriginX = this.originX * this.width, this._displayOriginY = this.originY * this.height, this
					}
				}
			}, function(t, e, i) {
				var n = i(39),
					s = i(88),
					r = i(6),
					o = i(89),
					a = i(3),
					h = {
						path: null,
						rotateToPath: !1,
						pathRotationOffset: 0,
						pathOffset: null,
						pathVector: null,
						pathDelta: null,
						pathTween: null,
						pathConfig: null,
						_prevDirection: o.PLAYING_FORWARD,
						setPath: function(t, e) {
							void 0 === e && (e = this.pathConfig);
							var i = this.pathTween;
							return i && i.isPlaying() && i.stop(), this.path = t, e && this.startFollow(e), this
						},
						setRotateToPath: function(t, e) {
							return void 0 === e && (e = 0), this.rotateToPath = t, this.pathRotationOffset = e, this
						},
						isFollowing: function() {
							var t = this.pathTween;
							return t && t.isPlaying()
						},
						startFollow: function(t, e) {
							void 0 === t && (t = {}), void 0 === e && (e = 0);
							var i = this.pathTween;
							i && i.isPlaying() && i.stop(), "number" == typeof t && (t = {
								duration: t
							}), t.from = r(t, "from", 0), t.to = r(t, "to", 1);
							var h = s(t, "positionOnPath", !1);
							this.rotateToPath = s(t, "rotateToPath", !1), this.pathRotationOffset = r(t, "rotationOffset", 0);
							var u, l = r(t, "startAt", e);
							return l && (t.onStart = function(t) {
								var e = t.data[0];
								e.progress = l, e.elapsed = e.duration * l;
								var i = e.ease(e.progress);
								e.current = e.start + (e.end - e.start) * i, e.target[e.key] = e.current
							}), this.pathOffset || (this.pathOffset = new a(this.x, this.y)), this.pathVector || (this.pathVector = new a), this.pathDelta || (this.pathDelta = new a), this.pathDelta.reset(), this.pathTween = this.scene.sys.tweens.addCounter(t), this.path.getStartPoint(this.pathOffset), h && (this.x = this.pathOffset.x, this.y = this.pathOffset.y), this.pathOffset.x = this.x - this.pathOffset.x, this.pathOffset.y = this.y - this.pathOffset.y, this._prevDirection = o.PLAYING_FORWARD, this.rotateToPath && (u = this.path.getPoint(.1), this.rotation = Math.atan2(u.y - this.y, u.x - this.x) + n(this.pathRotationOffset)), this.pathConfig = t, this
						},
						pauseFollow: function() {
							var t = this.pathTween;
							return t && t.isPlaying() && t.pause(), this
						},
						resumeFollow: function() {
							var t = this.pathTween;
							return t && t.isPaused() && t.resume(), this
						},
						stopFollow: function() {
							var t = this.pathTween;
							return t && t.isPlaying() && t.stop(), this
						},
						pathUpdate: function() {
							var t = this.pathTween;
							if (t) {
								var e = t.data[0],
									i = this.pathDelta,
									s = this.pathVector;
								if (i.copy(s).negate(), e.state === o.COMPLETE) return this.path.getPoint(1, s), i.add(s), s.add(this.pathOffset), void this.setPosition(s.x, s.y);
								if (e.state !== o.PLAYING_FORWARD && e.state !== o.PLAYING_BACKWARD) return;
								this.path.getPoint(t.getValue(), s), i.add(s), s.add(this.pathOffset);
								var r = this.x,
									a = this.y;
								this.setPosition(s.x, s.y);
								var h = this.x - r,
									u = this.y - a;
								if (0 == h && 0 == u) return;
								if (e.state !== this._prevDirection) return void(this._prevDirection = e.state);
								this.rotateToPath && (this.rotation = Math.atan2(u, h) + n(this.pathRotationOffset))
							}
						}
					};
				t.exports = h
			}, function(t, e) {
				var i = {
					_sizeComponent: !0,
					width: 0,
					height: 0,
					displayWidth: {
						get: function() {
							return Math.abs(this.scaleX * this.frame.realWidth)
						},
						set: function(t) {
							this.scaleX = t / this.frame.realWidth
						}
					},
					displayHeight: {
						get: function() {
							return Math.abs(this.scaleY * this.frame.realHeight)
						},
						set: function(t) {
							this.scaleY = t / this.frame.realHeight
						}
					},
					setSizeToFrame: function(t) {
						return void 0 === t && (t = this.frame), this.width = t.realWidth, this.height = t.realHeight, this
					},
					setSize: function(t, e) {
						return this.width = t, this.height = e, this
					},
					setDisplaySize: function(t, e) {
						return this.displayWidth = t, this.displayHeight = e, this
					}
				};
				t.exports = i
			}, function(t, e) {
				t.exports = {
					texture: null,
					frame: null,
					isCropped: !1,
					setTexture: function(t, e) {
						return this.texture = this.scene.sys.textures.get(t), this.setFrame(e)
					},
					setFrame: function(t, e, i) {
						return void 0 === e && (e = !0), void 0 === i && (i = !0), this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this._sizeComponent && e && this.setSizeToFrame(), this._originComponent && i && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this
					}
				}
			}, function(t, e) {
				t.exports = {
					texture: null,
					frame: null,
					isCropped: !1,
					setCrop: function(t, e, i, n) {
						return void 0 === t ? this.isCropped = !1 : this.frame && ("number" == typeof t ? this.frame.setCropUVs(this._crop, t, e, i, n, this.flipX, this.flipY) : this.frame.setCropUVs(this._crop, t.x, t.y, t.width, t.height, this.flipX, this.flipY), this.isCropped = !0), this
					},
					setTexture: function(t, e) {
						return this.texture = this.scene.sys.textures.get(t), this.setFrame(e)
					},
					setFrame: function(t, e, i) {
						return void 0 === e && (e = !0), void 0 === i && (i = !0), this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this._sizeComponent && e && this.setSizeToFrame(), this._originComponent && i && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this.isCropped && this.frame.updateCropUVs(this._crop, this.flipX, this.flipY), this
					},
					resetCropObject: function() {
						return {
							u0: 0,
							v0: 0,
							u1: 0,
							v1: 0,
							width: 0,
							height: 0,
							x: 0,
							y: 0,
							flipX: !1,
							flipY: !1,
							cx: 0,
							cy: 0,
							cw: 0,
							ch: 0
						}
					}
				}
			}, function(t, e) {
				function i(t) {
					return (t >> 16) + (65280 & t) + ((255 & t) << 16)
				}
				var n = {
					_tintTL: 16777215,
					_tintTR: 16777215,
					_tintBL: 16777215,
					_tintBR: 16777215,
					_isTinted: !1,
					tintFill: !1,
					clearTint: function() {
						return this.setTint(16777215), this._isTinted = !1, this
					},
					setTint: function(t, e, n, s) {
						return void 0 === t && (t = 16777215), void 0 === e && (s = n = e = t), this._tintTL = i(t), this._tintTR = i(e), this._tintBL = i(n), this._tintBR = i(s), this._isTinted = !0, this.tintFill = !1, this
					},
					setTintFill: function(t, e, i, n) {
						return this.setTint(t, e, i, n), this.tintFill = !0, this
					},
					tintTopLeft: {
						get: function() {
							return this._tintTL
						},
						set: function(t) {
							this._tintTL = i(t), this._isTinted = !0
						}
					},
					tintTopRight: {
						get: function() {
							return this._tintTR
						},
						set: function(t) {
							this._tintTR = i(t), this._isTinted = !0
						}
					},
					tintBottomLeft: {
						get: function() {
							return this._tintBL
						},
						set: function(t) {
							this._tintBL = i(t), this._isTinted = !0
						}
					},
					tintBottomRight: {
						get: function() {
							return this._tintBR
						},
						set: function(t) {
							this._tintBR = i(t), this._isTinted = !0
						}
					},
					tint: {
						set: function(t) {
							this.setTint(t, t, t, t)
						}
					},
					isTinted: {
						get: function() {
							return this._isTinted
						}
					}
				};
				t.exports = n
			}, function(t, e) {
				t.exports = "changedata"
			}, function(t, e) {
				t.exports = "changedata-"
			}, function(t, e) {
				t.exports = "removedata"
			}, function(t, e) {
				t.exports = "setdata"
			}, function(t, e) {
				t.exports = "destroy"
			}, function(t, e) {
				t.exports = "complete"
			}, function(t, e) {
				t.exports = "created"
			}, function(t, e) {
				t.exports = "error"
			}, function(t, e) {
				t.exports = "loop"
			}, function(t, e) {
				t.exports = "play"
			}, function(t, e) {
				t.exports = "seeked"
			}, function(t, e) {
				t.exports = "seeking"
			}, function(t, e) {
				t.exports = "stop"
			}, function(t, e) {
				t.exports = "timeout"
			}, function(t, e) {
				t.exports = "unlocked"
			}, function(t, e, i) {
				var n = i(38);
				t.exports = function(t, e, i, s, r) {
					return n(t, "alpha", e, i, s, r)
				}
			}, function(t, e, i) {
				var n = i(38);
				t.exports = function(t, e, i, s, r) {
					return n(t, "x", e, i, s, r)
				}
			}, function(t, e, i) {
				var n = i(38);
				t.exports = function(t, e, i, s, r, o, a) {
					return null == i && (i = e), n(t, "x", e, s, o, a), n(t, "y", i, r, o, a)
				}
			}, function(t, e, i) {
				var n = i(38);
				t.exports = function(t, e, i, s, r) {
					return n(t, "y", e, i, s, r)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					void 0 === i && (i = 0), void 0 === n && (n = 6.28);
					for (var s = i, r = (n - i) / t.length, o = 0; o < t.length; o++) t[o].x = e.x + e.radius * Math.cos(s), t[o].y = e.y + e.radius * Math.sin(s), s += r;
					return t
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					void 0 === i && (i = 0), void 0 === n && (n = 6.28);
					for (var s = i, r = (n - i) / t.length, o = e.width / 2, a = e.height / 2, h = 0; h < t.length; h++) t[h].x = e.x + o * Math.cos(s), t[h].y = e.y + a * Math.sin(s), s += r;
					return t
				}
			}, function(t, e, i) {
				var n = i(153);
				t.exports = function(t, e) {
					for (var i = n(e, t.length), s = 0; s < t.length; s++) {
						var r = t[s],
							o = i[s];
						r.x = o.x, r.y = o.y
					}
					return t
				}
			}, function(t, e, i) {
				var n = i(285),
					s = i(286),
					r = i(287);
				t.exports = function(t, e, i) {
					void 0 === i && (i = 0);
					var o = n(e, !1, t.length);
					0 < i ? s(o, i) : i < 0 && r(o, Math.abs(i));
					for (var a = 0; a < t.length; a++) t[a].x = o[a].x, t[a].y = o[a].y;
					return t
				}
			}, function(t, e, i) {
				var n = i(288);
				t.exports = function(t, e, i) {
					var s = n({
							x1: e.x1,
							y1: e.y1,
							x2: e.x2,
							y2: e.y2
						}, i),
						r = n({
							x1: e.x2,
							y1: e.y2,
							x2: e.x3,
							y2: e.y3
						}, i),
						o = n({
							x1: e.x3,
							y1: e.y3,
							x2: e.x1,
							y2: e.y1
						}, i);
					s.pop(), r.pop(), o.pop();
					for (var a = (s = s.concat(r, o)).length / t.length, h = 0, u = 0; u < t.length; u++) {
						var l = t[u],
							c = s[Math.floor(h)];
						l.x = c.x, l.y = c.y, h += a
					}
					return t
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					for (var n = 0; n < t.length; n++) t[n].anims.play(e, i);
					return t
				}
			}, function(t, e, i) {
				var n = i(150);
				t.exports = function(t, e) {
					for (var i = 0; i < t.length; i++) n(e, t[i]);
					return t
				}
			}, function(t, e, i) {
				var n = i(157);
				t.exports = function(t, e) {
					for (var i = 0; i < t.length; i++) n(e, t[i]);
					return t
				}
			}, function(t, e, i) {
				var n = i(154);
				t.exports = function(t, e) {
					for (var i = 0; i < t.length; i++) n(e, t[i]);
					return t
				}
			}, function(t, e, i) {
				var n = i(155);
				t.exports = function(t, e) {
					for (var i = 0; i < t.length; i++) n(e, t[i]);
					return t
				}
			}, function(t, e, i) {
				var n = i(158);
				t.exports = function(t, e) {
					for (var i = 0; i < t.length; i++) n(e, t[i]);
					return t
				}
			}, function(t, e, i) {
				var n = i(38);
				t.exports = function(t, e, i, s, r) {
					return n(t, "rotation", e, i, s, r)
				}
			}, function(t, e, i) {
				var n = i(159),
					s = i(53);
				t.exports = function(t, e, i) {
					for (var r = e.x, o = e.y, a = 0; a < t.length; a++) {
						var h = t[a];
						n(h, r, o, i, Math.max(1, s(h.x, h.y, r, o)))
					}
					return t
				}
			}, function(t, e, i) {
				var n = i(159);
				t.exports = function(t, e, i, s) {
					var r = e.x,
						o = e.y;
					if (0 === s) return t;
					for (var a = 0; a < t.length; a++) n(t[a], r, o, i, s);
					return t
				}
			}, function(t, e, i) {
				var n = i(38);
				t.exports = function(t, e, i, s, r) {
					return n(t, "scaleX", e, i, s, r)
				}
			}, function(t, e, i) {
				var n = i(38);
				t.exports = function(t, e, i, s, r, o, a) {
					return null == i && (i = e), n(t, "scaleX", e, s, o, a), n(t, "scaleY", i, r, o, a)
				}
			}, function(t, e, i) {
				var n = i(38);
				t.exports = function(t, e, i, s, r) {
					return n(t, "scaleY", e, i, s, r)
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s, r) {
					return n(t, "alpha", e, i, s, r)
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s) {
					return n(t, "blendMode", e, 0, i, s)
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s, r) {
					return n(t, "depth", e, i, s, r)
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					for (var n = 0; n < t.length; n++) t[n].setInteractive(e, i);
					return t
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s, r, o, a) {
					return null == i && (i = e), n(t, "originX", e, s, o, a), n(t, "originY", i, r, o, a)
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s, r) {
					return n(t, "rotation", e, i, s, r)
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s, r, o, a) {
					return null == i && (i = e), n(t, "scaleX", e, s, o, a), n(t, "scaleY", i, r, o, a)
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s, r) {
					return n(t, "scaleX", e, i, s, r)
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s, r) {
					return n(t, "scaleY", e, i, s, r)
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s, r, o, a) {
					return null == i && (i = e), n(t, "scrollFactorX", e, s, o, a), n(t, "scrollFactorY", i, r, o, a)
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s, r) {
					return n(t, "scrollFactorX", e, i, s, r)
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s, r) {
					return n(t, "scrollFactorY", e, i, s, r)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					for (var r = 0; r < t.length; r++) t[r].setTint(e, i, n, s);
					return t
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s) {
					return n(t, "visible", e, 0, i, s)
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s, r) {
					return n(t, "x", e, i, s, r)
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s, r, o, a) {
					return null == i && (i = e), n(t, "x", e, s, o, a), n(t, "y", i, r, o, a)
				}
			}, function(t, e, i) {
				var n = i(25);
				t.exports = function(t, e, i, s, r) {
					return n(t, "y", e, i, s, r)
				}
			}, function(t, e, i) {
				var n = i(3);
				t.exports = function(t, e, i, s, r) {
					var o, a, h;
					if (void 0 === s && (s = 0), void 0 === r && (r = new n), 1 < t.length)
						if (0 === s) {
							for (var u = t.length - 1, l = t[u].x, c = t[u].y, d = u - 1; 0 <= d; d--) o = (h = t[d]).x, a = h.y, h.x = l, h.y = c, l = o, c = a;
							t[u].x = e, t[u].y = i
						} else {
							for (l = t[0].x, c = t[0].y, d = 1; d < t.length; d++) o = (h = t[d]).x, a = h.y, h.x = l, h.y = c, l = o, c = a;
							t[0].x = e, t[0].y = i
						}
					else l = t[0].x, c = t[0].y, t[0].x = e, t[0].y = i;
					return r.x = l, r.y = c, r
				}
			}, function(t, e, i) {
				var n = i(114);
				t.exports = function(t) {
					return n(t)
				}
			}, function(t, e, i) {
				var n = i(160);
				t.exports = function(t, e, i, s, r) {
					void 0 === r && (r = !1);
					var o, a = Math.abs(s - i) / t.length;
					if (r)
						for (o = 0; o < t.length; o++) t[o][e] += n(o * a, i, s);
					else
						for (o = 0; o < t.length; o++) t[o][e] = n(o * a, i, s);
					return t
				}
			}, function(t, e, i) {
				var n = i(161);
				t.exports = function(t, e, i, s, r) {
					void 0 === r && (r = !1);
					var o, a = Math.abs(s - i) / t.length;
					if (r)
						for (o = 0; o < t.length; o++) t[o][e] += n(o * a, i, s);
					else
						for (o = 0; o < t.length; o++) t[o][e] = n(o * a, i, s);
					return t
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					void 0 === s && (s = !1);
					var r, o = Math.abs(n - i) / t.length;
					if (s)
						for (r = 0; r < t.length; r++) t[r][e] += r * o + i;
					else
						for (r = 0; r < t.length; r++) t[r][e] = r * o + i;
					return t
				}
			}, function(t, e) {
				t.exports = function(t) {
					for (var e = 0; e < t.length; e++) t[e].visible = !t[e].visible;
					return t
				}
			}, function(t, e, i) {
				var n = i(58);
				t.exports = function(t, e, i) {
					void 0 === i && (i = 0);
					for (var s = 0; s < t.length; s++) {
						var r = t[s];
						r.x = n(r.x, e.left - i, e.right + i), r.y = n(r.y, e.top - i, e.bottom + i)
					}
					return t
				}
			}, function(t, e, i) {
				t.exports = {
					Animation: i(151),
					AnimationFrame: i(271),
					AnimationManager: i(289),
					Events: i(111)
				}
			}, function(t, e, i) {
				t.exports = {
					BaseCache: i(290),
					CacheManager: i(292),
					Events: i(291)
				}
			}, function(t, e) {
				t.exports = "add"
			}, function(t, e) {
				t.exports = "remove"
			}, function(t, e, i) {
				t.exports = {
					Controls: i(643),
					Scene2D: i(646)
				}
			}, function(t, e, i) {
				t.exports = {
					FixedKeyControl: i(644),
					SmoothedKeyControl: i(645)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(6),
					r = new n({
						initialize: function(t) {
							this.camera = s(t, "camera", null), this.left = s(t, "left", null), this.right = s(t, "right", null), this.up = s(t, "up", null), this.down = s(t, "down", null), this.zoomIn = s(t, "zoomIn", null), this.zoomOut = s(t, "zoomOut", null), this.zoomSpeed = s(t, "zoomSpeed", .01), this.speedX = 0, this.speedY = 0;
							var e = s(t, "speed", null);
							"number" == typeof e ? (this.speedX = e, this.speedY = e) : (this.speedX = s(t, "speed.x", 0), this.speedY = s(t, "speed.y", 0)), this._zoom = 0, this.active = null !== this.camera
						},
						start: function() {
							return this.active = null !== this.camera, this
						},
						stop: function() {
							return this.active = !1, this
						},
						setCamera: function(t) {
							return this.camera = t, this
						},
						update: function(t) {
							var e;
							this.active && (void 0 === t && (t = 1), e = this.camera, this.up && this.up.isDown ? e.scrollY -= this.speedY * t | 0 : this.down && this.down.isDown && (e.scrollY += this.speedY * t | 0), this.left && this.left.isDown ? e.scrollX -= this.speedX * t | 0 : this.right && this.right.isDown && (e.scrollX += this.speedX * t | 0), this.zoomIn && this.zoomIn.isDown ? (e.zoom -= this.zoomSpeed, e.zoom < .1 && (e.zoom = .1)) : this.zoomOut && this.zoomOut.isDown && (e.zoom += this.zoomSpeed))
						},
						destroy: function() {
							this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = i(0),
					s = i(6),
					r = new n({
						initialize: function(t) {
							this.camera = s(t, "camera", null), this.left = s(t, "left", null), this.right = s(t, "right", null), this.up = s(t, "up", null), this.down = s(t, "down", null), this.zoomIn = s(t, "zoomIn", null), this.zoomOut = s(t, "zoomOut", null), this.zoomSpeed = s(t, "zoomSpeed", .01), this.accelX = 0, this.accelY = 0;
							var e = s(t, "acceleration", null);
							"number" == typeof e ? (this.accelX = e, this.accelY = e) : (this.accelX = s(t, "acceleration.x", 0), this.accelY = s(t, "acceleration.y", 0)), this.dragX = 0, this.dragY = 0;
							var i = s(t, "drag", null);
							"number" == typeof i ? (this.dragX = i, this.dragY = i) : (this.dragX = s(t, "drag.x", 0), this.dragY = s(t, "drag.y", 0)), this.maxSpeedX = 0, this.maxSpeedY = 0;
							var n = s(t, "maxSpeed", null);
							"number" == typeof n ? (this.maxSpeedX = n, this.maxSpeedY = n) : (this.maxSpeedX = s(t, "maxSpeed.x", 0), this.maxSpeedY = s(t, "maxSpeed.y", 0)), this._speedX = 0, this._speedY = 0, this._zoom = 0, this.active = null !== this.camera
						},
						start: function() {
							return this.active = null !== this.camera, this
						},
						stop: function() {
							return this.active = !1, this
						},
						setCamera: function(t) {
							return this.camera = t, this
						},
						update: function(t) {
							var e;
							this.active && (void 0 === t && (t = 1), e = this.camera, 0 < this._speedX ? (this._speedX -= this.dragX * t, this._speedX < 0 && (this._speedX = 0)) : this._speedX < 0 && (this._speedX += this.dragX * t, 0 < this._speedX && (this._speedX = 0)), 0 < this._speedY ? (this._speedY -= this.dragY * t, this._speedY < 0 && (this._speedY = 0)) : this._speedY < 0 && (this._speedY += this.dragY * t, 0 < this._speedY && (this._speedY = 0)), this.up && this.up.isDown ? (this._speedY += this.accelY, this._speedY > this.maxSpeedY && (this._speedY = this.maxSpeedY)) : this.down && this.down.isDown && (this._speedY -= this.accelY, this._speedY < -this.maxSpeedY && (this._speedY = -this.maxSpeedY)), this.left && this.left.isDown ? (this._speedX += this.accelX, this._speedX > this.maxSpeedX && (this._speedX = this.maxSpeedX)) : this.right && this.right.isDown && (this._speedX -= this.accelX, this._speedX < -this.maxSpeedX && (this._speedX = -this.maxSpeedX)), this.zoomIn && this.zoomIn.isDown ? this._zoom = -this.zoomSpeed : this.zoomOut && this.zoomOut.isDown ? this._zoom = this.zoomSpeed : this._zoom = 0, 0 !== this._speedX && (e.scrollX -= this._speedX * t | 0), 0 !== this._speedY && (e.scrollY -= this._speedY * t | 0), 0 !== this._zoom && (e.zoom += this._zoom, e.zoom < .001 && (e.zoom = .001)))
						},
						destroy: function() {
							this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null
						}
					});
				t.exports = r
			}, function(t, e, i) {
				t.exports = {
					Camera: i(293),
					BaseCamera: i(91),
					CameraManager: i(702),
					Effects: i(301),
					Events: i(40)
				}
			}, function(t, e) {
				t.exports = "cameradestroy"
			}, function(t, e) {
				t.exports = "camerafadeincomplete"
			}, function(t, e) {
				t.exports = "camerafadeinstart"
			}, function(t, e) {
				t.exports = "camerafadeoutcomplete"
			}, function(t, e) {
				t.exports = "camerafadeoutstart"
			}, function(t, e) {
				t.exports = "cameraflashcomplete"
			}, function(t, e) {
				t.exports = "cameraflashstart"
			}, function(t, e) {
				t.exports = "camerapancomplete"
			}, function(t, e) {
				t.exports = "camerapanstart"
			}, function(t, e) {
				t.exports = "postrender"
			}, function(t, e) {
				t.exports = "prerender"
			}, function(t, e) {
				t.exports = "camerarotatecomplete"
			}, function(t, e) {
				t.exports = "camerarotatestart"
			}, function(t, e) {
				t.exports = "camerashakecomplete"
			}, function(t, e) {
				t.exports = "camerashakestart"
			}, function(t, e) {
				t.exports = "camerazoomcomplete"
			}, function(t, e) {
				t.exports = "camerazoomstart"
			}, function(t, e, i) {
				var n = i(19),
					s = i(0),
					r = i(40),
					o = new s({
						initialize: function(t) {
							this.camera = t, this.isRunning = !1, this.isComplete = !1, this.direction = !0, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope
						},
						start: function(t, e, i, n, s, o, a, h) {
							if (void 0 === t && (t = !0), void 0 === e && (e = 1e3), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === o && (o = !1), void 0 === a && (a = null), void 0 === h && (h = this.camera.scene), !o && this.isRunning) return this.camera;
							this.isRunning = !0, this.isComplete = !1, this.duration = e, this.direction = t, this.progress = 0, this.red = i, this.green = n, this.blue = s, this.alpha = t ? Number.MIN_VALUE : 1, this._elapsed = 0, this._onUpdate = a, this._onUpdateScope = h;
							var u = t ? r.FADE_OUT_START : r.FADE_IN_START;
							return this.camera.emit(u, this.camera, this, e, i, n, s), this.camera
						},
						update: function(t, e) {
							this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = this.direction ? this.progress : 1 - this.progress : (this.alpha = this.direction ? 1 : 0, this.effectComplete()))
						},
						postRenderCanvas: function(t) {
							if (!this.isRunning && !this.isComplete) return !1;
							var e = this.camera;
							return t.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")", t.fillRect(e._cx, e._cy, e._cw, e._ch), !0
						},
						postRenderWebGL: function(t, e) {
							if (!this.isRunning && !this.isComplete) return !1;
							var i = this.camera,
								n = this.red / 255,
								s = this.blue / 255,
								r = this.green / 255;
							return t.drawFillRect(i._cx, i._cy, i._cw, i._ch, e(n, r, s, 1), this.alpha), !0
						},
						effectComplete: function() {
							this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.isComplete = !0;
							var t = this.direction ? r.FADE_OUT_COMPLETE : r.FADE_IN_COMPLETE;
							this.camera.emit(t, this.camera, this)
						},
						reset: function() {
							this.isRunning = !1, this.isComplete = !1, this._onUpdate = null, this._onUpdateScope = null
						},
						destroy: function() {
							this.reset(), this.camera = null
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(19),
					s = i(0),
					r = i(40),
					o = new s({
						initialize: function(t) {
							this.camera = t, this.isRunning = !1, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope
						},
						start: function(t, e, i, n, s, o, a) {
							return void 0 === t && (t = 250), void 0 === e && (e = 255), void 0 === i && (i = 255), void 0 === n && (n = 255), void 0 === s && (s = !1), void 0 === o && (o = null), void 0 === a && (a = this.camera.scene), !s && this.isRunning || (this.isRunning = !0, this.duration = t, this.progress = 0, this.red = e, this.green = i, this.blue = n, this.alpha = 1, this._elapsed = 0, this._onUpdate = o, this._onUpdateScope = a, this.camera.emit(r.FLASH_START, this.camera, this, t, e, i, n)), this.camera
						},
						update: function(t, e) {
							this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = 1 - this.progress : this.effectComplete())
						},
						postRenderCanvas: function(t) {
							if (!this.isRunning) return !1;
							var e = this.camera;
							return t.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")", t.fillRect(e._cx, e._cy, e._cw, e._ch), !0
						},
						postRenderWebGL: function(t, e) {
							if (!this.isRunning) return !1;
							var i = this.camera,
								n = this.red / 255,
								s = this.blue / 255,
								r = this.green / 255;
							return t.drawFillRect(i._cx, i._cy, i._cw, i._ch, e(n, r, s, 1), this.alpha), !0
						},
						effectComplete: function() {
							this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(r.FLASH_COMPLETE, this.camera, this)
						},
						reset: function() {
							this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null
						},
						destroy: function() {
							this.reset(), this.camera = null
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(19),
					s = i(0),
					r = i(115),
					o = i(40),
					a = i(3),
					h = new s({
						initialize: function(t) {
							this.camera = t, this.isRunning = !1, this.duration = 0, this.source = new a, this.current = new a, this.destination = new a, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope
						},
						start: function(t, e, i, n, s, a, h) {
							void 0 === i && (i = 1e3), void 0 === n && (n = r.Linear), void 0 === s && (s = !1), void 0 === a && (a = null), void 0 === h && (h = this.camera.scene);
							var u = this.camera;
							return !s && this.isRunning || (this.isRunning = !0, this.duration = i, this.progress = 0, this.source.set(u.scrollX, u.scrollY), this.destination.set(t, e), u.getScroll(t, e, this.current), "string" == typeof n && r.hasOwnProperty(n) ? this.ease = r[n] : "function" == typeof n && (this.ease = n), this._elapsed = 0, this._onUpdate = a, this._onUpdateScope = h, this.camera.emit(o.PAN_START, this.camera, this, i, t, e)), u
						},
						update: function(t, e) {
							var i, s, r, o, a;
							this.isRunning && (this._elapsed += e, i = n(this._elapsed / this.duration, 0, 1), this.progress = i, s = this.camera, this._elapsed < this.duration ? (r = this.ease(i), s.getScroll(this.destination.x, this.destination.y, this.current), o = this.source.x + (this.current.x - this.source.x) * r, a = this.source.y + (this.current.y - this.source.y) * r, s.setScroll(o, a), this._onUpdate && this._onUpdate.call(this._onUpdateScope, s, i, o, a)) : (s.centerOn(this.destination.x, this.destination.y), this._onUpdate && this._onUpdate.call(this._onUpdateScope, s, i, s.scrollX, s.scrollY), this.effectComplete()))
						},
						effectComplete: function() {
							this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(o.PAN_COMPLETE, this.camera, this)
						},
						reset: function() {
							this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null
						},
						destroy: function() {
							this.reset(), this.camera = null, this.source = null, this.destination = null
						}
					});
				t.exports = h
			}, function(t, e) {
				t.exports = function(t, e) {
					return void 0 === e && (e = 1.70158), t * t * ((e + 1) * t - e)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return void 0 === e && (e = 1.70158), --t * t * ((e + 1) * t + e) + 1
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					void 0 === e && (e = 1.70158);
					var i = 1.525 * e;
					return (t *= 2) < 1 ? t * t * ((1 + i) * t - i) * .5 : .5 * ((t -= 2) * t * ((1 + i) * t + i) + 2)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
				}
			}, function(t, e) {
				t.exports = function(t) {
					var e = !1;
					return t < .5 ? (t = 1 - 2 * t, e = !0) : t = 2 * t - 1, t < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
				}
			}, function(t, e) {
				t.exports = function(t) {
					return 1 - Math.sqrt(1 - t * t)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return Math.sqrt(1 - --t * t)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t * t * t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return --t * t * t + 1
				}
			}, function(t, e) {
				t.exports = function(t) {
					return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					if (void 0 === e && (e = .1), void 0 === i && (i = .1), 0 === t) return 0;
					if (1 === t) return 1;
					var n = i / 4;
					return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), -e * Math.pow(2, 10 * --t) * Math.sin((t - n) * (2 * Math.PI) / i)
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					if (void 0 === e && (e = .1), void 0 === i && (i = .1), 0 === t) return 0;
					if (1 === t) return 1;
					var n = i / 4;
					return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), e * Math.pow(2, -10 * t) * Math.sin((t - n) * (2 * Math.PI) / i) + 1
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					if (void 0 === e && (e = .1), void 0 === i && (i = .1), 0 === t) return 0;
					if (1 === t) return 1;
					var n = i / 4;
					return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), (t *= 2) < 1 ? e * Math.pow(2, 10 * --t) * Math.sin((t - n) * (2 * Math.PI) / i) * -.5 : e * Math.pow(2, -10 * --t) * Math.sin((t - n) * (2 * Math.PI) / i) * .5 + 1
				}
			}, function(t, e) {
				t.exports = function(t) {
					return Math.pow(2, 10 * (t - 1)) - .001
				}
			}, function(t, e) {
				t.exports = function(t) {
					return 1 - Math.pow(2, -10 * t)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t * t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t * (2 - t)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t * t * t * t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return 1 - --t * t * t * t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t * t * t * t * t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return --t * t * t * t * t + 1
				}
			}, function(t, e) {
				t.exports = function(t) {
					return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return void 0 === e && (e = 1), t <= 0 ? 0 : 1 <= t ? 1 : 1 / e * (1 + (e * t | 0))
				}
			}, function(t, e, i) {
				var n = i(19),
					s = i(0),
					r = i(40),
					o = i(3),
					a = new s({
						initialize: function(t) {
							this.camera = t, this.isRunning = !1, this.duration = 0, this.intensity = new o, this.progress = 0, this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate, this._onUpdateScope
						},
						start: function(t, e, i, n, s) {
							return void 0 === t && (t = 100), void 0 === e && (e = .05), void 0 === i && (i = !1), void 0 === n && (n = null), void 0 === s && (s = this.camera.scene), !i && this.isRunning || (this.isRunning = !0, this.duration = t, this.progress = 0, "number" == typeof e ? this.intensity.set(e) : this.intensity.set(e.x, e.y), this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate = n, this._onUpdateScope = s, this.camera.emit(r.SHAKE_START, this.camera, this, t, e)), this.camera
						},
						preRender: function() {
							this.isRunning && this.camera.matrix.translate(this._offsetX, this._offsetY)
						},
						update: function(t, e) {
							var i, s, r, o;
							this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? (i = this.intensity, s = this.camera._cw, r = this.camera._ch, o = this.camera.zoom, this._offsetX = (Math.random() * i.x * s * 2 - i.x * s) * o, this._offsetY = (Math.random() * i.y * r * 2 - i.y * r) * o, this.camera.roundPixels && (this._offsetX = Math.round(this._offsetX), this._offsetY = Math.round(this._offsetY))) : this.effectComplete())
						},
						effectComplete: function() {
							this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(r.SHAKE_COMPLETE, this.camera, this)
						},
						reset: function() {
							this.isRunning = !1, this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null
						},
						destroy: function() {
							this.reset(), this.camera = null, this.intensity = null
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(19),
					s = i(0),
					r = i(40),
					o = i(115),
					a = new s({
						initialize: function(t) {
							this.camera = t, this.isRunning = !1, this.duration = 0, this.source = 0, this.current = 0, this.destination = 0, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope, this.clockwise = !0, this.shortestPath = !1
						},
						start: function(t, e, i, n, s, a, h) {
							void 0 === i && (i = 1e3), void 0 === n && (n = o.Linear), void 0 === s && (s = !1), void 0 === a && (a = null), void 0 === h && (h = this.camera.scene), void 0 === e && (e = !1), this.shortestPath = e;
							var u = t;
							t < 0 ? (u = -1 * t, this.clockwise = !1) : this.clockwise = !0;
							var l = 360 * Math.PI / 180;
							u -= Math.floor(u / l) * l;
							var c, d, f = this.camera;
							return !s && this.isRunning || (this.isRunning = !0, this.duration = i, this.progress = 0, this.source = f.rotation, this.destination = u, "string" == typeof n && o.hasOwnProperty(n) ? this.ease = o[n] : "function" == typeof n && (this.ease = n), this._elapsed = 0, this._onUpdate = a, this._onUpdateScope = h, this.shortestPath && (0, (c = this.destination > this.source ? Math.abs(this.destination - this.source) : Math.abs(this.destination + l) - this.source) < (d = this.source > this.destination ? Math.abs(this.source - this.destination) : Math.abs(this.source + l) - this.destination) ? this.clockwise = !0 : d < c && (this.clockwise = !1)), this.camera.emit(r.ROTATE_START, this.camera, this, i, u)), f
						},
						update: function(t, e) {
							var i, s, r, o, a, h, u, l;
							this.isRunning && (this._elapsed += e, i = n(this._elapsed / this.duration, 0, 1), this.progress = i, s = this.camera, this._elapsed < this.duration ? (r = this.ease(i), this.current = s.rotation, 0, a = 360 * Math.PI / 180, h = this.destination, u = this.current, !1 === this.clockwise && (h = this.current, u = this.destination), o = u <= h ? Math.abs(h - u) : Math.abs(h + a) - u, 0, l = this.clockwise ? s.rotation + o * r : s.rotation - o * r, s.rotation = l, this._onUpdate && this._onUpdate.call(this._onUpdateScope, s, i, l)) : (s.rotation = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope, s, i, this.destination), this.effectComplete()))
						},
						effectComplete: function() {
							this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(r.ROTATE_COMPLETE, this.camera, this)
						},
						reset: function() {
							this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null
						},
						destroy: function() {
							this.reset(), this.camera = null, this.source = null, this.destination = null
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(19),
					s = i(0),
					r = i(115),
					o = i(40),
					a = new s({
						initialize: function(t) {
							this.camera = t, this.isRunning = !1, this.duration = 0, this.source = 1, this.destination = 1, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope
						},
						start: function(t, e, i, n, s, a) {
							void 0 === e && (e = 1e3), void 0 === i && (i = r.Linear), void 0 === n && (n = !1), void 0 === s && (s = null), void 0 === a && (a = this.camera.scene);
							var h = this.camera;
							return !n && this.isRunning || (this.isRunning = !0, this.duration = e, this.progress = 0, this.source = h.zoom, this.destination = t, "string" == typeof i && r.hasOwnProperty(i) ? this.ease = r[i] : "function" == typeof i && (this.ease = i), this._elapsed = 0, this._onUpdate = s, this._onUpdateScope = a, this.camera.emit(o.ZOOM_START, this.camera, this, e, t)), h
						},
						update: function(t, e) {
							this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._elapsed < this.duration ? (this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom)) : (this.camera.zoom = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination), this.effectComplete()))
						},
						effectComplete: function() {
							this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(o.ZOOM_COMPLETE, this.camera, this)
						},
						reset: function() {
							this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null
						},
						destroy: function() {
							this.reset(), this.camera = null
						}
					});
				t.exports = a
			}, function(t, e, i) {
				var n = i(293),
					s = i(0),
					r = i(2),
					o = i(23),
					a = i(48),
					h = i(92),
					u = i(22),
					l = new s({
						initialize: function(t) {
							this.scene = t, this.systems = t.sys, this.roundPixels = t.sys.game.config.roundPixels, this.cameras = [], this.main, this.default, t.sys.events.once(u.BOOT, this.boot, this), t.sys.events.on(u.START, this.start, this)
						},
						boot: function() {
							var t = this.systems;
							t.settings.cameras ? this.fromJSON(t.settings.cameras) : this.add(), this.main = this.cameras[0], this.default = new n(0, 0, t.scale.width, t.scale.height).setScene(this.scene), t.game.scale.on(h.RESIZE, this.onResize, this), this.systems.events.once(u.DESTROY, this.destroy, this)
						},
						start: function() {
							var t;
							this.main || ((t = this.systems).settings.cameras ? this.fromJSON(t.settings.cameras) : this.add(), this.main = this.cameras[0]);
							var e = this.systems.events;
							e.on(u.UPDATE, this.update, this), e.once(u.SHUTDOWN, this.shutdown, this)
						},
						add: function(t, e, i, s, r, o) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.scale.width), void 0 === s && (s = this.scene.sys.scale.height), void 0 === r && (r = !1), void 0 === o && (o = "");
							var a = new n(t, e, i, s);
							return a.setName(o), a.setScene(this.scene), a.setRoundPixels(this.roundPixels), a.id = this.getNextID(), this.cameras.push(a), r && (this.main = a), a
						},
						addExisting: function(t, e) {
							return void 0 === e && (e = !1), -1 === this.cameras.indexOf(t) ? (t.id = this.getNextID(), t.setRoundPixels(this.roundPixels), this.cameras.push(t), e && (this.main = t), t) : null
						},
						getNextID: function() {
							for (var t = this.cameras, e = 1, i = 0; i < 32; i++) {
								for (var n = !1, s = 0; s < t.length; s++) {
									var r = t[s];
									r && r.id === e && (n = !0)
								}
								if (!n) return e;
								e <<= 1
							}
							return 0
						},
						getTotal: function(t) {
							void 0 === t && (t = !1);
							for (var e = 0, i = this.cameras, n = 0; n < i.length; n++) {
								var s = i[n];
								(!t || t && s.visible) && e++
							}
							return e
						},
						fromJSON: function(t) {
							Array.isArray(t) || (t = [t]);
							for (var e = this.scene.sys.scale.width, i = this.scene.sys.scale.height, n = 0; n < t.length; n++) {
								var s = t[n],
									o = r(s, "x", 0),
									a = r(s, "y", 0),
									h = r(s, "width", e),
									u = r(s, "height", i),
									l = this.add(o, a, h, u);
								l.name = r(s, "name", ""), l.zoom = r(s, "zoom", 1), l.rotation = r(s, "rotation", 0), l.scrollX = r(s, "scrollX", 0), l.scrollY = r(s, "scrollY", 0), l.roundPixels = r(s, "roundPixels", !1), l.visible = r(s, "visible", !0);
								var c = r(s, "backgroundColor", !1);
								c && l.setBackgroundColor(c);
								var d, f, p, g, v = r(s, "bounds", null);
								v && (d = r(v, "x", 0), f = r(v, "y", 0), p = r(v, "width", e), g = r(v, "height", i), l.setBounds(d, f, p, g))
							}
							return this
						},
						getCamera: function(t) {
							for (var e = this.cameras, i = 0; i < e.length; i++)
								if (e[i].name === t) return e[i];
							return null
						},
						getCamerasBelowPointer: function(t) {
							for (var e = this.cameras, i = t.x, n = t.y, s = [], r = 0; r < e.length; r++) {
								var o = e[r];
								o.visible && o.inputEnabled && a(o, i, n) && s.unshift(o)
							}
							return s
						},
						remove: function(t, e) {
							void 0 === e && (e = !0), Array.isArray(t) || (t = [t]);
							for (var i = 0, n = this.cameras, s = 0; s < t.length; s++) {
								var r = n.indexOf(t[s]); - 1 !== r && (e && n[r].destroy(), n.splice(r, 1), i++)
							}
							return !this.main && n[0] && (this.main = n[0]), i
						},
						render: function(t, e, i) {
							for (var n = this.scene, s = this.cameras, r = 0; r < this.cameras.length; r++) {
								var o = s[r];
								o.visible && 0 < o.alpha && (o.preRender(1), t.render(n, e, i, o))
							}
						},
						resetAll: function() {
							for (var t = 0; t < this.cameras.length; t++) this.cameras[t].destroy();
							return this.cameras = [], this.main = this.add(), this.main
						},
						update: function(t, e) {
							for (var i = 0; i < this.cameras.length; i++) this.cameras[i].update(t, e)
						},
						onResize: function(t, e, i, n, s, r) {
							for (var o = 0; o < this.cameras.length; o++) {
								var a = this.cameras[o];
								0 === a._x && 0 === a._y && a._width === s && a._height === r && a.setSize(e.width, e.height)
							}
						},
						resize: function(t, e) {
							for (var i = 0; i < this.cameras.length; i++) this.cameras[i].setSize(t, e)
						},
						shutdown: function() {
							this.main = void 0;
							for (var t = 0; t < this.cameras.length; t++) this.cameras[t].destroy();
							this.cameras = [];
							var e = this.systems.events;
							e.off(u.UPDATE, this.update, this), e.off(u.SHUTDOWN, this.shutdown, this)
						},
						destroy: function() {
							this.shutdown(), this.default.destroy(), this.scene.sys.events.off(u.START, this.start, this), this.scene = null, this.systems = null
						}
					});
				o.register("CameraManager", l, "cameras"), t.exports = l
			}, function(t, e) {
				t.exports = "enterfullscreen"
			}, function(t, e) {
				t.exports = "fullscreenfailed"
			}, function(t, e) {
				t.exports = "fullscreenunsupported"
			}, function(t, e) {
				t.exports = "leavefullscreen"
			}, function(t, e) {
				t.exports = "orientationchange"
			}, function(t, e) {
				t.exports = "resize"
			}, function(t, e) {
				t.exports = "boot"
			}, function(t, e) {
				t.exports = "create"
			}, function(t, e) {
				t.exports = "destroy"
			}, function(t, e) {
				t.exports = "pause"
			}, function(t, e) {
				t.exports = "postupdate"
			}, function(t, e) {
				t.exports = "preupdate"
			}, function(t, e) {
				t.exports = "ready"
			}, function(t, e) {
				t.exports = "render"
			}, function(t, e) {
				t.exports = "resume"
			}, function(t, e) {
				t.exports = "shutdown"
			}, function(t, e) {
				t.exports = "sleep"
			}, function(t, e) {
				t.exports = "start"
			}, function(t, e) {
				t.exports = "transitioncomplete"
			}, function(t, e) {
				t.exports = "transitioninit"
			}, function(t, e) {
				t.exports = "transitionout"
			}, function(t, e) {
				t.exports = "transitionstart"
			}, function(t, e) {
				t.exports = "transitionwake"
			}, function(t, e) {
				t.exports = "update"
			}, function(t, e) {
				t.exports = "wake"
			}, function(t, e, i) {
				t.exports = {
					Config: i(314),
					CreateRenderer: i(338),
					DebugHeader: i(342),
					Events: i(20),
					TimeStep: i(343),
					VisibilityHandler: i(345)
				}
			}, function(t, e) {
				var i, n, s = t.exports = {};

				function r() {
					throw new Error("setTimeout has not been defined")
				}

				function o() {
					throw new Error("clearTimeout has not been defined")
				}

				function a(t) {
					if (i === setTimeout) return setTimeout(t, 0);
					if ((i === r || !i) && setTimeout) return i = setTimeout, setTimeout(t, 0);
					try {
						return i(t, 0)
					} catch (e) {
						try {
							return i.call(null, t, 0)
						} catch (e) {
							return i.call(this, t, 0)
						}
					}
				}! function() {
					try {
						i = "function" == typeof setTimeout ? setTimeout : r
					} catch (t) {
						i = r
					}
					try {
						n = "function" == typeof clearTimeout ? clearTimeout : o
					} catch (t) {
						n = o
					}
				}();
				var h, u = [],
					l = !1,
					c = -1;

				function d() {
					l && h && (l = !1, h.length ? u = h.concat(u) : c = -1, u.length && f())
				}

				function f() {
					if (!l) {
						var t = a(d);
						l = !0;
						for (var e = u.length; e;) {
							for (h = u, u = []; ++c < e;) h && h[c].run();
							c = -1, e = u.length
						}
						h = null, l = !1,
							function(t) {
								if (n === clearTimeout) return clearTimeout(t);
								if ((n === o || !n) && clearTimeout) return n = clearTimeout, clearTimeout(t);
								try {
									n(t)
								} catch (e) {
									try {
										return n.call(null, t)
									} catch (e) {
										return n.call(this, t)
									}
								}
							}(t)
					}
				}

				function p(t, e) {
					this.fun = t, this.array = e
				}

				function g() {}
				s.nextTick = function(t) {
					var e = new Array(arguments.length - 1);
					if (1 < arguments.length)
						for (var i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
					u.push(new p(t, e)), 1 !== u.length || l || a(f)
				}, p.prototype.run = function() {
					this.fun.apply(null, this.array)
				}, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {}, s.on = g, s.addListener = g, s.once = g, s.off = g, s.removeListener = g, s.removeAllListeners = g, s.emit = g, s.prependListener = g, s.prependOnceListener = g, s.listeners = function(t) {
					return []
				}, s.binding = function(t) {
					throw new Error("process.binding is not supported")
				}, s.cwd = function() {
					return "/"
				}, s.chdir = function(t) {
					throw new Error("process.chdir is not supported")
				}, s.umask = function() {
					return 0
				}
			}, function(t, e, i) {
				var n = i(118),
					s = {
						gamepads: !1,
						mspointer: !1,
						touch: !1,
						wheelEvent: null
					};
				t.exports = (("ontouchstart" in document.documentElement || navigator.maxTouchPoints && 1 <= navigator.maxTouchPoints) && (s.touch = !0), (navigator.msPointerEnabled || navigator.pointerEnabled) && (s.mspointer = !0), navigator.getGamepads && (s.gamepads = !0), "onwheel" in window || n.ie && "WheelEvent" in window ? s.wheelEvent = "wheel" : "onmousewheel" in window ? s.wheelEvent = "mousewheel" : n.firefox && "MouseScrollEvent" in window && (s.wheelEvent = "DOMMouseScroll"), s)
			}, function(t, e, i) {
				var n = i(118),
					s = {
						audioData: !1,
						dolby: !1,
						m4a: !1,
						mp3: !1,
						ogg: !1,
						opus: !1,
						wav: !1,
						webAudio: !1,
						webm: !1
					};
				t.exports = function() {
					s.audioData = !!window.Audio, s.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
					var t, e, i = document.createElement("audio"),
						r = !!i.canPlayType;
					try {
						r && (i.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (s.ogg = !0), (i.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || i.canPlayType("audio/opus;").replace(/^no$/, "")) && (s.opus = !0), i.canPlayType("audio/mpeg;").replace(/^no$/, "") && (s.mp3 = !0), i.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (s.wav = !0), (i.canPlayType("audio/x-m4a;") || i.canPlayType("audio/aac;").replace(/^no$/, "")) && (s.m4a = !0), i.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (s.webm = !0), "" !== i.canPlayType('audio/mp4;codecs="ec-3"') && (n.edge ? s.dolby = !0 : n.safari && 9 <= n.safariVersion && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent) && (t = parseInt(RegExp.$1, 10), e = parseInt(RegExp.$2, 10), (10 === t && 11 <= e || 10 < t) && (s.dolby = !0))))
					} catch (t) {}
					return s
				}()
			}, function(t, e) {
				var i = {
					h264: !1,
					hls: !1,
					mp4: !1,
					ogg: !1,
					vp9: !1,
					webm: !1
				};
				t.exports = function() {
					var t = document.createElement("video"),
						e = !!t.canPlayType;
					try {
						e && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (i.ogg = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (i.h264 = !0, i.mp4 = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (i.webm = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (i.vp9 = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (i.hls = !0))
					} catch (t) {}
					return i
				}()
			}, function(t, e) {
				var i = {
					available: !1,
					cancel: "",
					keyboard: !1,
					request: ""
				};
				t.exports = function() {
					for (var t = "Fullscreen", e = "FullScreen", n = ["request" + t, "request" + e, "webkitRequest" + t, "webkitRequest" + e, "msRequest" + t, "msRequest" + e, "mozRequest" + e, "mozRequest" + t], s = 0; s < n.length; s++)
						if (document.documentElement[n[s]]) {
							i.available = !0, i.request = n[s];
							break
						} var r = ["cancel" + e, "exit" + t, "webkitCancel" + e, "webkitExit" + t, "msCancel" + e, "msExit" + t, "mozCancel" + e, "mozExit" + t];
					if (i.available)
						for (s = 0; s < r.length; s++)
							if (document[r[s]]) {
								i.cancel = r[s];
								break
							} return window.Element && Element.ALLOW_KEYBOARD_INPUT && !/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent) && (i.keyboard = !0), Object.defineProperty(i, "active", {
						get: function() {
							return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
						}
					}), i
				}()
			}, function(t, e, i) {
				t.exports = {
					Between: i(317),
					BetweenPoints: i(318),
					BetweenPointsY: i(735),
					BetweenY: i(736),
					CounterClockwise: i(737),
					Normalize: i(319),
					Random: i(738),
					RandomDegrees: i(739),
					Reverse: i(740),
					RotateTo: i(741),
					ShortestBetween: i(742),
					Wrap: i(235),
					WrapDegrees: i(236)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return Math.atan2(e.x - t.x, e.y - t.y)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					return Math.atan2(i - t, n - e)
				}
			}, function(t, e, i) {
				var n = i(13);
				t.exports = function(t) {
					return t > Math.PI && (t -= n.PI2), Math.abs(((t + n.TAU) % n.PI2 - n.PI2) % n.PI2)
				}
			}, function(t, e, i) {
				var n = i(119);
				t.exports = function() {
					return n(-Math.PI, Math.PI)
				}
			}, function(t, e, i) {
				var n = i(119);
				t.exports = function() {
					return n(-180, 180)
				}
			}, function(t, e, i) {
				var n = i(319);
				t.exports = function(t) {
					return n(t + Math.PI)
				}
			}, function(t, e, i) {
				var n = i(13);
				t.exports = function(t, e, i) {
					return void 0 === i && (i = .05), t === e || (Math.abs(e - t) <= i || Math.abs(e - t) >= n.PI2 - i ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += n.PI2 : e -= n.PI2), t < e ? t += i : e < t && (t -= i))), t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = e - t;
					return 0 == i ? 0 : i - 360 * Math.floor((i + 180) / 360)
				}
			}, function(t, e, i) {
				t.exports = {
					Between: i(53),
					BetweenPoints: i(320),
					BetweenPointsSquared: i(744),
					Chebyshev: i(745),
					Power: i(746),
					Snake: i(747),
					Squared: i(321)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = t.x - e.x,
						n = t.y - e.y;
					return i * i + n * n
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					return Math.max(Math.abs(t - i), Math.abs(e - n))
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					return void 0 === s && (s = 2), Math.sqrt(Math.pow(i - t, s) + Math.pow(n - e, s))
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					return Math.abs(t - i) + Math.abs(e - n)
				}
			}, function(t, e, i) {
				t.exports = {
					Back: i(302),
					Bounce: i(303),
					Circular: i(304),
					Cubic: i(305),
					Elastic: i(306),
					Expo: i(307),
					Linear: i(308),
					Quadratic: i(309),
					Quartic: i(310),
					Quintic: i(311),
					Sine: i(312),
					Stepped: i(313)
				}
			}, function(t, e, i) {
				t.exports = {
					Ceil: i(750),
					Equal: i(106),
					Floor: i(751),
					GreaterThan: i(322),
					LessThan: i(323)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return void 0 === e && (e = 1e-4), Math.ceil(t - e)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return void 0 === e && (e = 1e-4), Math.floor(t + e)
				}
			}, function(t, e, i) {
				t.exports = {
					Bezier: i(753),
					CatmullRom: i(754),
					CubicBezier: i(326),
					Linear: i(755),
					QuadraticBezier: i(327),
					SmoothStep: i(328),
					SmootherStep: i(756)
				}
			}, function(t, e, i) {
				var n = i(324);
				t.exports = function(t, e) {
					for (var i = 0, s = t.length - 1, r = 0; r <= s; r++) i += Math.pow(1 - e, s - r) * Math.pow(e, r) * t[r] * n(s, r);
					return i
				}
			}, function(t, e, i) {
				var n = i(171);
				t.exports = function(t, e) {
					var i = t.length - 1,
						s = i * e,
						r = Math.floor(s);
					return t[0] === t[i] ? (e < 0 && (r = Math.floor(s = i * (1 + e))), n(s - r, t[(r - 1 + i) % i], t[r], t[(r + 1) % i], t[(r + 2) % i])) : e < 0 ? t[0] - (n(-s, t[0], t[0], t[1], t[1]) - t[0]) : 1 < e ? t[i] - (n(s - i, t[i], t[i], t[i - 1], t[i - 1]) - t[i]) : n(s - r, t[r ? r - 1 : 0], t[r], t[i < r + 1 ? i : r + 1], t[i < r + 2 ? i : r + 2])
				}
			}, function(t, e, i) {
				var n = i(116);
				t.exports = function(t, e) {
					var i = t.length - 1,
						s = i * e,
						r = Math.floor(s);
					return e < 0 ? n(t[0], t[1], s) : 1 < e ? n(t[i], t[i - 1], i - s) : n(t[r], t[i < r + 1 ? i : r + 1], s - r)
				}
			}, function(t, e, i) {
				var n = i(160);
				t.exports = function(t, e, i) {
					return e + (i - e) * n(t, 0, 1)
				}
			}, function(t, e, i) {
				t.exports = {
					GetNext: i(329),
					IsSize: i(120),
					IsValue: i(758)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return 0 < t && 0 == (t & t - 1)
				}
			}, function(t, e, i) {
				t.exports = {
					Ceil: i(330),
					Floor: i(93),
					To: i(760)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.round(t / e), n ? (i + t) / e : i + t)
				}
			}, function(t, e, i) {
				var n = new(i(0))({
					initialize: function(t) {
						void 0 === t && (t = [(Date.now() * Math.random()).toString()]), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.n = 0, this.signs = [-1, 1], t && this.init(t)
					},
					rnd: function() {
						var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
						return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
					},
					hash: function(t) {
						var e, i = this.n;
						t = t.toString();
						for (var n = 0; n < t.length; n++) e = .02519603282416938 * (i += t.charCodeAt(n)), e -= i = e >>> 0, i = (e *= i) >>> 0, i += 4294967296 * (e -= i);
						return 2.3283064365386963e-10 * ((this.n = i) >>> 0)
					},
					init: function(t) {
						"string" == typeof t ? this.state(t) : this.sow(t)
					},
					sow: function(t) {
						if (this.n = 4022871197, this.s0 = this.hash(" "), this.s1 = this.hash(" "), this.s2 = this.hash(" "), this.c = 1, t)
							for (var e = 0; e < t.length && null != t[e]; e++) {
								var i = t[e];
								this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0)
							}
					},
					integer: function() {
						return 4294967296 * this.rnd()
					},
					frac: function() {
						return this.rnd() + 1.1102230246251565e-16 * (2097152 * this.rnd() | 0)
					},
					real: function() {
						return this.integer() + this.frac()
					},
					integerInRange: function(t, e) {
						return Math.floor(this.realInRange(0, e - t + 1) + t)
					},
					between: function(t, e) {
						return Math.floor(this.realInRange(0, e - t + 1) + t)
					},
					realInRange: function(t, e) {
						return this.frac() * (e - t) + t
					},
					normal: function() {
						return 1 - 2 * this.frac()
					},
					uuid: function() {
						var t = "",
							e = "";
						for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-");
						return e
					},
					pick: function(t) {
						return t[this.integerInRange(0, t.length - 1)]
					},
					sign: function() {
						return this.pick(this.signs)
					},
					weightedPick: function(t) {
						return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
					},
					timestamp: function(t, e) {
						return this.realInRange(t || 9466848e5, e || 1577862e6)
					},
					angle: function() {
						return this.integerInRange(-180, 180)
					},
					rotation: function() {
						return this.realInRange(-3.1415926, 3.1415926)
					},
					state: function(t) {
						return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
					},
					shuffle: function(t) {
						for (var e = t.length - 1; 0 < e; e--) {
							var i = Math.floor(this.frac() * (e + 1)),
								n = t[i];
							t[i] = t[e], t[e] = n
						}
						return t
					}
				});
				t.exports = n
			}, function(t, e) {
				t.exports = function(t) {
					for (var e = 0, i = 0; i < t.length; i++) e += +t[i];
					return e / t.length
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					void 0 === e && (e = 0), void 0 === i && (i = 10);
					var n = Math.pow(i, -e);
					return Math.ceil(t * n) / n
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return Math.abs(t - e)
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					void 0 === e && (e = 0), void 0 === i && (i = 10);
					var n = Math.pow(i, -e);
					return Math.floor(t * n) / n
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t / e / 1e3
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t == parseFloat(t) ? !(t % 2) : void 0
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t === parseFloat(t) ? !(t % 2) : void 0
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return Math.min(t + e, i)
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return Math.max(t - e, i)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					void 0 === i && (i = e + 1);
					var s = (t - e) / (i - e);
					return 1 < s ? void 0 !== n ? (s = (n - t) / (n - i)) < 0 && (s = 0) : s = 1 : s < 0 && (s = 0), s
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					void 0 === e && (e = 1);
					var i = 2 * Math.random() * Math.PI;
					return t.x = Math.cos(i) * e, t.y = Math.sin(i) * e, t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					void 0 === e && (e = 1);
					var i = 2 * Math.random() * Math.PI,
						n = 2 * Math.random() - 1,
						s = Math.sqrt(1 - n * n) * e;
					return t.x = Math.cos(i) * s, t.y = Math.sin(i) * s, t.z = n * e, t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return void 0 === e && (e = 1), t.x = (2 * Math.random() - 1) * e, t.y = (2 * Math.random() - 1) * e, t.z = (2 * Math.random() - 1) * e, t.w = (2 * Math.random() - 1) * e, t
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					return t.x = e + s * Math.cos(n), t.y = i + s * Math.sin(n), t
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					void 0 === e && (e = 0), void 0 === i && (i = 10);
					var n = Math.pow(i, -e);
					return Math.round(t * n) / n
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === n && (n = 1), n *= Math.PI / t;
					for (var s = [], r = [], o = 0; o < t; o++) e += (i -= e * n) * n, s[o] = i, r[o] = e;
					return {
						sin: r,
						cos: s,
						length: t
					}
				}
			}, function(t, e, i) {
				var n = i(3);
				t.exports = function(t, e, i, s) {
					void 0 === s && (s = new n);
					var r = 0,
						o = 0;
					return 0 < t && t <= e * i && (r = e - 1 < t ? t - (o = Math.floor(t / e)) * e : t, s.set(r, o)), s
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return Math.abs(t - e) <= i
				}
			}, function(t, e, i) {
				var n = i(174),
					s = i(336),
					r = i(337),
					o = new s,
					a = new r,
					h = new n;
				t.exports = function(t, e, i) {
					return a.setAxisAngle(e, i), o.fromRotationTranslation(a, h.set(0, 0, 0)), t.transformMat4(o)
				}
			}, function(t, e) {
				t.exports = "addtexture"
			}, function(t, e) {
				t.exports = "onerror"
			}, function(t, e) {
				t.exports = "onload"
			}, function(t, e) {
				t.exports = "ready"
			}, function(t, e) {
				t.exports = "removetexture"
			}, function(t, e) {
				t.exports = ["#define SHADER_NAME PHASER_BITMAP_MASK_FS", "", "precision mediump float;", "", "uniform vec2 uResolution;", "uniform sampler2D uMainSampler;", "uniform sampler2D uMaskSampler;", "uniform bool uInvertMaskAlpha;", "", "void main()", "{", "    vec2 uv = gl_FragCoord.xy / uResolution;", "    vec4 mainColor = texture2D(uMainSampler, uv);", "    vec4 maskColor = texture2D(uMaskSampler, uv);", "    float alpha = mainColor.a;", "", "    if (!uInvertMaskAlpha)", "    {", "        alpha *= (maskColor.a);", "    }", "    else", "    {", "        alpha *= (1.0 - maskColor.a);", "    }", "", "    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);", "}", ""].join("\n")
			}, function(t, e) {
				t.exports = ["#define SHADER_NAME PHASER_BITMAP_MASK_VS", "", "precision mediump float;", "", "attribute vec2 inPosition;", "", "void main()", "{", "    gl_Position = vec4(inPosition, 0.0, 1.0);", "}", ""].join("\n")
			}, function(t, e) {
				t.exports = ["#define SHADER_NAME PHASER_FORWARD_DIFFUSE_FS", "", "precision mediump float;", "", "struct Light", "{", "    vec2 position;", "    vec3 color;", "    float intensity;", "    float radius;", "};", "", "const int kMaxLights = %LIGHT_COUNT%;", "", "uniform vec4 uCamera; /* x, y, rotation, zoom */", "uniform vec2 uResolution;", "uniform sampler2D uMainSampler;", "uniform sampler2D uNormSampler;", "uniform vec3 uAmbientLightColor;", "uniform Light uLights[kMaxLights];", "uniform mat3 uInverseRotationMatrix;", "", "varying vec2 outTexCoord;", "varying vec4 outTint;", "", "void main()", "{", "    vec3 finalColor = vec3(0.0, 0.0, 0.0);", "    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.rgb * outTint.a, outTint.a);", "    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;", "    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));", "    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;", "", "    for (int index = 0; index < kMaxLights; ++index)", "    {", "        Light light = uLights[index];", "        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);", "        vec3 lightNormal = normalize(lightDir);", "        float distToSurf = length(lightDir) * uCamera.w;", "        float diffuseFactor = max(dot(normal, lightNormal), 0.0);", "        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;", "        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);", "        vec3 diffuse = light.color * diffuseFactor;", "        finalColor += (attenuation * diffuse) * light.intensity;", "    }", "", "    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);", "    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);", "", "}", ""].join("\n")
			}, function(t, e, i) {
				t.exports = {
					GenerateTexture: i(346),
					Palettes: i(790)
				}
			}, function(t, e, i) {
				t.exports = {
					ARNE16: i(347),
					C64: i(791),
					CGA: i(792),
					JMP: i(793),
					MSX: i(794)
				}
			}, function(t, e) {
				t.exports = {
					0: "#000",
					1: "#fff",
					2: "#8b4131",
					3: "#7bbdc5",
					4: "#8b41ac",
					5: "#6aac41",
					6: "#3931a4",
					7: "#d5de73",
					8: "#945a20",
					9: "#5a4100",
					A: "#bd736a",
					B: "#525252",
					C: "#838383",
					D: "#acee8b",
					E: "#7b73de",
					F: "#acacac"
				}
			}, function(t, e) {
				t.exports = {
					0: "#000",
					1: "#2234d1",
					2: "#0c7e45",
					3: "#44aacc",
					4: "#8a3622",
					5: "#5c2e78",
					6: "#aa5c3d",
					7: "#b5b5b5",
					8: "#5e606e",
					9: "#4c81fb",
					A: "#6cd947",
					B: "#7be2f9",
					C: "#eb8a60",
					D: "#e23d69",
					E: "#ffd93f",
					F: "#fff"
				}
			}, function(t, e) {
				t.exports = {
					0: "#000",
					1: "#191028",
					2: "#46af45",
					3: "#a1d685",
					4: "#453e78",
					5: "#7664fe",
					6: "#833129",
					7: "#9ec2e8",
					8: "#dc534b",
					9: "#e18d79",
					A: "#d6b97b",
					B: "#e9d8a1",
					C: "#216c4b",
					D: "#d365c8",
					E: "#afaab9",
					F: "#f5f4eb"
				}
			}, function(t, e) {
				t.exports = {
					0: "#000",
					1: "#191028",
					2: "#46af45",
					3: "#a1d685",
					4: "#453e78",
					5: "#7664fe",
					6: "#833129",
					7: "#9ec2e8",
					8: "#dc534b",
					9: "#e18d79",
					A: "#d6b97b",
					B: "#e9d8a1",
					C: "#216c4b",
					D: "#d365c8",
					E: "#afaab9",
					F: "#fff"
				}
			}, function(t, e, i) {
				t.exports = {
					Path: i(796),
					CubicBezier: i(348),
					Curve: i(81),
					Ellipse: i(349),
					Line: i(350),
					QuadraticBezier: i(351),
					Spline: i(352)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(348),
					r = i(349),
					o = i(5),
					a = i(350),
					h = i(797),
					u = i(351),
					l = i(11),
					c = i(352),
					d = i(3),
					f = i(13),
					p = new n({
						initialize: function(t, e) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), this.name = "", this.curves = [], this.cacheLengths = [], this.autoClose = !1, this.startPoint = new d, this._tmpVec2A = new d, this._tmpVec2B = new d, "object" == typeof t ? this.fromJSON(t) : this.startPoint.set(t, e)
						},
						add: function(t) {
							return this.curves.push(t), this
						},
						circleTo: function(t, e, i) {
							return void 0 === e && (e = !1), this.ellipseTo(t, t, 0, 360, e, i)
						},
						closePath: function() {
							var t = this.curves[0].getPoint(0),
								e = this.curves[this.curves.length - 1].getPoint(1);
							return t.equals(e) || this.curves.push(new a(e, t)), this
						},
						cubicBezierTo: function(t, e, i, n, r, o) {
							var a, h, u = this.getEndPoint(),
								l = t instanceof d ? (a = t, h = e, i) : (a = new d(i, n), h = new d(r, o), new d(t, e));
							return this.add(new s(u, a, h, l))
						},
						quadraticBezierTo: function(t, e, i, n) {
							var s, r = this.getEndPoint(),
								o = t instanceof d ? (s = t, e) : (s = new d(i, n), new d(t, e));
							return this.add(new u(r, s, o))
						},
						draw: function(t, e) {
							for (var i = 0; i < this.curves.length; i++) {
								var n = this.curves[i];
								n.active && n.draw(t, e)
							}
							return t
						},
						ellipseTo: function(t, e, i, n, s, o) {
							var a = new r(0, 0, t, e, i, n, s, o),
								h = this.getEndPoint(this._tmpVec2A),
								u = a.getStartPoint(this._tmpVec2B);
							return h.subtract(u), a.x = h.x, a.y = h.y, this.add(a)
						},
						fromJSON: function(t) {
							this.curves = [], this.cacheLengths = [], this.startPoint.set(t.x, t.y), this.autoClose = t.autoClose;
							for (var e = 0; e < t.curves.length; e++) {
								var i = t.curves[e];
								switch (i.type) {
									case "LineCurve":
										this.add(a.fromJSON(i));
										break;
									case "EllipseCurve":
										this.add(r.fromJSON(i));
										break;
									case "SplineCurve":
										this.add(c.fromJSON(i));
										break;
									case "CubicBezierCurve":
										this.add(s.fromJSON(i));
										break;
									case "QuadraticBezierCurve":
										this.add(u.fromJSON(i))
								}
							}
							return this
						},
						getBounds: function(t, e) {
							void 0 === t && (t = new l), void 0 === e && (e = 16), t.x = Number.MAX_VALUE, t.y = Number.MAX_VALUE;
							for (var i = new l, n = f.MIN_SAFE_INTEGER, s = f.MIN_SAFE_INTEGER, r = 0; r < this.curves.length; r++) {
								var o = this.curves[r];
								o.active && (o.getBounds(i, e), t.x = Math.min(t.x, i.x), t.y = Math.min(t.y, i.y), n = Math.max(n, i.right), s = Math.max(s, i.bottom))
							}
							return t.right = n, t.bottom = s, t
						},
						getCurveLengths: function() {
							if (this.cacheLengths.length === this.curves.length) return this.cacheLengths;
							for (var t = [], e = 0, i = 0; i < this.curves.length; i++) e += this.curves[i].getLength(), t.push(e);
							return this.cacheLengths = t
						},
						getEndPoint: function(t) {
							return void 0 === t && (t = new d), 0 < this.curves.length ? this.curves[this.curves.length - 1].getPoint(1, t) : t.copy(this.startPoint), t
						},
						getLength: function() {
							var t = this.getCurveLengths();
							return t[t.length - 1]
						},
						getPoint: function(t, e) {
							void 0 === e && (e = new d);
							for (var i = t * this.getLength(), n = this.getCurveLengths(), s = 0; s < n.length;) {
								if (n[s] >= i) {
									var r = n[s] - i,
										o = this.curves[s],
										a = o.getLength(),
										h = 0 === a ? 0 : 1 - r / a;
									return o.getPointAt(h, e)
								}
								s++
							}
							return null
						},
						getPoints: function(t) {
							void 0 === t && (t = 12);
							for (var e, i = [], n = 0; n < this.curves.length; n++) {
								var s = this.curves[n];
								if (s.active)
									for (var r = s.getResolution(t), o = s.getPoints(r), a = 0; a < o.length; a++) {
										var h = o[a];
										e && e.equals(h) || (i.push(h), e = h)
									}
							}
							return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
						},
						getRandomPoint: function(t) {
							return void 0 === t && (t = new d), this.getPoint(Math.random(), t)
						},
						getSpacedPoints: function(t) {
							void 0 === t && (t = 40);
							for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
							return this.autoClose && e.push(e[0]), e
						},
						getStartPoint: function(t) {
							return void 0 === t && (t = new d), t.copy(this.startPoint)
						},
						getTangent: function(t, e) {
							void 0 === e && (e = new d);
							for (var i = t * this.getLength(), n = this.getCurveLengths(), s = 0; s < n.length;) {
								if (n[s] >= i) {
									var r = n[s] - i,
										o = this.curves[s],
										a = o.getLength(),
										h = 0 === a ? 0 : 1 - r / a;
									return o.getTangentAt(h, e)
								}
								s++
							}
							return null
						},
						lineTo: function(t, e) {
							t instanceof d ? this._tmpVec2B.copy(t) : this._tmpVec2B.set(t, e);
							var i = this.getEndPoint(this._tmpVec2A);
							return this.add(new a([i.x, i.y, this._tmpVec2B.x, this._tmpVec2B.y]))
						},
						splineTo: function(t) {
							return t.unshift(this.getEndPoint()), this.add(new c(t))
						},
						moveTo: function(t, e) {
							return t instanceof d ? this.add(new h(t.x, t.y)) : this.add(new h(t, e))
						},
						toJSON: function() {
							for (var t = [], e = 0; e < this.curves.length; e++) t.push(this.curves[e].toJSON());
							return {
								type: "Path",
								x: this.startPoint.x,
								y: this.startPoint.y,
								autoClose: this.autoClose,
								curves: t
							}
						},
						updateArcLengths: function() {
							this.cacheLengths = [], this.getCurveLengths()
						},
						destroy: function() {
							this.curves.length = 0, this.cacheLengths.length = 0, this.startPoint = void 0
						}
					});
				o.register("path", function(t, e) {
					return new p(t, e)
				}), t.exports = p
			}, function(t, e, i) {
				var n = i(0),
					s = i(3),
					r = new n({
						initialize: function(t, e) {
							this.active = !1, this.p0 = new s(t, e)
						},
						getPoint: function(t, e) {
							return void 0 === e && (e = new s), e.copy(this.p0)
						},
						getPointAt: function(t, e) {
							return this.getPoint(t, e)
						},
						getResolution: function() {
							return 1
						},
						getLength: function() {
							return 0
						},
						toJSON: function() {
							return {
								type: "MoveTo",
								points: [this.p0.x, this.p0.y]
							}
						}
					});
				t.exports = r
			}, function(t, e, i) {
				t.exports = {
					DataManager: i(113),
					DataManagerPlugin: i(799),
					Events: i(284)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(113),
					r = i(23),
					o = i(22),
					a = new n({
						Extends: s,
						initialize: function(t) {
							s.call(this, t, t.sys.events), this.scene = t, this.systems = t.sys, t.sys.events.once(o.BOOT, this.boot, this), t.sys.events.on(o.START, this.start, this)
						},
						boot: function() {
							this.events = this.systems.events, this.events.once(o.DESTROY, this.destroy, this)
						},
						start: function() {
							this.events.once(o.SHUTDOWN, this.shutdown, this)
						},
						shutdown: function() {
							this.systems.events.off(o.SHUTDOWN, this.shutdown, this)
						},
						destroy: function() {
							s.prototype.destroy.call(this), this.events.off(o.START, this.start, this), this.scene = null, this.systems = null
						}
					});
				r.register("DataManagerPlugin", a, "data"), t.exports = a
			}, function(t, e, i) {
				t.exports = {
					Align: i(801),
					BaseShader: i(353),
					Bounds: i(804),
					Canvas: i(808),
					Color: i(354),
					Masks: i(817)
				}
			}, function(t, e, i) {
				var n = i(105),
					s = i(18)(!1, s = {
						In: i(802),
						To: i(803)
					}, n);
				t.exports = s
			}, function(t, e, i) {
				t.exports = {
					BottomCenter: i(256),
					BottomLeft: i(257),
					BottomRight: i(258),
					Center: i(259),
					LeftCenter: i(261),
					QuickSet: i(255),
					RightCenter: i(262),
					TopCenter: i(263),
					TopLeft: i(264),
					TopRight: i(265)
				}
			}, function(t, e, i) {
				t.exports = {
					BottomCenter: i(243),
					BottomLeft: i(244),
					BottomRight: i(245),
					LeftBottom: i(246),
					LeftCenter: i(247),
					LeftTop: i(248),
					QuickSet: i(242),
					RightBottom: i(249),
					RightCenter: i(250),
					RightTop: i(251),
					TopCenter: i(252),
					TopLeft: i(253),
					TopRight: i(254)
				}
			}, function(t, e, i) {
				t.exports = {
					CenterOn: i(260),
					GetBottom: i(34),
					GetBounds: i(805),
					GetCenterX: i(76),
					GetCenterY: i(78),
					GetLeft: i(35),
					GetOffsetX: i(806),
					GetOffsetY: i(807),
					GetRight: i(36),
					GetTop: i(37),
					SetBottom: i(46),
					SetCenterX: i(77),
					SetCenterY: i(79),
					SetLeft: i(44),
					SetRight: i(45),
					SetTop: i(43)
				}
			}, function(t, e, i) {
				var n = i(34),
					s = i(35),
					r = i(36),
					o = i(37);
				t.exports = function(t, e) {
					void 0 === e && (e = {});
					var i = s(t),
						a = o(t);
					return e.x = i, e.y = a, e.width = r(t) - i, e.height = n(t) - a, e
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.width * t.originX
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.height * t.originY
				}
			}, function(t, e, i) {
				t.exports = {
					CanvasInterpolation: i(339),
					CanvasPool: i(26),
					Smoothing: i(167),
					TouchAction: i(809),
					UserSelect: i(810)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return void 0 === e && (e = "none"), t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return void 0 === e && (e = "none"), ["-webkit-", "-khtml-", "-moz-", "-ms-", ""].forEach(function(i) {
						t.style[i + "user-select"] = e
					}), t.style["-webkit-touch-callout"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
				}
			}, function(t, e) {
				t.exports = function(t) {
					var e = {
						r: t >> 16 & 255,
						g: t >> 8 & 255,
						b: 255 & t,
						a: 255
					};
					return 16777215 < t && (e.a = t >>> 24), e
				}
			}, function(t, e, i) {
				var n = i(31),
					s = i(356);
				t.exports = function(t, e, i) {
					var r, o, a = i,
						h = i,
						u = i;
					return 0 !== e && (a = s(o = 2 * i - (r = i < .5 ? i * (1 + e) : i + e - i * e), r, t + 1 / 3), h = s(o, r, t), u = s(o, r, t - 1 / 3)), (new n).setGLTo(a, h, u, 1)
				}
			}, function(t, e, i) {
				var n = i(166);
				t.exports = function(t, e) {
					void 0 === t && (t = 1), void 0 === e && (e = 1);
					for (var i = [], s = 0; s <= 359; s++) i.push(n(s / 359, t, e));
					return i
				}
			}, function(t, e, i) {
				function n(t, e, i, n, r, o, a, h) {
					void 0 === a && (a = 100), void 0 === h && (h = 0);
					var u = h / a;
					return {
						r: s(t, n, u),
						g: s(e, r, u),
						b: s(i, o, u)
					}
				}
				var s = i(116);
				t.exports = {
					RGBWithRGB: n,
					ColorWithRGB: function(t, e, i, s, r, o) {
						return void 0 === r && (r = 100), void 0 === o && (o = 0), n(t.r, t.g, t.b, e, i, s, r, o)
					},
					ColorWithColor: function(t, e, i, s) {
						return void 0 === i && (i = 100), void 0 === s && (s = 0), n(t.r, t.g, t.b, e.r, e.g, e.b, i, s)
					}
				}
			}, function(t, e, i) {
				var n = i(172),
					s = i(31);
				t.exports = function(t, e) {
					return void 0 === t && (t = 0), void 0 === e && (e = 255), new s(n(t, e), n(t, e), n(t, e))
				}
			}, function(t, e, i) {
				var n = i(355);
				t.exports = function(t, e, i, s, r) {
					return void 0 === s && (s = 255), void 0 === r && (r = "#"), "#" === r ? "#" + ((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1) : "0x" + n(s) + n(t) + n(e) + n(i)
				}
			}, function(t, e, i) {
				t.exports = {
					BitmapMask: i(278),
					GeometryMask: i(279)
				}
			}, function(t, e, i) {
				var n = {
					AddToDOM: i(122),
					DOMContentLoaded: i(357),
					GetScreenOrientation: i(358),
					GetTarget: i(363),
					ParseXML: i(364),
					RemoveFromDOM: i(178),
					RequestAnimationFrame: i(344)
				};
				t.exports = n
			}, function(t, e, i) {
				t.exports = {
					EventEmitter: i(820)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(10),
					r = i(23),
					o = new n({
						Extends: s,
						initialize: function() {
							s.call(this)
						},
						shutdown: function() {
							this.removeAllListeners()
						},
						destroy: function() {
							this.removeAllListeners()
						}
					});
				r.register("EventEmitter", o, "events"), t.exports = o
			}, function(t, e, i) {
				var n = i(122),
					s = i(289),
					r = i(292),
					o = i(26),
					a = i(0),
					h = i(314),
					u = i(822),
					l = i(338),
					c = i(113),
					d = i(342),
					f = i(315),
					p = i(357),
					g = i(10),
					v = i(20),
					m = i(365),
					y = i(23),
					x = i(370),
					T = i(371),
					w = i(373),
					E = i(121),
					_ = i(376),
					b = i(343),
					A = i(345),
					S = i(380),
					C = new a({
						initialize: function(t) {
							this.config = new h(t), this.renderer = null, this.domContainer = null, this.canvas = null, this.context = null, this.isBooted = !1, this.isRunning = !1, this.events = new g, this.anims = new s(this), this.textures = new _(this), this.cache = new r(this), this.registry = new c(this), this.input = new m(this, this.config), this.scene = new w(this, this.config.sceneConfig), this.device = f, this.scale = new T(this, this.config), this.sound = null, this.sound = S.create(this), this.loop = new b(this, this.config.fps), this.plugins = new x(this, this.config), this.pendingDestroy = !1, this.removeCanvas = !1, this.noReturn = !1, this.hasFocus = !1, p(this.boot.bind(this))
						},
						boot: function() {
							y.hasCore("EventEmitter") ? (this.isBooted = !0, this.config.preBoot(this), this.scale.preBoot(), l(this), u(this), d(this), n(this.canvas, this.config.parent), this.textures.once(E.READY, this.texturesReady, this), this.events.emit(v.BOOT)) : console.warn("Aborting. Core Plugins missing.")
						},
						texturesReady: function() {
							this.events.emit(v.READY), this.start()
						},
						start: function() {
							this.isRunning = !0, this.config.postBoot(this), this.renderer ? this.loop.start(this.step.bind(this)) : this.loop.start(this.headlessStep.bind(this)), A(this);
							var t = this.events;
							t.on(v.HIDDEN, this.onHidden, this), t.on(v.VISIBLE, this.onVisible, this), t.on(v.BLUR, this.onBlur, this), t.on(v.FOCUS, this.onFocus, this)
						},
						step: function(t, e) {
							if (this.pendingDestroy) return this.runDestroy();
							var i = this.events;
							i.emit(v.PRE_STEP, t, e), i.emit(v.STEP, t, e), this.scene.update(t, e), i.emit(v.POST_STEP, t, e);
							var n = this.renderer;
							n.preRender(), i.emit(v.PRE_RENDER, n, t, e), this.scene.render(n), n.postRender(), i.emit(v.POST_RENDER, n, t, e)
						},
						headlessStep: function(t, e) {
							if (this.pendingDestroy) return this.runDestroy();
							var i = this.events;
							i.emit(v.PRE_STEP, t, e), i.emit(v.STEP, t, e), this.scene.update(t, e), i.emit(v.POST_STEP, t, e), i.emit(v.PRE_RENDER), i.emit(v.POST_RENDER)
						},
						onHidden: function() {
							this.loop.pause(), this.events.emit(v.PAUSE)
						},
						onVisible: function() {
							this.loop.resume(), this.events.emit(v.RESUME)
						},
						onBlur: function() {
							this.hasFocus = !1, this.loop.blur()
						},
						onFocus: function() {
							this.hasFocus = !0, this.loop.focus()
						},
						getFrame: function() {
							return this.loop.frame
						},
						getTime: function() {
							return this.loop.now
						},
						destroy: function(t, e) {
							void 0 === e && (e = !1), this.pendingDestroy = !0, this.removeCanvas = t, this.noReturn = e
						},
						runDestroy: function() {
							this.scene.destroy(), this.events.emit(v.DESTROY), this.events.removeAllListeners(), this.renderer && this.renderer.destroy(), this.removeCanvas && this.canvas && (o.remove(this.canvas), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)), this.domContainer && this.domContainer.parentNode.removeChild(this.domContainer), this.loop.destroy(), this.pendingDestroy = !1
						}
					});
				t.exports = C
			}, function(t, e, i) {
				var n = i(122);
				t.exports = function(t) {
					var e, i = t.config;
					i.parent && i.domCreateContainer && ((e = document.createElement("div")).style.cssText = ["display: block;", "width: " + t.scale.width + "px;", "height: " + t.scale.height + "px;", "padding: 0; margin: 0;", "position: absolute;", "overflow: hidden;", "pointer-events: none;", "transform: scale(1);", "transform-origin: left top;"].join(" "), t.domContainer = e, n(e, i.parent))
				}
			}, function(t, e) {
				t.exports = "boot"
			}, function(t, e) {
				t.exports = "destroy"
			}, function(t, e) {
				t.exports = "dragend"
			}, function(t, e) {
				t.exports = "dragenter"
			}, function(t, e) {
				t.exports = "drag"
			}, function(t, e) {
				t.exports = "dragleave"
			}, function(t, e) {
				t.exports = "dragover"
			}, function(t, e) {
				t.exports = "dragstart"
			}, function(t, e) {
				t.exports = "drop"
			}, function(t, e) {
				t.exports = "gameout"
			}, function(t, e) {
				t.exports = "gameover"
			}, function(t, e) {
				t.exports = "gameobjectdown"
			}, function(t, e) {
				t.exports = "dragend"
			}, function(t, e) {
				t.exports = "dragenter"
			}, function(t, e) {
				t.exports = "drag"
			}, function(t, e) {
				t.exports = "dragleave"
			}, function(t, e) {
				t.exports = "dragover"
			}, function(t, e) {
				t.exports = "dragstart"
			}, function(t, e) {
				t.exports = "drop"
			}, function(t, e) {
				t.exports = "gameobjectmove"
			}, function(t, e) {
				t.exports = "gameobjectout"
			}, function(t, e) {
				t.exports = "gameobjectover"
			}, function(t, e) {
				t.exports = "pointerdown"
			}, function(t, e) {
				t.exports = "pointermove"
			}, function(t, e) {
				t.exports = "pointerout"
			}, function(t, e) {
				t.exports = "pointerover"
			}, function(t, e) {
				t.exports = "pointerup"
			}, function(t, e) {
				t.exports = "wheel"
			}, function(t, e) {
				t.exports = "gameobjectup"
			}, function(t, e) {
				t.exports = "gameobjectwheel"
			}, function(t, e) {
				t.exports = "boot"
			}, function(t, e) {
				t.exports = "process"
			}, function(t, e) {
				t.exports = "update"
			}, function(t, e) {
				t.exports = "pointerdown"
			}, function(t, e) {
				t.exports = "pointerdownoutside"
			}, function(t, e) {
				t.exports = "pointermove"
			}, function(t, e) {
				t.exports = "pointerout"
			}, function(t, e) {
				t.exports = "pointerover"
			}, function(t, e) {
				t.exports = "pointerup"
			}, function(t, e) {
				t.exports = "pointerupoutside"
			}, function(t, e) {
				t.exports = "wheel"
			}, function(t, e) {
				t.exports = "pointerlockchange"
			}, function(t, e) {
				t.exports = "preupdate"
			}, function(t, e) {
				t.exports = "shutdown"
			}, function(t, e) {
				t.exports = "start"
			}, function(t, e) {
				t.exports = "update"
			}, function(t, e) {
				t.exports = function(t) {
					if (!t) return window.innerHeight;
					var e = Math.abs(window.orientation),
						i = {
							w: 0,
							h: 0
						},
						n = document.createElement("div");
					return n.setAttribute("style", "position: fixed; height: 100vh; width: 0; top: 0"), document.documentElement.appendChild(n), i.w = 90 === e ? n.offsetHeight : window.innerWidth, i.h = 90 === e ? window.innerWidth : n.offsetHeight, document.documentElement.removeChild(n), n = null, 90 !== Math.abs(window.orientation) ? i.h : i.w
				}
			}, function(t, e) {
				t.exports = "addfile"
			}, function(t, e) {
				t.exports = "complete"
			}, function(t, e) {
				t.exports = "filecomplete"
			}, function(t, e) {
				t.exports = "filecomplete-"
			}, function(t, e) {
				t.exports = "loaderror"
			}, function(t, e) {
				t.exports = "load"
			}, function(t, e) {
				t.exports = "fileprogress"
			}, function(t, e) {
				t.exports = "postprocess"
			}, function(t, e) {
				t.exports = "progress"
			}, function(t, e) {
				t.exports = "start"
			}, function(t, e, i) {
				var n = i(2),
					s = i(181);
				t.exports = function(t) {
					var e = t.game.config.defaultPhysicsSystem,
						i = n(t.settings, "physics", !1);
					if (e || i) {
						var r = [];
						if (e && r.push(s(e + "Physics")), i)
							for (var o in i) o = s(o.concat("Physics")), -1 === r.indexOf(o) && r.push(o);
						return r
					}
				}
			}, function(t, e, i) {
				var n = i(2);
				t.exports = function(t) {
					var e = t.plugins.getDefaultScenePlugins(),
						i = n(t.settings, "plugins", !1);
					return Array.isArray(i) ? i : e || []
				}
			}, function(t, e, i) {
				t.exports = {
					game: "game",
					anims: "anims",
					cache: "cache",
					plugins: "plugins",
					registry: "registry",
					scale: "scale",
					sound: "sound",
					textures: "textures",
					events: "events",
					cameras: "cameras",
					add: "add",
					make: "make",
					scenePlugin: "scene",
					displayList: "children",
					lights: "lights",
					data: "data",
					input: "input",
					load: "load",
					time: "time",
					tweens: "tweens",
					arcadePhysics: "physics",
					impactPhysics: "impact",
					matterPhysics: "matter"
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					if (i.getElementsByTagName("TextureAtlas")) {
						var n = t.source[e];
						t.add("__BASE", e, 0, 0, n.width, n.height);
						for (var s = i.getElementsByTagName("SubTexture"), r = 0; r < s.length; r++) {
							var o, a, h, u, l = s[r].attributes,
								c = l.name.value,
								d = parseInt(l.x.value, 10),
								f = parseInt(l.y.value, 10),
								p = parseInt(l.width.value, 10),
								g = parseInt(l.height.value, 10),
								v = t.add(c, e, d, f, p, g);
							l.frameX && (o = Math.abs(parseInt(l.frameX.value, 10)), a = Math.abs(parseInt(l.frameY.value, 10)), h = parseInt(l.frameWidth.value, 10), u = parseInt(l.frameHeight.value, 10), v.setTrim(p, g, o, a, h, u))
						}
						return t
					}
					console.warn("Invalid Texture Atlas XML given")
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = t.source[e];
					return t.add("__BASE", e, 0, 0, i.width, i.height), t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = t.source[e];
					return t.add("__BASE", e, 0, 0, i.width, i.height), t
				}
			}, function(t, e, i) {
				var n = i(67);
				t.exports = function(t, e, i) {
					if (i.frames || i.textures) {
						var s = t.source[e];
						t.add("__BASE", e, 0, 0, s.width, s.height);
						for (var r = Array.isArray(i.textures) ? i.textures[e].frames : i.frames, o = 0; o < r.length; o++) {
							var a = r[o],
								h = t.add(a.filename, e, a.frame.x, a.frame.y, a.frame.w, a.frame.h);
							a.trimmed && h.setTrim(a.sourceSize.w, a.sourceSize.h, a.spriteSourceSize.x, a.spriteSourceSize.y, a.spriteSourceSize.w, a.spriteSourceSize.h), a.rotated && (h.rotated = !0, h.updateUVsInverted());
							var u = a.anchor || a.pivot;
							u && (h.customPivot = !0, h.pivotX = u.x, h.pivotY = u.y), h.customData = n(a)
						}
						for (var l in i) "frames" !== l && (Array.isArray(i[l]) ? t.customData[l] = i[l].slice(0) : t.customData[l] = i[l]);
						return t
					}
					console.warn("Invalid Texture Atlas JSON Array")
				}
			}, function(t, e, i) {
				var n = i(67);
				t.exports = function(t, e, i) {
					if (i.frames) {
						var s = t.source[e];
						t.add("__BASE", e, 0, 0, s.width, s.height);
						var r = i.frames;
						for (var o in r) {
							var a = r[o],
								h = t.add(o, e, a.frame.x, a.frame.y, a.frame.w, a.frame.h);
							a.trimmed && h.setTrim(a.sourceSize.w, a.sourceSize.h, a.spriteSourceSize.x, a.spriteSourceSize.y, a.spriteSourceSize.w, a.spriteSourceSize.h), a.rotated && (h.rotated = !0, h.updateUVsInverted());
							var u = a.anchor || a.pivot;
							u && (h.customPivot = !0, h.pivotX = u.x, h.pivotY = u.y), h.customData = n(a)
						}
						for (var l in i) "frames" !== l && (Array.isArray(i[l]) ? t.customData[l] = i[l].slice(0) : t.customData[l] = i[l]);
						return t
					}
					console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object")
				}
			}, function(t, e, i) {
				var n = i(2);
				t.exports = function(t, e, i, s, r, o, a) {
					var h = n(a, "frameWidth", null),
						u = n(a, "frameHeight", h);
					if (null === h) throw new Error("TextureManager.SpriteSheet: Invalid frameWidth given.");
					var l = t.source[e];
					t.add("__BASE", e, 0, 0, l.width, l.height);
					var c = n(a, "startFrame", 0),
						d = n(a, "endFrame", -1),
						f = n(a, "margin", 0),
						p = n(a, "spacing", 0),
						g = Math.floor((r - f + p) / (h + p)) * Math.floor((o - f + p) / (u + p));
					0 === g && console.warn("SpriteSheet frame dimensions will result in zero frames for texture:", t.key), (g < c || c < -g) && (c = 0), c < 0 && (c = g + c), -1 !== d && (g = c + (d + 1));
					for (var v = f, m = f, y = 0, x = 0, T = 0; T < g; T++) {
						x = y = 0;
						var w = v + h,
							E = m + u;
						r < w && (y = w - r), o < E && (x = E - o), t.add(T, e, i + v, s + m, h - y, u - x), r < (v += h + p) + h && (v = f, m += u + p)
					}
					return t
				}
			}, function(t, e, i) {
				var n = i(2);
				t.exports = function(t, e, i) {
					var s = n(i, "frameWidth", null),
						r = n(i, "frameHeight", s);
					if (!s) throw new Error("TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.");
					var o = t.source[0];
					t.add("__BASE", 0, 0, 0, o.width, o.height);
					var a = n(i, "startFrame", 0),
						h = n(i, "endFrame", -1),
						u = n(i, "margin", 0),
						l = n(i, "spacing", 0),
						c = e.cutX,
						d = e.cutY,
						f = e.cutWidth,
						p = e.cutHeight,
						g = e.realWidth,
						v = e.realHeight,
						m = Math.floor((g - u + l) / (s + l)),
						y = Math.floor((v - u + l) / (r + l)),
						x = m * y,
						T = e.x,
						w = s - T,
						E = s - (g - f - T),
						_ = e.y,
						b = r - _,
						A = r - (v - p - _);
					(x < a || a < -x) && (a = 0), a < 0 && (a = x + a), -1 !== h && (x = a + (h + 1));
					for (var S = u, C = u, M = 0, O = e.sourceIndex, P = 0; P < y; P++) {
						for (var R = 0 === P, L = P === y - 1, D = 0; D < m; D++) {
							var F, k, I, B, Y, N, X = 0 === D,
								U = D === m - 1,
								z = t.add(M, O, c + S, d + C, s, r);
							(X || R || U || L) && (F = X ? T : 0, k = R ? _ : 0, B = I = 0, X && (I += s - w), U && (I += s - E), R && (B += r - b), L && (B += r - A), Y = s - I, N = r - B, z.cutWidth = Y, z.cutHeight = N, z.setTrim(s, r, F, k, Y, N)), S += l, S += X ? w : U ? E : s, M++
						}
						S = u, C += l, C += R ? b : L ? A : r
					}
					return t
				}
			}, function(t, e) {
				function i(t, e, i, s) {
					var r = n - s.y - s.height;
					t.add(i, e, s.x, r, s.width, s.height)
				}
				var n = 0;
				t.exports = function(t, e, s) {
					var r = t.source[e];
					t.add("__BASE", e, 0, 0, r.width, r.height), n = r.height;
					for (var o = s.split("\n"), a = /^[ ]*(- )*(\w+)+[: ]+(.*)/, h = "", u = "", l = {
							x: 0,
							y: 0,
							width: 0,
							height: 0
						}, c = 0; c < o.length; c++) {
						var d = o[c].match(a);
						if (d) {
							var f = "- " === d[1],
								p = d[2],
								g = d[3];
							if (f && (u !== h && (i(t, e, u, l), h = u), l = {
									x: 0,
									y: 0,
									width: 0,
									height: 0
								}), "name" !== p) switch (p) {
								case "x":
								case "y":
								case "width":
								case "height":
									l[p] = parseInt(g, 10)
							} else u = g
						}
					}
					return u !== h && i(t, e, u, l), t
				}
			}, function(t, e) {
				t.exports = "complete"
			}, function(t, e) {
				t.exports = "decoded"
			}, function(t, e) {
				t.exports = "decodedall"
			}, function(t, e) {
				t.exports = "destroy"
			}, function(t, e) {
				t.exports = "detune"
			}, function(t, e) {
				t.exports = "detune"
			}, function(t, e) {
				t.exports = "mute"
			}, function(t, e) {
				t.exports = "rate"
			}, function(t, e) {
				t.exports = "volume"
			}, function(t, e) {
				t.exports = "loop"
			}, function(t, e) {
				t.exports = "looped"
			}, function(t, e) {
				t.exports = "mute"
			}, function(t, e) {
				t.exports = "pauseall"
			}, function(t, e) {
				t.exports = "pause"
			}, function(t, e) {
				t.exports = "play"
			}, function(t, e) {
				t.exports = "rate"
			}, function(t, e) {
				t.exports = "resumeall"
			}, function(t, e) {
				t.exports = "resume"
			}, function(t, e) {
				t.exports = "seek"
			}, function(t, e) {
				t.exports = "stopall"
			}, function(t, e) {
				t.exports = "stop"
			}, function(t, e) {
				t.exports = "unlocked"
			}, function(t, e) {
				t.exports = "volume"
			}, function(t, e, i) {
				var n = {
					Events: i(90),
					DisplayList: i(915),
					GameObjectCreator: i(16),
					GameObjectFactory: i(5),
					UpdateList: i(941),
					Components: i(12),
					BuildGameObject: i(27),
					BuildGameObjectAnimation: i(393),
					GameObject: i(14),
					BitmapText: i(132),
					Blitter: i(188),
					Container: i(189),
					DOMElement: i(395),
					DynamicBitmapText: i(190),
					Extern: i(397),
					Graphics: i(191),
					Group: i(97),
					Image: i(107),
					Particles: i(973),
					PathFollower: i(409),
					RenderTexture: i(195),
					RetroFont: i(982),
					Rope: i(197),
					Sprite: i(75),
					Text: i(198),
					TileSprite: i(199),
					Zone: i(110),
					Video: i(200),
					Shape: i(30),
					Arc: i(410),
					Curve: i(411),
					Ellipse: i(412),
					Grid: i(413),
					IsoBox: i(414),
					IsoTriangle: i(415),
					Line: i(416),
					Polygon: i(417),
					Rectangle: i(422),
					Star: i(423),
					Triangle: i(424),
					Factories: {
						Blitter: i(1033),
						Container: i(1034),
						DOMElement: i(1035),
						DynamicBitmapText: i(1036),
						Extern: i(1037),
						Graphics: i(1038),
						Group: i(1039),
						Image: i(1040),
						Particles: i(1041),
						PathFollower: i(1042),
						RenderTexture: i(1043),
						Rope: i(1044),
						Sprite: i(1045),
						StaticBitmapText: i(1046),
						Text: i(1047),
						TileSprite: i(1048),
						Zone: i(1049),
						Video: i(1050),
						Arc: i(1051),
						Curve: i(1052),
						Ellipse: i(1053),
						Grid: i(1054),
						IsoBox: i(1055),
						IsoTriangle: i(1056),
						Line: i(1057),
						Polygon: i(1058),
						Rectangle: i(1059),
						Star: i(1060),
						Triangle: i(1061)
					},
					Creators: {
						Blitter: i(1062),
						Container: i(1063),
						DynamicBitmapText: i(1064),
						Graphics: i(1065),
						Group: i(1066),
						Image: i(1067),
						Particles: i(1068),
						RenderTexture: i(1069),
						Rope: i(1070),
						Sprite: i(1071),
						StaticBitmapText: i(1072),
						Text: i(1073),
						TileSprite: i(1074),
						Zone: i(1075),
						Video: i(1076)
					}
				};
				n.Mesh = i(134), n.Quad = i(203), n.Shader = i(204), n.Factories.Mesh = i(1083), n.Factories.Quad = i(1084), n.Factories.Shader = i(1085), n.Creators.Mesh = i(1086), n.Creators.Quad = i(1087), n.Creators.Shader = i(1088), n.Light = i(428), i(429), i(1089), t.exports = n
			}, function(t, e, i) {
				var n = i(0),
					s = i(129),
					r = i(23),
					o = i(22),
					a = i(131),
					h = new n({
						Extends: s,
						initialize: function(t) {
							s.call(this, t), this.sortChildrenFlag = !1, this.scene = t, this.systems = t.sys, t.sys.events.once(o.BOOT, this.boot, this), t.sys.events.on(o.START, this.start, this)
						},
						boot: function() {
							this.systems.events.once(o.DESTROY, this.destroy, this)
						},
						start: function() {
							this.systems.events.once(o.SHUTDOWN, this.shutdown, this)
						},
						queueDepthSort: function() {
							this.sortChildrenFlag = !0
						},
						depthSort: function() {
							this.sortChildrenFlag && (a.inplace(this.list, this.sortByDepth), this.sortChildrenFlag = !1)
						},
						sortByDepth: function(t, e) {
							return t._depth - e._depth
						},
						getChildren: function() {
							return this.list
						},
						shutdown: function() {
							for (var t = this.list.length; t--;) this.list[t].destroy(!0);
							this.list.length = 0, this.systems.events.off(o.SHUTDOWN, this.shutdown, this)
						},
						destroy: function() {
							this.shutdown(), this.scene.sys.events.off(o.START, this.start, this), this.scene = null, this.systems = null
						}
					});
				r.register("DisplayList", h, "displayList"), t.exports = h
			}, function(t, e, i) {
				t.exports = {
					CheckMatrix: i(184),
					MatrixToString: i(917),
					ReverseColumns: i(918),
					ReverseRows: i(919),
					Rotate180: i(920),
					RotateLeft: i(921),
					RotateMatrix: i(130),
					RotateRight: i(922),
					TransposeMatrix: i(390)
				}
			}, function(t, e, i) {
				var n = i(163),
					s = i(184);
				t.exports = function(t) {
					var e = "";
					if (!s(t)) return e;
					for (var i = 0; i < t.length; i++) {
						for (var r = 0; r < t[i].length; r++) {
							var o = t[i][r].toString();
							e += "undefined" !== o ? n(o, 2) : "?", r < t[i].length - 1 && (e += " |")
						}
						if (i < t.length - 1) {
							e += "\n";
							for (var a = 0; a < t[i].length; a++) e += "---", a < t[i].length - 1 && (e += "+");
							e += "\n"
						}
					}
					return e
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.reverse()
				}
			}, function(t, e) {
				t.exports = function(t) {
					for (var e = 0; e < t.length; e++) t[e].reverse();
					return t
				}
			}, function(t, e, i) {
				var n = i(130);
				t.exports = function(t) {
					return n(t, 180)
				}
			}, function(t, e, i) {
				var n = i(130);
				t.exports = function(t) {
					return n(t, 90)
				}
			}, function(t, e, i) {
				var n = i(130);
				t.exports = function(t) {
					return n(t, -90)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					if (void 0 === s && (s = t), 0 < i) {
						var r = i - t.length;
						if (r <= 0) return null
					}
					if (!Array.isArray(e)) return -1 === t.indexOf(e) ? (t.push(e), n && n.call(s, e), e) : null;
					for (var o = e.length - 1; 0 <= o;) - 1 !== t.indexOf(e[o]) && e.splice(o, 1), o--;
					if (0 === (o = e.length)) return null;
					0 < i && r < o && (e.splice(r), o = r);
					for (var a = 0; a < o; a++) {
						var h = e[a];
						t.push(h), n && n.call(s, h)
					}
					return e
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s, r) {
					if (void 0 === i && (i = 0), void 0 === r && (r = t), 0 < n) {
						var o = n - t.length;
						if (o <= 0) return null
					}
					if (!Array.isArray(e)) return -1 === t.indexOf(e) ? (t.splice(i, 0, e), s && s.call(r, e), e) : null;
					for (var a = e.length - 1; 0 <= a;) - 1 !== t.indexOf(e[a]) && e.pop(), a--;
					if (0 === (a = e.length)) return null;
					0 < n && o < a && (e.splice(o), a = o);
					for (var h = a - 1; 0 <= h; h--) {
						var u = e[h];
						t.splice(i, 0, u), s && s.call(r, u)
					}
					return e
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = t.indexOf(e);
					return -1 !== i && i < t.length && (t.splice(i, 1), t.push(e)), e
				}
			}, function(t, e, i) {
				var n = i(68);
				t.exports = function(t, e, i, s, r) {
					void 0 === s && (s = 0), void 0 === r && (r = t.length);
					var o = 0;
					if (n(t, s, r))
						for (var a = s; a < r; a++) t[a][e] === i && o++;
					return o
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					for (var n = [null], s = 3; s < arguments.length; s++) n.push(arguments[s]);
					for (s = 0; s < t.length; s++) n[0] = t[s], e.apply(i, n);
					return t
				}
			}, function(t, e, i) {
				var n = i(68);
				t.exports = function(t, e, i, s, r) {
					if (void 0 === s && (s = 0), void 0 === r && (r = t.length), n(t, s, r)) {
						for (var o = [null], a = 5; a < arguments.length; a++) o.push(arguments[a]);
						for (a = s; a < r; a++) o[0] = t[a], e.apply(i, o)
					}
					return t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i, n, s = t.indexOf(e);
					return 0 < s && (i = t[s - 1], n = t.indexOf(i), t[s] = i, t[n] = e), t
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					var n = t.indexOf(e);
					if (-1 === n || i < 0 || i >= t.length) throw new Error("Supplied index out of bounds");
					return n !== i && (t.splice(n, 1), t.splice(i, 0, e)), e
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i, n, s = t.indexOf(e);
					return -1 !== s && s < t.length - 1 && (i = t[s + 1], n = t.indexOf(i), t[s] = i, t[n] = e), t
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					for (var s, r = [], o = t; o <= e; o++) i || n ? (s = i ? i + o.toString() : o.toString(), n && (s = s.concat(n)), r.push(s)) : r.push(o);
					return r
				}
			}, function(t, e, i) {
				var n = i(332);
				t.exports = function(t, e, i) {
					void 0 === t && (t = 0), void 0 === e && (e = null), void 0 === i && (i = 1), null === e && (e = t, t = 0);
					for (var s = [], r = Math.max(n((e - t) / (i || 1)), 0), o = 0; o < r; o++) s.push(t), t += i;
					return s
				}
			}, function(t, e, i) {
				var n = i(80);
				t.exports = function(t, e, i, s) {
					if (void 0 === s && (s = t), e < 0 || e > t.length - 1) throw new Error("Index out of bounds");
					var r = n(t, e);
					return i && i.call(s, r), r
				}
			}, function(t, e, i) {
				var n = i(68);
				t.exports = function(t, e, i, s, r) {
					if (void 0 === e && (e = 0), void 0 === i && (i = t.length), void 0 === r && (r = t), n(t, e, i)) {
						var o = i - e,
							a = t.splice(e, o);
						if (s)
							for (var h = 0; h < a.length; h++) {
								var u = a[h];
								s.call(r, u)
							}
						return a
					}
					return []
				}
			}, function(t, e, i) {
				var n = i(80);
				t.exports = function(t, e, i) {
					void 0 === e && (e = 0), void 0 === i && (i = t.length);
					var s = e + Math.floor(Math.random() * i);
					return n(t, s)
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					var n = t.indexOf(e),
						s = t.indexOf(i);
					return -1 !== n && -1 === s && (t[n] = i, !0)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = t.indexOf(e);
					return -1 !== i && 0 < i && (t.splice(i, 1), t.unshift(e)), e
				}
			}, function(t, e, i) {
				var n = i(68);
				t.exports = function(t, e, i, s, r) {
					if (void 0 === s && (s = 0), void 0 === r && (r = t.length), n(t, s, r))
						for (var o = s; o < r; o++) {
							var a = t[o];
							a.hasOwnProperty(e) && (a[e] = i)
						}
					return t
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					if (e !== i) {
						var n = t.indexOf(e),
							s = t.indexOf(i);
						if (n < 0 || s < 0) throw new Error("Supplied items must be elements of the same array");
						return t[n] = i, t[s] = e, t
					}
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(186),
					r = i(23),
					o = i(22),
					a = new n({
						Extends: s,
						initialize: function(t) {
							s.call(this), this.scene = t, this.systems = t.sys, t.sys.events.once(o.BOOT, this.boot, this), t.sys.events.on(o.START, this.start, this)
						},
						boot: function() {
							this.systems.events.once(o.DESTROY, this.destroy, this)
						},
						start: function() {
							var t = this.systems.events;
							t.on(o.PRE_UPDATE, this.update, this), t.on(o.UPDATE, this.sceneUpdate, this), t.once(o.SHUTDOWN, this.shutdown, this)
						},
						sceneUpdate: function(t, e) {
							for (var i = this._active, n = i.length, s = 0; s < n; s++) {
								var r = i[s];
								r.active && r.preUpdate.call(r, t, e)
							}
						},
						shutdown: function() {
							for (var t = this._active.length; t--;) this._active[t].destroy(!0);
							for (t = this._pending.length; t--;) this._pending[t].destroy(!0);
							for (t = this._destroy.length; t--;) this._destroy[t].destroy(!0);
							this._toProcess = 0, this._pending = [], this._active = [], this._destroy = [], this.removeAllListeners();
							var e = this.systems.events;
							e.off(o.PRE_UPDATE, this.preUpdate, this), e.off(o.UPDATE, this.sceneUpdate, this), e.off(o.SHUTDOWN, this.shutdown, this)
						},
						destroy: function() {
							this.shutdown(), this.systems.events.off(o.START, this.start, this), this.scene = null, this.systems = null
						}
					});
				r.register("UpdateList", a, "updateList"), t.exports = a
			}, function(t, e, i) {
				t.exports = {
					PROCESS_QUEUE_ADD: i(943),
					PROCESS_QUEUE_REMOVE: i(944)
				}
			}, function(t, e) {
				t.exports = "add"
			}, function(t, e) {
				t.exports = "remove"
			}, function(t, e) {
				t.exports = function(t, e, i) {
					if (void 0 === i) return {
						local: {
							x: 0,
							y: 0,
							width: 0,
							height: 0
						},
						global: {
							x: 0,
							y: 0,
							width: 0,
							height: 0
						},
						lines: {
							shortest: 0,
							longest: 0,
							lengths: null,
							height: 0
						},
						wrappedText: "",
						words: [],
						scaleX: 0,
						scaleY: 0
					};
					var n, s, r, o, a, h, u = t.text,
						l = u.length,
						c = t.maxWidth,
						d = t.wordWrapCharCode,
						f = Number.MAX_VALUE,
						p = Number.MAX_VALUE,
						g = 0,
						v = 0,
						m = t.fontData.chars,
						y = t.fontData.lineHeight,
						x = t.letterSpacing,
						T = 0,
						w = 0,
						E = 0,
						_ = null,
						b = 0,
						A = t.fontSize / t.fontData.size,
						S = A * t.scaleX,
						C = A * t.scaleY,
						M = null,
						O = 0,
						P = [],
						R = Number.MAX_VALUE,
						L = 0,
						D = 0,
						F = 0,
						k = [],
						I = null;
					if (0 < c) {
						for (N = 0; N < l; N++) 10 !== (E = u.charCodeAt(N)) ? (_ = m[E]) && (null !== M && (n = _.kerning[O]), E === d ? null !== I && (k.push({
							word: I.word,
							i: I.i,
							x: I.x * S,
							y: I.y * C,
							w: I.w * S,
							h: I.h * C,
							cr: !1
						}), I = null) : (null === I && (I = {
							word: "",
							i: N,
							x: T,
							y: w,
							w: 0,
							h: y,
							cr: !1
						}), I.word = I.word.concat(u[N]), I.w += _.xOffset + _.xAdvance + (void 0 !== n ? n : 0)), T += _.xAdvance + x, M = _, O = E) : (null !== I && (k.push({
							word: I.word,
							i: I.i,
							x: I.x * S,
							y: I.y * C,
							w: I.w * S,
							h: I.h * C,
							cr: !0
						}), I = null), T = 0, w += y, M = null);
						null !== I && k.push({
							word: I.word,
							i: I.i,
							x: I.x * S,
							y: I.y * C,
							w: I.w * S,
							h: I.h * C,
							cr: !1
						}), M = null;
						for (var B = O = w = T = 0, Y = [], N = 0; N < k.length; N++) {
							var X, U = k[N],
								z = U.x,
								G = U.x + U.w;
							X && (B = z - (z - (X.x + X.w) + X.w), X = null), c < z - B || c < G - B ? (Y.push(U.i - 1), X = U.cr ? (Y.push(U.i + U.word.length), B = 0, null) : U) : U.cr && (Y.push(U.i + U.word.length), B = 0, X = null)
						}
						for (N = Y.length - 1; 0 <= N; N--) s = u, r = Y[N], "\n", u = s.substr(0, r) + "\n" + s.substr(r + 1);
						l = (i.wrappedText = u).length, k = [], I = null
					}
					for (N = 0; N < l; N++) 10 !== (E = u.charCodeAt(N)) ? (_ = m[E]) && (b = T, null !== M && (b += void 0 !== (o = _.kerning[O]) ? o : 0), b < f && (f = b), w < p && (p = w), g < (a = b + _.xAdvance) && (g = a), v < (h = w + y) && (v = h), E === d ? null !== I && (k.push({
						word: I.word,
						i: I.i,
						x: I.x * S,
						y: I.y * C,
						w: I.w * S,
						h: I.h * C
					}), I = null) : (null === I && (I = {
						word: "",
						i: N,
						x: T,
						y: w,
						w: 0,
						h: y
					}), I.word = I.word.concat(u[N]), I.w += _.xOffset + _.xAdvance + (void 0 !== o ? o : 0)), T += _.xAdvance + x, M = _, O = E, F = a * A) : (null !== I && (k.push({
						word: I.word,
						i: I.i,
						x: I.x * S,
						y: I.y * C,
						w: I.w * S,
						h: I.h * C
					}), I = null), T = 0, w += y, M = null, L < (P[D] = F) && (L = F), F < R && (R = F), D++, F = 0);
					null !== I && k.push({
						word: I.word,
						i: I.i,
						x: I.x * S,
						y: I.y * C,
						w: I.w * S,
						h: I.h * C
					}), L < (P[D] = F) && (L = F), F < R && (R = F);
					var W = i.local,
						V = i.global,
						H = i.lines;
					return W.x = f * A, W.y = p * A, W.width = g * A, W.height = v * A, V.x = t.x - t.displayOriginX + f * S, V.y = t.y - t.displayOriginY + p * C, V.width = g * S, V.height = v * C, H.shortest = R, H.longest = L, H.lengths = P, e && (W.x = Math.round(W.x), W.y = Math.round(W.y), W.width = Math.round(W.width), W.height = Math.round(W.height), V.x = Math.round(V.x), V.y = Math.round(V.y), V.width = Math.round(V.width), V.height = Math.round(V.height), H.shortest = Math.round(R), H.longest = Math.round(L)), i.words = k, i.lines.height = y, i.scaleX = t.scaleX, i.scaleY = t.scaleY, i
				}
			}, function(t, e, i) {
				var n = i(187);
				t.exports = function(t, e, i, s, r, o, a) {
					var h = t.sys.textures.getFrame(i, s),
						u = t.sys.cache.xml.get(r);
					if (h && u) {
						var l = n(u, o, a, h);
						return t.sys.cache.bitmapFont.add(e, {
							data: l,
							texture: i,
							frame: s
						}), !0
					}
					return !1
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(948), s = i(949);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					var o = e._text,
						a = o.length;
					if (0 !== a) {
						var h = this.pipeline;
						t.setPipeline(h, e);
						var u = h._tempMatrix1,
							l = h._tempMatrix2,
							c = h._tempMatrix3;
						l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), u.copyFrom(s.matrix), r ? (u.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= s.scrollX * e.scrollFactorX, l.f -= s.scrollY * e.scrollFactorY), u.multiply(l, c);
						var d = e.frame,
							f = d.glTexture,
							p = d.cutX,
							g = d.cutY,
							v = f.width,
							m = f.height,
							y = e._isTinted && e.tintFill,
							x = n.getTintAppendFloatAlpha(e._tintTL, s.alpha * e._alphaTL),
							T = n.getTintAppendFloatAlpha(e._tintTR, s.alpha * e._alphaTR),
							w = n.getTintAppendFloatAlpha(e._tintBL, s.alpha * e._alphaBL),
							E = n.getTintAppendFloatAlpha(e._tintBR, s.alpha * e._alphaBR);
						h.setTexture2D(f, 0);
						var _, b, A, S, C, M, O = 0,
							P = 0,
							R = 0,
							L = e._letterSpacing,
							D = e.fontData,
							F = D.chars,
							k = D.lineHeight,
							I = e._fontSize / D.size,
							B = e._align,
							Y = 0,
							N = 0,
							X = e.getTextBounds(!1);
						0 < e.maxWidth && (a = (o = X.wrappedText).length);
						var U = e._bounds.lines;
						1 === B ? N = (U.longest - U.lengths[0]) / 2 : 2 === B && (N = U.longest - U.lengths[0]);
						for (var z, G, W, V, H, j, K, q, J, Z, Q, $, tt, et, it, nt, st, rt, ot = s.roundPixels, at = 0; at < a; at++) 10 !== (_ = o.charCodeAt(at)) ? (rt = F[_]) && (b = p + rt.x, A = g + rt.y, S = rt.width, C = rt.height, z = rt.xOffset + O, G = rt.yOffset + P, null !== M && (z += void 0 !== (W = rt.kerning[R]) ? W : 0), O += rt.xAdvance + L, M = rt, R = _, 0 !== S && 0 !== C && 32 !== _ && (z *= I, G *= I, z -= e.displayOriginX, V = b / v, H = A / m, j = (b + S) / v, K = (A + C) / m, q = (z += N) + S * I, J = (G -= e.displayOriginY) + C * I, Z = c.getX(z, G), Q = c.getY(z, G), $ = c.getX(z, J), tt = c.getY(z, J), et = c.getX(q, J), it = c.getY(q, J), nt = c.getX(q, G), st = c.getY(q, G), ot && (Z = Math.round(Z), Q = Math.round(Q), $ = Math.round($), tt = Math.round(tt), et = Math.round(et), it = Math.round(it), nt = Math.round(nt), st = Math.round(st)), h.batchQuad(Z, Q, $, tt, et, it, nt, st, V, H, j, K, x, T, w, E, y, f, 0))) : (Y++, 1 === B ? N = (U.longest - U.lengths[Y]) / 2 : 2 === B && (N = U.longest - U.lengths[Y]), O = 0, P += k, M = null)
					}
				}
			}, function(t, e, i) {
				var n = i(28);
				t.exports = function(t, e, i, s, r) {
					var o = e._text,
						a = o.length,
						h = t.currentContext;
					if (0 !== a && n(t, h, e, s, r)) {
						var u, l = e.frame,
							c = e.fontData.chars,
							d = e.fontData.lineHeight,
							f = e._letterSpacing,
							p = 0,
							g = 0,
							v = null,
							m = 0,
							y = 0,
							x = 0,
							T = 0,
							w = 0,
							E = 0,
							_ = null,
							b = 0,
							A = e.frame.source.image,
							S = l.cutX,
							C = l.cutY,
							M = e._fontSize / e.fontData.size,
							O = e._align,
							P = 0,
							R = 0,
							L = e.getTextBounds(!1);
						0 < e.maxWidth && (a = (o = L.wrappedText).length);
						var D = e._bounds.lines;
						1 === O ? R = (D.longest - D.lengths[0]) / 2 : 2 === O && (R = D.longest - D.lengths[0]), h.translate(-e.displayOriginX, -e.displayOriginY);
						for (var F, k = s.roundPixels, I = 0; I < a; I++) 10 !== (u = o.charCodeAt(I)) ? (v = c[u]) && (m = S + v.x, y = C + v.y, x = v.width, T = v.height, w = v.xOffset + p, E = v.yOffset + g, null !== _ && (w += void 0 !== (F = v.kerning[b]) ? F : 0), w *= M, E *= M, w += R, p += v.xAdvance + f, _ = v, b = u, 0 !== x && 0 !== T && 32 !== u && (k && (w = Math.round(w), E = Math.round(E)), h.save(), h.translate(w, E), h.scale(M, M), h.drawImage(A, m, y, x, T, 0, 0, x, T), h.restore())) : (P++, 1 === O ? R = (D.longest - D.lengths[P]) / 2 : 2 === O && (R = D.longest - D.lengths[P]), p = 0, g += d, _ = null);
						h.restore()
					}
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(951), s = i(952);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					var o = e.getRenderList();
					if (0 !== o.length) {
						var a = this.pipeline;
						t.setPipeline(a, e);
						var h = s.scrollX * e.scrollFactorX,
							u = s.scrollY * e.scrollFactorY,
							l = a._tempMatrix1;
						l.copyFrom(s.matrix), r && (l.multiplyWithOffset(r, -h, -u), u = h = 0);
						for (var c = e.x - h, d = e.y - u, f = -1, p = s.alpha * e.alpha, g = s.roundPixels, v = 0; v < o.length; v++) {
							var m, y, x, T, w, E, _, b, A, S, C, M = o[v],
								O = M.frame,
								P = M.alpha * p;
							0 != P && (m = O.width, y = O.height, x = c + M.x + O.x, T = d + M.y + O.y, M.flipX && (m *= -1, x += O.width), M.flipY && (y *= -1, T += O.height), w = x + m, E = T + y, _ = l.getX(x, T), b = l.getY(x, T), A = l.getX(w, E), S = l.getY(w, E), C = n.getTintAppendFloatAlpha(M.tint, P), O.sourceIndex !== f && (a.setTexture2D(O.glTexture, 0), f = O.sourceIndex), g && (_ = Math.round(_), b = Math.round(b), A = Math.round(A), S = Math.round(S)), a.batchQuad(_, b, _, S, A, S, A, b, O.u0, O.v0, O.u1, O.v1, C, C, C, C, !1, O.glTexture, 0) && (f = -1))
						}
					}
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					var r = e.getRenderList();
					if (0 !== r.length) {
						var o = t.currentContext,
							a = n.alpha * e.alpha;
						if (0 != a) {
							o.globalCompositeOperation = t.blendModes[e.blendMode], o.imageSmoothingEnabled = !(!t.antialias || e.frame.source.scaleMode);
							var h = e.x - n.scrollX * e.scrollFactorX,
								u = e.y - n.scrollY * e.scrollFactorY;
							o.save(), s && s.copyToContext(o);
							for (var l = n.roundPixels, c = 0; c < r.length; c++) {
								var d = r[c],
									f = d.flipX || d.flipY,
									p = d.frame,
									g = p.canvasData,
									v = p.x,
									m = p.y,
									y = 1,
									x = 1,
									T = d.alpha * a;
								0 != T && (o.globalAlpha = T, f ? (d.flipX && (y = -1, v -= g.width), d.flipY && (x = -1, m -= g.height), o.save(), o.translate(d.x + h, d.y + u), o.scale(y, x), o.drawImage(p.source.image, g.x, g.y, g.width, g.height, v, m, g.width, g.height), o.restore()) : (l && (v = Math.round(v), m = Math.round(m)), o.drawImage(p.source.image, g.x, g.y, g.width, g.height, v + d.x + h, m + d.y + u, g.width, g.height)))
							}
							o.restore()
						}
					}
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(94),
					r = new n({
						initialize: function(t, e, i, n, s) {
							this.parent = t, this.x = e, this.y = i, this.frame = n, this.data = {}, this.tint = 16777215, this._visible = s, this._alpha = 1, this.flipX = !1, this.flipY = !1
						},
						setFrame: function(t) {
							return void 0 === t ? this.frame = this.parent.frame : t instanceof s && t.texture === this.parent.texture ? this.frame = t : this.frame = this.parent.texture.get(t), this
						},
						resetFlip: function() {
							return this.flipX = !1, this.flipY = !1, this
						},
						reset: function(t, e, i) {
							return this.x = t, this.y = e, this.flipX = !1, this.flipY = !1, this._alpha = 1, this._visible = !0, this.parent.dirty = !0, i && this.setFrame(i), this
						},
						setPosition: function(t, e) {
							return this.x = t, this.y = e, this
						},
						setFlipX: function(t) {
							return this.flipX = t, this
						},
						setFlipY: function(t) {
							return this.flipY = t, this
						},
						setFlip: function(t, e) {
							return this.flipX = t, this.flipY = e, this
						},
						setVisible: function(t) {
							return this.visible = t, this
						},
						setAlpha: function(t) {
							return this.alpha = t, this
						},
						setTint: function(t) {
							return this.tint = t, this
						},
						destroy: function() {
							this.parent.dirty = !0, this.parent.children.remove(this), this.parent = void 0, this.frame = void 0, this.data = void 0
						},
						visible: {
							get: function() {
								return this._visible
							},
							set: function(t) {
								this.parent.dirty |= this._visible !== t, this._visible = t
							}
						},
						alpha: {
							get: function() {
								return this._alpha
							},
							set: function(t) {
								this.parent.dirty |= 0 < this._alpha != 0 < t, this._alpha = t
							}
						}
					});
				t.exports = r
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(955), s = i(956);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					var r = e.list;
					if (0 !== r.length) {
						var o = e.localTransform;
						s ? (o.loadIdentity(), o.multiply(s), o.translate(e.x, e.y), o.rotate(e.rotation), o.scale(e.scaleX, e.scaleY)) : o.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY);
						var a = -1 !== e.blendMode;
						a || t.setBlendMode(0);
						for (var h = e.alpha, u = e.scrollFactorX, l = e.scrollFactorY, c = r, d = r.length, f = 0; f < d; f++) {
							var p, g, v, m, y, x, T, w, E = r[f];
							E.willRender(n) && (m = void 0 !== E.alphaTopLeft ? (p = E.alphaTopLeft, g = E.alphaTopRight, v = E.alphaBottomLeft, E.alphaBottomRight) : v = g = p = E.alpha, y = E.scrollFactorX, x = E.scrollFactorY, a || E.blendMode === t.currentBlendMode || t.setBlendMode(E.blendMode), (T = E.mask) && T.preRenderWebGL(t, E, n), (w = E.type) !== t.currentType && (t.newType = !0, t.currentType = w), t.nextTypeMatch = f < d - 1 && c[f + 1].type === t.currentType, E.setScrollFactor(y * u, x * l), E.setAlpha(p * h, g * h, v * h, m * h), E.renderWebGL(t, E, i, n, o), E.setAlpha(p, g, v, m), E.setScrollFactor(y, x), T && T.postRenderWebGL(t, n), t.newType = !1)
						}
					}
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					var r = e.list;
					if (0 !== r.length) {
						var o = e.localTransform;
						s ? (o.loadIdentity(), o.multiply(s), o.translate(e.x, e.y), o.rotate(e.rotation), o.scale(e.scaleX, e.scaleY)) : o.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY);
						var a = -1 !== e.blendMode;
						a || t.setBlendMode(0);
						var h = e._alpha,
							u = e.scrollFactorX,
							l = e.scrollFactorY;
						e.mask && e.mask.preRenderCanvas(t, null, n);
						for (var c = 0; c < r.length; c++) {
							var d, f, p, g = r[c];
							g.willRender(n) && (d = g.alpha, f = g.scrollFactorX, p = g.scrollFactorY, a || g.blendMode === t.currentBlendMode || t.setBlendMode(g.blendMode), g.setScrollFactor(f * u, p * l), g.setAlpha(d * h), g.renderCanvas(t, g, i, n, o), g.setAlpha(d), g.setScrollFactor(f, p))
						}
						e.mask && e.mask.postRenderCanvas(t)
					}
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(396), s = i(396);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e) {
				t.exports = ["normal", "multiply", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(960), s = i(961);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					var o = e.text,
						a = o.length;
					if (0 !== a) {
						var h = this.pipeline;
						t.setPipeline(h, e);
						var u = 0 < e.cropWidth || 0 < e.cropHeight;
						u && (h.flush(), t.pushScissor(e.x, e.y, e.cropWidth * e.scaleX, e.cropHeight * e.scaleY));
						var l = h._tempMatrix1,
							c = h._tempMatrix2,
							d = h._tempMatrix3,
							f = h._tempMatrix4;
						c.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), l.copyFrom(s.matrix), r ? (l.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), c.e = e.x, c.f = e.y) : (c.e -= s.scrollX * e.scrollFactorX, c.f -= s.scrollY * e.scrollFactorY), l.multiply(c, d);
						var p = e.frame,
							g = p.glTexture,
							v = p.cutX,
							m = p.cutY,
							y = g.width,
							x = g.height,
							T = e._isTinted && e.tintFill,
							w = n.getTintAppendFloatAlpha(e._tintTL, s.alpha * e._alphaTL),
							E = n.getTintAppendFloatAlpha(e._tintTR, s.alpha * e._alphaTR),
							_ = n.getTintAppendFloatAlpha(e._tintBL, s.alpha * e._alphaBL),
							b = n.getTintAppendFloatAlpha(e._tintBR, s.alpha * e._alphaBR);
						h.setTexture2D(g, 0);
						var A, S, C, M, O, P, R = 0,
							L = 0,
							D = 0,
							F = e.letterSpacing,
							k = e.scrollX,
							I = e.scrollY,
							B = e.fontData,
							Y = B.chars,
							N = B.lineHeight,
							X = e.fontSize / B.size,
							U = 0,
							z = e._align,
							G = 0,
							W = 0;
						e.getTextBounds(!1);
						var V = e._bounds.lines;
						1 === z ? W = (V.longest - V.lengths[0]) / 2 : 2 === z && (W = V.longest - V.lengths[0]);
						for (var H, j, K, q, J, Z, Q, $, tt, et, it, nt, st, rt, ot, at, ht, ut = s.roundPixels, lt = e.displayCallback, ct = e.callbackData, dt = 0; dt < a; dt++) 10 !== (A = o.charCodeAt(dt)) ? (ht = Y[A]) && (S = v + ht.x, C = m + ht.y, M = ht.width, O = ht.height, K = ht.xOffset + R - k, q = ht.yOffset + L - I, null !== P && (K += void 0 !== (H = ht.kerning[D]) ? H : 0), R += ht.xAdvance + F, P = ht, D = A, 0 !== M && 0 !== O && 32 !== A && (X = e.fontSize / e.fontData.size, U = 0, lt && (ct.color = 0, ct.tint.topLeft = w, ct.tint.topRight = E, ct.tint.bottomLeft = _, ct.tint.bottomRight = b, ct.index = dt, ct.charCode = A, ct.x = K, ct.y = q, ct.scale = X, ct.rotation = U, ct.data = ht.data, K = (j = lt(ct)).x, q = j.y, X = j.scale, U = j.rotation, b = j.color ? (w = j.color, E = j.color, _ = j.color, j.color) : (w = j.tint.topLeft, E = j.tint.topRight, _ = j.tint.bottomLeft, j.tint.bottomRight), w = n.getTintAppendFloatAlpha(w, s.alpha * e._alphaTL), E = n.getTintAppendFloatAlpha(E, s.alpha * e._alphaTR), _ = n.getTintAppendFloatAlpha(_, s.alpha * e._alphaBL), b = n.getTintAppendFloatAlpha(b, s.alpha * e._alphaBR)), K *= X, q *= X, K -= e.displayOriginX, q -= e.displayOriginY, K += W, f.applyITRS(K, q, U, X, X), d.multiply(f, c), J = S / y, Z = C / x, Q = (S + M) / y, $ = (C + O) / x, tt = c.e, et = c.f, it = O * c.c + c.e, nt = O * c.d + c.f, st = M * c.a + O * c.c + c.e, rt = M * c.b + O * c.d + c.f, ot = M * c.a + c.e, at = M * c.b + c.f, ut && (tt = Math.round(tt), et = Math.round(et), it = Math.round(it), nt = Math.round(nt), st = Math.round(st), rt = Math.round(rt), ot = Math.round(ot), at = Math.round(at)), h.batchQuad(tt, et, it, nt, st, rt, ot, at, J, Z, Q, $, w, E, _, b, T, g, 0))) : (G++, 1 === z ? W = (V.longest - V.lengths[G]) / 2 : 2 === z && (W = V.longest - V.lengths[G]), R = 0, L += N, P = null);
						u && (h.flush(), t.popScissor())
					}
				}
			}, function(t, e, i) {
				var n = i(28);
				t.exports = function(t, e, i, s, r) {
					var o = e._text,
						a = o.length,
						h = t.currentContext;
					if (0 !== a && n(t, h, e, s, r)) {
						var u, l = e.frame,
							c = e.displayCallback,
							d = e.callbackData,
							f = e.fontData.chars,
							p = e.fontData.lineHeight,
							g = e._letterSpacing,
							v = 0,
							m = 0,
							y = null,
							x = 0,
							T = 0,
							w = 0,
							E = 0,
							_ = 0,
							b = 0,
							A = null,
							S = 0,
							C = e.frame.source.image,
							M = l.cutX,
							O = l.cutY,
							P = 0,
							R = 0,
							L = e._fontSize / e.fontData.size,
							D = e._align,
							F = 0,
							k = 0;
						e.getTextBounds(!1);
						var I = e._bounds.lines;
						1 === D ? k = (I.longest - I.lengths[0]) / 2 : 2 === D && (k = I.longest - I.lengths[0]), h.translate(-e.displayOriginX, -e.displayOriginY);
						var B = s.roundPixels;
						0 < e.cropWidth && 0 < e.cropHeight && (h.beginPath(), h.rect(0, 0, e.cropWidth, e.cropHeight), h.clip());
						for (var Y, N, X = 0; X < a; X++) R = L, P = 0, 10 !== (u = o.charCodeAt(X)) ? (y = f[u]) && (x = M + y.x, T = O + y.y, w = y.width, E = y.height, _ = y.xOffset + v - e.scrollX, b = y.yOffset + m - e.scrollY, null !== A && (_ += void 0 !== (Y = y.kerning[S]) ? Y : 0), c && (d.index = X, d.charCode = u, d.x = _, d.y = b, d.scale = R, d.rotation = P, d.data = y.data, _ = (N = c(d)).x, b = N.y, R = N.scale, P = N.rotation), _ *= R, b *= R, _ += k, v += y.xAdvance + g, A = y, S = u, 0 !== w && 0 !== E && 32 !== u && (B && (_ = Math.round(_), b = Math.round(b)), h.save(), h.translate(_, b), h.rotate(P), h.scale(R, R), h.drawImage(C, x, T, w, E, 0, 0, w, E), h.restore())) : (F++, 1 === D ? k = (I.longest - I.lengths[F]) / 2 : 2 === D && (k = I.longest - I.lengths[F]), v = 0, m += p, A = null);
						h.restore()
					}
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(963), s = i(964);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					var r = t.currentPipeline;
					t.clearPipeline();
					var o = t._tempMatrix1,
						a = t._tempMatrix2,
						h = t._tempMatrix3;
					a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h), e.render.call(e, t, n, h), t.rebindPipeline(r)
				}
			}, function(t, e) {}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(966), i(401);
				s = i(401), t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				function n(t, e, i) {
					this.x = t, this.y = e, this.width = i
				}

				function s(t, e, i) {
					this.points = [], this.pointsLength = 1, this.points[0] = new n(t, e, i)
				}
				var r = i(192),
					o = i(9),
					a = [];
				t.exports = function(t, e, i, h, u) {
					if (0 !== e.commandBuffer.length) {
						var l = this.pipeline;
						t.setPipeline(l, e);
						var c = e._tempMatrix1,
							d = e._tempMatrix2,
							f = e._tempMatrix3;
						f.loadIdentity(), d.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), c.copyFrom(h.matrix), u ? (c.multiplyWithOffset(u, -h.scrollX * e.scrollFactorX, -h.scrollY * e.scrollFactorY), d.e = e.x, d.f = e.y) : (d.e -= h.scrollX * e.scrollFactorX, d.f -= h.scrollY * e.scrollFactorY), c.multiply(d);
						for (var p = e.commandBuffer, g = h.alpha * e.alpha, v = 1, m = l.fillTint, y = l.strokeTint, x = 0, T = 0, w = 0, E = 2 * Math.PI, _ = [], b = 0, A = !1, S = null, C = o.getTintAppendFloatAlphaAndSwap, M = t.blankTexture.glTexture, O = 0; O < p.length; O++) switch (p[O]) {
							case r.BEGIN_PATH:
								_.length = 0, A = !(S = null);
								break;
							case r.CLOSE_PATH:
								A = !1, S && S.points.length && S.points.push(S.points[0]);
								break;
							case r.FILL_PATH:
								for (b = 0; b < _.length; b++) l.setTexture2D(M), l.batchFillPath(_[b].points, f, c);
								break;
							case r.STROKE_PATH:
								for (b = 0; b < _.length; b++) l.setTexture2D(M), l.batchStrokePath(_[b].points, v, A, f, c);
								break;
							case r.LINE_STYLE:
								v = p[++O];
								var P = C(p[++O], p[++O] * g);
								y.TL = P, y.TR = P, y.BL = P, y.BR = P;
								break;
							case r.FILL_STYLE:
								var R = C(p[++O], p[++O] * g);
								m.TL = R, m.TR = R, m.BL = R, m.BR = R;
								break;
							case r.GRADIENT_FILL_STYLE:
								var L = p[++O] * g;
								m.TL = C(p[++O], L), m.TR = C(p[++O], L), m.BL = C(p[++O], L), m.BR = C(p[++O], L);
								break;
							case r.GRADIENT_LINE_STYLE:
								v = p[++O];
								var D = p[++O] * g;
								y.TL = C(p[++O], D), y.TR = C(p[++O], D), y.BL = C(p[++O], D), y.BR = C(p[++O], D);
								break;
							case r.ARC:
								var F = 0,
									k = p[++O],
									I = p[++O],
									B = p[++O],
									Y = p[++O],
									N = p[++O],
									X = p[++O],
									U = p[++O];
								for (N -= Y, X ? N < -E ? N = -E : 0 < N && (N = N % E - E) : E < N ? N = E : N < 0 && (N = E + N % E), null === S && (S = new s(k + Math.cos(Y) * B, I + Math.sin(Y) * B, v), _.push(S), F += .01); F < 1 + U;) w = N * F + Y, x = k + Math.cos(w) * B, T = I + Math.sin(w) * B, S.points.push(new n(x, T, v)), F += .01;
								w = N + Y, x = k + Math.cos(w) * B, T = I + Math.sin(w) * B, S.points.push(new n(x, T, v));
								break;
							case r.FILL_RECT:
								l.setTexture2D(M), l.batchFillRect(p[++O], p[++O], p[++O], p[++O], f, c);
								break;
							case r.FILL_TRIANGLE:
								l.setTexture2D(M), l.batchFillTriangle(p[++O], p[++O], p[++O], p[++O], p[++O], p[++O], f, c);
								break;
							case r.STROKE_TRIANGLE:
								l.setTexture2D(M), l.batchStrokeTriangle(p[++O], p[++O], p[++O], p[++O], p[++O], p[++O], v, f, c);
								break;
							case r.LINE_TO:
								null !== S ? S.points.push(new n(p[++O], p[++O], v)) : (S = new s(p[++O], p[++O], v), _.push(S));
								break;
							case r.MOVE_TO:
								S = new s(p[++O], p[++O], v), _.push(S);
								break;
							case r.SAVE:
								a.push(f.copyToArray());
								break;
							case r.RESTORE:
								f.copyFromArray(a.pop());
								break;
							case r.TRANSLATE:
								k = p[++O], I = p[++O], f.translate(k, I);
								break;
							case r.SCALE:
								k = p[++O], I = p[++O], f.scale(k, I);
								break;
							case r.ROTATE:
								f.rotate(p[++O]);
								break;
							case r.SET_TEXTURE:
								var z = p[++O],
									G = p[++O];
								l.currentFrame = z, l.setTexture2D(z.glTexture, 0), l.tintEffect = G, M = z.glTexture;
								break;
							case r.CLEAR_TEXTURE:
								l.currentFrame = t.blankTexture, l.tintEffect = 2, M = t.blankTexture.glTexture
						}
					}
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(968), s = i(969);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					this.pipeline.batchSprite(e, n, s)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					t.batchSprite(e, e.frame, n, s)
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(971), s = i(972);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					this.pipeline.batchSprite(e, n, s)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					t.batchSprite(e, e.frame, n, s)
				}
			}, function(t, e, i) {
				t.exports = {
					GravityWell: i(402),
					Particle: i(403),
					ParticleEmitter: i(404),
					ParticleEmitterManager: i(194),
					Zones: i(978)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(119),
					r = i(69),
					o = i(2),
					a = i(58),
					h = new n({
						initialize: function(t, e, i, n) {
							void 0 === n && (n = !1), this.propertyKey = e, this.propertyValue = i, this.defaultValue = i, this.steps = 0, this.counter = 0, this.start = 0, this.end = 0, this.ease, this.emitOnly = n, this.onEmit = this.defaultEmit, this.onUpdate = this.defaultUpdate, this.loadConfig(t)
						},
						loadConfig: function(t, e) {
							void 0 === t && (t = {}), e && (this.propertyKey = e), this.propertyValue = o(t, this.propertyKey, this.defaultValue), this.setMethods(), this.emitOnly && (this.onUpdate = this.defaultUpdate)
						},
						toJSON: function() {
							return this.propertyValue
						},
						onChange: function(t) {
							return this.propertyValue = t, this.setMethods()
						},
						setMethods: function() {
							var t, e, i, n = this.propertyValue,
								s = typeof n;
							return "number" == s ? (this.onEmit = this.staticValueEmit, this.onUpdate = this.staticValueUpdate) : Array.isArray(n) ? this.onEmit = this.randomStaticValueEmit : "function" == s ? this.emitOnly ? this.onEmit = n : this.onUpdate = n : "object" == s && (this.has(n, "random") || this.hasBoth(n, "start", "end") || this.hasBoth(n, "min", "max")) ? (this.start = this.has(n, "start") ? n.start : n.min, this.end = this.has(n, "end") ? n.end : n.max, (t = this.hasBoth(n, "min", "max") || !!n.random) && (e = n.random, Array.isArray(e) && (this.start = e[0], this.end = e[1]), this.onEmit = this.randomRangedValueEmit), this.has(n, "steps") ? (this.steps = n.steps, this.counter = this.start, this.onEmit = this.steppedEmit) : (i = this.has(n, "ease") ? n.ease : "Linear", this.ease = r(i), t || (this.onEmit = this.easedValueEmit), this.onUpdate = this.easeValueUpdate)) : "object" == s && this.hasEither(n, "onEmit", "onUpdate") && (this.has(n, "onEmit") && (this.onEmit = n.onEmit), this.has(n, "onUpdate") && (this.onUpdate = n.onUpdate)), this
						},
						has: function(t, e) {
							return t.hasOwnProperty(e)
						},
						hasBoth: function(t, e, i) {
							return t.hasOwnProperty(e) && t.hasOwnProperty(i)
						},
						hasEither: function(t, e, i) {
							return t.hasOwnProperty(e) || t.hasOwnProperty(i)
						},
						defaultEmit: function(t, e, i) {
							return i
						},
						defaultUpdate: function(t, e, i, n) {
							return n
						},
						staticValueEmit: function() {
							return this.propertyValue
						},
						staticValueUpdate: function() {
							return this.propertyValue
						},
						randomStaticValueEmit: function() {
							var t = Math.floor(Math.random() * this.propertyValue.length);
							return this.propertyValue[t]
						},
						randomRangedValueEmit: function(t, e) {
							var i = s(this.start, this.end);
							return t && t.data[e] && (t.data[e].min = i), i
						},
						steppedEmit: function() {
							var t = this.counter,
								e = this.counter + (this.end - this.start) / this.steps;
							return this.counter = a(e, this.start, this.end), t
						},
						easedValueEmit: function(t, e) {
							var i;
							return t && t.data[e] && ((i = t.data[e]).min = this.start, i.max = this.end), this.start
						},
						easeValueUpdate: function(t, e, i) {
							var n = t.data[e];
							return (n.max - n.min) * this.ease(i) + n.min
						}
					});
				t.exports = h
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(976), s = i(977);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					var o = e.emitters.list,
						a = o.length;
					if (0 !== a) {
						var h = this.pipeline,
							u = h._tempMatrix1.copyFrom(s.matrix),
							l = h._tempMatrix2,
							c = h._tempMatrix3,
							d = h._tempMatrix4.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY);
						u.multiply(d), t.setPipeline(h);
						var f = s.roundPixels,
							p = e.defaultFrame.glTexture,
							g = n.getTintAppendFloatAlphaAndSwap;
						h.setTexture2D(p, 0);
						for (var v = 0; v < a; v++) {
							var m = o[v],
								y = m.alive,
								x = y.length;
							if (m.visible && 0 !== x) {
								var T = s.scrollX * m.scrollFactorX,
									w = s.scrollY * m.scrollFactorY;
								r && (u.multiplyWithOffset(r, -T, -w), w = T = 0), t.setBlendMode(m.blendMode) && h.setTexture2D(p, 0), m.mask && (m.mask.preRenderWebGL(t, m, s), h.setTexture2D(p, 0));
								for (var E = 0; E < x; E++) {
									var _, b, A, S, C, M, O, P, R, L, D, F, k, I, B = y[E],
										Y = B.alpha * s.alpha;
									Y <= 0 || (b = -(_ = B.frame).halfWidth, A = -_.halfHeight, S = b + _.width, C = A + _.height, c.applyITRS(0, 0, B.rotation, B.scaleX, B.scaleY), c.e = B.x - T, c.f = B.y - w, u.multiply(c, l), M = l.getX(b, A), O = l.getY(b, A), P = l.getX(b, C), R = l.getY(b, C), L = l.getX(S, C), D = l.getY(S, C), F = l.getX(S, A), k = l.getY(S, A), f && (M = Math.round(M), O = Math.round(O), P = Math.round(P), R = Math.round(R), L = Math.round(L), D = Math.round(D), F = Math.round(F), k = Math.round(k)), I = g(B.tint, Y), h.batchQuad(M, O, P, R, L, D, F, k, _.u0, _.v0, _.u1, _.v1, I, I, I, I, 0, p, 0))
								}
								m.mask && (m.mask.postRenderWebGL(t, s), h.setTexture2D(p, 0))
							}
						}
					}
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					var r = e.emitters.list,
						o = r.length;
					if (0 !== o) {
						var a = t._tempMatrix1.copyFrom(n.matrix),
							h = t._tempMatrix2,
							u = t._tempMatrix3,
							l = t._tempMatrix4.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY);
						a.multiply(l);
						var c = n.roundPixels,
							d = t.currentContext;
						d.save();
						for (var f = 0; f < o; f++) {
							var p = r[f],
								g = p.alive,
								v = g.length;
							if (p.visible && 0 !== v) {
								var m = n.scrollX * p.scrollFactorX,
									y = n.scrollY * p.scrollFactorY;
								s && (a.multiplyWithOffset(s, -m, -y), y = m = 0), d.globalCompositeOperation = t.blendModes[p.blendMode];
								for (var x = 0; x < v; x++) {
									var T, w, E, _, b = g[x],
										A = b.alpha * n.alpha;
									A <= 0 || (w = (T = b.frame).canvasData, E = -T.halfWidth, _ = -T.halfHeight, u.applyITRS(0, 0, b.rotation, b.scaleX, b.scaleY), u.e = b.x - m, u.f = b.y - y, a.multiply(u, h), d.globalAlpha = A, d.save(), h.copyToContext(d), c && (E = Math.round(E), _ = Math.round(_)), d.imageSmoothingEnabled = !(!t.antialias || T.source.scaleMode), d.drawImage(T.source.image, w.x, w.y, w.width, w.height, E, _, w.width, w.height), d.restore())
								}
							}
						}
						d.restore()
					}
				}
			}, function(t, e, i) {
				t.exports = {
					DeathZone: i(405),
					EdgeZone: i(406),
					RandomZone: i(408)
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(980), s = i(981);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					var o = e.frame,
						a = o.width,
						h = o.height,
						u = n.getTintAppendFloatAlpha;
					this.pipeline.batchTexture(e, o.glTexture, a, h, e.x, e.y, a, h, e.scaleX, e.scaleY, e.rotation, e.flipX, !e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, a, h, u(e._tintTL, s.alpha * e._alphaTL), u(e._tintTR, s.alpha * e._alphaTR), u(e._tintBL, s.alpha * e._alphaBL), u(e._tintBR, s.alpha * e._alphaBR), e._isTinted && e.tintFill, 0, 0, s, r), t.setBlankTexture(!0)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					t.batchSprite(e, e.frame, n, s)
				}
			}, function(t, e, i) {
				var n = i(983),
					s = i(18)(!1, s = {
						Parse: i(984)
					}, n);
				t.exports = s
			}, function(t, e) {
				t.exports = {
					TEXT_SET1: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
					TEXT_SET2: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ",
					TEXT_SET3: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ",
					TEXT_SET4: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789",
					TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789",
					TEXT_SET6: "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ",
					TEXT_SET7: "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39",
					TEXT_SET8: "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ",
					TEXT_SET9: "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!",
					TEXT_SET10: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
					TEXT_SET11: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789"
				}
			}, function(t, e, i) {
				var n = i(6);
				t.exports = function(t, e) {
					var i = e.width,
						s = e.height,
						r = Math.floor(i / 2),
						o = Math.floor(s / 2),
						a = n(e, "chars", "");
					if ("" !== a) {
						var h = n(e, "image", ""),
							u = n(e, "offset.x", 0),
							l = n(e, "offset.y", 0),
							c = n(e, "spacing.x", 0),
							d = n(e, "spacing.y", 0),
							f = n(e, "lineSpacing", 0),
							p = n(e, "charsPerRow", null);
						null === p && (p = t.sys.textures.getFrame(h).width / i) > a.length && (p = a.length);
						for (var g = u, v = l, m = {
								retroFont: !0,
								font: h,
								size: i,
								lineHeight: s + f,
								chars: {}
							}, y = 0, x = 0; x < a.length; x++) {
							var T = a.charCodeAt(x);
							m.chars[T] = {
								x: g,
								y: v,
								width: i,
								height: s,
								centerX: r,
								centerY: o,
								xOffset: 0,
								yOffset: 0,
								xAdvance: i,
								data: {},
								kerning: {}
							}, ++y === p ? (y = 0, g = u, v += s + d) : g += i + c
						}
						return {
							data: m,
							frame: null,
							texture: h
						}
					}
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(986), s = i(987);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					var o = e.pipeline;
					t.setPipeline(o, e);
					var a = o._tempMatrix1,
						h = o._tempMatrix2,
						u = o._tempMatrix3;
					h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY), a.multiply(h, u);
					var l = e.frame.glTexture,
						c = e.vertices,
						d = e.uv,
						f = e.colors,
						p = e.alphas,
						g = e.alpha,
						v = n.getTintAppendFloatAlphaAndSwap,
						m = s.roundPixels,
						y = c.length,
						x = Math.floor(.5 * y);
					o.flush(), o.setTexture2D(l, 0);
					var T = o.vertexViewF32,
						w = o.vertexViewU32,
						E = o.vertexCount * o.vertexComponentCount - 1,
						_ = 0,
						b = e.tintFill;
					e.dirty && e.updateVertices();
					for (var A = e.debugCallback, S = [], C = 0; C < y; C += 2) {
						var M = c[C + 0],
							O = c[C + 1],
							P = M * u.a + O * u.c + u.e,
							R = M * u.b + O * u.d + u.f;
						m && (P = Math.round(P), R = Math.round(R)), T[++E] = P, T[++E] = R, T[++E] = d[C + 0], T[++E] = d[C + 1], T[++E] = b, w[++E] = v(f[_], s.alpha * (p[_] * g)), _++, A && (S[C + 0] = P, S[C + 1] = R)
					}
					A && A.call(e, e, y, S), o.vertexCount += x
				}
			}, function(t, e) {
				t.exports = function() {}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					var n = t.canvas,
						s = t.context,
						r = t.style,
						o = [],
						a = 0,
						h = i.length;
					0 < r.maxLines && r.maxLines < i.length && (h = r.maxLines), r.syncFont(n, s);
					for (var u = 0; u < h; u++) {
						var l = r.strokeThickness;
						l += s.measureText(i[u]).width, r.wordWrap && (l -= s.measureText(" ").width), o[u] = Math.ceil(l), a = Math.max(a, o[u])
					}
					var c = e.fontSize + r.strokeThickness,
						d = c * h,
						f = t.lineSpacing;
					return 1 < h && (d += f * (h - 1)), {
						width: a,
						height: d,
						lines: h,
						lineWidths: o,
						lineSpacing: f,
						lineHeight: c
					}
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(990), s = i(991);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					var o, a, h, u;
					0 !== e.width && 0 !== e.height && (a = (o = e.frame).width, h = o.height, u = n.getTintAppendFloatAlpha, this.pipeline.batchTexture(e, o.glTexture, a, h, e.x, e.y, a / e.style.resolution, h / e.style.resolution, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, a, h, u(e._tintTL, s.alpha * e._alphaTL), u(e._tintTR, s.alpha * e._alphaTR), u(e._tintBL, s.alpha * e._alphaBL), u(e._tintBR, s.alpha * e._alphaBR), e._isTinted && e.tintFill, 0, 0, s, r))
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					0 !== e.width && 0 !== e.height && t.batchSprite(e, e.frame, n, s)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(15),
					r = i(6),
					o = i(993),
					a = {
						fontFamily: ["fontFamily", "Courier"],
						fontSize: ["fontSize", "16px"],
						fontStyle: ["fontStyle", ""],
						backgroundColor: ["backgroundColor", null],
						color: ["color", "#fff"],
						stroke: ["stroke", "#fff"],
						strokeThickness: ["strokeThickness", 0],
						shadowOffsetX: ["shadow.offsetX", 0],
						shadowOffsetY: ["shadow.offsetY", 0],
						shadowColor: ["shadow.color", "#000"],
						shadowBlur: ["shadow.blur", 0],
						shadowStroke: ["shadow.stroke", !1],
						shadowFill: ["shadow.fill", !1],
						align: ["align", "left"],
						maxLines: ["maxLines", 0],
						fixedWidth: ["fixedWidth", 0],
						fixedHeight: ["fixedHeight", 0],
						resolution: ["resolution", 0],
						rtl: ["rtl", !1],
						testString: ["testString", "|MÃƒâ€°qgy"],
						baselineX: ["baselineX", 1.2],
						baselineY: ["baselineY", 1.4],
						wordWrapWidth: ["wordWrap.width", null],
						wordWrapCallback: ["wordWrap.callback", null],
						wordWrapCallbackScope: ["wordWrap.callbackScope", null],
						wordWrapUseAdvanced: ["wordWrap.useAdvancedWrap", !1]
					},
					h = new n({
						initialize: function(t, e) {
							this.parent = t, this.fontFamily, this.fontSize, this.fontStyle, this.backgroundColor, this.color, this.stroke, this.strokeThickness, this.shadowOffsetX, this.shadowOffsetY, this.shadowColor, this.shadowBlur, this.shadowStroke, this.shadowFill, this.align, this.maxLines, this.fixedWidth, this.fixedHeight, this.resolution, this.rtl, this.testString, this.baselineX, this.baselineY, this.wordWrapWidth, this.wordWrapCallback, this.wordWrapCallbackScope, this.wordWrapUseAdvanced, this._font, this.setStyle(e, !1, !0);
							var i = r(e, "metrics", !1);
							this.metrics = i ? {
								ascent: r(i, "ascent", 0),
								descent: r(i, "descent", 0),
								fontSize: r(i, "fontSize", 0)
							} : o(this)
						},
						setStyle: function(t, e, i) {
							for (var n in void 0 === e && (e = !0), void 0 === i && (i = !1), t && t.hasOwnProperty("fontSize") && "number" == typeof t.fontSize && (t.fontSize = t.fontSize.toString() + "px"), a) {
								var o = i ? a[n][1] : this[n];
								this[n] = ("wordWrapCallback" === n || "wordWrapCallbackScope" === n ? r : s)(t, a[n][0], o)
							}
							var h = r(t, "font", null);
							null !== h && this.setFont(h, !1), this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
							var u = r(t, "fill", null);
							return null !== u && (this.color = u), e ? this.update(!0) : this.parent
						},
						syncFont: function(t, e) {
							e.font = this._font
						},
						syncStyle: function(t, e) {
							e.textBaseline = "alphabetic", e.fillStyle = this.color, e.strokeStyle = this.stroke, e.lineWidth = this.strokeThickness, e.lineCap = "round", e.lineJoin = "round"
						},
						syncShadow: function(t, e) {
							e ? (t.shadowOffsetX = this.shadowOffsetX, t.shadowOffsetY = this.shadowOffsetY, t.shadowColor = this.shadowColor, t.shadowBlur = this.shadowBlur) : (t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowColor = 0, t.shadowBlur = 0)
						},
						update: function(t) {
							return t && (this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim(), this.metrics = o(this)), this.parent.updateText()
						},
						setFont: function(t, e) {
							void 0 === e && (e = !0);
							var i, n, s = t,
								o = "",
								a = "";
							return "string" != typeof t ? (s = r(t, "fontFamily", "Courier"), o = r(t, "fontSize", "16px"), a = r(t, "fontStyle", "")) : (n = 0, a = 2 < (i = t.split(" ")).length ? i[n++] : "", o = i[n++] || "16px", s = i[n++] || "Courier"), s === this.fontFamily && o === this.fontSize && a === this.fontStyle || (this.fontFamily = s, this.fontSize = o, this.fontStyle = a, e && this.update(!0)), this.parent
						},
						setFontFamily: function(t) {
							return this.fontFamily !== t && (this.fontFamily = t, this.update(!0)), this.parent
						},
						setFontStyle: function(t) {
							return this.fontStyle !== t && (this.fontStyle = t, this.update(!0)), this.parent
						},
						setFontSize: function(t) {
							return "number" == typeof t && (t = t.toString() + "px"), this.fontSize !== t && (this.fontSize = t, this.update(!0)), this.parent
						},
						setTestString: function(t) {
							return this.testString = t, this.update(!0)
						},
						setFixedSize: function(t, e) {
							return this.fixedWidth = t, this.fixedHeight = e, t && (this.parent.width = t), e && (this.parent.height = e), this.update(!1)
						},
						setBackgroundColor: function(t) {
							return this.backgroundColor = t, this.update(!1)
						},
						setFill: function(t) {
							return this.color = t, this.update(!1)
						},
						setColor: function(t) {
							return this.color = t, this.update(!1)
						},
						setResolution: function(t) {
							return this.resolution = t, this.update(!1)
						},
						setStroke: function(t, e) {
							return void 0 === e && (e = this.strokeThickness), void 0 === t && 0 !== this.strokeThickness ? (this.strokeThickness = 0, this.update(!0)) : this.stroke === t && this.strokeThickness === e || (this.stroke = t, this.strokeThickness = e, this.update(!0)), this.parent
						},
						setShadow: function(t, e, i, n, s, r) {
							return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "#000"), void 0 === n && (n = 0), void 0 === s && (s = !1), void 0 === r && (r = !0), this.shadowOffsetX = t, this.shadowOffsetY = e, this.shadowColor = i, this.shadowBlur = n, this.shadowStroke = s, this.shadowFill = r, this.update(!1)
						},
						setShadowOffset: function(t, e) {
							return void 0 === t && (t = 0), void 0 === e && (e = t), this.shadowOffsetX = t, this.shadowOffsetY = e, this.update(!1)
						},
						setShadowColor: function(t) {
							return void 0 === t && (t = "#000"), this.shadowColor = t, this.update(!1)
						},
						setShadowBlur: function(t) {
							return void 0 === t && (t = 0), this.shadowBlur = t, this.update(!1)
						},
						setShadowStroke: function(t) {
							return this.shadowStroke = t, this.update(!1)
						},
						setShadowFill: function(t) {
							return this.shadowFill = t, this.update(!1)
						},
						setWordWrapWidth: function(t, e) {
							return void 0 === e && (e = !1), this.wordWrapWidth = t, this.wordWrapUseAdvanced = e, this.update(!1)
						},
						setWordWrapCallback: function(t, e) {
							return void 0 === e && (e = null), this.wordWrapCallback = t, this.wordWrapCallbackScope = e, this.update(!1)
						},
						setAlign: function(t) {
							return void 0 === t && (t = "left"), this.align = t, this.update(!1)
						},
						setMaxLines: function(t) {
							return void 0 === t && (t = 0), this.maxLines = t, this.update(!1)
						},
						getTextMetrics: function() {
							var t = this.metrics;
							return {
								ascent: t.ascent,
								descent: t.descent,
								fontSize: t.fontSize
							}
						},
						toJSON: function() {
							var t = {};
							for (var e in a) t[e] = this[e];
							return t.metrics = this.getTextMetrics(), t
						},
						destroy: function() {
							this.parent = void 0
						}
					});
				t.exports = h
			}, function(t, e, i) {
				var n = i(26);
				t.exports = function(t) {
					var e = n.create(this),
						i = e.getContext("2d");
					t.syncFont(e, i);
					var s = Math.ceil(i.measureText(t.testString).width * t.baselineX),
						r = 2 * (o = s),
						o = o * t.baselineY | 0;
					e.width = s, e.height = r, i.fillStyle = "#f00", i.fillRect(0, 0, s, r), i.font = t._font, i.textBaseline = "alphabetic", i.fillStyle = "#000", i.fillText(t.testString, 0, o);
					var a = {
						ascent: 0,
						descent: 0,
						fontSize: 0
					};
					if (!i.getImageData(0, 0, s, r)) return a.ascent = o, a.descent = 6 + o, a.fontSize = a.ascent + a.descent, n.remove(e), a;
					for (var h, u = i.getImageData(0, 0, s, r).data, l = u.length, c = 4 * s, d = 0, f = !1, p = 0; p < o; p++) {
						for (h = 0; h < c; h += 4)
							if (255 !== u[d + h]) {
								f = !0;
								break
							} if (f) break;
						d += c
					}
					for (a.ascent = o - p, d = l - c, f = !1, p = r; o < p; p--) {
						for (h = 0; h < c; h += 4)
							if (255 !== u[d + h]) {
								f = !0;
								break
							} if (f) break;
						d -= c
					}
					return a.descent = p - o, a.fontSize = a.ascent + a.descent, n.remove(e), a
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(995), s = i(996);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					e.updateCanvas();
					var o = n.getTintAppendFloatAlpha;
					this.pipeline.batchTexture(e, e.fillPattern, e.displayFrame.width * e.tileScaleX, e.displayFrame.height * e.tileScaleY, e.x, e.y, e.width, e.height, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.originX * e.width, e.originY * e.height, 0, 0, e.width, e.height, o(e._tintTL, s.alpha * e._alphaTL), o(e._tintTR, s.alpha * e._alphaTR), o(e._tintBL, s.alpha * e._alphaBL), o(e._tintBR, s.alpha * e._alphaBR), e._isTinted && e.tintFill, e.tilePositionX % e.displayFrame.width / e.displayFrame.width, e.tilePositionY % e.displayFrame.height / e.displayFrame.height, s, r)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					e.updateCanvas(), t.batchSprite(e, e.frame, n, s)
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(998), s = i(999);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					e.videoTexture && this.pipeline.batchSprite(e, n, s)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					e.videoTexture && t.batchSprite(e, e.frame, n, s)
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1001), s = i(1002);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(98),
					s = i(70);
				t.exports = function(t, e, i, r, o) {
					var a = this.pipeline,
						h = a._tempMatrix1,
						u = a._tempMatrix2,
						l = a._tempMatrix3;
					t.setPipeline(a), u.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), u.e = e.x, u.f = e.y) : (u.e -= r.scrollX * e.scrollFactorX, u.f -= r.scrollY * e.scrollFactorY), h.multiply(u, l);
					var c = e._displayOriginX,
						d = e._displayOriginY,
						f = r.alpha * e.alpha;
					e.isFilled && n(a, l, e, f, c, d), e.isStroked && s(a, e, f, c, d)
				}
			}, function(t, e, i) {
				var n = i(39),
					s = i(41),
					r = i(49),
					o = i(28);
				t.exports = function(t, e, i, a, h) {
					var u, l = t.currentContext;
					o(t, l, e, a, h) && (u = e.radius, l.beginPath(), l.arc(u - e.originX * (2 * u), u - e.originY * (2 * u), u, n(e._startAngle), n(e._endAngle), e.anticlockwise), e.closePath && l.closePath(), e.isFilled && (s(l, e), l.fill()), e.isStroked && (r(l, e), l.stroke()), l.restore())
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1004), s = i(1005);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(98),
					s = i(70);
				t.exports = function(t, e, i, r, o) {
					var a = this.pipeline,
						h = a._tempMatrix1,
						u = a._tempMatrix2,
						l = a._tempMatrix3;
					t.setPipeline(a), u.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), u.e = e.x, u.f = e.y) : (u.e -= r.scrollX * e.scrollFactorX, u.f -= r.scrollY * e.scrollFactorY), h.multiply(u, l);
					var c = e._displayOriginX + e._curveBounds.x,
						d = e._displayOriginY + e._curveBounds.y,
						f = r.alpha * e.alpha;
					e.isFilled && n(a, l, e, f, c, d), e.isStroked && s(a, e, f, c, d)
				}
			}, function(t, e, i) {
				var n = i(41),
					s = i(49),
					r = i(28);
				t.exports = function(t, e, i, o, a) {
					var h = t.currentContext;
					if (r(t, h, e, o, a)) {
						var u = e._displayOriginX + e._curveBounds.x,
							l = e._displayOriginY + e._curveBounds.y,
							c = e.pathData,
							d = c.length - 1,
							f = c[0] - u,
							p = c[1] - l;
						h.beginPath(), h.moveTo(f, p), e.closePath || (d -= 2);
						for (var g = 2; g < d; g += 2) {
							var v = c[g] - u,
								m = c[g + 1] - l;
							h.lineTo(v, m)
						}
						e.closePath && h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()), h.restore()
					}
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1007), s = i(1008);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(98),
					s = i(70);
				t.exports = function(t, e, i, r, o) {
					var a = this.pipeline,
						h = a._tempMatrix1,
						u = a._tempMatrix2,
						l = a._tempMatrix3;
					t.setPipeline(a), u.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), u.e = e.x, u.f = e.y) : (u.e -= r.scrollX * e.scrollFactorX, u.f -= r.scrollY * e.scrollFactorY), h.multiply(u, l);
					var c = e._displayOriginX,
						d = e._displayOriginY,
						f = r.alpha * e.alpha;
					e.isFilled && n(a, l, e, f, c, d), e.isStroked && s(a, e, f, c, d)
				}
			}, function(t, e, i) {
				var n = i(41),
					s = i(49),
					r = i(28);
				t.exports = function(t, e, i, o, a) {
					var h = t.currentContext;
					if (r(t, h, e, o, a)) {
						var u = e._displayOriginX,
							l = e._displayOriginY,
							c = e.pathData,
							d = c.length - 1,
							f = c[0] - u,
							p = c[1] - l;
						h.beginPath(), h.moveTo(f, p), e.closePath || (d -= 2);
						for (var g = 2; g < d; g += 2) {
							var v = c[g] - u,
								m = c[g + 1] - l;
							h.lineTo(v, m)
						}
						h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()), h.restore()
					}
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1010), s = i(1011);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					var o = this.pipeline,
						a = o._tempMatrix1,
						h = o._tempMatrix2,
						u = o._tempMatrix3;
					t.setPipeline(o), h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY), a.multiply(h, u), u.translate(-e._displayOriginX, -e._displayOriginY);
					var l, c, d = s.alpha * e.alpha,
						f = e.width,
						p = e.height,
						g = e.cellWidth,
						v = e.cellHeight,
						m = Math.ceil(f / g),
						y = Math.ceil(p / v),
						x = g,
						T = v,
						w = g - (m * g - f),
						E = v - (y * v - p),
						_ = e.showCells,
						b = e.showAltCells,
						A = e.showOutline,
						S = 0,
						C = 0,
						M = 0,
						O = 0,
						P = 0;
					if (A && (x--, T--, w === g && w--, E === v && E--), _ && 0 < e.fillAlpha)
						for (l = o.fillTint, c = n.getTintAppendFloatAlphaAndSwap(e.fillColor, e.fillAlpha * d), l.TL = c, l.TR = c, l.BL = c, l.BR = c, C = 0; C < y; C++)
							for (b && (M = C % 2), S = 0; S < m; S++) b && M ? M = 0 : (M++, O = S < m - 1 ? x : w, P = C < y - 1 ? T : E, o.setTexture2D(), o.batchFillRect(S * g, C * v, O, P));
					if (b && 0 < e.altFillAlpha)
						for (l = o.fillTint, c = n.getTintAppendFloatAlphaAndSwap(e.altFillColor, e.altFillAlpha * d), l.TL = c, l.TR = c, l.BL = c, l.BR = c, C = 0; C < y; C++)
							for (b && (M = C % 2), S = 0; S < m; S++) !b || M ? (M = 0, O = S < m - 1 ? x : w, P = C < y - 1 ? T : E, o.setTexture2D(), o.batchFillRect(S * g, C * v, O, P)) : M = 1;
					if (A && 0 < e.outlineFillAlpha) {
						var R = o.strokeTint,
							L = n.getTintAppendFloatAlphaAndSwap(e.outlineFillColor, e.outlineFillAlpha * d);
						for (R.TL = L, R.TR = L, R.BL = L, R.BR = L, S = 1; S < m; S++) {
							var D = S * g;
							o.setTexture2D(), o.batchLine(D, 0, D, p, 1, 1, 1, 0, !1)
						}
						for (C = 1; C < y; C++) {
							var F = C * v;
							o.setTexture2D(), o.batchLine(0, F, f, F, 1, 1, 1, 0, !1)
						}
					}
				}
			}, function(t, e, i) {
				var n = i(41),
					s = i(49),
					r = i(28);
				t.exports = function(t, e, i, o, a) {
					var h = t.currentContext;
					if (r(t, h, e, o, a)) {
						var u = -e._displayOriginX,
							l = -e._displayOriginY,
							c = o.alpha * e.alpha,
							d = e.width,
							f = e.height,
							p = e.cellWidth,
							g = e.cellHeight,
							v = Math.ceil(d / p),
							m = Math.ceil(f / g),
							y = p,
							x = g,
							T = p - (v * p - d),
							w = g - (m * g - f),
							E = e.showCells,
							_ = e.showAltCells,
							b = e.showOutline,
							A = 0,
							S = 0,
							C = 0,
							M = 0,
							O = 0;
						if (b && (y--, x--, T === p && T--, w === g && w--), E && 0 < e.fillAlpha)
							for (n(h, e), S = 0; S < m; S++)
								for (_ && (C = S % 2), A = 0; A < v; A++) _ && C ? C = 0 : (C++, M = A < v - 1 ? y : T, O = S < m - 1 ? x : w, h.fillRect(u + A * p, l + S * g, M, O));
						if (_ && 0 < e.altFillAlpha)
							for (n(h, e, e.altFillColor, e.altFillAlpha * c), S = 0; S < m; S++)
								for (_ && (C = S % 2), A = 0; A < v; A++) !_ || C ? (C = 0, M = A < v - 1 ? y : T, O = S < m - 1 ? x : w, h.fillRect(u + A * p, l + S * g, M, O)) : C = 1;
						if (b && 0 < e.outlineFillAlpha) {
							for (s(h, e, e.outlineFillColor, e.outlineFillAlpha * c), A = 1; A < v; A++) {
								var P = A * p;
								h.beginPath(), h.moveTo(P + u, l), h.lineTo(P + u, f + l), h.stroke()
							}
							for (S = 1; S < m; S++) {
								var R = S * g;
								h.beginPath(), h.moveTo(u, R + l), h.lineTo(u + d, R + l), h.stroke()
							}
						}
						h.restore()
					}
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1013), s = i(1014);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					var o = this.pipeline,
						a = o._tempMatrix1,
						h = o._tempMatrix2,
						u = o._tempMatrix3;
					t.setPipeline(o), h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY), a.multiply(h, u);
					var l, c, d, f, p, g, v, m, y, x = e.width,
						T = e.height,
						w = x / 2,
						E = x / e.projection,
						_ = s.alpha * e.alpha;
					e.isFilled && (e.showTop && (l = n.getTintAppendFloatAlphaAndSwap(e.fillTop, _), c = u.getX(-w, -T), d = u.getY(-w, -T), f = u.getX(0, -E - T), p = u.getY(0, -E - T), g = u.getX(w, -T), v = u.getY(w, -T), m = u.getX(0, E - T), y = u.getY(0, E - T), o.setTexture2D(), o.batchQuad(c, d, f, p, g, v, m, y, 0, 0, 1, 1, l, l, l, l, 2)), e.showLeft && (l = n.getTintAppendFloatAlphaAndSwap(e.fillLeft, _), c = u.getX(-w, 0), d = u.getY(-w, 0), f = u.getX(0, E), p = u.getY(0, E), g = u.getX(0, E - T), v = u.getY(0, E - T), m = u.getX(-w, -T), y = u.getY(-w, -T), o.setTexture2D(), o.batchQuad(c, d, f, p, g, v, m, y, 0, 0, 1, 1, l, l, l, l, 2)), e.showRight && (l = n.getTintAppendFloatAlphaAndSwap(e.fillRight, _), c = u.getX(w, 0), d = u.getY(w, 0), f = u.getX(0, E), p = u.getY(0, E), g = u.getX(0, E - T), v = u.getY(0, E - T), m = u.getX(w, -T), y = u.getY(w, -T), o.setTexture2D(), o.batchQuad(c, d, f, p, g, v, m, y, 0, 0, 1, 1, l, l, l, l, 2)))
				}
			}, function(t, e, i) {
				var n = i(41),
					s = i(28);
				t.exports = function(t, e, i, r, o) {
					var a, h, u, l, c = t.currentContext;
					s(t, c, e, r, o) && e.isFilled && (a = e.width, h = e.height, u = a / 2, l = a / e.projection, e.showTop && (n(c, e, e.fillTop), c.beginPath(), c.moveTo(-u, -h), c.lineTo(0, -l - h), c.lineTo(u, -h), c.lineTo(u, -1), c.lineTo(0, l - 1), c.lineTo(-u, -1), c.lineTo(-u, -h), c.fill()), e.showLeft && (n(c, e, e.fillLeft), c.beginPath(), c.moveTo(-u, 0), c.lineTo(0, l), c.lineTo(0, l - h), c.lineTo(-u, -h), c.lineTo(-u, 0), c.fill()), e.showRight && (n(c, e, e.fillRight), c.beginPath(), c.moveTo(u, 0), c.lineTo(0, l), c.lineTo(0, l - h), c.lineTo(u, -h), c.lineTo(u, 0), c.fill()), c.restore())
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1016), s = i(1017);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					var o = this.pipeline,
						a = o._tempMatrix1,
						h = o._tempMatrix2,
						u = o._tempMatrix3;
					t.setPipeline(o), h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY), a.multiply(h, u);
					var l, c, d, f, p, g, v, m, y, x = e.width,
						T = e.height,
						w = x / 2,
						E = x / e.projection,
						_ = e.isReversed,
						b = s.alpha * e.alpha;
					e.isFilled && (e.showTop && _ && (l = n.getTintAppendFloatAlphaAndSwap(e.fillTop, b), c = u.getX(-w, -T), d = u.getY(-w, -T), f = u.getX(0, -E - T), p = u.getY(0, -E - T), g = u.getX(w, -T), v = u.getY(w, -T), m = u.getX(0, E - T), y = u.getY(0, E - T), o.setTexture2D(), o.batchQuad(c, d, f, p, g, v, m, y, 0, 0, 1, 1, l, l, l, l, 2)), e.showLeft && (l = n.getTintAppendFloatAlphaAndSwap(e.fillLeft, b), d = _ ? (c = u.getX(-w, -T), u.getY(-w, -T)) : (c = u.getX(-w, 0), u.getY(-w, 0)), f = u.getX(0, E), p = u.getY(0, E), g = u.getX(0, E - T), v = u.getY(0, E - T), o.setTexture2D(), o.batchTri(c, d, f, p, g, v, 0, 0, 1, 1, l, l, l, 2)), e.showRight && (l = n.getTintAppendFloatAlphaAndSwap(e.fillRight, b), d = _ ? (c = u.getX(w, -T), u.getY(w, -T)) : (c = u.getX(w, 0), u.getY(w, 0)), f = u.getX(0, E), p = u.getY(0, E), g = u.getX(0, E - T), v = u.getY(0, E - T), o.setTexture2D(), o.batchTri(c, d, f, p, g, v, 0, 0, 1, 1, l, l, l, 2)))
				}
			}, function(t, e, i) {
				var n = i(41),
					s = i(28);
				t.exports = function(t, e, i, r, o) {
					var a, h, u, l, c, d = t.currentContext;
					s(t, d, e, r, o) && e.isFilled && (a = e.width, h = e.height, u = a / 2, l = a / e.projection, c = e.isReversed, e.showTop && c && (n(d, e, e.fillTop), d.beginPath(), d.moveTo(-u, -h), d.lineTo(0, -l - h), d.lineTo(u, -h), d.lineTo(0, l - h), d.fill()), e.showLeft && (n(d, e, e.fillLeft), d.beginPath(), c ? d.moveTo(-u, -h) : d.moveTo(-u, 0), d.lineTo(0, l), d.lineTo(0, l - h), d.fill()), e.showRight && (n(d, e, e.fillRight), d.beginPath(), c ? d.moveTo(u, -h) : d.moveTo(u, 0), d.lineTo(0, l), d.lineTo(0, l - h), d.fill()), d.restore())
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1019), s = i(1020);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					var o = this.pipeline,
						a = o._tempMatrix1,
						h = o._tempMatrix2;
					t.setPipeline(o), h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY);
					var u, l, c, d, f = e._displayOriginX,
						p = e._displayOriginY,
						g = s.alpha * e.alpha;
					e.isStroked && (u = o.strokeTint, l = n.getTintAppendFloatAlphaAndSwap(e.strokeColor, e.strokeAlpha * g), u.TL = l, u.TR = l, u.BL = l, u.BR = l, c = e._startWidth, d = e._endWidth, o.setTexture2D(), o.batchLine(e.geom.x1 - f, e.geom.y1 - p, e.geom.x2 - f, e.geom.y2 - p, c, d, 1, 0, !1, h, a))
				}
			}, function(t, e, i) {
				var n = i(49),
					s = i(28);
				t.exports = function(t, e, i, r, o) {
					var a, h, u = t.currentContext;
					s(t, u, e, r, o) && (a = e._displayOriginX, h = e._displayOriginY, e.isStroked && (n(u, e), u.beginPath(), u.moveTo(e.geom.x1 - a, e.geom.y1 - h), u.lineTo(e.geom.x2 - a, e.geom.y2 - h), u.stroke()), u.restore())
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1022), s = i(1023);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(98),
					s = i(70);
				t.exports = function(t, e, i, r, o) {
					var a = this.pipeline,
						h = a._tempMatrix1,
						u = a._tempMatrix2,
						l = a._tempMatrix3;
					t.setPipeline(a), u.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), u.e = e.x, u.f = e.y) : (u.e -= r.scrollX * e.scrollFactorX, u.f -= r.scrollY * e.scrollFactorY), h.multiply(u, l);
					var c = e._displayOriginX,
						d = e._displayOriginY,
						f = r.alpha * e.alpha;
					e.isFilled && n(a, l, e, f, c, d), e.isStroked && s(a, e, f, c, d)
				}
			}, function(t, e, i) {
				var n = i(41),
					s = i(49),
					r = i(28);
				t.exports = function(t, e, i, o, a) {
					var h = t.currentContext;
					if (r(t, h, e, o, a)) {
						var u = e._displayOriginX,
							l = e._displayOriginY,
							c = e.pathData,
							d = c.length - 1,
							f = c[0] - u,
							p = c[1] - l;
						h.beginPath(), h.moveTo(f, p), e.closePath || (d -= 2);
						for (var g = 2; g < d; g += 2) {
							var v = c[g] - u,
								m = c[g + 1] - l;
							h.lineTo(v, m)
						}
						h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()), h.restore()
					}
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1025), s = i(1026);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(70),
					s = i(9);
				t.exports = function(t, e, i, r, o) {
					var a = this.pipeline,
						h = a._tempMatrix1,
						u = a._tempMatrix2,
						l = a._tempMatrix3;
					t.setPipeline(a), u.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), u.e = e.x, u.f = e.y) : (u.e -= r.scrollX * e.scrollFactorX, u.f -= r.scrollY * e.scrollFactorY), h.multiply(u, l);
					var c, d, f = e._displayOriginX,
						p = e._displayOriginY,
						g = r.alpha * e.alpha;
					e.isFilled && (c = a.fillTint, d = s.getTintAppendFloatAlphaAndSwap(e.fillColor, e.fillAlpha * g), c.TL = d, c.TR = d, c.BL = d, c.BR = d, a.setTexture2D(), a.batchFillRect(-f, -p, e.width, e.height)), e.isStroked && n(a, e, g, f, p)
				}
			}, function(t, e, i) {
				var n = i(41),
					s = i(49),
					r = i(28);
				t.exports = function(t, e, i, o, a) {
					var h, u, l = t.currentContext;
					r(t, l, e, o, a) && (h = e._displayOriginX, u = e._displayOriginY, e.isFilled && (n(l, e), l.fillRect(-h, -u, e.width, e.height)), e.isStroked && (s(l, e), l.beginPath(), l.rect(-h, -u, e.width, e.height), l.stroke()), l.restore())
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1028), s = i(1029);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(98),
					s = i(70);
				t.exports = function(t, e, i, r, o) {
					var a = this.pipeline,
						h = a._tempMatrix1,
						u = a._tempMatrix2,
						l = a._tempMatrix3;
					t.setPipeline(a), u.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), u.e = e.x, u.f = e.y) : (u.e -= r.scrollX * e.scrollFactorX, u.f -= r.scrollY * e.scrollFactorY), h.multiply(u, l);
					var c = e._displayOriginX,
						d = e._displayOriginY,
						f = r.alpha * e.alpha;
					e.isFilled && n(a, l, e, f, c, d), e.isStroked && s(a, e, f, c, d)
				}
			}, function(t, e, i) {
				var n = i(41),
					s = i(49),
					r = i(28);
				t.exports = function(t, e, i, o, a) {
					var h = t.currentContext;
					if (r(t, h, e, o, a)) {
						var u = e._displayOriginX,
							l = e._displayOriginY,
							c = e.pathData,
							d = c.length - 1,
							f = c[0] - u,
							p = c[1] - l;
						h.beginPath(), h.moveTo(f, p), e.closePath || (d -= 2);
						for (var g = 2; g < d; g += 2) {
							var v = c[g] - u,
								m = c[g + 1] - l;
							h.lineTo(v, m)
						}
						h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()), h.restore()
					}
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1031), s = i(1032);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(70),
					s = i(9);
				t.exports = function(t, e, i, r, o) {
					var a = this.pipeline,
						h = a._tempMatrix1,
						u = a._tempMatrix2,
						l = a._tempMatrix3;
					t.setPipeline(a), u.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), u.e = e.x, u.f = e.y) : (u.e -= r.scrollX * e.scrollFactorX, u.f -= r.scrollY * e.scrollFactorY), h.multiply(u, l);
					var c, d, f, p, g, v, m, y, x = e._displayOriginX,
						T = e._displayOriginY,
						w = r.alpha * e.alpha;
					e.isFilled && (c = a.fillTint, d = s.getTintAppendFloatAlphaAndSwap(e.fillColor, e.fillAlpha * w), c.TL = d, c.TR = d, c.BL = d, c.BR = d, f = e.geom.x1 - x, p = e.geom.y1 - T, g = e.geom.x2 - x, v = e.geom.y2 - T, m = e.geom.x3 - x, y = e.geom.y3 - T, a.setTexture2D(), a.batchFillTriangle(f, p, g, v, m, y, u, h)), e.isStroked && n(a, e, w, x, T)
				}
			}, function(t, e, i) {
				var n = i(41),
					s = i(49),
					r = i(28);
				t.exports = function(t, e, i, o, a) {
					var h, u, l, c, d, f, p, g, v = t.currentContext;
					r(t, v, e, o, a) && (h = e._displayOriginX, u = e._displayOriginY, l = e.geom.x1 - h, c = e.geom.y1 - u, d = e.geom.x2 - h, f = e.geom.y2 - u, p = e.geom.x3 - h, g = e.geom.y3 - u, v.beginPath(), v.moveTo(l, c), v.lineTo(d, f), v.lineTo(p, g), v.closePath(), e.isFilled && (n(v, e), v.fill()), e.isStroked && (s(v, e), v.stroke()), v.restore())
				}
			}, function(t, e, i) {
				var n = i(188);
				i(5).register("blitter", function(t, e, i, s) {
					return this.displayList.add(new n(this.scene, t, e, i, s))
				})
			}, function(t, e, i) {
				var n = i(189);
				i(5).register("container", function(t, e, i) {
					return this.displayList.add(new n(this.scene, t, e, i))
				})
			}, function(t, e, i) {
				var n = i(395);
				i(5).register("dom", function(t, e, i, s, r) {
					var o = new n(this.scene, t, e, i, s, r);
					return this.displayList.add(o), this.updateList.add(o), o
				})
			}, function(t, e, i) {
				var n = i(190);
				i(5).register("dynamicBitmapText", function(t, e, i, s, r) {
					return this.displayList.add(new n(this.scene, t, e, i, s, r))
				})
			}, function(t, e, i) {
				var n = i(397);
				i(5).register("extern", function() {
					var t = new n(this.scene);
					return this.displayList.add(t), this.updateList.add(t), t
				})
			}, function(t, e, i) {
				var n = i(191);
				i(5).register("graphics", function(t) {
					return this.displayList.add(new n(this.scene, t))
				})
			}, function(t, e, i) {
				var n = i(97);
				i(5).register("group", function(t, e) {
					return this.updateList.add(new n(this.scene, t, e))
				})
			}, function(t, e, i) {
				var n = i(107);
				i(5).register("image", function(t, e, i, s) {
					return this.displayList.add(new n(this.scene, t, e, i, s))
				})
			}, function(t, e, i) {
				var n = i(5),
					s = i(194);
				n.register("particles", function(t, e, i) {
					var n = new s(this.scene, t, e, i);
					return this.displayList.add(n), this.updateList.add(n), n
				})
			}, function(t, e, i) {
				var n = i(5),
					s = i(409);
				n.register("follower", function(t, e, i, n, r) {
					var o = new s(this.scene, t, e, i, n, r);
					return this.displayList.add(o), this.updateList.add(o), o
				})
			}, function(t, e, i) {
				var n = i(5),
					s = i(195);
				n.register("renderTexture", function(t, e, i, n, r, o) {
					return this.displayList.add(new s(this.scene, t, e, i, n, r, o))
				})
			}, function(t, e, i) {
				var n = i(197);
				i(5).register("rope", function(t, e, i, s, r, o, a, h) {
					var u = new n(this.scene, t, e, i, s, r, o, a, h);
					return this.displayList.add(u), this.updateList.add(u)
				})
			}, function(t, e, i) {
				var n = i(5),
					s = i(75);
				n.register("sprite", function(t, e, i, n) {
					var r = new s(this.scene, t, e, i, n);
					return this.displayList.add(r), this.updateList.add(r), r
				})
			}, function(t, e, i) {
				var n = i(132);
				i(5).register("bitmapText", function(t, e, i, s, r, o) {
					return this.displayList.add(new n(this.scene, t, e, i, s, r, o))
				})
			}, function(t, e, i) {
				var n = i(198);
				i(5).register("text", function(t, e, i, s) {
					return this.displayList.add(new n(this.scene, t, e, i, s))
				})
			}, function(t, e, i) {
				var n = i(199);
				i(5).register("tileSprite", function(t, e, i, s, r, o) {
					return this.displayList.add(new n(this.scene, t, e, i, s, r, o))
				})
			}, function(t, e, i) {
				var n = i(110);
				i(5).register("zone", function(t, e, i, s) {
					return this.displayList.add(new n(this.scene, t, e, i, s))
				})
			}, function(t, e, i) {
				var n = i(200);
				i(5).register("video", function(t, e, i) {
					var s = new n(this.scene, t, e, i);
					return this.displayList.add(s), this.updateList.add(s), s
				})
			}, function(t, e, i) {
				var n = i(410),
					s = i(5);
				s.register("arc", function(t, e, i, s, r, o, a, h) {
					return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a, h))
				}), s.register("circle", function(t, e, i, s, r) {
					return this.displayList.add(new n(this.scene, t, e, i, 0, 360, !1, s, r))
				})
			}, function(t, e, i) {
				var n = i(5),
					s = i(411);
				n.register("curve", function(t, e, i, n, r) {
					return this.displayList.add(new s(this.scene, t, e, i, n, r))
				})
			}, function(t, e, i) {
				var n = i(412);
				i(5).register("ellipse", function(t, e, i, s, r, o) {
					return this.displayList.add(new n(this.scene, t, e, i, s, r, o))
				})
			}, function(t, e, i) {
				var n = i(5),
					s = i(413);
				n.register("grid", function(t, e, i, n, r, o, a, h, u, l) {
					return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h, u, l))
				})
			}, function(t, e, i) {
				var n = i(5),
					s = i(414);
				n.register("isobox", function(t, e, i, n, r, o, a) {
					return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a))
				})
			}, function(t, e, i) {
				var n = i(5),
					s = i(415);
				n.register("isotriangle", function(t, e, i, n, r, o, a, h) {
					return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h))
				})
			}, function(t, e, i) {
				var n = i(5),
					s = i(416);
				n.register("line", function(t, e, i, n, r, o, a, h) {
					return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h))
				})
			}, function(t, e, i) {
				var n = i(5),
					s = i(417);
				n.register("polygon", function(t, e, i, n, r) {
					return this.displayList.add(new s(this.scene, t, e, i, n, r))
				})
			}, function(t, e, i) {
				var n = i(5),
					s = i(422);
				n.register("rectangle", function(t, e, i, n, r, o) {
					return this.displayList.add(new s(this.scene, t, e, i, n, r, o))
				})
			}, function(t, e, i) {
				var n = i(423);
				i(5).register("star", function(t, e, i, s, r, o, a) {
					return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a))
				})
			}, function(t, e, i) {
				var n = i(5),
					s = i(424);
				n.register("triangle", function(t, e, i, n, r, o, a, h, u, l) {
					return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h, u, l))
				})
			}, function(t, e, i) {
				var n = i(188),
					s = i(27),
					r = i(16),
					o = i(15);
				r.register("blitter", function(t, e) {
					void 0 === t && (t = {});
					var i = o(t, "key", null),
						r = o(t, "frame", null),
						a = new n(this.scene, 0, 0, i, r);
					return void 0 !== e && (t.add = e), s(this.scene, a, t), a
				})
			}, function(t, e, i) {
				var n = i(27),
					s = i(189),
					r = i(16),
					o = i(15);
				r.register("container", function(t, e) {
					void 0 === t && (t = {});
					var i = o(t, "x", 0),
						r = o(t, "y", 0),
						a = new s(this.scene, i, r);
					return void 0 !== e && (t.add = e), n(this.scene, a, t), a
				})
			}, function(t, e, i) {
				var n = i(190),
					s = i(27),
					r = i(16),
					o = i(15);
				r.register("dynamicBitmapText", function(t, e) {
					void 0 === t && (t = {});
					var i = o(t, "font", ""),
						r = o(t, "text", ""),
						a = o(t, "size", !1),
						h = new n(this.scene, 0, 0, i, r, a);
					return void 0 !== e && (t.add = e), s(this.scene, h, t), h
				})
			}, function(t, e, i) {
				var n = i(16),
					s = i(191);
				n.register("graphics", function(t, e) {
					void 0 === t && (t = {}), void 0 !== e && (t.add = e);
					var i = new s(this.scene, t);
					return t.add && this.scene.sys.displayList.add(i), i
				})
			}, function(t, e, i) {
				var n = i(16),
					s = i(97);
				n.register("group", function(t) {
					return new s(this.scene, null, t)
				})
			}, function(t, e, i) {
				var n = i(27),
					s = i(16),
					r = i(15),
					o = i(107);
				s.register("image", function(t, e) {
					void 0 === t && (t = {});
					var i = r(t, "key", null),
						s = r(t, "frame", null),
						a = new o(this.scene, 0, 0, i, s);
					return void 0 !== e && (t.add = e), n(this.scene, a, t), a
				})
			}, function(t, e, i) {
				var n = i(16),
					s = i(15),
					r = i(2),
					o = i(194);
				n.register("particles", function(t, e) {
					void 0 === t && (t = {});
					var i = s(t, "key", null),
						n = s(t, "frame", null),
						a = r(t, "emitters", null),
						h = new o(this.scene, i, n, a);
					return void 0 !== e && (t.add = e), r(t, "add", !1) && this.displayList.add(h), this.updateList.add(h), h
				})
			}, function(t, e, i) {
				var n = i(27),
					s = i(16),
					r = i(15),
					o = i(195);
				s.register("renderTexture", function(t, e) {
					void 0 === t && (t = {});
					var i = r(t, "x", 0),
						s = r(t, "y", 0),
						a = r(t, "width", 32),
						h = r(t, "height", 32),
						u = r(t, "key", void 0),
						l = r(t, "frame", void 0),
						c = new o(this.scene, i, s, a, h, u, l);
					return void 0 !== e && (t.add = e), n(this.scene, c, t), c
				})
			}, function(t, e, i) {
				var n = i(27),
					s = i(16),
					r = i(15),
					o = i(6),
					a = i(197);
				s.register("rope", function(t, e) {
					void 0 === t && (t = {});
					var i = r(t, "key", null),
						s = r(t, "frame", null),
						h = r(t, "horizontal", !0),
						u = o(t, "points", void 0),
						l = o(t, "colors", void 0),
						c = o(t, "alphas", void 0),
						d = new a(this.scene, 0, 0, i, s, u, h, l, c);
					return void 0 !== e && (t.add = e), n(this.scene, d, t), d
				})
			}, function(t, e, i) {
				var n = i(27),
					s = i(393),
					r = i(16),
					o = i(15),
					a = i(75);
				r.register("sprite", function(t, e) {
					void 0 === t && (t = {});
					var i = o(t, "key", null),
						r = o(t, "frame", null),
						h = new a(this.scene, 0, 0, i, r);
					return void 0 !== e && (t.add = e), n(this.scene, h, t), s(h, t), h
				})
			}, function(t, e, i) {
				var n = i(132),
					s = i(27),
					r = i(16),
					o = i(15),
					a = i(6);
				r.register("bitmapText", function(t, e) {
					void 0 === t && (t = {});
					var i = a(t, "font", ""),
						r = o(t, "text", ""),
						h = o(t, "size", !1),
						u = a(t, "align", 0),
						l = new n(this.scene, 0, 0, i, r, h, u);
					return void 0 !== e && (t.add = e), s(this.scene, l, t), l
				})
			}, function(t, e, i) {
				var n = i(27),
					s = i(16),
					r = i(15),
					o = i(198);
				s.register("text", function(t, e) {
					void 0 === t && (t = {});
					var i = r(t, "text", ""),
						s = r(t, "style", null),
						a = r(t, "padding", null);
					null !== a && (s.padding = a);
					var h = new o(this.scene, 0, 0, i, s);
					return void 0 !== e && (t.add = e), n(this.scene, h, t), h.autoRound = r(t, "autoRound", !0), h.resolution = r(t, "resolution", 1), h
				})
			}, function(t, e, i) {
				var n = i(27),
					s = i(16),
					r = i(15),
					o = i(199);
				s.register("tileSprite", function(t, e) {
					void 0 === t && (t = {});
					var i = r(t, "x", 0),
						s = r(t, "y", 0),
						a = r(t, "width", 512),
						h = r(t, "height", 512),
						u = r(t, "key", ""),
						l = r(t, "frame", ""),
						c = new o(this.scene, i, s, a, h, u, l);
					return void 0 !== e && (t.add = e), n(this.scene, c, t), c
				})
			}, function(t, e, i) {
				var n = i(16),
					s = i(15),
					r = i(110);
				n.register("zone", function(t) {
					var e = s(t, "x", 0),
						i = s(t, "y", 0),
						n = s(t, "width", 1),
						o = s(t, "height", n);
					return new r(this.scene, e, i, n, o)
				})
			}, function(t, e, i) {
				var n = i(27),
					s = i(16),
					r = i(15),
					o = i(200);
				s.register("video", function(t, e) {
					void 0 === t && (t = {});
					var i = r(t, "key", null),
						s = new o(this.scene, 0, 0, i);
					return void 0 !== e && (t.add = e), n(this.scene, s, t), s
				})
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1078), s = i(1079);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s, r) {
					var o = this.pipeline;
					t.setPipeline(o, e);
					var a = o._tempMatrix1,
						h = o._tempMatrix2,
						u = o._tempMatrix3;
					h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY), a.multiply(h, u);
					var l = e.frame.glTexture,
						c = e.vertices,
						d = e.uv,
						f = e.colors,
						p = e.alphas,
						g = c.length,
						v = Math.floor(.5 * g);
					o.vertexCount + v > o.vertexCapacity && o.flush(), o.setTexture2D(l, 0);
					for (var m = o.vertexViewF32, y = o.vertexViewU32, x = o.vertexCount * o.vertexComponentCount - 1, T = 0, w = e.tintFill, E = 0; E < g; E += 2) {
						var _ = c[E + 0],
							b = c[E + 1],
							A = _ * u.a + b * u.c + u.e,
							S = _ * u.b + b * u.d + u.f;
						s.roundPixels && (A = Math.round(A), S = Math.round(S)), m[++x] = A, m[++x] = S, m[++x] = d[E + 0], m[++x] = d[E + 1], m[++x] = w, y[++x] = n.getTintAppendFloatAlpha(f[T], s.alpha * p[T]), T++
					}
					o.vertexCount += v
				}
			}, function(t, e) {
				t.exports = function() {}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1081), s = i(1082);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					var r, o, a, h;
					e.shader && (r = t.currentPipeline, t.clearPipeline(), e.renderToTexture ? e.load() : (o = e._tempMatrix1, a = e._tempMatrix2, h = e._tempMatrix3, a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h), t.width === e._rendererWidth && t.height === e._rendererHeight || e.projOrtho(0, t.width, t.height, 0), e.load(h.matrix)), e.flush(), t.rebindPipeline(r))
				}
			}, function(t, e) {
				t.exports = function() {}
			}, function(t, e, i) {
				var n = i(134);
				i(5).register("mesh", function(t, e, i, s, r, o, a, h) {
					return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a, h))
				})
			}, function(t, e, i) {
				var n = i(203);
				i(5).register("quad", function(t, e, i, s) {
					return this.displayList.add(new n(this.scene, t, e, i, s))
				})
			}, function(t, e, i) {
				var n = i(204);
				i(5).register("shader", function(t, e, i, s, r, o, a) {
					return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a))
				})
			}, function(t, e, i) {
				var n = i(27),
					s = i(16),
					r = i(15),
					o = i(6),
					a = i(134);
				s.register("mesh", function(t, e) {
					void 0 === t && (t = {});
					var i = r(t, "key", null),
						s = r(t, "frame", null),
						h = o(t, "vertices", []),
						u = o(t, "colors", []),
						l = o(t, "alphas", []),
						c = o(t, "uv", []),
						d = new a(this.scene, 0, 0, h, c, u, l, i, s);
					return void 0 !== e && (t.add = e), n(this.scene, d, t), d
				})
			}, function(t, e, i) {
				var n = i(27),
					s = i(16),
					r = i(15),
					o = i(203);
				s.register("quad", function(t, e) {
					void 0 === t && (t = {});
					var i = r(t, "x", 0),
						s = r(t, "y", 0),
						a = r(t, "key", null),
						h = r(t, "frame", null),
						u = new o(this.scene, i, s, a, h);
					return void 0 !== e && (t.add = e), n(this.scene, u, t), u
				})
			}, function(t, e, i) {
				var n = i(27),
					s = i(16),
					r = i(15),
					o = i(204);
				s.register("shader", function(t, e) {
					void 0 === t && (t = {});
					var i = r(t, "key", null),
						s = r(t, "x", 0),
						a = r(t, "y", 0),
						h = r(t, "width", 128),
						u = r(t, "height", 128),
						l = new o(this.scene, i, s, a, h, u);
					return void 0 !== e && (t.add = e), n(this.scene, l, t), l
				})
			}, function(t, e, i) {
				var n = i(0),
					s = i(429),
					r = i(23),
					o = i(22),
					a = new n({
						Extends: s,
						initialize: function(t) {
							this.scene = t, this.systems = t.sys, t.sys.settings.isBooted || t.sys.events.once(o.BOOT, this.boot, this), s.call(this)
						},
						boot: function() {
							var t = this.systems.events;
							t.on(o.SHUTDOWN, this.shutdown, this), t.on(o.DESTROY, this.destroy, this)
						},
						destroy: function() {
							this.shutdown(), this.scene = void 0, this.systems = void 0
						}
					});
				r.register("LightsPlugin", a, "lights"), t.exports = a
			}, function(t, e, i) {
				var n = i(65);
				n.Area = i(1091), n.Circumference = i(268), n.CircumferencePoint = i(149), n.Clone = i(1092), n.Contains = i(55), n.ContainsPoint = i(1093), n.ContainsRect = i(1094), n.CopyFrom = i(1095), n.Equals = i(1096), n.GetBounds = i(1097), n.GetPoint = i(266), n.GetPoints = i(267), n.Offset = i(1098), n.OffsetPoint = i(1099), n.Random = i(150), t.exports = n
			}, function(t, e) {
				t.exports = function(t) {
					return 0 < t.radius ? Math.PI * t.radius * t.radius : 0
				}
			}, function(t, e, i) {
				var n = i(65);
				t.exports = function(t) {
					return new n(t.x, t.y, t.radius)
				}
			}, function(t, e, i) {
				var n = i(55);
				t.exports = function(t, e) {
					return n(t, e.x, e.y)
				}
			}, function(t, e, i) {
				var n = i(55);
				t.exports = function(t, e) {
					return n(t, e.x, e.y) && n(t, e.right, e.y) && n(t, e.x, e.bottom) && n(t, e.right, e.bottom)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return e.setTo(t.x, t.y, t.radius)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.x === e.x && t.y === e.y && t.radius === e.radius
				}
			}, function(t, e, i) {
				var n = i(11);
				t.exports = function(t, e) {
					return void 0 === e && (e = new n), e.x = t.left, e.y = t.top, e.width = t.diameter, e.height = t.diameter, e
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return t.x += e, t.y += i, t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.x += e.x, t.y += e.y, t
				}
			}, function(t, e, i) {
				var n = i(95);
				n.Area = i(1101), n.Circumference = i(400), n.CircumferencePoint = i(193), n.Clone = i(1102), n.Contains = i(96), n.ContainsPoint = i(1103), n.ContainsRect = i(1104), n.CopyFrom = i(1105), n.Equals = i(1106), n.GetBounds = i(1107), n.GetPoint = i(398), n.GetPoints = i(399), n.Offset = i(1108), n.OffsetPoint = i(1109), n.Random = i(157), t.exports = n
			}, function(t, e) {
				t.exports = function(t) {
					return t.isEmpty() ? 0 : t.getMajorRadius() * t.getMinorRadius() * Math.PI
				}
			}, function(t, e, i) {
				var n = i(95);
				t.exports = function(t) {
					return new n(t.x, t.y, t.width, t.height)
				}
			}, function(t, e, i) {
				var n = i(96);
				t.exports = function(t, e) {
					return n(t, e.x, e.y)
				}
			}, function(t, e, i) {
				var n = i(96);
				t.exports = function(t, e) {
					return n(t, e.x, e.y) && n(t, e.right, e.y) && n(t, e.x, e.bottom) && n(t, e.right, e.bottom)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return e.setTo(t.x, t.y, t.width, t.height)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
				}
			}, function(t, e, i) {
				var n = i(11);
				t.exports = function(t, e) {
					return void 0 === e && (e = new n), e.x = t.left, e.y = t.top, e.width = t.width, e.height = t.height, e
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return t.x += e, t.y += i, t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.x += e.x, t.y += e.y, t
				}
			}, function(t, e, i) {
				var n = i(4),
					s = i(205);
				t.exports = function(t, e, i) {
					var r, o, a, h, u, l, c, d, f, p, g, v;
					return void 0 === i && (i = []), s(t, e) && (r = t.x, o = t.y, a = t.radius, h = e.x, u = e.y, l = e.radius, o === u ? 0 == (v = (g = -2 * u) * g - 4 * (p = 1) * (h * h + (c = (l * l - a * a - h * h + r * r) / (2 * (r - h))) * c - 2 * h * c + u * u - l * l)) ? i.push(new n(c, -g / (2 * p))) : 0 < v && (i.push(new n(c, (-g + Math.sqrt(v)) / (2 * p))), i.push(new n(c, (-g - Math.sqrt(v)) / (2 * p)))) : 0 == (v = (g = 2 * o * (d = (r - h) / (o - u)) - 2 * (f = (l * l - a * a - h * h + r * r - u * u + o * o) / (2 * (o - u))) * d - 2 * r) * g - 4 * (p = d * d + 1) * (r * r + o * o + f * f - a * a - 2 * o * f)) ? (c = -g / (2 * p), i.push(new n(c, f - c * d))) : 0 < v && (c = (-g + Math.sqrt(v)) / (2 * p), i.push(new n(c, f - c * d)), c = (-g - Math.sqrt(v)) / (2 * p), i.push(new n(c, f - c * d)))), i
				}
			}, function(t, e, i) {
				var n = i(207),
					s = i(206);
				t.exports = function(t, e, i) {
					var r, o, a, h;
					return void 0 === i && (i = []), s(t, e) && (r = e.getLineA(), o = e.getLineB(), a = e.getLineC(), h = e.getLineD(), n(r, t, i), n(o, t, i), n(a, t, i), n(h, t, i)), i
				}
			}, function(t, e, i) {
				var n = i(11),
					s = i(135);
				t.exports = function(t, e, i) {
					return void 0 === i && (i = new n), s(t, e) && (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y), i
				}
			}, function(t, e, i) {
				var n = i(209),
					s = i(135);
				t.exports = function(t, e, i) {
					var r, o, a, h;
					return void 0 === i && (i = []), s(t, e) && (r = t.getLineA(), o = t.getLineB(), a = t.getLineC(), h = t.getLineD(), n(r, e, i), n(o, e, i), n(a, e, i), n(h, e, i)), i
				}
			}, function(t, e, i) {
				var n = i(433),
					s = i(209);
				t.exports = function(t, e, i) {
					var r, o, a;
					return void 0 === i && (i = []), n(t, e) && (r = e.getLineA(), o = e.getLineB(), a = e.getLineC(), s(r, t, i), s(o, t, i), s(a, t, i)), i
				}
			}, function(t, e, i) {
				var n = i(207),
					s = i(435);
				t.exports = function(t, e, i) {
					var r, o, a;
					return void 0 === i && (i = []), s(t, e) && (r = t.getLineA(), o = t.getLineB(), a = t.getLineC(), n(r, e, i), n(o, e, i), n(a, e, i)), i
				}
			}, function(t, e, i) {
				var n = i(438),
					s = i(436);
				t.exports = function(t, e, i) {
					var r, o, a;
					return void 0 === i && (i = []), n(t, e) && (r = e.getLineA(), o = e.getLineB(), a = e.getLineC(), s(t, r, i), s(t, o, i), s(t, a, i)), i
				}
			}, function(t, e, i) {
				var n = i(440);
				t.exports = function(t, e) {
					if (!n(t, e)) return !1;
					var i = Math.min(e.x1, e.x2),
						s = Math.max(e.x1, e.x2),
						r = Math.min(e.y1, e.y2),
						o = Math.max(e.y1, e.y2);
					return t.x >= i && t.x <= s && t.y >= r && t.y <= o
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s, r) {
					return void 0 === r && (r = 0), !(e > t.right + r || i < t.left - r || n > t.bottom + r || s < t.top - r)
				}
			}, function(t, e, i) {
				var n = i(56);
				n.Angle = i(85), n.BresenhamPoints = i(288), n.CenterOn = i(1120), n.Clone = i(1121), n.CopyFrom = i(1122), n.Equals = i(1123), n.Extend = i(1124), n.GetEasedPoints = i(1125), n.GetMidPoint = i(1126), n.GetNearestPoint = i(1127), n.GetNormal = i(1128), n.GetPoint = i(275), n.GetPoints = i(153), n.GetShortestDistance = i(1129), n.Height = i(1130), n.Length = i(57), n.NormalAngle = i(441), n.NormalX = i(1131), n.NormalY = i(1132), n.Offset = i(1133), n.PerpSlope = i(1134), n.Random = i(154), n.ReflectAngle = i(1135), n.Rotate = i(1136), n.RotateAroundPoint = i(1137), n.RotateAroundXY = i(211), n.SetToAngle = i(1138), n.Slope = i(1139), n.Width = i(1140), t.exports = n
			}, function(t, e) {
				t.exports = function(t, e, i) {
					var n = e - (t.x1 + t.x2) / 2,
						s = i - (t.y1 + t.y2) / 2;
					return t.x1 += n, t.y1 += s, t.x2 += n, t.y2 += s, t
				}
			}, function(t, e, i) {
				var n = i(56);
				t.exports = function(t) {
					return new n(t.x1, t.y1, t.x2, t.y2)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return e.setTo(t.x1, t.y1, t.x2, t.y2)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.x1 === e.x1 && t.y1 === e.y1 && t.x2 === e.x2 && t.y2 === e.y2
				}
			}, function(t, e, i) {
				var n = i(57);
				t.exports = function(t, e, i) {
					void 0 === i && (i = e);
					var s = n(t),
						r = t.x2 - t.x1,
						o = t.y2 - t.y1;
					return e && (t.x1 = t.x1 - r / s * e, t.y1 = t.y1 - o / s * e), i && (t.x2 = t.x2 + r / s * i, t.y2 = t.y2 + o / s * i), t
				}
			}, function(t, e, i) {
				var n = i(320),
					s = i(69),
					r = i(4);
				t.exports = function(t, e, i, o, a) {
					void 0 === o && (o = 0), void 0 === a && (a = []);
					var h, u = [],
						l = t.x1,
						c = t.y1,
						d = t.x2 - l,
						f = t.y2 - c,
						p = s(e, a),
						g = i - 1;
					for (y = 0; y < g; y++) h = p(y / g), u.push(new r(l + d * h, c + f * h));
					if (h = p(1), u.push(new r(l + d * h, c + f * h)), 0 < o) {
						for (var v = u[0], m = [v], y = 1; y < u.length - 1; y++) {
							var x = u[y];
							n(v, x) >= o && (m.push(x), v = x)
						}
						var T = u[u.length - 1];
						return n(v, T) < o && m.pop(), m.push(T), m
					}
					return u
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e) {
					return void 0 === e && (e = new n), e.x = (t.x1 + t.x2) / 2, e.y = (t.y1 + t.y2) / 2, e
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e, i) {
					void 0 === i && (i = new n);
					var s = t.x1,
						r = t.y1,
						o = t.x2,
						a = t.y2,
						h = (o - s) * (o - s) + (a - r) * (a - r);
					if (0 == h) return i;
					var u = ((e.x - s) * (o - s) + (e.y - r) * (a - r)) / h;
					return i.x = s + u * (o - s), i.y = r + u * (a - r), i
				}
			}, function(t, e, i) {
				var n = i(13),
					s = i(85),
					r = i(4);
				t.exports = function(t, e) {
					void 0 === e && (e = new r);
					var i = s(t) - n.TAU;
					return e.x = Math.cos(i), e.y = Math.sin(i), e
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = t.x1,
						n = t.y1,
						s = t.x2,
						r = t.y2,
						o = (s - i) * (s - i) + (r - n) * (r - n);
					if (0 == o) return !1;
					var a = ((n - e.y) * (s - i) - (i - e.x) * (r - n)) / o;
					return Math.abs(a) * Math.sqrt(o)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return Math.abs(t.y1 - t.y2)
				}
			}, function(t, e, i) {
				var n = i(13),
					s = i(85);
				t.exports = function(t) {
					return Math.cos(s(t) - n.TAU)
				}
			}, function(t, e, i) {
				var n = i(13),
					s = i(85);
				t.exports = function(t) {
					return Math.sin(s(t) - n.TAU)
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return t.x1 += e, t.y1 += i, t.x2 += e, t.y2 += i, t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return -(t.x2 - t.x1) / (t.y2 - t.y1)
				}
			}, function(t, e, i) {
				var n = i(85),
					s = i(441);
				t.exports = function(t, e) {
					return 2 * s(e) - Math.PI - n(t)
				}
			}, function(t, e, i) {
				var n = i(211);
				t.exports = function(t, e) {
					var i = (t.x1 + t.x2) / 2,
						s = (t.y1 + t.y2) / 2;
					return n(t, i, s, e)
				}
			}, function(t, e, i) {
				var n = i(211);
				t.exports = function(t, e, i) {
					return n(t, e.x, e.y, i)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					return t.x1 = e, t.y1 = i, t.x2 = e + Math.cos(n) * s, t.y2 = i + Math.sin(n) * s, t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return (t.y2 - t.y1) / (t.x2 - t.x1)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return Math.abs(t.x1 - t.x2)
				}
			}, function(t, e, i) {
				var n = i(4);
				n.Ceil = i(1142), n.Clone = i(1143), n.CopyFrom = i(1144), n.Equals = i(1145), n.Floor = i(1146), n.GetCentroid = i(1147), n.GetMagnitude = i(442), n.GetMagnitudeSq = i(443), n.GetRectangleFromPoints = i(1148), n.Interpolate = i(1149), n.Invert = i(1150), n.Negative = i(1151), n.Project = i(1152), n.ProjectUnit = i(1153), n.SetMagnitude = i(1154), t.exports = n
			}, function(t, e) {
				t.exports = function(t) {
					return t.setTo(Math.ceil(t.x), Math.ceil(t.y))
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t) {
					return new n(t.x, t.y)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return e.setTo(t.x, t.y)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.x === e.x && t.y === e.y
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.setTo(Math.floor(t.x), Math.floor(t.y))
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e) {
					if (void 0 === e && (e = new n), !Array.isArray(t)) throw new Error("GetCentroid points argument must be an array");
					var i = t.length;
					if (i < 1) throw new Error("GetCentroid points array must not be empty");
					if (1 === i) e.x = t[0].x, e.y = t[0].y;
					else {
						for (var s = 0; s < i; s++) e.x += t[s].x, e.y += t[s].y;
						e.x /= i, e.y /= i
					}
					return e
				}
			}, function(t, e, i) {
				var n = i(11);
				t.exports = function(t, e) {
					void 0 === e && (e = new n);
					for (var i = Number.NEGATIVE_INFINITY, s = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY, o = Number.POSITIVE_INFINITY, a = 0; a < t.length; a++) {
						var h = t[a];
						h.x > i && (i = h.x), h.x < s && (s = h.x), h.y > r && (r = h.y), h.y < o && (o = h.y)
					}
					return e.x = s, e.y = o, e.width = i - s, e.height = r - o, e
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e, i, s) {
					return void 0 === i && (i = 0), void 0 === s && (s = new n), s.x = t.x + (e.x - t.x) * i, s.y = t.y + (e.y - t.y) * i, s
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.setTo(t.y, t.x)
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e) {
					return void 0 === e && (e = new n), e.setTo(-t.x, -t.y)
				}
			}, function(t, e, i) {
				var n = i(4),
					s = i(443);
				t.exports = function(t, e, i) {
					void 0 === i && (i = new n);
					var r = (t.x * e.x + t.y * e.y) / s(e);
					return 0 != r && (i.x = r * e.x, i.y = r * e.y), i
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e, i) {
					void 0 === i && (i = new n);
					var s = t.x * e.x + t.y * e.y;
					return 0 != s && (i.x = s * e.x, i.y = s * e.y), i
				}
			}, function(t, e, i) {
				var n = i(442);
				t.exports = function(t, e) {
					var i;
					return 0 === t.x && 0 === t.y || (i = n(t), t.x /= i, t.y /= i), t.x *= e, t.y *= e, t
				}
			}, function(t, e, i) {
				var n = i(201);
				n.Clone = i(1156), n.Contains = i(202), n.ContainsPoint = i(1157), n.GetAABB = i(418), n.GetNumberArray = i(1158), n.GetPoints = i(419), n.Perimeter = i(420), n.Reverse = i(1159), n.Smooth = i(421), t.exports = n
			}, function(t, e, i) {
				var n = i(201);
				t.exports = function(t) {
					return new n(t.points)
				}
			}, function(t, e, i) {
				var n = i(202);
				t.exports = function(t, e) {
					return n(t, e.x, e.y)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					void 0 === e && (e = []);
					for (var i = 0; i < t.points.length; i++) e.push(t.points[i].x), e.push(t.points[i].y);
					return e
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.points.reverse(), t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.width * t.height
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.x = Math.ceil(t.x), t.y = Math.ceil(t.y), t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.x = Math.ceil(t.x), t.y = Math.ceil(t.y), t.width = Math.ceil(t.width), t.height = Math.ceil(t.height), t
				}
			}, function(t, e, i) {
				var n = i(11);
				t.exports = function(t) {
					return new n(t.x, t.y, t.width, t.height)
				}
			}, function(t, e, i) {
				var n = i(48);
				t.exports = function(t, e) {
					return n(t, e.x, e.y)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return e.setTo(t.x, t.y, t.width, t.height)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
				}
			}, function(t, e, i) {
				var n = i(212);
				t.exports = function(t, e) {
					var i = n(t);
					return i < n(e) ? t.setSize(e.height * i, e.height) : t.setSize(e.width, e.width / i), t.setPosition(e.centerX - t.width / 2, e.centerY - t.height / 2)
				}
			}, function(t, e, i) {
				var n = i(212);
				t.exports = function(t, e) {
					var i = n(t);
					return i > n(e) ? t.setSize(e.height * i, e.height) : t.setSize(e.width, e.width / i), t.setPosition(e.centerX - t.width / 2, e.centerY - t.height / 2)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.x = Math.floor(t.x), t.y = Math.floor(t.y), t
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.x = Math.floor(t.x), t.y = Math.floor(t.y), t.width = Math.floor(t.width), t.height = Math.floor(t.height), t
				}
			}, function(t, e, i) {
				var n = i(11);
				t.exports = function(t, e, i, s, r) {
					return void 0 === r && (r = new n), r.setTo(Math.min(t, i), Math.min(e, s), Math.abs(t - i), Math.abs(e - s))
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e) {
					return void 0 === e && (e = new n), e.x = t.centerX, e.y = t.centerY, e
				}
			}, function(t, e, i) {
				var n = i(4);
				t.exports = function(t, e) {
					return void 0 === e && (e = new n), e.x = t.width, e.y = t.height, e
				}
			}, function(t, e, i) {
				var n = i(168);
				t.exports = function(t, e, i) {
					var s = t.centerX,
						r = t.centerY;
					return t.setSize(t.width + 2 * e, t.height + 2 * i), n(t, s, r)
				}
			}, function(t, e, i) {
				var n = i(11),
					s = i(135);
				t.exports = function(t, e, i) {
					return void 0 === i && (i = new n), s(t, e) ? (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y) : i.setEmpty(), i
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					for (var i = t.x, n = t.right, s = t.y, r = t.bottom, o = 0; o < e.length; o++) i = Math.min(i, e[o].x), n = Math.max(n, e[o].x), s = Math.min(s, e[o].y), r = Math.max(r, e[o].y);
					return t.x = i, t.y = s, t.width = n - i, t.height = r - s, t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					var i = Math.min(t.x, e.x),
						n = Math.max(t.right, e.right);
					t.x = i, t.width = n - i;
					var s = Math.min(t.y, e.y),
						r = Math.max(t.bottom, e.bottom);
					return t.y = s, t.height = r - s, t
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					var n = Math.min(t.x, e),
						s = Math.max(t.right, e);
					t.x = n, t.width = s - n;
					var r = Math.min(t.y, i),
						o = Math.max(t.bottom, i);
					return t.y = r, t.height = o - r, t
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return t.x += e, t.y += i, t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.x += e.x, t.y += e.y, t
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.x < e.right && t.right > e.x && t.y < e.bottom && t.bottom > e.y
				}
			}, function(t, e, i) {
				var n = i(4),
					s = i(39);
				t.exports = function(t, e, i) {
					void 0 === i && (i = new n), e = s(e);
					var r = Math.sin(e),
						o = Math.cos(e),
						a = 0 < o ? t.width / 2 : t.width / -2,
						h = 0 < r ? t.height / 2 : t.height / -2;
					return Math.abs(a * r) < Math.abs(h * o) ? h = a * r / o : a = h * o / r, i.x = a + t.centerX, i.y = h + t.centerY, i
				}
			}, function(t, e, i) {
				var n = i(172),
					s = i(445),
					r = i(4);
				t.exports = function(t, e, i) {
					if (void 0 === i && (i = new r), s(t, e)) switch (n(0, 3)) {
						case 0:
							i.x = t.x + Math.random() * (e.right - t.x), i.y = t.y + Math.random() * (e.top - t.y);
							break;
						case 1:
							i.x = e.x + Math.random() * (t.right - e.x), i.y = e.bottom + Math.random() * (t.bottom - e.bottom);
							break;
						case 2:
							i.x = t.x + Math.random() * (e.x - t.x), i.y = e.y + Math.random() * (t.bottom - e.y);
							break;
						case 3:
							i.x = e.right + Math.random() * (t.right - e.right), i.y = t.y + Math.random() * (e.bottom - t.y)
					}
					return i
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.width === e.width && t.height === e.height
				}
			}, function(t, e) {
				t.exports = function(t, e, i) {
					return void 0 === i && (i = e), t.width *= e, t.height *= i, t
				}
			}, function(t, e, i) {
				var n = i(71);
				n.Area = i(1187), n.BuildEquilateral = i(1188), n.BuildFromPolygon = i(1189), n.BuildRight = i(1190), n.CenterOn = i(1191), n.Centroid = i(446), n.CircumCenter = i(1192), n.CircumCircle = i(1193), n.Clone = i(1194), n.Contains = i(83), n.ContainsArray = i(210), n.ContainsPoint = i(1195), n.CopyFrom = i(1196), n.Decompose = i(439), n.Equals = i(1197), n.GetPoint = i(425), n.GetPoints = i(426), n.InCenter = i(448), n.Perimeter = i(1198), n.Offset = i(447), n.Random = i(158), n.Rotate = i(1199), n.RotateAroundPoint = i(1200), n.RotateAroundXY = i(213), t.exports = n
			}, function(t, e) {
				t.exports = function(t) {
					var e = t.x1,
						i = t.y1,
						n = t.x2,
						s = t.y2,
						r = t.x3,
						o = t.y3;
					return Math.abs(((r - e) * (s - i) - (n - e) * (o - i)) / 2)
				}
			}, function(t, e, i) {
				var n = i(71);
				t.exports = function(t, e, i) {
					var s = i * (Math.sqrt(3) / 2);
					return new n(t, e, t + i / 2, e + s, t - i / 2, e + s)
				}
			}, function(t, e, i) {
				var n = i(66),
					s = i(71);
				t.exports = function(t, e, i, r, o) {
					void 0 === e && (e = null), void 0 === i && (i = 1), void 0 === r && (r = 1), void 0 === o && (o = []);
					for (var a, h, u, l, c, d, f, p, g, v = n(t, e), m = 0; m < v.length; m += 3) a = v[m], h = v[m + 1], u = v[m + 2], l = t[2 * a] * i, c = t[2 * a + 1] * r, d = t[2 * h] * i, f = t[2 * h + 1] * r, p = t[2 * u] * i, g = t[2 * u + 1] * r, o.push(new s(l, c, d, f, p, g));
					return o
				}
			}, function(t, e, i) {
				var n = i(71);
				t.exports = function(t, e, i, s) {
					return void 0 === s && (s = i), new n(t, e, t, e - s, t + i, e)
				}
			}, function(t, e, i) {
				var n = i(446),
					s = i(447);
				t.exports = function(t, e, i, r) {
					void 0 === r && (r = n);
					var o = r(t),
						a = e - o.x,
						h = i - o.y;
					return s(t, a, h)
				}
			}, function(t, e, i) {
				var n = i(3);
				t.exports = function(t, e) {
					void 0 === e && (e = new n);
					var i = t.x3,
						s = t.y3,
						r = t.x1 - i,
						o = t.y1 - s,
						a = t.x2 - i,
						h = t.y2 - s,
						u = 2 * (r * h - o * a),
						l = o * (a * a + h * h) - (r * r + o * o) * h,
						c = r * (a * a + h * h) - (r * r + o * o) * a;
					return e.x = i - l / u, e.y = s + c / u, e
				}
			}, function(t, e, i) {
				var n = i(65);
				t.exports = function(t, e) {
					void 0 === e && (e = new n);
					var i, s, r, o, a = t.x1,
						h = t.y1,
						u = t.x2,
						l = t.y2,
						c = t.x3,
						d = t.y3,
						f = u - a,
						p = l - h,
						g = c - a,
						v = d - h,
						m = f * (a + u) + p * (h + l),
						y = g * (a + c) + v * (h + d),
						x = 2 * (f * (d - l) - p * (c - u));
					return Math.abs(x) < 1e-6 ? (i = Math.min(a, u, c), s = Math.min(h, l, d), r = .5 * (Math.max(a, u, c) - i), o = .5 * (Math.max(h, l, d) - s), e.x = i + r, e.y = s + o) : (e.x = (v * m - p * y) / x, e.y = (f * y - g * m) / x, r = e.x - a, o = e.y - h), e.radius = Math.sqrt(r * r + o * o), e
				}
			}, function(t, e, i) {
				var n = i(71);
				t.exports = function(t) {
					return new n(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3)
				}
			}, function(t, e, i) {
				var n = i(83);
				t.exports = function(t, e) {
					return n(t, e.x, e.y)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return e.setTo(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.x1 === e.x1 && t.y1 === e.y1 && t.x2 === e.x2 && t.y2 === e.y2 && t.x3 === e.x3 && t.y3 === e.y3
				}
			}, function(t, e, i) {
				var n = i(57);
				t.exports = function(t) {
					var e = t.getLineA(),
						i = t.getLineB(),
						s = t.getLineC();
					return n(e) + n(i) + n(s)
				}
			}, function(t, e, i) {
				var n = i(213),
					s = i(448);
				t.exports = function(t, e) {
					var i = s(t);
					return n(t, i.x, i.y, e)
				}
			}, function(t, e, i) {
				var n = i(213);
				t.exports = function(t, e, i) {
					return n(t, e.x, e.y, i)
				}
			}, function(t, e, i) {
				var n = i(179),
					s = i(18)(!1, s = {
						CreateInteractiveObject: i(449),
						Events: i(54),
						Gamepad: i(1202),
						InputManager: i(365),
						InputPlugin: i(1214),
						InputPluginCache: i(136),
						Keyboard: i(1216),
						Mouse: i(1233),
						Pointer: i(368),
						Touch: i(1234)
					}, n);
				t.exports = s
			}, function(t, e, i) {
				t.exports = {
					Axis: i(450),
					Button: i(451),
					Events: i(214),
					Gamepad: i(452),
					GamepadPlugin: i(1209),
					Configs: i(1210)
				}
			}, function(t, e) {
				t.exports = "down"
			}, function(t, e) {
				t.exports = "up"
			}, function(t, e) {
				t.exports = "connected"
			}, function(t, e) {
				t.exports = "disconnected"
			}, function(t, e) {
				t.exports = "down"
			}, function(t, e) {
				t.exports = "up"
			}, function(t, e, i) {
				var n = i(0),
					s = i(10),
					r = i(214),
					o = i(452),
					a = i(6),
					h = i(136),
					u = i(54),
					l = new n({
						Extends: s,
						initialize: function(t) {
							s.call(this), this.scene = t.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = t, this.enabled = !0, this.target, this.gamepads = [], this.queue = [], this.onGamepadHandler, this._pad1, this._pad2, this._pad3, this._pad4, t.pluginEvents.once(u.BOOT, this.boot, this), t.pluginEvents.on(u.START, this.start, this)
						},
						boot: function() {
							var t = this.scene.sys.game,
								e = this.settings.input,
								i = t.config;
							this.enabled = a(e, "gamepad", i.inputGamepad) && t.device.input.gamepads, this.target = a(e, "gamepad.target", i.inputGamepadEventTarget), this.sceneInputPlugin.pluginEvents.once(u.DESTROY, this.destroy, this)
						},
						start: function() {
							this.enabled && this.startListeners(), this.sceneInputPlugin.pluginEvents.once(u.SHUTDOWN, this.shutdown, this)
						},
						isActive: function() {
							return this.enabled && this.scene.sys.isActive()
						},
						startListeners: function() {
							function t(t) {
								!t.defaultPrevented && e.isActive() && (e.refreshPads(), e.queue.push(t))
							}
							var e = this,
								i = this.target;
							this.onGamepadHandler = t, i.addEventListener("gamepadconnected", t, !1), i.addEventListener("gamepaddisconnected", t, !1), this.sceneInputPlugin.pluginEvents.on(u.UPDATE, this.update, this)
						},
						stopListeners: function() {
							this.target.removeEventListener("gamepadconnected", this.onGamepadHandler), this.target.removeEventListener("gamepaddisconnected", this.onGamepadHandler), this.sceneInputPlugin.pluginEvents.off(u.UPDATE, this.update)
						},
						disconnectAll: function() {
							for (var t = 0; t < this.gamepads.length; t++) this.gamepads.connected = !1
						},
						refreshPads: function() {
							var t = navigator.getGamepads();
							if (t)
								for (var e = this.gamepads, i = 0; i < t.length; i++) {
									var n, s, r, a, h = t[i];
									h && (n = h.id, (r = e[s = h.index]) ? r.id !== n ? (r.destroy(), e[s] = new o(this, h)) : r.update(h) : (a = new o(this, h), e[s] = a, this._pad1 ? this._pad2 ? this._pad3 ? this._pad4 || (this._pad4 = a) : this._pad3 = a : this._pad2 = a : this._pad1 = a))
								} else this.disconnectAll()
						},
						getAll: function() {
							for (var t = [], e = this.gamepads, i = 0; i < e.length; i++) e[i] && t.push(e[i]);
							return t
						},
						getPad: function(t) {
							for (var e = this.gamepads, i = 0; i < e.length; i++)
								if (e[i] && e[i].index === t) return e[i]
						},
						update: function() {
							if (this.enabled) {
								this.refreshPads();
								var t = this.queue.length;
								if (0 !== t)
									for (var e = this.queue.splice(0, t), i = 0; i < t; i++) {
										var n = e[i],
											s = this.getPad(n.gamepad.index);
										"gamepadconnected" === n.type ? this.emit(r.CONNECTED, s, n) : "gamepaddisconnected" === n.type && this.emit(r.DISCONNECTED, s, n)
									}
							}
						},
						shutdown: function() {
							this.stopListeners(), this.disconnectAll(), this.removeAllListeners()
						},
						destroy: function() {
							this.shutdown();
							for (var t = 0; t < this.gamepads.length; t++) this.gamepads[t] && this.gamepads[t].destroy();
							this.gamepads = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.target = null
						},
						total: {
							get: function() {
								return this.gamepads.length
							}
						},
						pad1: {
							get: function() {
								return this._pad1
							}
						},
						pad2: {
							get: function() {
								return this._pad2
							}
						},
						pad3: {
							get: function() {
								return this._pad3
							}
						},
						pad4: {
							get: function() {
								return this._pad4
							}
						}
					});
				h.register("GamepadPlugin", l, "gamepad", "gamepad", "inputGamepad"), t.exports = l
			}, function(t, e, i) {
				t.exports = {
					DUALSHOCK_4: i(1211),
					SNES_USB: i(1212),
					XBOX_360: i(1213)
				}
			}, function(t, e) {
				t.exports = {
					UP: 12,
					DOWN: 13,
					LEFT: 14,
					RIGHT: 15,
					SHARE: 8,
					OPTIONS: 9,
					PS: 16,
					TOUCHBAR: 17,
					X: 0,
					CIRCLE: 1,
					SQUARE: 2,
					TRIANGLE: 3,
					L1: 4,
					R1: 5,
					L2: 6,
					R2: 7,
					L3: 10,
					R3: 11,
					LEFT_STICK_H: 0,
					LEFT_STICK_V: 1,
					RIGHT_STICK_H: 2,
					RIGHT_STICK_V: 3
				}
			}, function(t, e) {
				t.exports = {
					UP: 12,
					DOWN: 13,
					LEFT: 14,
					RIGHT: 15,
					SELECT: 8,
					START: 9,
					B: 0,
					A: 1,
					Y: 2,
					X: 3,
					LEFT_SHOULDER: 4,
					RIGHT_SHOULDER: 5
				}
			}, function(t, e) {
				t.exports = {
					UP: 12,
					DOWN: 13,
					LEFT: 14,
					RIGHT: 15,
					MENU: 16,
					A: 0,
					B: 1,
					X: 2,
					Y: 3,
					LB: 4,
					RB: 5,
					LT: 6,
					RT: 7,
					BACK: 8,
					START: 9,
					LS: 10,
					RS: 11,
					LEFT_STICK_H: 0,
					LEFT_STICK_V: 1,
					RIGHT_STICK_H: 2,
					RIGHT_STICK_V: 3
				}
			}, function(t, e, i) {
				var n = i(65),
					s = i(55),
					r = i(0),
					o = i(179),
					a = i(449),
					h = i(1215),
					u = i(53),
					l = i(95),
					c = i(96),
					d = i(54),
					f = i(10),
					p = i(2),
					g = i(47),
					v = i(136),
					m = i(7),
					y = i(23),
					x = i(11),
					T = i(48),
					w = i(22),
					E = i(71),
					_ = i(83),
					b = new r({
						Extends: f,
						initialize: function(t) {
							f.call(this), this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.manager = t.sys.game.input, this.pluginEvents = new f, this.enabled = !0, this.displayList, this.cameras, v.install(this), this.mouse = this.manager.mouse, this.topOnly = !0, this.pollRate = -1, this._pollTimer = 0;
							var e = {
								cancelled: !1
							};
							this._eventContainer = {
								stopPropagation: function() {
									e.cancelled = !0
								}
							}, this._eventData = e, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this._temp = [], this._tempZones = [], this._list = [], this._pendingInsertion = [], this._pendingRemoval = [], this._draggable = [], this._drag = {
								0: [],
								1: [],
								2: [],
								3: [],
								4: [],
								5: [],
								6: [],
								7: [],
								8: [],
								9: [],
								10: []
							}, this._dragState = [], this._over = {
								0: [],
								1: [],
								2: [],
								3: [],
								4: [],
								5: [],
								6: [],
								7: [],
								8: [],
								9: [],
								10: []
							}, this._validTypes = ["onDown", "onUp", "onOver", "onOut", "onMove", "onDragStart", "onDrag", "onDragEnd", "onDragEnter", "onDragLeave", "onDragOver", "onDrop"], this._updatedThisFrame = !1, t.sys.events.once(w.BOOT, this.boot, this), t.sys.events.on(w.START, this.start, this)
						},
						boot: function() {
							this.cameras = this.systems.cameras, this.displayList = this.systems.displayList, this.systems.events.once(w.DESTROY, this.destroy, this), this.pluginEvents.emit(d.BOOT)
						},
						start: function() {
							var t = this.systems.events;
							t.on(w.TRANSITION_START, this.transitionIn, this), t.on(w.TRANSITION_OUT, this.transitionOut, this), t.on(w.TRANSITION_COMPLETE, this.transitionComplete, this), t.on(w.PRE_UPDATE, this.preUpdate, this), t.once(w.SHUTDOWN, this.shutdown, this), this.manager.events.on(d.GAME_OUT, this.onGameOut, this), this.manager.events.on(d.GAME_OVER, this.onGameOver, this), this.enabled = !0, this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.pluginEvents.emit(d.START)
						},
						onGameOver: function(t) {
							this.isActive() && this.emit(d.GAME_OVER, t.timeStamp, t)
						},
						onGameOut: function(t) {
							this.isActive() && this.emit(d.GAME_OUT, t.timeStamp, t)
						},
						preUpdate: function() {
							this.pluginEvents.emit(d.PRE_UPDATE);
							var t = this._pendingRemoval,
								e = this._pendingInsertion,
								i = t.length,
								n = e.length;
							if (0 !== i || 0 !== n) {
								for (var s = this._list, r = 0; r < i; r++) {
									var o = t[r],
										a = s.indexOf(o); - 1 < a && (s.splice(a, 1), this.clear(o, !0))
								}
								t.length = 0, this._pendingRemoval.length = 0, this._list = s.concat(e.splice(0))
							}
						},
						isActive: function() {
							return this.enabled && this.scene.sys.isActive()
						},
						updatePoll: function(t, e) {
							if (!this.isActive()) return !1;
							if (this.pluginEvents.emit(d.UPDATE, t, e), this._updatedThisFrame) return this._updatedThisFrame = !1;
							for (var i = this.manager, n = i.pointers, s = i.pointersTotal, r = 0; r < s; r++) n[r].updateMotion();
							if (0 === this._list.length) return !1;
							var o = this.pollRate;
							if (-1 === o) return !1;
							if (0 < o) {
								if (this._pollTimer -= e, !(this._pollTimer < 0)) return !1;
								this._pollTimer = this.pollRate
							}
							var a = !1;
							for (r = 0; r < s; r++) {
								var h = 0,
									u = n[r];
								this._tempZones = [], this._temp = this.hitTestPointer(u), this.sortGameObjects(this._temp), this.sortGameObjects(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)), h += this.processOverOutEvents(u), 2 === this.getDragState(u) && this.processDragThresholdEvent(u, t), 0 < h && (a = !0)
							}
							return a
						},
						update: function(t, e) {
							if (!this.isActive()) return !1;
							for (var i = e.length, n = !1, s = 0; s < i; s++) {
								var r = 0,
									a = e[s];
								switch (this._tempZones = [], this._temp = this.hitTestPointer(a), this.sortGameObjects(this._temp), this.sortGameObjects(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)), t) {
									case o.MOUSE_DOWN:
										r += this.processDragDownEvent(a), r += this.processDownEvents(a), r += this.processOverOutEvents(a);
										break;
									case o.MOUSE_UP:
										r += this.processDragUpEvent(a), r += this.processUpEvents(a), r += this.processOverOutEvents(a);
										break;
									case o.TOUCH_START:
										r += this.processDragDownEvent(a), r += this.processDownEvents(a), r += this.processOverEvents(a);
										break;
									case o.TOUCH_END:
									case o.TOUCH_CANCEL:
										r += this.processDragUpEvent(a), r += this.processUpEvents(a), r += this.processOutEvents(a);
										break;
									case o.MOUSE_MOVE:
									case o.TOUCH_MOVE:
										r += this.processDragMoveEvent(a), r += this.processMoveEvents(a), r += this.processOverOutEvents(a);
										break;
									case o.MOUSE_WHEEL:
										r += this.processWheelEvent(a)
								}
								0 < r && (n = !0)
							}
							return this._updatedThisFrame = !0, n
						},
						clear: function(t, e) {
							void 0 === e && (e = !1);
							var i = t.input;
							if (i) {
								e || this.queueForRemoval(t), i.gameObject = void 0, i.target = void 0, i.hitArea = void 0, i.hitAreaCallback = void 0, i.callbackContext = void 0, this.manager.resetCursor(i), t.input = null;
								var n = this._draggable.indexOf(t);
								return -1 < n && this._draggable.splice(n, 1), -1 < (n = this._drag[0].indexOf(t)) && this._drag[0].splice(n, 1), -1 < (n = this._over[0].indexOf(t)) && this._over[0].splice(n, 1), t
							}
						},
						disable: function(t) {
							t.input.enabled = !1
						},
						enable: function(t, e, i, n) {
							return void 0 === n && (n = !1), t.input ? t.input.enabled = !0 : this.setHitArea(t, e, i), t.input && n && !t.input.dropZone && (t.input.dropZone = n), this
						},
						hitTestPointer: function(t) {
							for (var e = this.cameras.getCamerasBelowPointer(t), i = 0; i < e.length; i++) {
								for (var n = e[i], s = this.manager.hitTest(t, this._list, n), r = 0; r < s.length; r++) {
									var o = s[r];
									o.input.dropZone && this._tempZones.push(o)
								}
								if (0 < s.length) return t.camera = n, s
							}
							return t.camera = e[0], []
						},
						processDownEvents: function(t) {
							for (var e = 0, i = this._temp, n = this._eventData, s = this._eventContainer, r = n.cancelled = !1, o = 0; o < i.length; o++) {
								var a = i[o];
								if (a.input) {
									if (e++, a.emit(d.GAMEOBJECT_POINTER_DOWN, t, a.input.localX, a.input.localY, s), n.cancelled || !a.input) {
										r = !0;
										break
									}
									if (this.emit(d.GAMEOBJECT_DOWN, t, a, s), n.cancelled || !a.input) {
										r = !0;
										break
									}
								}
							}
							return !r && this.manager && (t.downElement === this.manager.game.canvas ? this.emit(d.POINTER_DOWN, t, i) : this.emit(d.POINTER_DOWN_OUTSIDE, t)), e
						},
						getDragState: function(t) {
							return this._dragState[t.id]
						},
						setDragState: function(t, e) {
							this._dragState[t.id] = e
						},
						processDragThresholdEvent: function(t, e) {
							var i = !1,
								n = this.dragTimeThreshold,
								s = this.dragDistanceThreshold;
							if ((0 < s && u(t.x, t.y, t.downX, t.downY) >= s || 0 < n && e >= t.downTime + n) && (i = !0), i) return this.setDragState(t, 3), this.processDragStartList(t)
						},
						processDragStartList: function(t) {
							if (3 !== this.getDragState(t)) return 0;
							for (var e = this._drag[t.id], i = 0; i < e.length; i++) {
								var n = e[i],
									s = n.input;
								s.dragState = 2, s.dragStartX = n.x, s.dragStartY = n.y, s.dragStartXGlobal = t.worldX, s.dragStartYGlobal = t.worldY, s.dragX = s.dragStartXGlobal - s.dragStartX, s.dragY = s.dragStartYGlobal - s.dragStartY, n.emit(d.GAMEOBJECT_DRAG_START, t, s.dragX, s.dragY), this.emit(d.DRAG_START, t, n)
							}
							return this.setDragState(t, 4), e.length
						},
						processDragDownEvent: function(t) {
							var e = this._temp;
							if (0 === this._draggable.length || 0 === e.length || !t.primaryDown || 0 !== this.getDragState(t)) return 0;
							this.setDragState(t, 1);
							for (var i = [], n = 0; n < e.length; n++) {
								var s = e[n];
								s.input.draggable && 0 === s.input.dragState && i.push(s)
							}
							return 0 === i.length ? (this.setDragState(t, 0), 0) : (1 < i.length && (this.sortGameObjects(i), this.topOnly && i.splice(1)), this._drag[t.id] = i, 0 === this.dragDistanceThreshold && 0 === this.dragTimeThreshold ? (this.setDragState(t, 3), this.processDragStartList(t)) : (this.setDragState(t, 2), 0))
						},
						processDragMoveEvent: function(t) {
							if (2 === this.getDragState(t) && this.processDragThresholdEvent(t, this.manager.game.loop.now), 4 !== this.getDragState(t)) return 0;
							for (var e = this._tempZones, i = this._drag[t.id], n = 0; n < i.length; n++) {
								var s, r, o, a, h, u, l, c, f = i[n],
									p = f.input,
									g = p.target;
								g ? 0 === (s = e.indexOf(g)) ? (f.emit(d.GAMEOBJECT_DRAG_OVER, t, g), this.emit(d.DRAG_OVER, t, f, g)) : 0 < s ? (f.emit(d.GAMEOBJECT_DRAG_LEAVE, t, g), this.emit(d.DRAG_LEAVE, t, f, g), p.target = e[0], g = p.target, f.emit(d.GAMEOBJECT_DRAG_ENTER, t, g), this.emit(d.DRAG_ENTER, t, f, g)) : (f.emit(d.GAMEOBJECT_DRAG_LEAVE, t, g), this.emit(d.DRAG_LEAVE, t, f, g), e[0] ? (p.target = e[0], g = p.target, f.emit(d.GAMEOBJECT_DRAG_ENTER, t, g), this.emit(d.DRAG_ENTER, t, f, g)) : p.target = null) : !g && e[0] && (p.target = e[0], g = p.target, f.emit(d.GAMEOBJECT_DRAG_ENTER, t, g), this.emit(d.DRAG_ENTER, t, f, g)), o = f.parentContainer ? (a = t.worldX - p.dragStartXGlobal, h = t.worldY - p.dragStartYGlobal, u = f.getParentRotation(), l = a * Math.cos(u) + h * Math.sin(u), c = h * Math.cos(u) - a * Math.sin(u), l *= 1 / f.parentContainer.scaleX, c *= 1 / f.parentContainer.scaleY, r = l + p.dragStartX, c + p.dragStartY) : (r = t.worldX - p.dragX, t.worldY - p.dragY), f.emit(d.GAMEOBJECT_DRAG, t, r, o), this.emit(d.DRAG, t, f, r, o)
							}
							return i.length
						},
						processDragUpEvent: function(t) {
							for (var e = this._drag[t.id], i = 0; i < e.length; i++) {
								var n, s, r = e[i],
									o = r.input;
								o && 2 === o.dragState && (o.dragState = 0, o.dragX = o.localX - r.displayOriginX, o.dragY = o.localY - r.displayOriginY, n = !1, (s = o.target) && (r.emit(d.GAMEOBJECT_DROP, t, s), this.emit(d.DROP, t, r, s), n = !(o.target = null)), r.input && (r.emit(d.GAMEOBJECT_DRAG_END, t, o.dragX, o.dragY, n), this.emit(d.DRAG_END, t, r, n)))
							}
							return this.setDragState(t, 0), e.splice(0), 0
						},
						processMoveEvents: function(t) {
							for (var e = 0, i = this._temp, n = this._eventData, s = this._eventContainer, r = n.cancelled = !1, o = 0; o < i.length; o++) {
								var a = i[o];
								if (a.input) {
									if (e++, a.emit(d.GAMEOBJECT_POINTER_MOVE, t, a.input.localX, a.input.localY, s), n.cancelled || !a.input) {
										r = !0;
										break
									}
									if (this.emit(d.GAMEOBJECT_MOVE, t, a, s), n.cancelled || !a.input) {
										r = !0;
										break
									}
									if (this.topOnly) break
								}
							}
							return r || this.emit(d.POINTER_MOVE, t, i), e
						},
						processWheelEvent: function(t) {
							for (var e = 0, i = this._temp, n = this._eventData, s = this._eventContainer, r = n.cancelled = !1, o = t.deltaX, a = t.deltaY, h = t.deltaZ, u = 0; u < i.length; u++) {
								var l = i[u];
								if (l.input) {
									if (e++, l.emit(d.GAMEOBJECT_POINTER_WHEEL, t, o, a, h, s), n.cancelled || !l.input) {
										r = !0;
										break
									}
									if (this.emit(d.GAMEOBJECT_WHEEL, t, l, o, a, h, s), n.cancelled || !l.input) {
										r = !0;
										break
									}
								}
							}
							return r || this.emit(d.POINTER_WHEEL, t, i, o, a, h), e
						},
						processOverEvents: function(t) {
							var e = this._temp,
								i = 0,
								n = e.length,
								s = [];
							if (0 < n) {
								for (var r = this.manager, o = this._eventData, a = this._eventContainer, h = o.cancelled = !1, u = 0; u < n; u++) {
									var l = e[u];
									if (l.input) {
										if (s.push(l), r.setCursor(l.input), l.emit(d.GAMEOBJECT_POINTER_OVER, t, l.input.localX, l.input.localY, a), i++, o.cancelled || !l.input) {
											h = !0;
											break
										}
										if (this.emit(d.GAMEOBJECT_OVER, t, l, a), o.cancelled || !l.input) {
											h = !0;
											break
										}
									}
								}
								h || this.emit(d.POINTER_OVER, t, s)
							}
							return this._over[t.id] = s, i
						},
						processOutEvents: function(t) {
							var e = this._over[t.id],
								i = 0,
								n = e.length;
							if (0 < n) {
								var s = this.manager,
									r = this._eventData,
									o = this._eventContainer,
									a = r.cancelled = !1;
								this.sortGameObjects(e);
								for (var h = 0; h < n; h++) {
									var u = e[h];
									for (h = 0; h < n; h++)
										if ((u = e[h]).input) {
											if (s.resetCursor(u.input), u.emit(d.GAMEOBJECT_POINTER_OUT, t, o), i++, r.cancelled || !u.input) {
												a = !0;
												break
											}
											if (this.emit(d.GAMEOBJECT_OUT, t, u, o), r.cancelled || !u.input) {
												a = !0;
												break
											}
										} a || this.emit(d.POINTER_OUT, t, e)
								}
								this._over[t.id] = []
							}
							return i
						},
						processOverOutEvents: function(t) {
							for (var e, i = this._temp, n = [], s = [], r = [], o = this._over[t.id], a = this._drag[t.id], h = this.manager, u = 0; u < o.length; u++) e = o[u], -1 === i.indexOf(e) && -1 === a.indexOf(e) ? n.push(e) : r.push(e);
							for (u = 0; u < i.length; u++) e = i[u], -1 === o.indexOf(e) && s.push(e);
							var l = n.length,
								c = 0,
								f = this._eventData,
								p = this._eventContainer,
								g = f.cancelled = !1;
							if (0 < l) {
								for (this.sortGameObjects(n), u = 0; u < l; u++)
									if ((e = n[u]).input) {
										if (h.resetCursor(e.input), e.emit(d.GAMEOBJECT_POINTER_OUT, t, p), c++, f.cancelled || !e.input) {
											g = !0;
											break
										}
										if (this.emit(d.GAMEOBJECT_OUT, t, e, p), f.cancelled || !e.input) {
											g = !0;
											break
										}
									} g || this.emit(d.POINTER_OUT, t, n)
							}
							if (l = s.length, g = f.cancelled = !1, 0 < l) {
								for (this.sortGameObjects(s), u = 0; u < l; u++)
									if ((e = s[u]).input) {
										if (h.setCursor(e.input), e.emit(d.GAMEOBJECT_POINTER_OVER, t, e.input.localX, e.input.localY, p), c++, f.cancelled || !e.input) {
											g = !0;
											break
										}
										if (this.emit(d.GAMEOBJECT_OVER, t, e, p), f.cancelled || !e.input) {
											g = !0;
											break
										}
									} g || this.emit(d.POINTER_OVER, t, s)
							}
							return o = r.concat(s), this._over[t.id] = this.sortGameObjects(o), c
						},
						processUpEvents: function(t) {
							for (var e = this._temp, i = this._eventData, n = this._eventContainer, s = i.cancelled = !1, r = 0; r < e.length; r++) {
								var o = e[r];
								if (o.input) {
									if (o.emit(d.GAMEOBJECT_POINTER_UP, t, o.input.localX, o.input.localY, n), i.cancelled || !o.input) {
										s = !0;
										break
									}
									if (this.emit(d.GAMEOBJECT_UP, t, o, n), i.cancelled || !o.input) {
										s = !0;
										break
									}
								}
							}
							return !s && this.manager && (t.upElement === this.manager.game.canvas ? this.emit(d.POINTER_UP, t, e) : this.emit(d.POINTER_UP_OUTSIDE, t)), e.length
						},
						queueForInsertion: function(t) {
							return -1 === this._pendingInsertion.indexOf(t) && -1 === this._list.indexOf(t) && this._pendingInsertion.push(t), this
						},
						queueForRemoval: function(t) {
							return this._pendingRemoval.push(t), this
						},
						setDraggable: function(t, e) {
							void 0 === e && (e = !0), Array.isArray(t) || (t = [t]);
							for (var i = 0; i < t.length; i++) {
								var n = t[i];
								n.input.draggable = e;
								var s = this._draggable.indexOf(n);
								e && -1 === s ? this._draggable.push(n) : !e && -1 < s && this._draggable.splice(s, 1)
							}
							return this
						},
						makePixelPerfect: function(t) {
							void 0 === t && (t = 1);
							var e = this.systems.textures;
							return h(e, t)
						},
						setHitArea: function(t, e, i) {
							if (void 0 === e) return this.setHitAreaFromTexture(t);
							Array.isArray(t) || (t = [t]);
							var n, s, r = !1,
								o = !1,
								h = !1,
								u = !1,
								l = !1,
								c = !0;
							m(e) ? (e = p(n = e, "hitArea", null), i = p(n, "hitAreaCallback", null), r = p(n, "draggable", !1), o = p(n, "dropZone", !1), h = p(n, "cursor", !1), u = p(n, "useHandCursor", !1), l = p(n, "pixelPerfect", !1), s = p(n, "alphaTolerance", 1), l && (e = {}, i = this.makePixelPerfect(s)), e && i || (this.setHitAreaFromTexture(t), c = !1)) : "function" != typeof e || i || (i = e, e = {});
							for (var d = 0; d < t.length; d++) {
								var f, g = t[d];
								l && "Container" === g.type ? console.warn("Cannot pixelPerfect test a Container. Use a custom callback.") : ((f = g.input ? g.input : a(g, e, i)).customHitArea = c, f.dropZone = o, f.cursor = u ? "pointer" : h, g.input = f, r && this.setDraggable(g), this.queueForInsertion(g))
							}
							return this
						},
						setHitAreaCircle: function(t, e, i, r, o) {
							void 0 === o && (o = s);
							var a = new n(e, i, r);
							return this.setHitArea(t, a, o)
						},
						setHitAreaEllipse: function(t, e, i, n, s, r) {
							void 0 === r && (r = c);
							var o = new l(e, i, n, s);
							return this.setHitArea(t, o, r)
						},
						setHitAreaFromTexture: function(t, e) {
							void 0 === e && (e = T), Array.isArray(t) || (t = [t]);
							for (var i = 0; i < t.length; i++) {
								var n = t[i],
									s = n.frame,
									r = 0,
									o = 0;
								n.width ? (r = n.width, o = n.height) : s && (r = s.realWidth, o = s.realHeight), "Container" !== n.type || 0 !== r && 0 !== o ? 0 !== r && 0 !== o && (n.input = a(n, new x(0, 0, r, o), e), this.queueForInsertion(n)) : console.warn("Container.setInteractive must specify a Shape or call setSize() first")
							}
							return this
						},
						setHitAreaRectangle: function(t, e, i, n, s, r) {
							void 0 === r && (r = T);
							var o = new x(e, i, n, s);
							return this.setHitArea(t, o, r)
						},
						setHitAreaTriangle: function(t, e, i, n, s, r, o, a) {
							void 0 === a && (a = _);
							var h = new E(e, i, n, s, r, o);
							return this.setHitArea(t, h, a)
						},
						enableDebug: function(t, e) {
							void 0 === e && (e = 65280);
							var i = t.input;
							if (!i || !i.hitArea) return this;
							var n = i.hitArea,
								s = n.type,
								r = i.hitAreaDebug,
								o = this.systems.add,
								a = this.systems.updateList;
							r && (a.remove(r), r.destroy(), r = null);
							var h = 0,
								u = 0;
							switch (s) {
								case g.CIRCLE:
									r = o.arc(0, 0, n.radius), h = n.x - n.radius, u = n.y - n.radius;
									break;
								case g.ELLIPSE:
									r = o.ellipse(0, 0, n.width, n.height), h = n.x - n.width / 2, u = n.y - n.height / 2;
									break;
								case g.LINE:
									r = o.line(0, 0, n.x1, n.y1, n.x2, n.y2);
									break;
								case g.POLYGON:
									r = o.polygon(0, 0, n.points);
									break;
								case g.RECTANGLE:
									r = o.rectangle(0, 0, n.width, n.height), h = n.x, u = n.y;
									break;
								case g.TRIANGLE:
									r = o.triangle(0, 0, n.x1, n.y1, n.x2, n.y2, n.x3, n.y3)
							}
							return r && (r.isFilled = !1, r.preUpdate = function() {
								r.setStrokeStyle(1 / t.scale, e), r.setDisplayOrigin(t.displayOriginX, t.displayOriginY);
								var i, n = t.x,
									s = t.y,
									o = t.rotation,
									a = t.scaleX,
									l = t.scaleY;
								t.parentContainer && (n = (i = t.getWorldTransformMatrix()).tx, s = i.ty, o = i.rotation, a = i.scaleX, l = i.scaleY), r.setRotation(o), r.setScale(a, l), r.setPosition(n + h, s + u), r.setScrollFactor(t.scrollFactorX, t.scrollFactorY), r.setDepth(t.depth)
							}, a.add(r), i.hitAreaDebug = r), this
						},
						removeDebug: function(t) {
							var e, i = t.input;
							return i && i.hitAreaDebug && (e = i.hitAreaDebug, this.systems.updateList.remove(e), e.destroy(), i.hitAreaDebug = null), this
						},
						setPollAlways: function() {
							return this.setPollRate(0)
						},
						setPollOnMove: function() {
							return this.setPollRate(-1)
						},
						setPollRate: function(t) {
							return this.pollRate = t, this._pollTimer = 0, this
						},
						setGlobalTopOnly: function(t) {
							return this.manager.globalTopOnly = t, this
						},
						setTopOnly: function(t) {
							return this.topOnly = t, this
						},
						sortGameObjects: function(t) {
							return t.length < 2 ? t : (this.scene.sys.depthSort(), t.sort(this.sortHandlerGO.bind(this)))
						},
						sortHandlerGO: function(t, e) {
							if (t.parentContainer || e.parentContainer) {
								if (t.parentContainer === e.parentContainer) return e.parentContainer.getIndex(e) - t.parentContainer.getIndex(t);
								if (t.parentContainer === e) return -1;
								if (e.parentContainer === t) return 1;
								for (var i = t.getIndexList(), n = e.getIndexList(), s = Math.min(i.length, n.length), r = 0; r < s; r++) {
									var o = i[r],
										a = n[r];
									if (o !== a) return a - o
								}
								return n.length - i.length
							}
							return this.displayList.getIndex(e) - this.displayList.getIndex(t)
						},
						stopPropagation: function() {
							return this.manager._tempSkip = !0, this
						},
						addPointer: function(t) {
							return this.manager.addPointer(t)
						},
						setDefaultCursor: function(t) {
							return this.manager.setDefaultCursor(t), this
						},
						transitionIn: function() {
							this.enabled = this.settings.transitionAllowInput
						},
						transitionComplete: function() {
							this.settings.transitionAllowInput || (this.enabled = !0)
						},
						transitionOut: function() {
							this.enabled = this.settings.transitionAllowInput
						},
						shutdown: function() {
							this.pluginEvents.emit(d.SHUTDOWN), this._temp.length = 0, this._list.length = 0, this._draggable.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0;
							for (var t = this._dragState.length = 0; t < 10; t++) this._drag[t] = [], this._over[t] = [];
							this.removeAllListeners();
							var e = this.systems.events;
							e.off(w.TRANSITION_START, this.transitionIn, this), e.off(w.TRANSITION_OUT, this.transitionOut, this), e.off(w.TRANSITION_COMPLETE, this.transitionComplete, this), e.off(w.PRE_UPDATE, this.preUpdate, this), this.manager.events.off(d.GAME_OUT, this.onGameOut, this), this.manager.events.off(d.GAME_OVER, this.onGameOver, this), e.off(w.SHUTDOWN, this.shutdown, this)
						},
						destroy: function() {
							this.shutdown(), this.pluginEvents.emit(d.DESTROY), this.pluginEvents.removeAllListeners(), this.scene.sys.events.off(w.START, this.start, this), this.scene = null, this.cameras = null, this.manager = null, this.events = null, this.mouse = null
						},
						x: {
							get: function() {
								return this.manager.activePointer.x
							}
						},
						y: {
							get: function() {
								return this.manager.activePointer.y
							}
						},
						isOver: {
							get: function() {
								return this.manager.isOver
							}
						},
						mousePointer: {
							get: function() {
								return this.manager.mousePointer
							}
						},
						activePointer: {
							get: function() {
								return this.manager.activePointer
							}
						},
						pointer1: {
							get: function() {
								return this.manager.pointers[1]
							}
						},
						pointer2: {
							get: function() {
								return this.manager.pointers[2]
							}
						},
						pointer3: {
							get: function() {
								return this.manager.pointers[3]
							}
						},
						pointer4: {
							get: function() {
								return this.manager.pointers[4]
							}
						},
						pointer5: {
							get: function() {
								return this.manager.pointers[5]
							}
						},
						pointer6: {
							get: function() {
								return this.manager.pointers[6]
							}
						},
						pointer7: {
							get: function() {
								return this.manager.pointers[7]
							}
						},
						pointer8: {
							get: function() {
								return this.manager.pointers[8]
							}
						},
						pointer9: {
							get: function() {
								return this.manager.pointers[9]
							}
						},
						pointer10: {
							get: function() {
								return this.manager.pointers[10]
							}
						}
					});
				y.register("InputPlugin", b, "input"), t.exports = b
			}, function(t, e) {
				t.exports = function(t, e) {
					return function(i, n, s, r) {
						var o = t.getPixelAlpha(n, s, r.texture.key, r.frame.name);
						return o && e <= o
					}
				}
			}, function(t, e, i) {
				t.exports = {
					Events: i(137),
					KeyboardManager: i(366),
					KeyboardPlugin: i(1224),
					Key: i(453),
					KeyCodes: i(124),
					KeyCombo: i(454),
					JustDown: i(1229),
					JustUp: i(1230),
					DownDuration: i(1231),
					UpDuration: i(1232)
				}
			}, function(t, e) {
				t.exports = "keydown"
			}, function(t, e) {
				t.exports = "keyup"
			}, function(t, e) {
				t.exports = "keycombomatch"
			}, function(t, e) {
				t.exports = "down"
			}, function(t, e) {
				t.exports = "keydown-"
			}, function(t, e) {
				t.exports = "keyup-"
			}, function(t, e) {
				t.exports = "up"
			}, function(t, e, i) {
				var n = i(0),
					s = i(10),
					r = i(137),
					o = i(20),
					a = i(6),
					h = i(54),
					u = i(136),
					l = i(453),
					c = i(124),
					d = i(454),
					f = i(1228),
					p = i(93),
					g = new n({
						Extends: s,
						initialize: function(t) {
							s.call(this), this.game = t.systems.game, this.scene = t.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = t, this.manager = t.manager.keyboard, this.enabled = !0, this.keys = [], this.combos = [], t.pluginEvents.once(h.BOOT, this.boot, this), t.pluginEvents.on(h.START, this.start, this)
						},
						boot: function() {
							var t = this.settings.input;
							this.enabled = a(t, "keyboard", !0);
							var e = a(t, "keyboard.capture", null);
							e && this.addCaptures(e), this.sceneInputPlugin.pluginEvents.once(h.DESTROY, this.destroy, this)
						},
						start: function() {
							this.sceneInputPlugin.manager.useQueue ? this.sceneInputPlugin.pluginEvents.on(h.UPDATE, this.update, this) : this.sceneInputPlugin.manager.events.on(h.MANAGER_PROCESS, this.update, this), this.sceneInputPlugin.pluginEvents.once(h.SHUTDOWN, this.shutdown, this), this.game.events.on(o.BLUR, this.resetKeys, this)
						},
						isActive: function() {
							return this.enabled && this.scene.sys.isActive()
						},
						addCapture: function(t) {
							return this.manager.addCapture(t), this
						},
						removeCapture: function(t) {
							return this.manager.removeCapture(t), this
						},
						getCaptures: function() {
							return this.manager.captures
						},
						enableGlobalCapture: function() {
							return this.manager.preventDefault = !0, this
						},
						disableGlobalCapture: function() {
							return this.manager.preventDefault = !1, this
						},
						clearCaptures: function() {
							return this.manager.clearCaptures(), this
						},
						createCursorKeys: function() {
							return this.addKeys({
								up: c.UP,
								down: c.DOWN,
								left: c.LEFT,
								right: c.RIGHT,
								space: c.SPACE,
								shift: c.SHIFT
							})
						},
						addKeys: function(t, e, i) {
							void 0 === e && (e = !0), void 0 === i && (i = !1);
							var n = {};
							if ("string" == typeof t) {
								t = t.split(",");
								for (var s = 0; s < t.length; s++) {
									var r = t[s].trim();
									r && (n[r] = this.addKey(r, e, i))
								}
							} else
								for (var o in t) n[o] = this.addKey(t[o], e, i);
							return n
						},
						addKey: function(t, e, i) {
							void 0 === e && (e = !0), void 0 === i && (i = !1);
							var n = this.keys;
							if (t instanceof l) {
								var s = n.indexOf(t);
								return -1 < s ? n[s] = t : n[t.keyCode] = t, e && this.addCapture(t.keyCode), t.setEmitOnRepeat(i), t
							}
							return "string" == typeof t && (t = c[t.toUpperCase()]), n[t] || (n[t] = new l(this, t), e && this.addCapture(t), n[t].setEmitOnRepeat(i)), n[t]
						},
						removeKey: function(t, e) {
							void 0 === e && (e = !1);
							var i, n, s = this.keys;
							return t instanceof l ? -1 < (n = s.indexOf(t)) && (i = this.keys[n], this.keys[n] = void 0) : "string" == typeof t && (t = c[t.toUpperCase()]), s[t] && (i = s[t], s[t] = void 0), i && (i.plugin = null, e && i.destroy()), this
						},
						removeAllKeys: function(t) {
							for (var e = this.keys, i = 0; i < e.length; i++) {
								var n = e[i];
								n && (e[i] = void 0, t && n.destroy())
							}
							return this
						},
						createCombo: function(t, e) {
							return new d(this, t, e)
						},
						checkDown: function(t, e) {
							if (void 0 === e && (e = 0), this.enabled && t.isDown) {
								var i = p(this.time - t.timeDown, e);
								if (i > t._tick) return t._tick = i, !0
							}
							return !1
						},
						update: function() {
							var t = this.manager.queue,
								e = t.length;
							if (this.isActive() && 0 !== e)
								for (var i = this.keys, n = 0; n < e; n++) {
									var s = t[n],
										o = s.keyCode,
										a = i[o],
										h = !1;
									void 0 === s.cancelled && (s.cancelled = 0, s.stopImmediatePropagation = function() {
										s.cancelled = 1
									}, s.stopPropagation = function() {
										s.cancelled = -1
									}), -1 !== s.cancelled && ("keydown" === s.type ? (a && (h = a.isDown, a.onDown(s)), s.cancelled || a && h || (f[o] && (this.emit(r.KEY_DOWN + f[o], s), this.emit("keydown_" + f[o], s)), s.cancelled || this.emit(r.ANY_KEY_DOWN, s))) : (a && a.onUp(s), s.cancelled || (f[o] && (this.emit(r.KEY_UP + f[o], s), this.emit("keyup_" + f[o], s)), s.cancelled || this.emit(r.ANY_KEY_UP, s))), 1 === s.cancelled && (s.cancelled = 0))
								}
						},
						resetKeys: function() {
							for (var t = this.keys, e = 0; e < t.length; e++) t[e] && t[e].reset();
							return this
						},
						shutdown: function() {
							this.resetKeys(), this.sceneInputPlugin.manager.useQueue ? this.sceneInputPlugin.pluginEvents.off(h.UPDATE, this.update, this) : this.sceneInputPlugin.manager.events.off(h.MANAGER_PROCESS, this.update, this), this.game.events.off(o.BLUR, this.resetKeys), this.removeAllListeners(), this.queue = []
						},
						destroy: function() {
							this.shutdown();
							for (var t = this.keys, e = 0; e < t.length; e++) t[e] && t[e].destroy();
							this.keys = [], this.combos = [], this.queue = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.manager = null
						},
						time: {
							get: function() {
								return this.sceneInputPlugin.manager.time
							}
						}
					});
				u.register("KeyboardPlugin", g, "keyboard", "keyboard", "inputKeyboard"), t.exports = g
			}, function(t, e, i) {
				var n = i(1226);
				t.exports = function(t, e) {
					if (e.matched) return !0;
					var i, s = !1,
						r = !1;
					return t.keyCode === e.current && (0 < e.index && 0 < e.maxKeyDelay ? (i = e.timeLastMatched + e.maxKeyDelay, t.timeStamp <= i && (r = !0, s = n(t, e))) : (r = !0, s = n(t, e))), !r && e.resetOnWrongKey && (e.index = 0, e.current = e.keyCodes[0]), s && (e.timeLastMatched = t.timeStamp, e.matched = !0, e.timeMatched = t.timeStamp), s
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return e.timeLastMatched = t.timeStamp, e.index++, e.index === e.size || (e.current = e.keyCodes[e.index], !1)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.current = t.keyCodes[0], t.index = 0, t.timeLastMatched = 0, t.matched = !1, t.timeMatched = 0, t
				}
			}, function(t, e, i) {
				var n = i(124),
					s = {};
				for (var r in n) s[n[r]] = r;
				t.exports = s
			}, function(t, e) {
				t.exports = function(t) {
					return !!t._justDown && !(t._justDown = !1)
				}
			}, function(t, e) {
				t.exports = function(t) {
					return !!t._justUp && !(t._justUp = !1)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					void 0 === e && (e = 50);
					var i = t.plugin.game.loop.time - t.timeDown;
					return t.isDown && i < e
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					void 0 === e && (e = 50);
					var i = t.plugin.game.loop.time - t.timeUp;
					return t.isUp && i < e
				}
			}, function(t, e, i) {
				t.exports = {
					MouseManager: i(367)
				}
			}, function(t, e, i) {
				t.exports = {
					TouchManager: i(369)
				}
			}, function(t, e, i) {
				var n = i(17),
					s = i(18)(!1, s = {
						Events: i(82),
						FileTypes: i(1236),
						File: i(21),
						FileTypesManager: i(8),
						GetURL: i(138),
						LoaderPlugin: i(1260),
						MergeXHRSettings: i(215),
						MultiFile: i(61),
						XHRLoader: i(455),
						XHRSettings: i(139)
					}, n);
				t.exports = s
			}, function(t, e, i) {
				t.exports = {
					AnimationJSONFile: i(1237),
					AtlasJSONFile: i(1238),
					AtlasXMLFile: i(1239),
					AudioFile: i(456),
					AudioSpriteFile: i(1240),
					BinaryFile: i(1241),
					BitmapFontFile: i(1242),
					CSSFile: i(1243),
					GLSLFile: i(1244),
					HTML5AudioFile: i(457),
					HTMLFile: i(1245),
					HTMLTextureFile: i(1246),
					ImageFile: i(72),
					JSONFile: i(60),
					MultiAtlasFile: i(1247),
					MultiScriptFile: i(1248),
					PackFile: i(1249),
					PluginFile: i(1250),
					SceneFile: i(1251),
					ScenePluginFile: i(1252),
					ScriptFile: i(458),
					SpriteSheetFile: i(1253),
					SVGFile: i(1254),
					TextFile: i(459),
					TilemapCSVFile: i(1255),
					TilemapImpactFile: i(1256),
					TilemapJSONFile: i(1257),
					UnityAtlasFile: i(1258),
					VideoFile: i(1259),
					XMLFile: i(216)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(8),
					r = i(60),
					o = i(82),
					a = new n({
						Extends: r,
						initialize: function(t, e, i, n, s) {
							r.call(this, t, e, i, n, s), this.type = "animationJSON"
						},
						onProcess: function() {
							this.loader.once(o.POST_PROCESS, this.onLoadComplete, this), r.prototype.onProcess.call(this)
						},
						onLoadComplete: function() {
							this.loader.systems.anims.fromJSON(this.data)
						}
					});
				s.register("animation", function(t, e, i, n) {
					if (Array.isArray(t))
						for (var s = 0; s < t.length; s++) this.addFile(new a(this, t[s]));
					else this.addFile(new a(this, t, e, n, i));
					return this
				}), t.exports = a
			}, function(t, e, i) {
				var n = i(0),
					s = i(8),
					r = i(2),
					o = i(72),
					a = i(7),
					h = i(60),
					u = i(61),
					l = new n({
						Extends: u,
						initialize: function(t, e, i, n, s, l) {
							var c, d, f = a(e) ? (e = r(d = e, "key"), c = new o(t, {
								key: e,
								url: r(d, "textureURL"),
								extension: r(d, "textureExtension", "png"),
								normalMap: r(d, "normalMap"),
								xhrSettings: r(d, "textureXhrSettings")
							}), new h(t, {
								key: e,
								url: r(d, "atlasURL"),
								extension: r(d, "atlasExtension", "json"),
								xhrSettings: r(d, "atlasXhrSettings")
							})) : (c = new o(t, e, i, s), new h(t, e, n, l));
							c.linkFile ? u.call(this, t, "atlasjson", e, [c, f, c.linkFile]) : u.call(this, t, "atlasjson", e, [c, f])
						},
						addToCache: function() {
							var t, e, i;
							this.isReadyToProcess() && (t = this.files[0], e = this.files[1], i = this.files[2] ? this.files[2].data : null, this.loader.textureManager.addAtlas(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0)
						}
					});
				s.register("atlas", function(t, e, i, n, s) {
					var r;
					if (Array.isArray(t))
						for (var o = 0; o < t.length; o++) r = new l(this, t[o]), this.addFile(r.files);
					else r = new l(this, t, e, i, n, s), this.addFile(r.files);
					return this
				}), t.exports = l
			}, function(t, e, i) {
				var n = i(0),
					s = i(8),
					r = i(2),
					o = i(72),
					a = i(7),
					h = i(61),
					u = i(216),
					l = new n({
						Extends: h,
						initialize: function(t, e, i, n, s, l) {
							var c, d, f = a(e) ? (e = r(d = e, "key"), c = new o(t, {
								key: e,
								url: r(d, "textureURL"),
								extension: r(d, "textureExtension", "png"),
								normalMap: r(d, "normalMap"),
								xhrSettings: r(d, "textureXhrSettings")
							}), new u(t, {
								key: e,
								url: r(d, "atlasURL"),
								extension: r(d, "atlasExtension", "xml"),
								xhrSettings: r(d, "atlasXhrSettings")
							})) : (c = new o(t, e, i, s), new u(t, e, n, l));
							c.linkFile ? h.call(this, t, "atlasxml", e, [c, f, c.linkFile]) : h.call(this, t, "atlasxml", e, [c, f])
						},
						addToCache: function() {
							var t, e, i;
							this.isReadyToProcess() && (t = this.files[0], e = this.files[1], i = this.files[2] ? this.files[2].data : null, this.loader.textureManager.addAtlasXML(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0)
						}
					});
				s.register("atlasXML", function(t, e, i, n, s) {
					var r;
					if (Array.isArray(t))
						for (var o = 0; o < t.length; o++) r = new l(this, t[o]), this.addFile(r.files);
					else r = new l(this, t, e, i, n, s), this.addFile(r.files);
					return this
				}), t.exports = l
			}, function(t, e, i) {
				var n = i(456),
					s = i(0),
					r = i(8),
					o = i(2),
					a = i(7),
					h = i(60),
					u = i(61),
					l = new s({
						Extends: u,
						initialize: function(t, e, i, s, r, l, c) {
							var d, f, p;
							a(e) && (e = o(d = e, "key"), i = o(d, "jsonURL"), s = o(d, "audioURL"), r = o(d, "audioConfig"), l = o(d, "audioXhrSettings"), c = o(d, "jsonXhrSettings")), s ? (p = n.create(t, e, s, r, l)) && (f = new h(t, e, i, c), u.call(this, t, "audiosprite", e, [p, f]), this.config.resourceLoad = !1) : (f = new h(t, e, i, c), u.call(this, t, "audiosprite", e, [f]), this.config.resourceLoad = !0, this.config.audioConfig = r, this.config.audioXhrSettings = l)
						},
						onFileComplete: function(t) {
							var e, i, s, r; - 1 !== this.files.indexOf(t) && (this.pending--, this.config.resourceLoad && "json" === t.type && t.data.hasOwnProperty("resources") && (e = t.data.resources, i = o(this.config, "audioConfig"), s = o(this.config, "audioXhrSettings"), (r = n.create(this.loader, t.key, e, i, s)) && (this.addToMultiFile(r), this.loader.addFile(r))))
						},
						addToCache: function() {
							var t, e;
							this.isReadyToProcess() && (t = this.files[0], e = this.files[1], t.addToCache(), e.addToCache(), this.complete = !0)
						}
					});
				r.register("audioSprite", function(t, e, i, n, s, r) {
					var o, a = this.systems.game,
						h = a.config.audio,
						u = a.device.audio;
					if (h && h.noAudio || !u.webAudio && !u.audioData) return this;
					if (Array.isArray(t))
						for (var c = 0; c < t.length; c++)(o = new l(this, t[c])).files && this.addFile(o.files);
					else(o = new l(this, t, e, i, n, s, r)).files && this.addFile(o.files);
					return this
				})
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = new n({
						Extends: r,
						initialize: function(t, e, i, n, s) {
							var o, u = "bin";
							h(e) && (e = a(o = e, "key"), i = a(o, "url"), n = a(o, "xhrSettings"), u = a(o, "extension", u), s = a(o, "dataType", s));
							var l = {
								type: "binary",
								cache: t.cacheManager.binary,
								extension: u,
								responseType: "arraybuffer",
								key: e,
								url: i,
								xhrSettings: n,
								config: {
									dataType: s
								}
							};
							r.call(this, t, l)
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING;
							var t = this.config.dataType;
							this.data = t ? new t(this.xhrLoader.response) : this.xhrLoader.response, this.onProcessComplete()
						}
					});
				o.register("binary", function(t, e, i, n) {
					if (Array.isArray(t))
						for (var s = 0; s < t.length; s++) this.addFile(new u(this, t[s]));
					else this.addFile(new u(this, t, e, n, i));
					return this
				}), t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(8),
					r = i(2),
					o = i(72),
					a = i(7),
					h = i(61),
					u = i(187),
					l = i(216),
					c = new n({
						Extends: h,
						initialize: function(t, e, i, n, s, u) {
							var c, d, f = a(e) ? (e = r(d = e, "key"), c = new o(t, {
								key: e,
								url: r(d, "textureURL"),
								extension: r(d, "textureExtension", "png"),
								normalMap: r(d, "normalMap"),
								xhrSettings: r(d, "textureXhrSettings")
							}), new l(t, {
								key: e,
								url: r(d, "fontDataURL"),
								extension: r(d, "fontDataExtension", "xml"),
								xhrSettings: r(d, "fontDataXhrSettings")
							})) : (c = new o(t, e, i, s), new l(t, e, n, u));
							c.linkFile ? h.call(this, t, "bitmapfont", e, [c, f, c.linkFile]) : h.call(this, t, "bitmapfont", e, [c, f])
						},
						addToCache: function() {
							var t, e;
							this.isReadyToProcess() && (t = this.files[0], e = this.files[1], t.addToCache(), e.addToCache(), this.loader.cacheManager.bitmapFont.add(t.key, {
								data: u(e.data),
								texture: t.key,
								frame: null
							}), this.complete = !0)
						}
					});
				s.register("bitmapFont", function(t, e, i, n, s) {
					var r;
					if (Array.isArray(t))
						for (var o = 0; o < t.length; o++) r = new c(this, t[o]), this.addFile(r.files);
					else r = new c(this, t, e, i, n, s), this.addFile(r.files);
					return this
				}), t.exports = c
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = new n({
						Extends: r,
						initialize: function(t, e, i, n) {
							var s, o = "css";
							h(e) && (e = a(s = e, "key"), i = a(s, "url"), n = a(s, "xhrSettings"), o = a(s, "extension", o));
							var u = {
								type: "script",
								cache: !1,
								extension: o,
								responseType: "text",
								key: e,
								url: i,
								xhrSettings: n
							};
							r.call(this, t, u)
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING, this.data = document.createElement("style"), this.data.defer = !1, this.data.innerHTML = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete()
						}
					});
				o.register("css", function(t, e, i) {
					if (Array.isArray(t))
						for (var n = 0; n < t.length; n++) this.addFile(new u(this, t[n]));
					else this.addFile(new u(this, t, e, i));
					return this
				}), t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = i(353),
					l = new n({
						Extends: r,
						initialize: function(t, e, i, n, s) {
							var o, u = "glsl";
							h(e) ? (e = a(o = e, "key"), i = a(o, "url"), n = a(o, "shaderType", "fragment"), s = a(o, "xhrSettings"), u = a(o, "extension", u)) : void 0 === n && (n = "fragment");
							var l = {
								type: "glsl",
								cache: t.cacheManager.shader,
								extension: u,
								responseType: "text",
								key: e,
								url: i,
								config: {
									shaderType: n
								},
								xhrSettings: s
							};
							r.call(this, t, l)
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete()
						},
						addToCache: function() {
							var t = this.data.split("\n"),
								e = this.extractBlock(t, 0);
							if (e)
								for (; e;) {
									var i, n = this.getShaderName(e.header),
										s = this.getShaderType(e.header),
										r = this.getShaderUniforms(e.header),
										o = e.shader;
									this.cache.has(n) ? (i = this.cache.get(n), "fragment" === s ? i.fragmentSrc = o : i.vertexSrc = o, i.uniforms || (i.uniforms = r)) : "fragment" === s ? this.cache.add(n, new u(n, o, "", r)) : this.cache.add(n, new u(n, "", o, r)), e = this.extractBlock(t, e.offset)
								} else "fragment" === this.config.shaderType ? this.cache.add(this.key, new u(this.key, this.data)) : this.cache.add(this.key, new u(this.key, "", this.data));
							this.pendingDestroy()
						},
						getShaderName: function(t) {
							for (var e = 0; e < t.length; e++) {
								var i = t[e].trim();
								if ("name:" === i.substring(0, 5)) return i.substring(5).trim()
							}
							return this.key
						},
						getShaderType: function(t) {
							for (var e = 0; e < t.length; e++) {
								var i = t[e].trim();
								if ("type:" === i.substring(0, 5)) return i.substring(5).trim()
							}
							return this.config.shaderType
						},
						getShaderUniforms: function(t) {
							for (var e = {}, i = 0; i < t.length; i++) {
								var n = t[i].trim();
								if ("uniform." === n.substring(0, 8)) {
									var s = n.indexOf(":");
									if (s) {
										var r = n.substring(8, s);
										try {
											e[r] = JSON.parse(n.substring(s + 1))
										} catch (t) {
											console.warn("Invalid uniform JSON: " + r)
										}
									}
								}
							}
							return e
						},
						extractBlock: function(t, e) {
							for (var i = -1, n = -1, s = -1, r = !1, o = !1, a = [], h = [], u = e; u < t.length; u++) {
								var l = t[u].trim();
								if ("---" === l)
									if (-1 === i) i = u, r = !0;
									else {
										if (!r) {
											o = !1;
											break
										}
										n = u, o = !(r = !1)
									}
								else r ? a.push(l) : o && (h.push(l), s = u)
							}
							return r || -1 === n ? null : {
								header: a,
								shader: h.join("\n"),
								offset: s
							}
						}
					});
				o.register("glsl", function(t, e, i, n) {
					if (Array.isArray(t))
						for (var s = 0; s < t.length; s++) this.addFile(new l(this, t[s]));
					else this.addFile(new l(this, t, e, i, n));
					return this
				}), t.exports = l
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = new n({
						Extends: r,
						initialize: function(t, e, i, n) {
							var s, o = "html";
							h(e) && (e = a(s = e, "key"), i = a(s, "url"), n = a(s, "xhrSettings"), o = a(s, "extension", o));
							var u = {
								type: "text",
								cache: t.cacheManager.html,
								extension: o,
								responseType: "text",
								key: e,
								url: i,
								xhrSettings: n
							};
							r.call(this, t, u)
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete()
						}
					});
				o.register("html", function(t, e, i) {
					if (Array.isArray(t))
						for (var n = 0; n < t.length; n++) this.addFile(new u(this, t[n]));
					else this.addFile(new u(this, t, e, i));
					return this
				}), t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = new n({
						Extends: r,
						initialize: function(t, e, i, n, s, o) {
							void 0 === n && (n = 512), void 0 === s && (s = 512);
							var u, l = "html";
							h(e) && (e = a(u = e, "key"), i = a(u, "url"), o = a(u, "xhrSettings"), l = a(u, "extension", l), n = a(u, "width", n), s = a(u, "height", s));
							var c = {
								type: "html",
								cache: t.textureManager,
								extension: l,
								responseType: "text",
								key: e,
								url: i,
								xhrSettings: o,
								config: {
									width: n,
									height: s
								}
							};
							r.call(this, t, c)
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING;
							var t = this.config.width,
								e = this.config.height,
								i = [];
							i.push('<svg width="' + t + 'px" height="' + e + 'px" viewBox="0 0 ' + t + " " + e + '" xmlns="http://www.w3.org/2000/svg">'), i.push('<foreignObject width="100%" height="100%">'), i.push('<body xmlns="http://www.w3.org/1999/xhtml">'), i.push(this.xhrLoader.responseText), i.push("</body>"), i.push("</foreignObject>"), i.push("</svg>");
							var n = [i.join("\n")],
								o = this;
							try {
								var a = new window.Blob(n, {
									type: "image/svg+xml;charset=utf-8"
								})
							} catch (t) {
								return o.state = s.FILE_ERRORED, void o.onProcessComplete()
							}
							this.data = new Image, this.data.crossOrigin = this.crossOrigin, this.data.onload = function() {
								r.revokeObjectURL(o.data), o.onProcessComplete()
							}, this.data.onerror = function() {
								r.revokeObjectURL(o.data), o.onProcessError()
							}, r.createObjectURL(this.data, a, "image/svg+xml")
						},
						addToCache: function() {
							var t = this.cache.addImage(this.key, this.data);
							this.pendingDestroy(t)
						}
					});
				o.register("htmlTexture", function(t, e, i, n, s) {
					if (Array.isArray(t))
						for (var r = 0; r < t.length; r++) this.addFile(new u(this, t[r]));
					else this.addFile(new u(this, t, e, i, n, s));
					return this
				}), t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(8),
					r = i(2),
					o = i(72),
					a = i(7),
					h = i(60),
					u = i(61),
					l = new n({
						Extends: u,
						initialize: function(t, e, i, n, s, o, l) {
							var c;
							a(e) && (e = r(c = e, "key"), i = r(c, "url", !1) ? r(c, "url") : r(c, "atlasURL"), o = r(c, "xhrSettings"), n = r(c, "path"), s = r(c, "baseURL"), l = r(c, "textureXhrSettings"));
							var d = new h(t, e, i, o);
							u.call(this, t, "multiatlas", e, [d]), this.config.path = n, this.config.baseURL = s, this.config.textureXhrSettings = l
						},
						onFileComplete: function(t) {
							if (-1 !== this.files.indexOf(t) && (this.pending--, "json" === t.type && t.data.hasOwnProperty("textures"))) {
								var e = t.data.textures,
									i = this.config,
									n = this.loader,
									s = n.baseURL,
									a = n.path,
									h = n.prefix,
									u = r(i, "baseURL", this.baseURL),
									l = r(i, "path", this.path),
									c = r(i, "prefix", this.prefix),
									d = r(i, "textureXhrSettings");
								n.setBaseURL(u), n.setPath(l), n.setPrefix(c);
								for (var f = 0; f < e.length; f++) {
									var p, g = e[f].image,
										v = "MA" + this.multiKeyIndex + "_" + g,
										m = new o(n, v, g, d);
									this.addToMultiFile(m), n.addFile(m), e[f].normalMap && ((p = new o(n, v, e[f].normalMap, d)).type = "normalMap", m.setLink(p), this.addToMultiFile(p), n.addFile(p))
								}
								n.setBaseURL(s), n.setPath(a), n.setPrefix(h)
							}
						},
						addToCache: function() {
							if (this.isReadyToProcess()) {
								for (var t = this.files[0], e = [], i = [], n = [], s = 1; s < this.files.length; s++) {
									var r = this.files[s];
									if ("normalMap" !== r.type)
										for (var o = r.key.indexOf("_"), a = r.key.substr(o + 1), h = r.data, u = 0; u < t.data.textures.length; u++) {
											var l = t.data.textures[u];
											if (l.image === a) {
												i.push(h), e.push(l), r.linkFile && n.push(r.linkFile.data);
												break
											}
										}
								}
								for (0 === n.length && (n = void 0), this.loader.textureManager.addAtlasJSONArray(this.key, i, e, n), this.complete = !0, s = 0; s < this.files.length; s++) this.files[s].pendingDestroy()
							}
						}
					});
				s.register("multiatlas", function(t, e, i, n, s) {
					var r;
					if (Array.isArray(t))
						for (var o = 0; o < t.length; o++) r = new l(this, t[o]), this.addFile(r.files);
					else r = new l(this, t, e, i, n, s), this.addFile(r.files);
					return this
				}), t.exports = l
			}, function(t, e, i) {
				var n = i(0),
					s = i(8),
					r = i(2),
					o = i(7),
					a = i(61),
					h = i(458),
					u = new n({
						Extends: a,
						initialize: function(t, e, i, n) {
							var s, u = "js",
								l = [];
							o(e) && (e = r(s = e, "key"), i = r(s, "url"), n = r(s, "xhrSettings"), u = r(s, "extension", u)), Array.isArray(i) || (i = [i]);
							for (var c = 0; c < i.length; c++) {
								var d = new h(t, {
									key: e + "_" + c.toString(),
									url: i[c],
									extension: u,
									xhrSettings: n
								});
								d.onProcess = function() {
									this.onProcessComplete()
								}, l.push(d)
							}
							a.call(this, t, "scripts", e, l)
						},
						addToCache: function() {
							if (this.isReadyToProcess()) {
								for (var t = 0; t < this.files.length; t++) {
									var e = this.files[t];
									e.data = document.createElement("script"), e.data.language = "javascript", e.data.type = "text/javascript", e.data.defer = !1, e.data.text = e.xhrLoader.responseText, document.head.appendChild(e.data)
								}
								this.complete = !0
							}
						}
					});
				s.register("scripts", function(t, e, i) {
					var n;
					if (Array.isArray(t))
						for (var s = 0; s < t.length; s++) n = new u(this, t[s]), this.addFile(n.files);
					else n = new u(this, t, e, i), this.addFile(n.files);
					return this
				}), t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(8),
					o = i(60),
					a = new n({
						Extends: o,
						initialize: function(t, e, i, n, s) {
							o.call(this, t, e, i, n, s), this.type = "packfile"
						},
						onProcess: function() {
							this.state !== s.FILE_POPULATED && (this.state = s.FILE_PROCESSING, this.data = JSON.parse(this.xhrLoader.responseText)), this.loader.addPack(this.data, this.config), this.onProcessComplete()
						}
					});
				r.register("pack", function(t, e, i, n) {
					if (Array.isArray(t))
						for (var s = 0; s < t.length; s++) this.addFile(new a(this, t[s]));
					else this.addFile(new a(this, t, e, n, i));
					return this
				}), t.exports = a
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = new n({
						Extends: r,
						initialize: function(t, e, i, n, o, u) {
							var l, c = "js";
							h(e) && (e = a(l = e, "key"), i = a(l, "url"), u = a(l, "xhrSettings"), c = a(l, "extension", c), n = a(l, "start"), o = a(l, "mapping"));
							var d = {
								type: "plugin",
								cache: !1,
								extension: c,
								responseType: "text",
								key: e,
								url: i,
								xhrSettings: u,
								config: {
									start: n,
									mapping: o
								}
							};
							r.call(this, t, d), "function" == typeof i && (this.data = i, this.state = s.FILE_POPULATED)
						},
						onProcess: function() {
							var t, e = this.loader.systems.plugins,
								i = this.config,
								n = a(i, "start", !1),
								r = a(i, "mapping", null);
							this.state === s.FILE_POPULATED ? e.install(this.key, this.data, n, r) : (this.state = s.FILE_PROCESSING, this.data = document.createElement("script"), this.data.language = "javascript", this.data.type = "text/javascript", this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), t = e.install(this.key, window[this.key], n, r), (n || r) && (this.loader.systems[r] = t, this.loader.scene[r] = t)), this.onProcessComplete()
						}
					});
				o.register("plugin", function(t, e, i, n, s) {
					if (Array.isArray(t))
						for (var r = 0; r < t.length; r++) this.addFile(new u(this, t[r]));
					else this.addFile(new u(this, t, e, i, n, s));
					return this
				}), t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = new n({
						Extends: r,
						initialize: function(t, e, i, n) {
							var s, o = "js";
							h(e) && (e = a(s = e, "key"), i = a(s, "url"), n = a(s, "xhrSettings"), o = a(s, "extension", o));
							var u = {
								type: "text",
								cache: t.cacheManager.text,
								extension: o,
								responseType: "text",
								key: e,
								url: i,
								xhrSettings: n
							};
							r.call(this, t, u)
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete()
						},
						addToCache: function() {
							var t = this.data.concat("(function(){\nreturn new " + this.key + "();\n}).call(this);"),
								e = eval;
							this.loader.sceneManager.add(this.key, e(t)), this.complete = !0
						}
					});
				o.register("sceneFile", function(t, e, i) {
					if (Array.isArray(t))
						for (var n = 0; n < t.length; n++) this.addFile(new u(this, t[n]));
					else this.addFile(new u(this, t, e, i));
					return this
				}), t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = new n({
						Extends: r,
						initialize: function(t, e, i, n, o, u) {
							var l, c = "js";
							h(e) && (e = a(l = e, "key"), i = a(l, "url"), u = a(l, "xhrSettings"), c = a(l, "extension", c), n = a(l, "systemKey"), o = a(l, "sceneKey"));
							var d = {
								type: "scenePlugin",
								cache: !1,
								extension: c,
								responseType: "text",
								key: e,
								url: i,
								xhrSettings: u,
								config: {
									systemKey: n,
									sceneKey: o
								}
							};
							r.call(this, t, d), "function" == typeof i && (this.data = i, this.state = s.FILE_POPULATED)
						},
						onProcess: function() {
							var t = this.loader.systems.plugins,
								e = this.config,
								i = this.key,
								n = a(e, "systemKey", i),
								r = a(e, "sceneKey", i);
							this.state === s.FILE_POPULATED ? t.installScenePlugin(n, this.data, r, this.loader.scene, !0) : (this.state = s.FILE_PROCESSING, this.data = document.createElement("script"), this.data.language = "javascript", this.data.type = "text/javascript", this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), t.installScenePlugin(n, window[this.key], r, this.loader.scene, !0)), this.onProcessComplete()
						}
					});
				o.register("scenePlugin", function(t, e, i, n, s) {
					if (Array.isArray(t))
						for (var r = 0; r < t.length; r++) this.addFile(new u(this, t[r]));
					else this.addFile(new u(this, t, e, i, n, s));
					return this
				}), t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(8),
					r = i(72),
					o = new n({
						Extends: r,
						initialize: function(t, e, i, n, s) {
							r.call(this, t, e, i, s, n), this.type = "spritesheet"
						},
						addToCache: function() {
							var t = this.cache.addSpriteSheet(this.key, this.data, this.config);
							this.pendingDestroy(t)
						}
					});
				s.register("spritesheet", function(t, e, i, n) {
					if (Array.isArray(t))
						for (var s = 0; s < t.length; s++) this.addFile(new o(this, t[s]));
					else this.addFile(new o(this, t, e, i, n));
					return this
				}), t.exports = o
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = new n({
						Extends: r,
						initialize: function(t, e, i, n, s) {
							var o, u = "svg";
							h(e) && (e = a(o = e, "key"), i = a(o, "url"), n = a(o, "svgConfig", {}), s = a(o, "xhrSettings"), u = a(o, "extension", u));
							var l = {
								type: "svg",
								cache: t.textureManager,
								extension: u,
								responseType: "text",
								key: e,
								url: i,
								xhrSettings: s,
								config: {
									width: a(n, "width"),
									height: a(n, "height"),
									scale: a(n, "scale")
								}
							};
							r.call(this, t, l)
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING;
							var t = this.xhrLoader.responseText,
								e = [t],
								i = this.config.width,
								n = this.config.height,
								o = this.config.scale;
							t: if (i && n || o) {
								var a, h = (new DOMParser).parseFromString(t, "text/xml").getElementsByTagName("svg")[0],
									u = h.hasAttribute("viewBox"),
									l = parseFloat(h.getAttribute("width")),
									c = parseFloat(h.getAttribute("height"));
								if (!u && l && c ? h.setAttribute("viewBox", "0  0 " + l + " " + c) : !u || l || c || (l = (a = h.getAttribute("viewBox").split(/\s+|,/))[2], c = a[3]), o) {
									if (!l || !c) break t;
									i = l * o, n = c * o
								}
								h.setAttribute("width", i.toString() + "px"), h.setAttribute("height", n.toString() + "px"), e = [(new XMLSerializer).serializeToString(h)]
							}
							try {
								var d = new window.Blob(e, {
									type: "image/svg+xml;charset=utf-8"
								})
							} catch (t) {
								return void this.onProcessError()
							}
							this.data = new Image, this.data.crossOrigin = this.crossOrigin;
							var f = this,
								p = !1;
							this.data.onload = function() {
								p || r.revokeObjectURL(f.data), f.onProcessComplete()
							}, this.data.onerror = function() {
								p ? f.onProcessError() : (p = !0, r.revokeObjectURL(f.data), f.data.src = "data:image/svg+xml," + encodeURIComponent(e.join("")))
							}, r.createObjectURL(this.data, d, "image/svg+xml")
						},
						addToCache: function() {
							var t = this.cache.addImage(this.key, this.data);
							this.pendingDestroy(t)
						}
					});
				o.register("svg", function(t, e, i, n) {
					if (Array.isArray(t))
						for (var s = 0; s < t.length; s++) this.addFile(new u(this, t[s]));
					else this.addFile(new u(this, t, e, i, n));
					return this
				}), t.exports = u
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(2),
					h = i(7),
					u = i(32),
					l = new n({
						Extends: r,
						initialize: function(t, e, i, n) {
							var s, o = "csv";
							h(e) && (e = a(s = e, "key"), i = a(s, "url"), n = a(s, "xhrSettings"), o = a(s, "extension", o));
							var l = {
								type: "tilemapCSV",
								cache: t.cacheManager.tilemap,
								extension: o,
								responseType: "text",
								key: e,
								url: i,
								xhrSettings: n
							};
							r.call(this, t, l), this.tilemapFormat = u.CSV
						},
						onProcess: function() {
							this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete()
						},
						addToCache: function() {
							var t = {
								format: this.tilemapFormat,
								data: this.data
							};
							this.cache.add(this.key, t), this.pendingDestroy(t)
						}
					});
				o.register("tilemapCSV", function(t, e, i) {
					if (Array.isArray(t))
						for (var n = 0; n < t.length; n++) this.addFile(new l(this, t[n]));
					else this.addFile(new l(this, t, e, i));
					return this
				}), t.exports = l
			}, function(t, e, i) {
				var n = i(0),
					s = i(8),
					r = i(60),
					o = i(32),
					a = new n({
						Extends: r,
						initialize: function(t, e, i, n) {
							r.call(this, t, e, i, n), this.type = "tilemapJSON", this.cache = t.cacheManager.tilemap
						},
						addToCache: function() {
							var t = {
								format: o.WELTMEISTER,
								data: this.data
							};
							this.cache.add(this.key, t), this.pendingDestroy(t)
						}
					});
				s.register("tilemapImpact", function(t, e, i) {
					if (Array.isArray(t))
						for (var n = 0; n < t.length; n++) this.addFile(new a(this, t[n]));
					else this.addFile(new a(this, t, e, i));
					return this
				}), t.exports = a
			}, function(t, e, i) {
				var n = i(0),
					s = i(8),
					r = i(60),
					o = i(32),
					a = new n({
						Extends: r,
						initialize: function(t, e, i, n) {
							r.call(this, t, e, i, n), this.type = "tilemapJSON", this.cache = t.cacheManager.tilemap
						},
						addToCache: function() {
							var t = {
								format: o.TILED_JSON,
								data: this.data
							};
							this.cache.add(this.key, t), this.pendingDestroy(t)
						}
					});
				s.register("tilemapTiledJSON", function(t, e, i) {
					if (Array.isArray(t))
						for (var n = 0; n < t.length; n++) this.addFile(new a(this, t[n]));
					else this.addFile(new a(this, t, e, i));
					return this
				}), t.exports = a
			}, function(t, e, i) {
				var n = i(0),
					s = i(8),
					r = i(2),
					o = i(72),
					a = i(7),
					h = i(61),
					u = i(459),
					l = new n({
						Extends: h,
						initialize: function(t, e, i, n, s, l) {
							var c, d, f = a(e) ? (e = r(d = e, "key"), c = new o(t, {
								key: e,
								url: r(d, "textureURL"),
								extension: r(d, "textureExtension", "png"),
								normalMap: r(d, "normalMap"),
								xhrSettings: r(d, "textureXhrSettings")
							}), new u(t, {
								key: e,
								url: r(d, "atlasURL"),
								extension: r(d, "atlasExtension", "txt"),
								xhrSettings: r(d, "atlasXhrSettings")
							})) : (c = new o(t, e, i, s), new u(t, e, n, l));
							c.linkFile ? h.call(this, t, "unityatlas", e, [c, f, c.linkFile]) : h.call(this, t, "unityatlas", e, [c, f])
						},
						addToCache: function() {
							var t, e, i;
							this.isReadyToProcess() && (t = this.files[0], e = this.files[1], i = this.files[2] ? this.files[2].data : null, this.loader.textureManager.addUnityAtlas(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0)
						}
					});
				s.register("unityAtlas", function(t, e, i, n, s) {
					var r;
					if (Array.isArray(t))
						for (var o = 0; o < t.length; o++) r = new l(this, t[o]), this.addFile(r.files);
					else r = new l(this, t, e, i, n, s), this.addFile(r.files);
					return this
				}), t.exports = l
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(21),
					o = i(8),
					a = i(138),
					h = i(2),
					u = i(7),
					l = new n({
						Extends: r,
						initialize: function(t, e, i, n, s, o, a) {
							void 0 === n && (n = "loadeddata"), void 0 === s && (s = !1), void 0 === o && (o = !1), "loadeddata" !== n && "canplay" !== n && "canplaythrough" !== n && (n = "loadeddata");
							var h = {
								type: "video",
								cache: t.cacheManager.video,
								extension: i.type,
								responseType: "blob",
								key: e,
								url: i.url,
								xhrSettings: a,
								config: {
									loadEvent: n,
									asBlob: s,
									noAudio: o
								}
							};
							this.onLoadCallback = this.onVideoLoadHandler.bind(this), this.onErrorCallback = this.onVideoErrorHandler.bind(this), r.call(this, t, h)
						},
						onProcess: function() {
							var t, e;
							this.state = s.FILE_PROCESSING, this.config.asBlob ? (t = this.createVideoElement(), this.data = t, (e = this).data.onloadeddata = function() {
								e.onProcessComplete()
							}, this.data.onerror = function() {
								r.revokeObjectURL(e.data), e.onProcessError()
							}, r.createObjectURL(t, this.xhrLoader.response, ""), t.load()) : this.onProcessComplete()
						},
						createVideoElement: function() {
							var t = document.createElement("video");
							return t.controls = !1, t.crossOrigin = this.loader.crossOrigin, this.config.noAudio && (t.muted = !0, t.defaultMuted = !0, t.setAttribute("autoplay", "autoplay")), t.setAttribute("playsinline", "playsinline"), t.setAttribute("preload", "auto"), t
						},
						onVideoLoadHandler: function(t) {
							var e = t.target;
							e.removeEventListener(this.config.loadEvent, this.onLoadCallback, !0), e.removeEventListener("error", this.onErrorCallback, !0), this.data = e, this.resetXHR(), this.loader.nextFile(this, !0)
						},
						onVideoErrorHandler: function(t) {
							var e = t.target;
							e && (e.removeEventListener(this.config.loadEvent, this.onLoadCallback, !0), e.removeEventListener("error", this.onErrorCallback, !0)), this.resetXHR(), this.loader.nextFile(this, !1)
						},
						load: function() {
							var t, e = this.config.loadEvent;
							this.config.asBlob ? r.prototype.load.call(this) : (this.percentComplete = 0, (t = this.createVideoElement()).addEventListener(e, this.onLoadCallback, !0), t.addEventListener("error", this.onErrorCallback, !0), t.src = a(this, this.loader.baseURL), t.load())
						}
					});
				l.create = function(t, e, i, n, s, r, o) {
					var a = t.systems.game;
					u(e) && (i = h(e, "url", []), n = h(e, "loadEvent", "loadeddata"), s = h(e, "asBlob", !1), r = h(e, "noAudio", !1), o = h(e, "xhrSettings"));
					var c = l.getVideoURL(a, i);
					if (c) return new l(t, e, c, n, s, r, o)
				}, l.getVideoURL = function(t, e) {
					Array.isArray(e) || (e = [e]);
					for (var i = 0; i < e.length; i++) {
						var n, s = h(e[i], "url", e[i]);
						if (0 === s.indexOf("blob:")) return {
							url: s,
							type: ""
						};
						if (n = 0 === s.indexOf("data:") ? s.split(",")[0].match(/\/(.*?);/) : s.match(/\.([a-zA-Z0-9]+)($|\?)/), n = h(e[i], "type", n ? n[1] : "").toLowerCase(), t.device.video[n]) return {
							url: s,
							type: n
						}
					}
					return null
				}, o.register("video", function(t, e, i, n, s, r) {
					var o;
					if (Array.isArray(t))
						for (var a = 0; a < t.length; a++)(o = l.create(this, t[a])) && this.addFile(o);
					else(o = l.create(this, t, e, i, n, s, r)) && this.addFile(o);
					return this
				}), t.exports = l
			}, function(t, e, i) {
				var n = i(0),
					s = i(17),
					r = i(133),
					o = i(10),
					a = i(82),
					h = i(8),
					u = i(2),
					l = i(23),
					c = i(22),
					d = i(139),
					f = new n({
						Extends: o,
						initialize: function(t) {
							o.call(this);
							var e = t.sys.game.config,
								i = t.sys.settings.loader;
							this.scene = t, this.systems = t.sys, this.cacheManager = t.sys.cache, this.textureManager = t.sys.textures, this.sceneManager = t.sys.game.scene, h.install(this), this.prefix = "", this.path = "", this.baseURL = "", this.setBaseURL(u(i, "baseURL", e.loaderBaseURL)), this.setPath(u(i, "path", e.loaderPath)), this.setPrefix(u(i, "prefix", e.loaderPrefix)), this.maxParallelDownloads = u(i, "maxParallelDownloads", e.loaderMaxParallelDownloads), this.xhr = d(u(i, "responseType", e.loaderResponseType), u(i, "async", e.loaderAsync), u(i, "user", e.loaderUser), u(i, "password", e.loaderPassword), u(i, "timeout", e.loaderTimeout), u(i, "withCredentials", e.loaderWithCredentials)), this.crossOrigin = u(i, "crossOrigin", e.loaderCrossOrigin), this.totalToLoad = 0, this.progress = 0, this.list = new r, this.inflight = new r, this.queue = new r, this._deleteQueue = new r, this.totalFailed = 0, this.totalComplete = 0, this.state = s.LOADER_IDLE, this.multiKeyIndex = 0, t.sys.events.once(c.BOOT, this.boot, this), t.sys.events.on(c.START, this.pluginStart, this)
						},
						boot: function() {
							this.systems.events.once(c.DESTROY, this.destroy, this)
						},
						pluginStart: function() {
							this.systems.events.once(c.SHUTDOWN, this.shutdown, this)
						},
						setBaseURL: function(t) {
							return void 0 === t && (t = ""), "" !== t && "/" !== t.substr(-1) && (t = t.concat("/")), this.baseURL = t, this
						},
						setPath: function(t) {
							return void 0 === t && (t = ""), "" !== t && "/" !== t.substr(-1) && (t = t.concat("/")), this.path = t, this
						},
						setPrefix: function(t) {
							return void 0 === t && (t = ""), this.prefix = t, this
						},
						setCORS: function(t) {
							return this.crossOrigin = t, this
						},
						addFile: function(t) {
							Array.isArray(t) || (t = [t]);
							for (var e = 0; e < t.length; e++) {
								var i = t[e];
								this.keyExists(i) || (this.list.set(i), this.emit(a.ADD, i.key, i.type, this, i), this.isLoading() && (this.totalToLoad++, this.updateProgress()))
							}
						},
						keyExists: function(t) {
							var e = t.hasCacheConflict();
							return e || this.list.iterate(function(i) {
								if (i.type === t.type && i.key === t.key) return !(e = !0)
							}), !e && this.isLoading() && (this.inflight.iterate(function(i) {
								if (i.type === t.type && i.key === t.key) return !(e = !0)
							}), this.queue.iterate(function(i) {
								if (i.type === t.type && i.key === t.key) return !(e = !0)
							})), e
						},
						addPack: function(t, e) {
							e && t.hasOwnProperty(e) && (t = {
								packKey: t[e]
							});
							var i = 0,
								n = this.baseURL,
								s = this.path,
								r = this.prefix;
							for (var o in t)
								if (Object.prototype.hasOwnProperty.call(t, o)) {
									var a = t[o],
										h = u(a, "baseURL", n),
										l = u(a, "path", s),
										c = u(a, "prefix", r),
										d = u(a, "files", null),
										f = u(a, "defaultType", "void");
									if (Array.isArray(d)) {
										this.setBaseURL(h), this.setPath(l), this.setPrefix(c);
										for (var p = 0; p < d.length; p++) {
											var g = d[p],
												v = g.hasOwnProperty("type") ? g.type : f;
											this[v] && (this[v](g), i++)
										}
									}
								} return this.setBaseURL(n), this.setPath(s), this.setPrefix(r), 0 < i
						},
						isLoading: function() {
							return this.state === s.LOADER_LOADING || this.state === s.LOADER_PROCESSING
						},
						isReady: function() {
							return this.state === s.LOADER_IDLE || this.state === s.LOADER_COMPLETE
						},
						start: function() {
							this.isReady() && (this.progress = 0, this.totalFailed = 0, this.totalComplete = 0, this.totalToLoad = this.list.size, this.emit(a.START, this), 0 === this.list.size ? this.loadComplete() : (this.state = s.LOADER_LOADING, this.inflight.clear(), this.queue.clear(), this.updateProgress(), this.checkLoadQueue(), this.systems.events.on(c.UPDATE, this.update, this)))
						},
						updateProgress: function() {
							this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad, this.emit(a.PROGRESS, this.progress)
						},
						update: function() {
							this.state === s.LOADER_LOADING && 0 < this.list.size && this.inflight.size < this.maxParallelDownloads && this.checkLoadQueue()
						},
						checkLoadQueue: function() {
							this.list.each(function(t) {
								if ((t.state === s.FILE_POPULATED || t.state === s.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) && (this.inflight.set(t), this.list.delete(t), t.crossOrigin || (t.crossOrigin = this.crossOrigin), t.load()), this.inflight.size === this.maxParallelDownloads) return !1
							}, this)
						},
						nextFile: function(t, e) {
							this.inflight && (this.inflight.delete(t), this.updateProgress(), e ? (this.totalComplete++, this.queue.set(t), this.emit(a.FILE_LOAD, t), t.onProcess()) : (this.totalFailed++, this._deleteQueue.set(t), this.emit(a.FILE_LOAD_ERROR, t), this.fileProcessComplete(t)))
						},
						fileProcessComplete: function(t) {
							this.scene && this.systems && this.systems.game && !this.systems.game.pendingDestroy && (t.state === s.FILE_ERRORED ? t.multiFile && t.multiFile.onFileFailed(t) : t.state === s.FILE_COMPLETE && (t.multiFile ? t.multiFile.isReadyToProcess() && t.multiFile.addToCache() : t.addToCache()), this.queue.delete(t), 0 === this.list.size && 0 === this.inflight.size && 0 === this.queue.size && this.loadComplete())
						},
						loadComplete: function() {
							this.emit(a.POST_PROCESS, this), this.list.clear(), this.inflight.clear(), this.queue.clear(), this.progress = 1, this.state = s.LOADER_COMPLETE, this.systems.events.off(c.UPDATE, this.update, this), this._deleteQueue.iterateLocal("destroy"), this._deleteQueue.clear(), this.emit(a.COMPLETE, this, this.totalComplete, this.totalFailed)
						},
						flagForRemoval: function(t) {
							this._deleteQueue.set(t)
						},
						saveJSON: function(t, e) {
							return this.save(JSON.stringify(t), e)
						},
						save: function(t, e, i) {
							void 0 === e && (e = "file.json"), void 0 === i && (i = "application/json");
							var n = new Blob([t], {
									type: i
								}),
								s = URL.createObjectURL(n),
								r = document.createElement("a");
							return r.download = e, r.textContent = "Download " + e, r.href = s, r.click(), this
						},
						reset: function() {
							this.list.clear(), this.inflight.clear(), this.queue.clear();
							var t = this.systems.game.config,
								e = this.systems.settings.loader;
							this.setBaseURL(u(e, "baseURL", t.loaderBaseURL)), this.setPath(u(e, "path", t.loaderPath)), this.setPrefix(u(e, "prefix", t.loaderPrefix)), this.state = s.LOADER_IDLE
						},
						shutdown: function() {
							this.reset(), this.state = s.LOADER_SHUTDOWN, this.systems.events.off(c.UPDATE, this.update, this), this.systems.events.off(c.SHUTDOWN, this.shutdown, this)
						},
						destroy: function() {
							this.shutdown(), this.state = s.LOADER_DESTROYED, this.systems.events.off(c.UPDATE, this.update, this), this.systems.events.off(c.START, this.pluginStart, this), this.list = null, this.inflight = null, this.queue = null, this.scene = null, this.systems = null, this.textureManager = null, this.cacheManager = null, this.sceneManager = null
						}
					});
				l.register("Loader", f, "load"), t.exports = f
			}, function(t, e, i) {
				var n = i(50),
					s = i(18)(!1, s = {
						ArcadePhysics: i(1262),
						Body: i(466),
						Collider: i(467),
						Components: i(217),
						Events: i(218),
						Factory: i(460),
						Group: i(462),
						Image: i(461),
						Sprite: i(140),
						StaticBody: i(472),
						StaticGroup: i(463),
						World: i(465)
					}, n);
				t.exports = s
			}, function(t, e, i) {
				var n = i(0),
					s = i(39),
					r = i(53),
					o = i(321),
					a = i(460),
					h = i(2),
					u = i(126),
					l = i(1275),
					c = i(464),
					d = i(23),
					f = i(22),
					p = i(3),
					g = i(465),
					v = new n({
						initialize: function(t) {
							this.scene = t, this.systems = t.sys, this.config = this.getConfig(), this.world, this.add, t.sys.events.once(f.BOOT, this.boot, this), t.sys.events.on(f.START, this.start, this)
						},
						boot: function() {
							this.world = new g(this.scene, this.config), this.add = new a(this.world), this.systems.events.once(f.DESTROY, this.destroy, this)
						},
						start: function() {
							this.world || (this.world = new g(this.scene, this.config), this.add = new a(this.world));
							var t = this.systems.events;
							t.on(f.UPDATE, this.world.update, this.world), t.on(f.POST_UPDATE, this.world.postUpdate, this.world), t.once(f.SHUTDOWN, this.shutdown, this)
						},
						getConfig: function() {
							var t = this.systems.game.config.physics,
								e = this.systems.settings.physics;
							return u(h(e, "arcade", {}), h(t, "arcade", {}))
						},
						overlap: function(t, e, i, n, s) {
							return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.world.collideObjects(t, e, i, n, s, !0)
						},
						collide: function(t, e, i, n, s) {
							return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.world.collideObjects(t, e, i, n, s, !1)
						},
						collideTiles: function(t, e, i, n, s) {
							return this.world.collideTiles(t, e, i, n, s)
						},
						overlapTiles: function(t, e, i, n, s) {
							return this.world.overlapTiles(t, e, i, n, s)
						},
						pause: function() {
							return this.world.pause()
						},
						resume: function() {
							return this.world.resume()
						},
						accelerateTo: function(t, e, i, n, s, r) {
							void 0 === n && (n = 60);
							var o = Math.atan2(i - t.y, e - t.x);
							return t.body.acceleration.setToPolar(o, n), void 0 !== s && void 0 !== r && t.body.maxVelocity.set(s, r), o
						},
						accelerateToObject: function(t, e, i, n, s) {
							return this.accelerateTo(t, e.x, e.y, i, n, s)
						},
						closest: function(t, e) {
							e = e || this.world.bodies.entries;
							for (var i = Number.MAX_VALUE, n = null, s = t.x, r = t.y, a = e.length, h = 0; h < a; h++) {
								var u, l = e[h],
									c = l.body || l;
								t !== l && t !== c && t !== c.gameObject && t !== c.center && (u = o(s, r, c.center.x, c.center.y)) < i && (n = l, i = u)
							}
							return n
						},
						furthest: function(t, e) {
							e = e || this.world.bodies.entries;
							for (var i = -1, n = null, s = t.x, r = t.y, a = e.length, h = 0; h < a; h++) {
								var u, l = e[h],
									c = l.body || l;
								t !== l && t !== c && t !== c.gameObject && t !== c.center && i < (u = o(s, r, c.center.x, c.center.y)) && (n = l, i = u)
							}
							return n
						},
						moveTo: function(t, e, i, n, s) {
							void 0 === n && (n = 60), void 0 === s && (s = 0);
							var o = Math.atan2(i - t.y, e - t.x);
							return 0 < s && (n = r(t.x, t.y, e, i) / (s / 1e3)), t.body.velocity.setToPolar(o, n), o
						},
						moveToObject: function(t, e, i, n) {
							return this.moveTo(t, e.x, e.y, i, n)
						},
						velocityFromAngle: function(t, e, i) {
							return void 0 === e && (e = 60), void 0 === i && (i = new p), i.setToPolar(s(t), e)
						},
						velocityFromRotation: function(t, e, i) {
							return void 0 === e && (e = 60), void 0 === i && (i = new p), i.setToPolar(t, e)
						},
						overlapRect: function(t, e, i, n, s, r) {
							return c(this.world, t, e, i, n, s, r)
						},
						overlapCirc: function(t, e, i, n, s) {
							return l(this.world, t, e, i, n, s)
						},
						shutdown: function() {
							var t;
							this.world && ((t = this.systems.events).off(f.UPDATE, this.world.update, this.world), t.off(f.POST_UPDATE, this.world.postUpdate, this.world), t.off(f.SHUTDOWN, this.shutdown, this), this.add.destroy(), this.world.destroy(), this.add = null, this.world = null)
						},
						destroy: function() {
							this.shutdown(), this.scene.sys.events.off(f.START, this.start, this), this.scene = null, this.systems = null
						}
					});
				d.register("ArcadePhysics", v, "arcadePhysics"), t.exports = v
			}, function(t, e) {
				t.exports = {
					setAcceleration: function(t, e) {
						return this.body.acceleration.set(t, e), this
					},
					setAccelerationX: function(t) {
						return this.body.acceleration.x = t, this
					},
					setAccelerationY: function(t) {
						return this.body.acceleration.y = t, this
					}
				}
			}, function(t, e) {
				t.exports = {
					setAngularVelocity: function(t) {
						return this.body.angularVelocity = t, this
					},
					setAngularAcceleration: function(t) {
						return this.body.angularAcceleration = t, this
					},
					setAngularDrag: function(t) {
						return this.body.angularDrag = t, this
					}
				}
			}, function(t, e) {
				t.exports = {
					setBounce: function(t, e) {
						return this.body.bounce.set(t, e), this
					},
					setBounceX: function(t) {
						return this.body.bounce.x = t, this
					},
					setBounceY: function(t) {
						return this.body.bounce.y = t, this
					},
					setCollideWorldBounds: function(t, e, i) {
						return this.body.setCollideWorldBounds(t, e, i), this
					}
				}
			}, function(t, e) {
				t.exports = {
					setDebug: function(t, e, i) {
						return this.debugShowBody = t, this.debugShowVelocity = e, this.debugBodyColor = i, this
					},
					setDebugBodyColor: function(t) {
						return this.body.debugBodyColor = t, this
					},
					debugShowBody: {
						get: function() {
							return this.body.debugShowBody
						},
						set: function(t) {
							this.body.debugShowBody = t
						}
					},
					debugShowVelocity: {
						get: function() {
							return this.body.debugShowVelocity
						},
						set: function(t) {
							this.body.debugShowVelocity = t
						}
					},
					debugBodyColor: {
						get: function() {
							return this.body.debugBodyColor
						},
						set: function(t) {
							this.body.debugBodyColor = t
						}
					}
				}
			}, function(t, e) {
				t.exports = {
					setDrag: function(t, e) {
						return this.body.drag.set(t, e), this
					},
					setDragX: function(t) {
						return this.body.drag.x = t, this
					},
					setDragY: function(t) {
						return this.body.drag.y = t, this
					},
					setDamping: function(t) {
						return this.body.useDamping = t, this
					}
				}
			}, function(t, e) {
				t.exports = {
					enableBody: function(t, e, i, n, s) {
						return t && this.body.reset(e, i), n && (this.body.gameObject.active = !0), s && (this.body.gameObject.visible = !0), this.body.enable = !0, this
					},
					disableBody: function(t, e) {
						return void 0 === t && (t = !1), void 0 === e && (e = !1), this.body.stop(), this.body.enable = !1, t && (this.body.gameObject.active = !1), e && (this.body.gameObject.visible = !1), this
					},
					refreshBody: function() {
						return this.body.updateFromGameObject(), this
					}
				}
			}, function(t, e) {
				t.exports = {
					setFriction: function(t, e) {
						return this.body.friction.set(t, e), this
					},
					setFrictionX: function(t) {
						return this.body.friction.x = t, this
					},
					setFrictionY: function(t) {
						return this.body.friction.y = t, this
					}
				}
			}, function(t, e) {
				t.exports = {
					setGravity: function(t, e) {
						return this.body.gravity.set(t, e), this
					},
					setGravityX: function(t) {
						return this.body.gravity.x = t, this
					},
					setGravityY: function(t) {
						return this.body.gravity.y = t, this
					}
				}
			}, function(t, e) {
				t.exports = {
					setImmovable: function(t) {
						return void 0 === t && (t = !0), this.body.immovable = t, this
					}
				}
			}, function(t, e) {
				t.exports = {
					setMass: function(t) {
						return this.body.mass = t, this
					}
				}
			}, function(t, e) {
				t.exports = {
					setOffset: function(t, e) {
						return this.body.setOffset(t, e), this
					},
					setSize: function(t, e, i) {
						return this.body.setSize(t, e, i), this
					},
					setBodySize: function(t, e, i) {
						return this.body.setSize(t, e, i), this
					},
					setCircle: function(t, e, i) {
						return this.body.setCircle(t, e, i), this
					}
				}
			}, function(t, e) {
				t.exports = {
					setVelocity: function(t, e) {
						return this.body.setVelocity(t, e), this
					},
					setVelocityX: function(t) {
						return this.body.setVelocityX(t), this
					},
					setVelocityY: function(t) {
						return this.body.setVelocityY(t), this
					},
					setMaxVelocity: function(t, e) {
						return this.body.maxVelocity.set(t, e), this
					}
				}
			}, function(t, e, i) {
				var n = i(464),
					s = i(65),
					r = i(205),
					o = i(206);
				t.exports = function(t, e, i, a, h, u) {
					var l = n(t, e - a, i - a, 2 * a, 2 * a, h, u);
					if (0 === l.length) return l;
					for (var c = new s(e, i, a), d = new s, f = [], p = 0; p < l.length; p++) {
						var g = l[p];
						g.isCircle ? (d.setTo(g.center.x, g.center.y, g.halfWidth), r(c, d) && f.push(g)) : o(c, g) && f.push(g)
					}
					return f
				}
			}, function(t, e) {
				t.exports = "collide"
			}, function(t, e) {
				t.exports = "overlap"
			}, function(t, e) {
				t.exports = "pause"
			}, function(t, e) {
				t.exports = "resume"
			}, function(t, e) {
				t.exports = "tilecollide"
			}, function(t, e) {
				t.exports = "tileoverlap"
			}, function(t, e) {
				t.exports = "worldbounds"
			}, function(t, e) {
				t.exports = "worldstep"
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.collisionCallback ? !t.collisionCallback.call(t.collisionCallbackContext, e, t) : !t.layer.callbacks[t.index] || !t.layer.callbacks[t.index].callback.call(t.layer.callbacks[t.index].callbackContext, e, t)
				}
			}, function(t, e, i) {
				var n = i(1286),
					s = i(1288),
					r = i(471);
				t.exports = function(t, e, i, o, a, h, u) {
					var l = o.left,
						c = o.top,
						d = o.right,
						f = o.bottom,
						p = i.faceLeft || i.faceRight,
						g = i.faceTop || i.faceBottom;
					if (u || (g = p = !0), !p && !g) return !1;
					var v = 0,
						m = 0,
						y = 0,
						x = 1;
					if (e.deltaAbsX() > e.deltaAbsY() ? y = -1 : e.deltaAbsX() < e.deltaAbsY() && (x = -1), 0 !== e.deltaX() && 0 !== e.deltaY() && p && g && (y = Math.min(Math.abs(e.position.x - d), Math.abs(e.right - l)), x = Math.min(Math.abs(e.position.y - f), Math.abs(e.bottom - c))), y < x) {
						if (p && 0 !== (v = n(e, i, l, d, h, u)) && !r(o, e)) return !0;
						g && (m = s(e, i, c, f, h, u))
					} else {
						if (g && 0 !== (m = s(e, i, c, f, h, u)) && !r(o, e)) return !0;
						p && (v = n(e, i, l, d, h, u))
					}
					return 0 !== v || 0 !== m
				}
			}, function(t, e, i) {
				var n = i(1287);
				t.exports = function(t, e, i, s, r, o) {
					var a = 0,
						h = e.faceLeft,
						u = e.faceRight,
						l = e.collideLeft,
						c = e.collideRight;
					return o || (c = l = u = h = !0), t.deltaX() < 0 && c && t.checkCollision.left ? u && t.x < s && (a = t.x - s) < -r && (a = 0) : 0 < t.deltaX() && l && t.checkCollision.right && h && t.right > i && r < (a = t.right - i) && (a = 0), 0 !== a && (t.customSeparateX ? t.overlapX = a : n(t, a)), a
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					e < 0 ? (t.blocked.none = !1, t.blocked.left = !0) : 0 < e && (t.blocked.none = !1, t.blocked.right = !0), t.position.x -= e, 0 === t.bounce.x ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x
				}
			}, function(t, e, i) {
				var n = i(1289);
				t.exports = function(t, e, i, s, r, o) {
					var a = 0,
						h = e.faceTop,
						u = e.faceBottom,
						l = e.collideUp,
						c = e.collideDown;
					return o || (c = l = u = h = !0), t.deltaY() < 0 && c && t.checkCollision.up ? u && t.y < s && (a = t.y - s) < -r && (a = 0) : 0 < t.deltaY() && l && t.checkCollision.down && h && t.bottom > i && r < (a = t.bottom - i) && (a = 0), 0 !== a && (t.customSeparateY ? t.overlapY = a : n(t, a)), a
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					e < 0 ? (t.blocked.none = !1, t.blocked.up = !0) : 0 < e && (t.blocked.none = !1, t.blocked.down = !0), t.position.y -= e, 0 === t.bounce.y ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y
				}
			}, function(t, e, i) {
				var n = i(468);
				t.exports = function(t, e, i, s) {
					var r = n(t, e, i, s);
					if (i || 0 === r || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== r || t.embedded && e.embedded;
					var o, a, h, u = t.velocity.x,
						l = e.velocity.x;
					return t.immovable || e.immovable ? t.immovable ? (e.x += r, e.velocity.x = u - l * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= r, t.velocity.x = l - u * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y)) : (r *= .5, t.x -= r, e.x += r, o = Math.sqrt(l * l * e.mass / t.mass) * (0 < l ? 1 : -1), o -= h = .5 * (o + (a = Math.sqrt(u * u * t.mass / e.mass) * (0 < u ? 1 : -1))), a -= h, t.velocity.x = h + o * t.bounce.x, e.velocity.x = h + a * e.bounce.x), !0
				}
			}, function(t, e, i) {
				var n = i(469);
				t.exports = function(t, e, i, s) {
					var r = n(t, e, i, s);
					if (i || 0 === r || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return 0 !== r || t.embedded && e.embedded;
					var o, a, h, u = t.velocity.y,
						l = e.velocity.y;
					return t.immovable || e.immovable ? t.immovable ? (e.y += r, e.velocity.y = u - l * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= r, t.velocity.y = l - u * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x)) : (r *= .5, t.y -= r, e.y += r, o = Math.sqrt(l * l * e.mass / t.mass) * (0 < l ? 1 : -1), o -= h = .5 * (o + (a = Math.sqrt(u * u * t.mass / e.mass) * (0 < u ? 1 : -1))), a -= h, t.velocity.y = h + o * t.bounce.y, e.velocity.y = h + a * e.bounce.y), !0
				}
			}, , , , , , , , , , , , , function(t, e, i) {
				t.exports = {
					BasePlugin: i(474),
					DefaultPlugins: i(175),
					PluginCache: i(23),
					PluginManager: i(370),
					ScenePlugin: i(1305)
				}
			}, function(t, e, i) {
				var n = i(474),
					s = i(0),
					r = i(22),
					o = new s({
						Extends: n,
						initialize: function(t, e) {
							n.call(this, e), this.scene = t, this.systems = t.sys, t.sys.events.once(r.BOOT, this.boot, this)
						},
						boot: function() {},
						destroy: function() {
							this.pluginManager = null, this.game = null, this.scene = null, this.systems = null
						}
					});
				t.exports = o
			}, function(t, e, i) {
				var n = i(18),
					s = i(177),
					r = n(!1, r = {
						Center: i(359),
						Events: i(92),
						Orientation: i(360),
						ScaleManager: i(371),
						ScaleModes: i(361),
						Zoom: i(362)
					}, s.CENTER);
				r = n(!1, r, s.ORIENTATION), r = n(!1, r, s.SCALE_MODE), r = n(!1, r, s.ZOOM), t.exports = r
			}, function(t, e, i) {
				var n = i(125),
					s = i(18)(!1, s = {
						Events: i(22),
						SceneManager: i(373),
						ScenePlugin: i(1308),
						Settings: i(375),
						Systems: i(180)
					}, n);
				t.exports = s
			}, function(t, e, i) {
				var n = i(19),
					s = i(0),
					r = i(22),
					o = i(2),
					a = i(23),
					h = new s({
						initialize: function(t) {
							this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.key = t.sys.settings.key, this.manager = t.sys.game.scene, this.transitionProgress = 0, this._elapsed = 0, this._target = null, this._duration = 0, this._onUpdate, this._onUpdateScope, this._willSleep = !1, this._willRemove = !1, t.sys.events.once(r.BOOT, this.boot, this), t.sys.events.on(r.START, this.pluginStart, this)
						},
						boot: function() {
							this.systems.events.once(r.DESTROY, this.destroy, this)
						},
						pluginStart: function() {
							this._target = null, this.systems.events.once(r.SHUTDOWN, this.shutdown, this)
						},
						start: function(t, e) {
							return void 0 === t && (t = this.key), this.manager.queueOp("stop", this.key), this.manager.queueOp("start", t, e), this
						},
						restart: function(t) {
							var e = this.key;
							return this.manager.queueOp("stop", e), this.manager.queueOp("start", e, t), this
						},
						transition: function(t) {
							void 0 === t && (t = {});
							var e = o(t, "target", !1),
								i = this.manager.getScene(e);
							if (!e || !this.checkValidTransition(i)) return !1;
							var n = o(t, "duration", 1e3);
							this._elapsed = 0, this._target = i, this._duration = n, this._willSleep = o(t, "sleep", !1), this._willRemove = o(t, "remove", !1);
							var s = o(t, "onUpdate", null);
							s && (this._onUpdate = s, this._onUpdateScope = o(t, "onUpdateScope", this.scene));
							var a = o(t, "allowInput", !1);
							this.settings.transitionAllowInput = a;
							var h = i.sys.settings;
							return h.isTransition = !0, h.transitionFrom = this.scene, h.transitionDuration = n, h.transitionAllowInput = a, o(t, "moveAbove", !1) ? this.manager.moveAbove(this.key, e) : o(t, "moveBelow", !1) && this.manager.moveBelow(this.key, e), i.sys.isSleeping() ? i.sys.wake(o(t, "data")) : this.manager.start(e, o(t, "data")), this.systems.events.emit(r.TRANSITION_OUT, i, n), this.systems.events.on(r.UPDATE, this.step, this), !0
						},
						checkValidTransition: function(t) {
							return !(!t || t.sys.isActive() || t.sys.isTransitioning() || t === this.scene || this.systems.isTransitioning())
						},
						step: function(t, e) {
							this._elapsed += e, this.transitionProgress = n(this._elapsed / this._duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.transitionProgress), this._elapsed >= this._duration && this.transitionComplete()
						},
						transitionComplete: function() {
							var t = this._target.sys,
								e = this._target.sys.settings;
							this.systems.events.off(r.UPDATE, this.step, this), t.events.emit(r.TRANSITION_COMPLETE, this.scene), e.isTransition = !1, e.transitionFrom = null, this._duration = 0, this._target = null, this._onUpdate = null, this._onUpdateScope = null, this._willRemove ? this.manager.remove(this.key) : this._willSleep ? this.systems.sleep() : this.manager.stop(this.key)
						},
						add: function(t, e, i, n) {
							return this.manager.add(t, e, i, n)
						},
						launch: function(t, e) {
							return t && t !== this.key && this.manager.queueOp("start", t, e), this
						},
						run: function(t, e) {
							return t && t !== this.key && this.manager.queueOp("run", t, e), this
						},
						pause: function(t, e) {
							return void 0 === t && (t = this.key), this.manager.queueOp("pause", t, e), this
						},
						resume: function(t, e) {
							return void 0 === t && (t = this.key), this.manager.queueOp("resume", t, e), this
						},
						sleep: function(t, e) {
							return void 0 === t && (t = this.key), this.manager.queueOp("sleep", t, e), this
						},
						wake: function(t, e) {
							return void 0 === t && (t = this.key), this.manager.queueOp("wake", t, e), this
						},
						switch: function(t) {
							return t !== this.key && this.manager.queueOp("switch", this.key, t), this
						},
						stop: function(t, e) {
							return void 0 === t && (t = this.key), this.manager.queueOp("stop", t, e), this
						},
						setActive: function(t, e, i) {
							void 0 === e && (e = this.key);
							var n = this.manager.getScene(e);
							return n && n.sys.setActive(t, i), this
						},
						setVisible: function(t, e) {
							void 0 === e && (e = this.key);
							var i = this.manager.getScene(e);
							return i && i.sys.setVisible(t), this
						},
						isSleeping: function(t) {
							return void 0 === t && (t = this.key), this.manager.isSleeping(t)
						},
						isActive: function(t) {
							return void 0 === t && (t = this.key), this.manager.isActive(t)
						},
						isPaused: function(t) {
							return void 0 === t && (t = this.key), this.manager.isPaused(t)
						},
						isVisible: function(t) {
							return void 0 === t && (t = this.key), this.manager.isVisible(t)
						},
						swapPosition: function(t, e) {
							return void 0 === e && (e = this.key), t !== e && this.manager.swapPosition(t, e), this
						},
						moveAbove: function(t, e) {
							return void 0 === e && (e = this.key), t !== e && this.manager.moveAbove(t, e), this
						},
						moveBelow: function(t, e) {
							return void 0 === e && (e = this.key), t !== e && this.manager.moveBelow(t, e), this
						},
						remove: function(t) {
							return void 0 === t && (t = this.key), this.manager.remove(t), this
						},
						moveUp: function(t) {
							return void 0 === t && (t = this.key), this.manager.moveUp(t), this
						},
						moveDown: function(t) {
							return void 0 === t && (t = this.key), this.manager.moveDown(t), this
						},
						bringToTop: function(t) {
							return void 0 === t && (t = this.key), this.manager.bringToTop(t), this
						},
						sendToBack: function(t) {
							return void 0 === t && (t = this.key), this.manager.sendToBack(t), this
						},
						get: function(t) {
							return this.manager.getScene(t)
						},
						getIndex: function(t) {
							return void 0 === t && (t = this.key), this.manager.getIndex(t)
						},
						shutdown: function() {
							var t = this.systems.events;
							t.off(r.SHUTDOWN, this.shutdown, this), t.off(r.POST_UPDATE, this.step, this), t.off(r.TRANSITION_OUT)
						},
						destroy: function() {
							this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null, this.settings = null, this.manager = null
						}
					});
				a.register("ScenePlugin", h, "scenePlugin"), t.exports = h
			}, function(t, e, i) {
				t.exports = {
					List: i(129),
					Map: i(162),
					ProcessQueue: i(186),
					RTree: i(470),
					Set: i(133),
					Size: i(372)
				}
			}, function(t, e, i) {
				var n = i(18),
					s = i(1311),
					r = n(!1, r = {
						CanvasTexture: i(377),
						Events: i(121),
						FilterMode: s,
						Frame: i(94),
						Parsers: i(379),
						Texture: i(182),
						TextureManager: i(376),
						TextureSource: i(378)
					}, s);
				t.exports = r
			}, function(t, e) {
				t.exports = {
					LINEAR: 0,
					NEAREST: 1
				}
			}, function(t, e, i) {
				t.exports = {
					Components: i(141),
					Parsers: i(1342),
					Formats: i(32),
					ImageCollection: i(485),
					ParseToTilemap: i(227),
					Tile: i(74),
					Tilemap: i(494),
					TilemapCreator: i(1351),
					TilemapFactory: i(1352),
					Tileset: i(104),
					LayerData: i(102),
					MapData: i(103),
					ObjectLayer: i(488),
					DynamicTilemapLayer: i(495),
					StaticTilemapLayer: i(496)
				}
			}, function(t, e, i) {
				var n = i(24),
					s = i(51);
				t.exports = function(t, e, i, r, o, a, h, u) {
					t < 0 && (t = 0), e < 0 && (e = 0), void 0 === h && (h = !0);
					for (var l = n(t, e, i, r, null, u), c = o - t, d = a - e, f = 0; f < l.length; f++) {
						var p = l[f].x + c,
							g = l[f].y + d;
						0 <= p && p < u.width && 0 <= g && g < u.height && u.data[g][p] && u.data[g][p].copy(l[f])
					}
					h && s(o - 1, a - 1, i + 2, r + 2, u)
				}
			}, function(t, e, i) {
				var n = i(143),
					s = i(144),
					r = i(24),
					o = i(475);
				t.exports = function(t, e, i, a, h, u) {
					void 0 === i && (i = {}), Array.isArray(t) || (t = [t]);
					var l = u.tilemapLayer;
					void 0 === a && (a = l.scene), void 0 === h && (h = a.cameras.main);
					for (var c = r(0, 0, u.width, u.height, null, u), d = [], f = 0; f < c.length; f++) {
						var p, g = c[f]; - 1 !== t.indexOf(g.index) && (i.x = n(g.x, h, u), i.y = s(g.y, h, u), p = a.make.sprite(i), d.push(p))
					}
					if ("number" == typeof e)
						for (f = 0; f < t.length; f++) o(t[f], e, 0, 0, u.width, u.height, u);
					else if (Array.isArray(e))
						for (f = 0; f < t.length; f++) o(t[f], e[f], 0, 0, u.width, u.height, u);
					return d
				}
			}, function(t, e, i) {
				var n = i(93),
					s = i(330);
				t.exports = function(t, e, i, r) {
					void 0 === i && (i = []), void 0 === r && (r = 0), i.length = 0;
					var o, a, h, u, l, c, d, f = t.tilemapLayer.tilemap,
						p = t.tilemapLayer,
						g = t.data,
						v = t.width,
						m = t.height,
						y = Math.floor(f.tileWidth * p.scaleX),
						x = Math.floor(f.tileHeight * p.scaleY),
						T = 0,
						w = v,
						E = 0,
						_ = m;
					if (p.skipCull || 1 !== p.scrollFactorX || 1 !== p.scrollFactorY || (o = n(e.worldView.x - p.x, y, 0, !0) - p.cullPaddingX, a = s(e.worldView.right - p.x, y, 0, !0) + p.cullPaddingX, h = n(e.worldView.y - p.y, x, 0, !0) - p.cullPaddingY, u = s(e.worldView.bottom - p.y, x, 0, !0) + p.cullPaddingY, T = Math.max(0, o), w = Math.min(v, a), E = Math.max(0, h), _ = Math.min(m, u)), 0 === r)
						for (c = E; c < _; c++)
							for (l = T; g[c] && l < w; l++)(d = g[c][l]) && -1 !== d.index && d.visible && 0 !== d.alpha && i.push(d);
					else if (1 === r)
						for (c = E; c < _; c++)
							for (l = w; g[c] && T <= l; l--)(d = g[c][l]) && -1 !== d.index && d.visible && 0 !== d.alpha && i.push(d);
					else if (2 === r)
						for (c = _; E <= c; c--)
							for (l = T; g[c] && l < w; l++)(d = g[c][l]) && -1 !== d.index && d.visible && 0 !== d.alpha && i.push(d);
					else if (3 === r)
						for (c = _; E <= c; c--)
							for (l = w; g[c] && T <= l; l--)(d = g[c][l]) && -1 !== d.index && d.visible && 0 !== d.alpha && i.push(d);
					return p.tilesDrawn = i.length, p.tilesTotal = v * m, i
				}
			}, function(t, e, i) {
				var n = i(24),
					s = i(51),
					r = i(73);
				t.exports = function(t, e, i, o, a, h, u) {
					for (var l = -1 !== u.collideIndexes.indexOf(t), c = n(e, i, o, a, null, u), d = 0; d < c.length; d++) c[d].index = t, r(c[d], l);
					h && s(e - 1, i - 1, o + 2, a + 2, u)
				}
			}, function(t, e, i) {
				var n = i(24);
				t.exports = function(t, e, i, s, r, o, a, h) {
					return n(i, s, r, o, a, h).filter(t, e)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					void 0 === e && (e = 0), void 0 === i && (i = !1);
					var s, r, o, a = 0;
					if (i) {
						for (r = n.height - 1; 0 <= r; r--)
							for (s = n.width - 1; 0 <= s; s--)
								if ((o = n.data[r][s]) && o.index === t) {
									if (a === e) return o;
									a += 1
								}
					} else
						for (r = 0; r < n.height; r++)
							for (s = 0; s < n.width; s++)
								if ((o = n.data[r][s]) && o.index === t) {
									if (a === e) return o;
									a += 1
								} return null
				}
			}, function(t, e, i) {
				var n = i(24);
				t.exports = function(t, e, i, s, r, o, a, h) {
					return n(i, s, r, o, a, h).find(t, e) || null
				}
			}, function(t, e, i) {
				var n = i(24);
				t.exports = function(t, e, i, s, r, o, a, h) {
					n(i, s, r, o, a, h).forEach(t, e)
				}
			}, function(t, e, i) {
				var n = i(142),
					s = i(63),
					r = i(64);
				t.exports = function(t, e, i, o, a) {
					var h = s(t, !0, o, a),
						u = r(e, !0, o, a);
					return n(h, u, i, a)
				}
			}, function(t, e, i) {
				function n(t, e) {
					return o.RectangleToTriangle(e, t)
				}
				var s = i(430),
					r = i(24),
					o = i(431),
					a = i(1),
					h = i(143),
					u = i(144),
					l = i(63),
					c = i(64);
				t.exports = function(t, e, i, d) {
					if (void 0 === t) return [];
					var f = a;
					t instanceof s.Circle ? f = o.CircleToRectangle : t instanceof s.Rectangle ? f = o.RectangleToRectangle : t instanceof s.Triangle ? f = n : t instanceof s.Line && (f = o.LineToRectangle);
					var p = l(t.left, !0, i, d),
						g = c(t.top, !0, i, d),
						v = Math.ceil(l(t.right, !1, i, d)),
						m = Math.ceil(c(t.bottom, !1, i, d)),
						y = Math.max(v - p, 1),
						x = Math.max(m - g, 1),
						T = r(p, g, y, x, e, d),
						w = d.tileWidth,
						E = d.tileHeight;
					d.tilemapLayer && (w *= d.tilemapLayer.scaleX, E *= d.tilemapLayer.scaleY);
					for (var _ = [], b = new s.Rectangle(0, 0, w, E), A = 0; A < T.length; A++) {
						var S = T[A];
						b.x = h(S.x, i, d), b.y = u(S.y, i, d), f(t, b) && _.push(S)
					}
					return _
				}
			}, function(t, e, i) {
				var n = i(24),
					s = i(63),
					r = i(64);
				t.exports = function(t, e, i, o, a, h, u) {
					var l = s(t, !0, h, u),
						c = r(e, !0, h, u),
						d = Math.ceil(s(t + i, !1, h, u)),
						f = Math.ceil(r(e + o, !1, h, u));
					return n(l, c, d - l, f - c, a, u)
				}
			}, function(t, e, i) {
				var n = i(476),
					s = i(63),
					r = i(64);
				t.exports = function(t, e, i, o) {
					var a = s(t, !0, i, o),
						h = r(e, !0, i, o);
					return n(a, h, o)
				}
			}, function(t, e, i) {
				var n = i(221),
					s = i(63),
					r = i(64);
				t.exports = function(t, e, i, o, a, h) {
					var u = s(e, !0, a, h),
						l = r(i, !0, a, h);
					return n(t, u, l, o, h)
				}
			}, function(t, e, i) {
				var n = i(51),
					s = i(221);
				t.exports = function(t, e, i, r, o) {
					if (!Array.isArray(t)) return null;
					void 0 === r && (r = !0), Array.isArray(t[0]) || (t = [t]);
					for (var a = t.length, h = t[0].length, u = 0; u < a; u++)
						for (var l = 0; l < h; l++) {
							var c = t[u][l];
							s(c, e + l, i + u, !1, o)
						}
					r && n(e - 1, i - 1, h + 2, a + 2, o)
				}
			}, function(t, e, i) {
				var n = i(24),
					s = i(185);
				t.exports = function(t, e, i, r, o, a) {
					var h, u = n(t, e, i, r, null, a);
					if (void 0 === o)
						for (o = [], h = 0; h < u.length; h++) - 1 === o.indexOf(u[h].index) && o.push(u[h].index);
					for (h = 0; h < u.length; h++) u[h].index = s(o)
				}
			}, function(t, e, i) {
				var n = i(477),
					s = i(63),
					r = i(64);
				t.exports = function(t, e, i, o, a, h) {
					var u = s(t, !0, a, h),
						l = r(e, !0, a, h);
					return n(u, l, i, o, h)
				}
			}, function(t, e, i) {
				var n = i(24),
					s = i(354),
					r = new s(105, 210, 231, 150),
					o = new s(243, 134, 48, 200),
					a = new s(40, 39, 37, 150);
				t.exports = function(t, e, i) {
					void 0 === e && (e = {});
					var s = void 0 !== e.tileColor ? e.tileColor : r,
						h = void 0 !== e.collidingTileColor ? e.collidingTileColor : o,
						u = void 0 !== e.faceColor ? e.faceColor : a,
						l = n(0, 0, i.width, i.height, null, i);
					t.translateCanvas(i.tilemapLayer.x, i.tilemapLayer.y), t.scaleCanvas(i.tilemapLayer.scaleX, i.tilemapLayer.scaleY);
					for (var c = 0; c < l.length; c++) {
						var d = l[c],
							f = d.width,
							p = d.height,
							g = d.pixelX,
							v = d.pixelY,
							m = d.collides ? h : s;
						null !== m && (t.fillStyle(m.color, m.alpha / 255), t.fillRect(g, v, f, p)), g += 1, v += 1, f -= 2, p -= 2, null !== u && (t.lineStyle(1, u.color, u.alpha / 255), d.faceTop && t.lineBetween(g, v, g + f, v), d.faceRight && t.lineBetween(g + f, v, g + f, v + p), d.faceBottom && t.lineBetween(g, v + p, g + f, v + p), d.faceLeft && t.lineBetween(g, v, g, v + p))
					}
				}
			}, function(t, e, i) {
				var n = i(73),
					s = i(51),
					r = i(222);
				t.exports = function(t, e, i, o, a) {
					void 0 === e && (e = !0), void 0 === i && (i = !0), Array.isArray(t) || (t = [t]), void 0 === a && (a = !0);
					for (var h = 0; h < t.length; h++) r(t[h], e, o);
					if (a)
						for (var u = 0; u < o.height; u++)
							for (var l = 0; l < o.width; l++) {
								var c = o.data[u][l];
								c && -1 !== t.indexOf(c.index) && n(c, e)
							}
					i && s(0, 0, o.width, o.height, o)
				}
			}, function(t, e, i) {
				var n = i(73),
					s = i(51),
					r = i(222);
				t.exports = function(t, e, i, o, a, h) {
					if (void 0 === i && (i = !0), void 0 === o && (o = !0), void 0 === h && (h = !0), !(e < t)) {
						for (var u = t; u <= e; u++) r(u, i, a);
						if (h)
							for (var l = 0; l < a.height; l++)
								for (var c = 0; c < a.width; c++) {
									var d = a.data[l][c];
									d && d.index >= t && d.index <= e && n(d, i)
								}
						o && s(0, 0, a.width, a.height, a)
					}
				}
			}, function(t, e, i) {
				var n = i(73),
					s = i(51),
					r = i(222);
				t.exports = function(t, e, i, o) {
					void 0 === e && (e = !0), void 0 === i && (i = !0), Array.isArray(t) || (t = [t]);
					for (var a = 0; a < o.height; a++)
						for (var h = 0; h < o.width; h++) {
							var u = o.data[a][h];
							u && -1 === t.indexOf(u.index) && (n(u, e), r(u.index, e, o))
						}
					i && s(0, 0, o.width, o.height, o)
				}
			}, function(t, e, i) {
				var n = i(73),
					s = i(51),
					r = i(108);
				t.exports = function(t, e, i, o) {
					void 0 === e && (e = !0), void 0 === i && (i = !0);
					for (var a = 0; a < o.height; a++)
						for (var h = 0; h < o.width; h++) {
							var u = o.data[a][h];
							if (u)
								for (var l in t)
									if (r(u.properties, l)) {
										var c = t[l];
										Array.isArray(c) || (c = [c]);
										for (var d = 0; d < c.length; d++) u.properties[l] === c[d] && n(u, e)
									}
						}
					i && s(0, 0, o.width, o.height, o)
				}
			}, function(t, e, i) {
				var n = i(73),
					s = i(51);
				t.exports = function(t, e, i) {
					void 0 === t && (t = !0), void 0 === e && (e = !0);
					for (var r = 0; r < i.height; r++)
						for (var o = 0; o < i.width; o++) {
							var a, h = i.data[r][o];
							h && (a = h.getCollisionGroup()) && a.objects && 0 < a.objects.length && n(h, t)
						}
					e && s(0, 0, i.width, i.height, i)
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					if ("number" == typeof t) n.callbacks[t] = null !== e ? {
						callback: e,
						callbackContext: i
					} : void 0;
					else
						for (var s = 0, r = t.length; s < r; s++) n.callbacks[t[s]] = null !== e ? {
							callback: e,
							callbackContext: i
						} : void 0
				}
			}, function(t, e, i) {
				var n = i(24);
				t.exports = function(t, e, i, s, r, o, a) {
					for (var h = n(t, e, i, s, null, a), u = 0; u < h.length; u++) h[u].setCollisionCallback(r, o)
				}
			}, function(t, e, i) {
				var n = i(24),
					s = i(114);
				t.exports = function(t, e, i, r, o) {
					var a = n(t, e, i, r, null, o),
						h = a.map(function(t) {
							return t.index
						});
					s(h);
					for (var u = 0; u < a.length; u++) a[u].index = h[u]
				}
			}, function(t, e, i) {
				var n = i(24);
				t.exports = function(t, e, i, s, r, o, a) {
					for (var h = n(i, s, r, o, null, a), u = 0; u < h.length; u++) h[u] && (h[u].index === t ? h[u].index = e : h[u].index === e && (h[u].index = t))
				}
			}, function(t, e, i) {
				var n = i(143),
					s = i(144),
					r = i(3);
				t.exports = function(t, e, i, o, a) {
					return void 0 === i && (i = new r(0, 0)), i.x = n(t, o, a), i.y = s(e, o, a), i
				}
			}, function(t, e, i) {
				var n = i(24);
				t.exports = function(t, e, i, s, r, o) {
					if (void 0 !== r) {
						for (var a = n(t, e, i, s, null, o), h = 0, u = 0; u < r.length; u++) h += r[u].weight;
						if (!(h <= 0))
							for (u = 0; u < a.length; u++) {
								for (var l = Math.random() * h, c = 0, d = -1, f = 0; f < r.length; f++)
									if (l <= (c += r[f].weight)) {
										var p = r[f].index;
										d = Array.isArray(p) ? p[Math.floor(Math.random() * p.length)] : p;
										break
									} a[u].index = d
							}
					}
				}
			}, function(t, e, i) {
				var n = i(63),
					s = i(64),
					r = i(3);
				t.exports = function(t, e, i, o, a, h) {
					return void 0 === o && (o = new r(0, 0)), o.x = n(t, i, a, h), o.y = s(e, i, a, h), o
				}
			}, function(t, e, i) {
				t.exports = {
					Parse: i(478),
					Parse2DArray: i(223),
					ParseCSV: i(479),
					Impact: i(1343),
					Tiled: i(1344)
				}
			}, function(t, e, i) {
				t.exports = {
					ParseTileLayers: i(492),
					ParseTilesets: i(493),
					ParseWeltmeister: i(491)
				}
			}, function(t, e, i) {
				t.exports = {
					AssignTileProperties: i(490),
					Base64Decode: i(482),
					BuildTilesetIndex: i(489),
					ParseGID: i(224),
					ParseImageLayers: i(483),
					ParseJSONTiled: i(480),
					ParseObject: i(226),
					ParseObjectLayers: i(487),
					ParseTileLayers: i(481),
					ParseTilesets: i(484)
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1346), s = i(1347);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e, i) {
				var n = i(9);
				t.exports = function(t, e, i, s) {
					e.cull(s);
					var r = e.culledTiles,
						o = r.length,
						a = s.alpha * e.alpha;
					if (!(0 === o || a <= 0))
						for (var h = e.gidMap, u = e.pipeline, l = n.getTintAppendFloatAlphaAndSwap, c = e.scrollFactorX, d = e.scrollFactorY, f = e.x, p = e.y, g = e.scaleX, v = e.scaleY, m = e.tileset, y = 0; y < m.length; y++)
							for (var x = m[y], T = x.glTexture, w = 0; w < o; w++) {
								var E, _, b, A, S, C, M, O, P = r[w],
									R = h[P.index];
								R === x && null !== (E = R.getTileTextureCoordinates(P.index)) && (_ = P.width, b = P.height, A = E.x, S = E.y, C = .5 * P.width, M = .5 * P.height, O = l(P.tint, a * P.alpha), u.batchTexture(e, T, T.width, T.height, f + (C + P.pixelX) * g, p + (M + P.pixelY) * v, P.width, P.height, g, v, P.rotation, P.flipX, P.flipY, c, d, C, M, A, S, _, b, O, O, O, O, !1, 0, 0, s, null, !0))
							}
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					e.cull(n);
					var r = e.culledTiles,
						o = r.length;
					if (0 !== o) {
						var a = t._tempMatrix1,
							h = t._tempMatrix2,
							u = t._tempMatrix3;
						h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(n.matrix);
						var l = t.currentContext,
							c = e.gidMap;
						l.save(), s ? (a.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y, a.multiply(h, u), u.copyToContext(l)) : (h.e -= n.scrollX * e.scrollFactorX, h.f -= n.scrollY * e.scrollFactorY, h.copyToContext(l));
						var d = n.alpha * e.alpha;
						(!t.antialias || 1 < e.scaleX || 1 < e.scaleY) && (l.imageSmoothingEnabled = !1);
						for (var f = 0; f < o; f++) {
							var p, g, v, m, y = r[f],
								x = c[y.index];
							x && (p = x.image.getSourceImage(), (g = x.getTileTextureCoordinates(y.index)) && (v = y.width / 2, m = y.height / 2, l.save(), l.translate(y.pixelX + v, y.pixelY + m), 0 !== y.rotation && l.rotate(y.rotation), (y.flipX || y.flipY) && l.scale(y.flipX ? -1 : 1, y.flipY ? -1 : 1), l.globalAlpha = d * y.alpha, l.drawImage(p, g.x, g.y, y.width, y.height, -v, -m, y.width, y.height), l.restore()))
						}
						l.restore()
					}
				}
			}, function(t, e, i) {
				var n = i(1),
					s = i(1);
				n = i(1349), s = i(1350);
				t.exports = {
					renderWebGL: n,
					renderCanvas: s
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n) {
					var s = e.tileset,
						r = e.pipeline,
						o = r.vertexBuffer;
					t.setPipeline(r), r.modelIdentity(), r.modelTranslate(e.x - n.scrollX * e.scrollFactorX, e.y - n.scrollY * e.scrollFactorY, 0), r.modelScale(e.scaleX, e.scaleY, 1), r.viewLoad2D(n.matrix.matrix);
					for (var a = 0; a < s.length; a++) e.upload(n, a), 0 < e.vertexCount[a] && (t.currentPipeline && 0 < t.currentPipeline.vertexCount && t.flush(), r.vertexBuffer = e.vertexBuffer[a], t.setPipeline(r), t.setTexture2D(s[a].glTexture, 0), t.gl.drawArrays(r.topology, 0, e.vertexCount[a]));
					r.vertexBuffer = o, r.viewIdentity(), r.modelIdentity()
				}
			}, function(t, e) {
				t.exports = function(t, e, i, n, s) {
					e.cull(n);
					var r = e.culledTiles,
						o = r.length;
					if (0 !== o) {
						var a = t._tempMatrix1,
							h = t._tempMatrix2,
							u = t._tempMatrix3;
						h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(n.matrix);
						var l = t.currentContext,
							c = e.gidMap;
						l.save(), s ? (a.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y, a.multiply(h, u), u.copyToContext(l)) : (h.e -= n.scrollX * e.scrollFactorX, h.f -= n.scrollY * e.scrollFactorY, h.copyToContext(l));
						var d = n.alpha * e.alpha;
						(!t.antialias || 1 < e.scaleX || 1 < e.scaleY) && (l.imageSmoothingEnabled = !1);
						for (var f = 0; f < o; f++) {
							var p, g, v, m, y, x, T = r[f],
								w = c[T.index];
							w && (p = w.image.getSourceImage(), (g = w.getTileTextureCoordinates(T.index)) && (y = (v = w.tileWidth) / 2, x = (m = w.tileHeight) / 2, l.save(), l.translate(T.pixelX + y, T.pixelY + x), 0 !== T.rotation && l.rotate(T.rotation), (T.flipX || T.flipY) && l.scale(T.flipX ? -1 : 1, T.flipY ? -1 : 1), l.globalAlpha = d * T.alpha, l.drawImage(p, g.x, g.y, v, m, -y, -x, v, m), l.restore()))
						}
						l.restore()
					}
				}
			}, function(t, e, i) {
				var n = i(16),
					s = i(227);
				n.register("tilemap", function(t) {
					var e = void 0 !== t ? t : {};
					return s(this.scene, e.key, e.tileWidth, e.tileHeight, e.width, e.height, e.data, e.insertNull)
				})
			}, function(t, e, i) {
				var n = i(5),
					s = i(227);
				n.register("tilemap", function(t, e, i, n, r, o, a) {
					return null === t && (t = void 0), null === e && (e = void 0), null === i && (i = void 0), null === n && (n = void 0), null === r && (r = void 0), s(this.scene, t, e, i, n, r, o, a)
				})
			}, function(t, e, i) {
				t.exports = {
					Clock: i(1354),
					TimerEvent: i(497)
				}
			}, function(t, e, i) {
				var n = i(0),
					s = i(23),
					r = i(22),
					o = i(497),
					a = new n({
						initialize: function(t) {
							this.scene = t, this.systems = t.sys, this.now = 0, this.timeScale = 1, this.paused = !1, this._active = [], this._pendingInsertion = [], this._pendingRemoval = [], t.sys.events.once(r.BOOT, this.boot, this), t.sys.events.on(r.START, this.start, this)
						},
						boot: function() {
							this.now = this.systems.game.loop.time, this.systems.events.once(r.DESTROY, this.destroy, this)
						},
						start: function() {
							var t = this.systems.events;
							t.on(r.PRE_UPDATE, this.preUpdate, this), t.on(r.UPDATE, this.update, this), t.once(r.SHUTDOWN, this.shutdown, this)
						},
						addEvent: function(t) {
							var e = new o(t);
							return this._pendingInsertion.push(e), e
						},
						delayedCall: function(t, e, i, n) {
							return this.addEvent({
								delay: t,
								callback: e,
								args: i,
								callbackScope: n
							})
						},
						clearPendingEvents: function() {
							return this._pendingInsertion = [], this
						},
						removeAllEvents: function() {
							return this._pendingRemoval = this._pendingRemoval.concat(this._active), this
						},
						preUpdate: function() {
							var t = this._pendingRemoval.length,
								e = this._pendingInsertion.length;
							if (0 !== t || 0 !== e) {
								for (var i, n = 0; n < t; n++) {
									i = this._pendingRemoval[n];
									var s = this._active.indexOf(i); - 1 < s && this._active.splice(s, 1), i.destroy()
								}
								for (n = 0; n < e; n++) i = this._pendingInsertion[n], this._active.push(i);
								this._pendingRemoval.length = 0, this._pendingInsertion.length = 0
							}
						},
						update: function(t, e) {
							if (this.now = t, !this.paused) {
								e *= this.timeScale;
								for (var i = 0; i < this._active.length; i++) {
									var n, s = this._active[i];
									s.paused || (s.elapsed += e * s.timeScale, s.elapsed >= s.delay && (n = s.elapsed - s.delay, s.elapsed = s.delay, !s.hasDispatched && s.callback && (s.hasDispatched = !0, s.callback.apply(s.callbackScope, s.args)), 0 < s.repeatCount ? (s.repeatCount--, s.elapsed = n, s.hasDispatched = !1) : this._pendingRemoval.push(s)))
								}
							}
						},
						shutdown: function() {
							for (var t = 0; t < this._pendingInsertion.length; t++) this._pendingInsertion[t].destroy();
							for (t = 0; t < this._active.length; t++) this._active[t].destroy();
							for (t = 0; t < this._pendingRemoval.length; t++) this._pendingRemoval[t].destroy();
							this._active.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0;
							var e = this.systems.events;
							e.off(r.PRE_UPDATE, this.preUpdate, this), e.off(r.UPDATE, this.update, this), e.off(r.SHUTDOWN, this.shutdown, this)
						},
						destroy: function() {
							this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null
						}
					});
				s.register("Clock", a, "time"), t.exports = a
			}, function(t, e, i) {
				var n = i(89),
					s = i(18)(!1, s = {
						Builders: i(1356),
						Events: i(232),
						TweenManager: i(1372),
						Tween: i(231),
						TweenData: i(233),
						Timeline: i(503)
					}, n);
				t.exports = s
			}, function(t, e, i) {
				t.exports = {
					GetBoolean: i(88),
					GetEaseFunction: i(69),
					GetNewValue: i(145),
					GetProps: i(498),
					GetTargets: i(228),
					GetTweens: i(499),
					GetValueOp: i(229),
					NumberTweenBuilder: i(500),
					StaggerBuilder: i(501),
					TimelineBuilder: i(502),
					TweenBuilder: i(146)
				}
			}, function(t, e) {
				t.exports = ["callbackScope", "completeDelay", "delay", "duration", "ease", "easeParams", "flipX", "flipY", "hold", "loop", "loopDelay", "offset", "onActive", "onActiveParams", "onActiveScope", "onComplete", "onCompleteParams", "onCompleteScope", "onLoop", "onLoopParams", "onLoopScope", "onRepeat", "onRepeatParams", "onRepeatScope", "onStart", "onStartParams", "onStartScope", "onStop", "onStopParams", "onStopScope", "onUpdate", "onUpdateParams", "onUpdateScope", "onYoyo", "onYoyoParams", "onYoyoScope", "paused", "props", "repeat", "repeatDelay", "targets", "useFrames", "yoyo"]
			}, function(t, e) {
				t.exports = "complete"
			}, function(t, e) {
				t.exports = "loop"
			}, function(t, e) {
				t.exports = "pause"
			}, function(t, e) {
				t.exports = "resume"
			}, function(t, e) {
				t.exports = "start"
			}, function(t, e) {
				t.exports = "update"
			}, function(t, e) {
				t.exports = "active"
			}, function(t, e) {
				t.exports = "complete"
			}, function(t, e) {
				t.exports = "loop"
			}, function(t, e) {
				t.exports = "repeat"
			}, function(t, e) {
				t.exports = "start"
			}, function(t, e) {
				t.exports = "stop"
			}, function(t, e) {
				t.exports = "update"
			}, function(t, e) {
				t.exports = "yoyo"
			}, function(t, e, i) {
				var n = i(123),
					s = i(0),
					r = i(500),
					o = i(23),
					a = i(22),
					h = i(501),
					u = i(502),
					l = i(89),
					c = i(146),
					d = new s({
						initialize: function(t) {
							this.scene = t, this.systems = t.sys, this.timeScale = 1, this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0, t.sys.events.once(a.BOOT, this.boot, this), t.sys.events.on(a.START, this.start, this)
						},
						boot: function() {
							this.systems.events.once(a.DESTROY, this.destroy, this)
						},
						start: function() {
							var t = this.systems.events;
							t.on(a.PRE_UPDATE, this.preUpdate, this), t.on(a.UPDATE, this.update, this), t.once(a.SHUTDOWN, this.shutdown, this), this.timeScale = 1
						},
						createTimeline: function(t) {
							return u(this, t)
						},
						timeline: function(t) {
							var e = u(this, t);
							return e.paused || (this._add.push(e), this._toProcess++), e
						},
						create: function(t) {
							return c(this, t)
						},
						add: function(t) {
							var e = c(this, t);
							return this._add.push(e), this._toProcess++, e
						},
						existing: function(t) {
							return this._add.push(t), this._toProcess++, this
						},
						addCounter: function(t) {
							var e = r(this, t);
							return this._add.push(e), this._toProcess++, e
						},
						stagger: function(t, e) {
							return h(t, e)
						},
						preUpdate: function() {
							if (0 !== this._toProcess) {
								for (var t, e = this._destroy, i = this._active, n = this._pending, s = 0; s < e.length; s++) {
									t = e[s];
									var r = i.indexOf(t); - 1 === r ? -1 < (r = n.indexOf(t)) && (t.state = l.REMOVED, n.splice(r, 1)) : (t.state = l.REMOVED, i.splice(r, 1))
								}
								for (e.length = 0, e = this._add, s = 0; s < e.length; s++)(t = e[s]).state === l.PENDING_ADD && (t.init() ? (t.play(), this._active.push(t)) : this._pending.push(t));
								e.length = 0, this._toProcess = 0
							}
						},
						update: function(t, e) {
							var i, n = this._active;
							e *= this.timeScale;
							for (var s = 0; s < n.length; s++)(i = n[s]).update(t, e) && (this._destroy.push(i), this._toProcess++)
						},
						remove: function(t) {
							return n(this._add, t), n(this._pending, t), n(this._active, t), n(this._destroy, t), t.state = l.REMOVED, this
						},
						makeActive: function(t) {
							if (-1 !== this._add.indexOf(t) || -1 !== this._active.indexOf(t)) return this;
							var e = this._pending.indexOf(t);
							return -1 !== e && this._pending.splice(e, 1), this._add.push(t), t.state = l.PENDING_ADD, this._toProcess++, this
						},
						each: function(t, e) {
							for (var i = [null], n = 1; n < arguments.length; n++) i.push(arguments[n]);
							for (var s in this.list) i[0] = this.list[s], t.apply(e, i)
						},
						getAllTweens: function() {
							for (var t = this._active, e = [], i = 0; i < t.length; i++) e.push(t[i]);
							return e
						},
						getGlobalTimeScale: function() {
							return this.timeScale
						},
						getTweensOf: function(t) {
							var e, i, n = this._active,
								s = [];
							if (Array.isArray(t))
								for (i = 0; i < n.length; i++) {
									e = n[i];
									for (var r = 0; r < t.length; r++) e.hasTarget(t[r]) && s.push(e)
								} else
									for (i = 0; i < n.length; i++)(e = n[i]).hasTarget(t) && s.push(e);
							return s
						},
						isTweening: function(t) {
							for (var e, i = this._active, n = 0; n < i.length; n++)
								if ((e = i[n]).hasTarget(t) && e.isPlaying()) return !0;
							return !1
						},
						killAll: function() {
							for (var t = this.getAllTweens(), e = 0; e < t.length; e++) t[e].stop();
							return this
						},
						killTweensOf: function(t) {
							for (var e = this.getTweensOf(t), i = 0; i < e.length; i++) e[i].stop();
							return this
						},
						pauseAll: function() {
							for (var t = this._active, e = 0; e < t.length; e++) t[e].pause();
							return this
						},
						resumeAll: function() {
							for (var t = this._active, e = 0; e < t.length; e++) t[e].resume();
							return this
						},
						setGlobalTimeScale: function(t) {
							return this.timeScale = t, this
						},
						shutdown: function() {
							this.killAll(), this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0;
							var t = this.systems.events;
							t.off(a.PRE_UPDATE, this.preUpdate, this), t.off(a.UPDATE, this.update, this), t.off(a.SHUTDOWN, this.shutdown, this)
						},
						destroy: function() {
							this.shutdown(), this.scene.sys.events.off(a.START, this.start, this), this.scene = null, this.systems = null
						}
					});
				o.register("TweenManager", d, "tweens"), t.exports = d
			}, function(t, e, i) {
				t.exports = {
					Array: i(183),
					Base64: i(1374),
					Objects: i(1376),
					String: i(1380)
				}
			}, function(t, e, i) {
				t.exports = {
					ArrayBufferToBase64: i(1375),
					Base64ToArrayBuffer: i(388)
				}
			}, function(t, e) {
				var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
				t.exports = function(t, e) {
					for (var n = new Uint8Array(t), s = n.length, r = e ? "data:" + e + ";base64," : "", o = 0; o < s; o += 3) r += i[n[o] >> 2], r += i[(3 & n[o]) << 4 | n[o + 1] >> 4], r += i[(15 & n[o + 1]) << 2 | n[o + 2] >> 6], r += i[63 & n[o + 2]];
					return s % 3 == 2 ? r = r.substring(0, r.length - 1) + "=" : s % 3 == 1 && (r = r.substring(0, r.length - 2) + "=="), r
				}
			}, function(t, e, i) {
				t.exports = {
					Clone: i(67),
					Extend: i(18),
					GetAdvancedValue: i(15),
					GetFastValue: i(2),
					GetMinMaxValue: i(1377),
					GetValue: i(6),
					HasAll: i(1378),
					HasAny: i(407),
					HasValue: i(108),
					IsPlainObject: i(7),
					Merge: i(126),
					MergeRight: i(1379),
					Pick: i(486),
					SetValue: i(427)
				}
			}, function(t, e, i) {
				var n = i(6),
					s = i(19);
				t.exports = function(t, e, i, r, o) {
					void 0 === o && (o = i);
					var a = n(t, e, o);
					return s(a, i, r)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					for (var i = 0; i < e.length; i++)
						if (!t.hasOwnProperty(e[i])) return !1;
					return !0
				}
			}, function(t, e, i) {
				var n = i(67);
				t.exports = function(t, e) {
					var i = n(t);
					for (var s in e) i.hasOwnProperty(s) && (i[s] = e[s]);
					return i
				}
			}, function(t, e, i) {
				t.exports = {
					Format: i(1381),
					Pad: i(163),
					Reverse: i(1382),
					UppercaseFirst: i(181),
					UUID: i(196)
				}
			}, function(t, e) {
				t.exports = function(t, e) {
					return t.replace(/%([0-9]+)/g, function(t, i) {
						return e[Number(i) - 1]
					})
				}
			}, function(t, e) {
				t.exports = function(t) {
					return t.split("").reverse().join("")
				}
			}, function(t, e, i) {
				t.exports = {
					SoundManagerCreator: i(380),
					Events: i(59),
					BaseSound: i(128),
					BaseSoundManager: i(127),
					WebAudioSound: i(389),
					WebAudioSoundManager: i(387),
					HTML5AudioSound: i(384),
					HTML5AudioSoundManager: i(381),
					NoAudioSound: i(386),
					NoAudioSoundManager: i(385)
				}
			}, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, i) {
				(function(e) {
					i(518);
					var n = i(33),
						s = i(18),
						r = {
							Actions: i(241),
							Animations: i(638),
							Cache: i(639),
							Cameras: i(642),
							Core: i(728),
							Class: i(0),
							Create: i(789),
							Curves: i(795),
							Data: i(798),
							Display: i(800),
							DOM: i(818),
							Events: i(819),
							Game: i(821),
							GameObjects: i(914),
							Geom: i(430),
							Input: i(1201),
							Loader: i(1235),
							Math: i(170),
							Physics: {
								Arcade: i(1261)
							},
							Plugins: i(1304),
							Scale: i(1306),
							Scene: i(374),
							Scenes: i(1307),
							Structs: i(1309),
							Textures: i(1310),
							Tilemaps: i(1312),
							Time: i(1353),
							Tweens: i(1355),
							Utils: i(1373)
						};
					(r = s(!1, r, n)).Sound = i(1383), t.exports = r, e.Phaser = r
				}).call(this, i(517))
			}], t.c = i, t.d = function(e, i, n) {
				t.o(e, i) || Object.defineProperty(e, i, {
					enumerable: !0,
					get: n
				})
			}, t.r = function(t) {
				"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
					value: "Module"
				}), Object.defineProperty(t, "__esModule", {
					value: !0
				})
			}, t.t = function(e, i) {
				if (1 & i && (e = t(e)), 8 & i) return e;
				if (4 & i && "object" == typeof e && e && e.__esModule) return e;
				var n = Object.create(null);
				if (t.r(n), Object.defineProperty(n, "default", {
						enumerable: !0,
						value: e
					}), 2 & i && "string" != typeof e)
					for (var s in e) t.d(n, s, function(t) {
						return e[t]
					}.bind(null, s));
				return n
			}, t.n = function(e) {
				var i = e && e.__esModule ? function() {
					return e.default
				} : function() {
					return e
				};
				return t.d(i, "a", i), i
			}, t.o = function(t, e) {
				return Object.prototype.hasOwnProperty.call(t, e)
			}, t.p = "", t(t.s = 1436);

			function t(n) {
				if (i[n]) return i[n].exports;
				var s = i[n] = {
					i: n,
					l: !1,
					exports: {}
				};
				return e[n].call(s.exports, s, s.exports, t), s.l = !0, s.exports
			}
			var e, i
		});

	}, {}],
	56: [function(require, module, exports) {
		var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};

		function defaultSetTimout() {
			throw new Error("setTimeout has not been defined")
		}

		function defaultClearTimeout() {
			throw new Error("clearTimeout has not been defined")
		}

		function runTimeout(e) {
			if (cachedSetTimeout === setTimeout) return setTimeout(e, 0);
			if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, setTimeout(e, 0);
			try {
				return cachedSetTimeout(e, 0)
			} catch (t) {
				try {
					return cachedSetTimeout.call(null, e, 0)
				} catch (t) {
					return cachedSetTimeout.call(this, e, 0)
				}
			}
		}

		function runClearTimeout(e) {
			if (cachedClearTimeout === clearTimeout) return clearTimeout(e);
			if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, clearTimeout(e);
			try {
				return cachedClearTimeout(e)
			} catch (t) {
				try {
					return cachedClearTimeout.call(null, e)
				} catch (t) {
					return cachedClearTimeout.call(this, e)
				}
			}
		}! function() {
			try {
				cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout
			} catch (e) {
				cachedSetTimeout = defaultSetTimout
			}
			try {
				cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout
			} catch (e) {
				cachedClearTimeout = defaultClearTimeout
			}
		}();
		var currentQueue, queue = [],
			draining = !1,
			queueIndex = -1;

		function cleanUpNextTick() {
			draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue())
		}

		function drainQueue() {
			if (!draining) {
				var e = runTimeout(cleanUpNextTick);
				draining = !0;
				for (var t = queue.length; t;) {
					for (currentQueue = queue, queue = []; ++queueIndex < t;) currentQueue && currentQueue[queueIndex].run();
					queueIndex = -1, t = queue.length
				}
				currentQueue = null, draining = !1, runClearTimeout(e)
			}
		}

		function Item(e, t) {
			this.fun = e, this.array = t
		}

		function noop() {}
		process.nextTick = function(e) {
			var t = new Array(arguments.length - 1);
			if (arguments.length > 1)
				for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
			queue.push(new Item(e, t)), 1 !== queue.length || draining || runTimeout(drainQueue)
		}, Item.prototype.run = function() {
			this.fun.apply(null, this.array)
		}, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, process.listeners = function(e) {
			return []
		}, process.binding = function(e) {
			throw new Error("process.binding is not supported")
		}, process.cwd = function() {
			return "/"
		}, process.chdir = function(e) {
			throw new Error("process.chdir is not supported")
		}, process.umask = function() {
			return 0
		};

	}, {}],
	57: [function(require, module, exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", {
			value: !0
		});
		var internal = require("./internal");
		Object.defineProperty(exports, "SvelteComponent", {
			enumerable: !0,
			get: function() {
				return internal.SvelteComponentDev
			}
		}), Object.defineProperty(exports, "afterUpdate", {
			enumerable: !0,
			get: function() {
				return internal.afterUpdate
			}
		}), Object.defineProperty(exports, "beforeUpdate", {
			enumerable: !0,
			get: function() {
				return internal.beforeUpdate
			}
		}), Object.defineProperty(exports, "createEventDispatcher", {
			enumerable: !0,
			get: function() {
				return internal.createEventDispatcher
			}
		}), Object.defineProperty(exports, "getContext", {
			enumerable: !0,
			get: function() {
				return internal.getContext
			}
		}), Object.defineProperty(exports, "onDestroy", {
			enumerable: !0,
			get: function() {
				return internal.onDestroy
			}
		}), Object.defineProperty(exports, "onMount", {
			enumerable: !0,
			get: function() {
				return internal.onMount
			}
		}), Object.defineProperty(exports, "setContext", {
			enumerable: !0,
			get: function() {
				return internal.setContext
			}
		}), Object.defineProperty(exports, "tick", {
			enumerable: !0,
			get: function() {
				return internal.tick
			}
		});

	}, {
		"./internal": 58
	}],
	58: [function(require, module, exports) {
		(function(global) {
			"use strict";

			function noop() {}
			Object.defineProperty(exports, "__esModule", {
				value: !0
			});
			const identity = t => t;

			function assign(t, e) {
				for (const n in e) t[n] = e[n];
				return t
			}

			function is_promise(t) {
				return t && "object" == typeof t && "function" == typeof t.then
			}

			function add_location(t, e, n, o, r) {
				t.__svelte_meta = {
					loc: {
						file: e,
						line: n,
						column: o,
						char: r
					}
				}
			}

			function run(t) {
				return t()
			}

			function blank_object() {
				return Object.create(null)
			}

			function run_all(t) {
				t.forEach(run)
			}

			function is_function(t) {
				return "function" == typeof t
			}

			function safe_not_equal(t, e) {
				return t != t ? e == e : t !== e || t && "object" == typeof t || "function" == typeof t
			}

			function not_equal(t, e) {
				return t != t ? e == e : t !== e
			}

			function is_empty(t) {
				return 0 === Object.keys(t).length
			}

			function validate_store(t, e) {
				if (null != t && "function" != typeof t.subscribe) throw new Error(`'${e}' is not a store with a 'subscribe' method`)
			}

			function subscribe(t, ...e) {
				if (null == t) return noop;
				const n = t.subscribe(...e);
				return n.unsubscribe ? () => n.unsubscribe() : n
			}

			function get_store_value(t) {
				let e;
				return subscribe(t, t => e = t)(), e
			}

			function component_subscribe(t, e, n) {
				t.$$.on_destroy.push(subscribe(e, n))
			}

			function create_slot(t, e, n, o) {
				if (t) {
					const r = get_slot_context(t, e, n, o);
					return t[0](r)
				}
			}

			function get_slot_context(t, e, n, o) {
				return t[1] && o ? assign(n.ctx.slice(), t[1](o(e))) : n.ctx
			}

			function get_slot_changes(t, e, n, o) {
				if (t[2] && o) {
					const r = t[2](o(n));
					if (void 0 === e.dirty) return r;
					if ("object" == typeof r) {
						const t = [],
							n = Math.max(e.dirty.length, r.length);
						for (let o = 0; o < n; o += 1) t[o] = e.dirty[o] | r[o];
						return t
					}
					return e.dirty | r
				}
				return e.dirty
			}

			function update_slot(t, e, n, o, r, s, c) {
				const i = get_slot_changes(e, o, r, s);
				if (i) {
					const r = get_slot_context(e, n, o, c);
					t.p(r, i)
				}
			}

			function exclude_internal_props(t) {
				const e = {};
				for (const n in t) "$" !== n[0] && (e[n] = t[n]);
				return e
			}

			function compute_rest_props(t, e) {
				const n = {};
				e = new Set(e);
				for (const o in t) e.has(o) || "$" === o[0] || (n[o] = t[o]);
				return n
			}

			function compute_slots(t) {
				const e = {};
				for (const n in t) e[n] = !0;
				return e
			}

			function once(t) {
				let e = !1;
				return function(...n) {
					e || (e = !0, t.call(this, ...n))
				}
			}

			function null_to_empty(t) {
				return null == t ? "" : t
			}

			function set_store_value(t, e, n = e) {
				return t.set(n), e
			}
			const has_prop = (t, e) => Object.prototype.hasOwnProperty.call(t, e);

			function action_destroyer(t) {
				return t && is_function(t.destroy) ? t.destroy : noop
			}
			const is_client = "undefined" != typeof window;

			function set_now(t) {
				exports.now = t
			}

			function set_raf(t) {
				exports.raf = t
			}
			exports.now = is_client ? () => window.performance.now() : () => Date.now(), exports.raf = is_client ? t => requestAnimationFrame(t) : noop;
			const tasks = new Set;

			function run_tasks(t) {
				tasks.forEach(e => {
					e.c(t) || (tasks.delete(e), e.f())
				}), 0 !== tasks.size && exports.raf(run_tasks)
			}

			function clear_loops() {
				tasks.clear()
			}

			function loop(t) {
				let e;
				return 0 === tasks.size && exports.raf(run_tasks), {
					promise: new Promise(n => {
						tasks.add(e = {
							c: t,
							f: n
						})
					}),
					abort() {
						tasks.delete(e)
					}
				}
			}

			function append(t, e) {
				t.appendChild(e)
			}

			function insert(t, e, n) {
				t.insertBefore(e, n || null)
			}

			function detach(t) {
				t.parentNode.removeChild(t)
			}

			function destroy_each(t, e) {
				for (let n = 0; n < t.length; n += 1) t[n] && t[n].d(e)
			}

			function element(t) {
				return document.createElement(t)
			}

			function element_is(t, e) {
				return document.createElement(t, {
					is: e
				})
			}

			function object_without_properties(t, e) {
				const n = {};
				for (const o in t) has_prop(t, o) && -1 === e.indexOf(o) && (n[o] = t[o]);
				return n
			}

			function svg_element(t) {
				return document.createElementNS("http://www.w3.org/2000/svg", t)
			}

			function text(t) {
				return document.createTextNode(t)
			}

			function space() {
				return text(" ")
			}

			function empty() {
				return text("")
			}

			function listen(t, e, n, o) {
				return t.addEventListener(e, n, o), () => t.removeEventListener(e, n, o)
			}

			function prevent_default(t) {
				return function(e) {
					return e.preventDefault(), t.call(this, e)
				}
			}

			function stop_propagation(t) {
				return function(e) {
					return e.stopPropagation(), t.call(this, e)
				}
			}

			function self(t) {
				return function(e) {
					e.target === this && t.call(this, e)
				}
			}

			function attr(t, e, n) {
				null == n ? t.removeAttribute(e) : t.getAttribute(e) !== n && t.setAttribute(e, n)
			}

			function set_attributes(t, e) {
				const n = Object.getOwnPropertyDescriptors(t.__proto__);
				for (const o in e) null == e[o] ? t.removeAttribute(o) : "style" === o ? t.style.cssText = e[o] : "__value" === o ? t.value = t[o] = e[o] : n[o] && n[o].set ? t[o] = e[o] : attr(t, o, e[o])
			}

			function set_svg_attributes(t, e) {
				for (const n in e) attr(t, n, e[n])
			}

			function set_custom_element_data(t, e, n) {
				e in t ? t[e] = n : attr(t, e, n)
			}

			function xlink_attr(t, e, n) {
				t.setAttributeNS("http://www.w3.org/1999/xlink", e, n)
			}

			function get_binding_group_value(t, e, n) {
				const o = new Set;
				for (let e = 0; e < t.length; e += 1) t[e].checked && o.add(t[e].__value);
				return n || o.delete(e), Array.from(o)
			}

			function to_number(t) {
				return "" === t ? null : +t
			}

			function time_ranges_to_array(t) {
				const e = [];
				for (let n = 0; n < t.length; n += 1) e.push({
					start: t.start(n),
					end: t.end(n)
				});
				return e
			}

			function children(t) {
				return Array.from(t.childNodes)
			}

			function claim_element(t, e, n, o) {
				for (let o = 0; o < t.length; o += 1) {
					const r = t[o];
					if (r.nodeName === e) {
						let e = 0;
						const s = [];
						for (; e < r.attributes.length;) {
							const t = r.attributes[e++];
							n[t.name] || s.push(t.name)
						}
						for (let t = 0; t < s.length; t++) r.removeAttribute(s[t]);
						return t.splice(o, 1)[0]
					}
				}
				return o ? svg_element(e) : element(e)
			}

			function claim_text(t, e) {
				for (let n = 0; n < t.length; n += 1) {
					const o = t[n];
					if (3 === o.nodeType) return o.data = "" + e, t.splice(n, 1)[0]
				}
				return text(e)
			}

			function claim_space(t) {
				return claim_text(t, " ")
			}

			function set_data(t, e) {
				e = "" + e, t.wholeText !== e && (t.data = e)
			}

			function set_input_value(t, e) {
				t.value = null == e ? "" : e
			}

			function set_input_type(t, e) {
				try {
					t.type = e
				} catch (t) {}
			}

			function set_style(t, e, n, o) {
				t.style.setProperty(e, n, o ? "important" : "")
			}

			function select_option(t, e) {
				for (let n = 0; n < t.options.length; n += 1) {
					const o = t.options[n];
					if (o.__value === e) return void(o.selected = !0)
				}
			}

			function select_options(t, e) {
				for (let n = 0; n < t.options.length; n += 1) {
					const o = t.options[n];
					o.selected = ~e.indexOf(o.__value)
				}
			}

			function select_value(t) {
				const e = t.querySelector(":checked") || t.options[0];
				return e && e.__value
			}

			function select_multiple_value(t) {
				return [].map.call(t.querySelectorAll(":checked"), t => t.__value)
			}
			let crossorigin;

			function is_crossorigin() {
				if (void 0 === crossorigin) {
					crossorigin = !1;
					try {
						"undefined" != typeof window && window.parent && window.parent.document
					} catch (t) {
						crossorigin = !0
					}
				}
				return crossorigin
			}

			function add_resize_listener(t, e) {
				const n = getComputedStyle(t),
					o = (parseInt(n.zIndex) || 0) - 1;
				"static" === n.position && (t.style.position = "relative");
				const r = element("iframe");
				r.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; " + `overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: ${o};`), r.setAttribute("aria-hidden", "true"), r.tabIndex = -1;
				const s = is_crossorigin();
				let c;
				return s ? (r.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>", c = listen(window, "message", t => {
					t.source === r.contentWindow && e()
				})) : (r.src = "about:blank", r.onload = (() => {
					c = listen(r.contentWindow, "resize", e)
				})), append(t, r), () => {
					s ? c() : c && r.contentWindow && c(), detach(r)
				}
			}

			function toggle_class(t, e, n) {
				t.classList[n ? "add" : "remove"](e)
			}

			function custom_event(t, e) {
				const n = document.createEvent("CustomEvent");
				return n.initCustomEvent(t, !1, !1, e), n
			}

			function query_selector_all(t, e = document.body) {
				return Array.from(e.querySelectorAll(t))
			}
			class HtmlTag {
				constructor(t = null) {
					this.a = t, this.e = this.n = null
				}
				m(t, e, n = null) {
					this.e || (this.e = element(e.nodeName), this.t = e, this.h(t)), this.i(n)
				}
				h(t) {
					this.e.innerHTML = t, this.n = Array.from(this.e.childNodes)
				}
				i(t) {
					for (let e = 0; e < this.n.length; e += 1) insert(this.t, this.n[e], t)
				}
				p(t) {
					this.d(), this.h(t), this.i(this.a)
				}
				d() {
					this.n.forEach(detach)
				}
			}
			const active_docs = new Set;
			let active = 0;

			function hash(t) {
				let e = 5381,
					n = t.length;
				for (; n--;) e = (e << 5) - e ^ t.charCodeAt(n);
				return e >>> 0
			}

			function create_rule(t, e, n, o, r, s, c, i = 0) {
				const a = 16.666 / o;
				let l = "{\n";
				for (let t = 0; t <= 1; t += a) {
					const o = e + (n - e) * s(t);
					l += 100 * t + `%{${c(o,1-o)}}\n`
				}
				const u = l + `100% {${c(n,1-n)}}\n}`,
					_ = `__svelte_${hash(u)}_${i}`,
					p = t.ownerDocument;
				active_docs.add(p);
				const d = p.__svelte_stylesheet || (p.__svelte_stylesheet = p.head.appendChild(element("style")).sheet),
					f = p.__svelte_rules || (p.__svelte_rules = {});
				f[_] || (f[_] = !0, d.insertRule(`@keyframes ${_} ${u}`, d.cssRules.length));
				const h = t.style.animation || "";
				return t.style.animation = `${h?`${h}, `:""}${_} ${o}ms linear ${r}ms 1 both`, active += 1, _
			}

			function delete_rule(t, e) {
				const n = (t.style.animation || "").split(", "),
					o = n.filter(e ? t => t.indexOf(e) < 0 : t => -1 === t.indexOf("__svelte")),
					r = n.length - o.length;
				r && (t.style.animation = o.join(", "), (active -= r) || clear_rules())
			}

			function clear_rules() {
				exports.raf(() => {
					active || (active_docs.forEach(t => {
						const e = t.__svelte_stylesheet;
						let n = e.cssRules.length;
						for (; n--;) e.deleteRule(n);
						t.__svelte_rules = {}
					}), active_docs.clear())
				})
			}

			function create_animation(t, e, n, o) {
				if (!e) return noop;
				const r = t.getBoundingClientRect();
				if (e.left === r.left && e.right === r.right && e.top === r.top && e.bottom === r.bottom) return noop;
				const {
					delay: s = 0,
					duration: c = 300,
					easing: i = identity,
					start: a = exports.now() + s,
					end: l = a + c,
					tick: u = noop,
					css: _
				} = n(t, {
					from: e,
					to: r
				}, o);
				let p, d = !0,
					f = !1;

				function h() {
					_ && delete_rule(t, p), d = !1
				}
				return loop(t => {
					if (!f && t >= a && (f = !0), f && t >= l && (u(1, 0), h()), !d) return !1;
					if (f) {
						const e = 0 + 1 * i((t - a) / c);
						u(e, 1 - e)
					}
					return !0
				}), _ && (p = create_rule(t, 0, 1, c, s, i, _)), s || (f = !0), u(0, 1), h
			}

			function fix_position(t) {
				const e = getComputedStyle(t);
				if ("absolute" !== e.position && "fixed" !== e.position) {
					const {
						width: n,
						height: o
					} = e, r = t.getBoundingClientRect();
					t.style.position = "absolute", t.style.width = n, t.style.height = o, add_transform(t, r)
				}
			}

			function add_transform(t, e) {
				const n = t.getBoundingClientRect();
				if (e.left !== n.left || e.top !== n.top) {
					const o = getComputedStyle(t),
						r = "none" === o.transform ? "" : o.transform;
					t.style.transform = `${r} translate(${e.left-n.left}px, ${e.top-n.top}px)`
				}
			}

			function set_current_component(t) {
				exports.current_component = t
			}

			function get_current_component() {
				if (!exports.current_component) throw new Error("Function called outside component initialization");
				return exports.current_component
			}

			function beforeUpdate(t) {
				get_current_component().$$.before_update.push(t)
			}

			function onMount(t) {
				get_current_component().$$.on_mount.push(t)
			}

			function afterUpdate(t) {
				get_current_component().$$.after_update.push(t)
			}

			function onDestroy(t) {
				get_current_component().$$.on_destroy.push(t)
			}

			function createEventDispatcher() {
				const t = get_current_component();
				return (e, n) => {
					const o = t.$$.callbacks[e];
					if (o) {
						const r = custom_event(e, n);
						o.slice().forEach(e => {
							e.call(t, r)
						})
					}
				}
			}

			function setContext(t, e) {
				get_current_component().$$.context.set(t, e)
			}

			function getContext(t) {
				return get_current_component().$$.context.get(t)
			}

			function bubble(t, e) {
				const n = t.$$.callbacks[e.type];
				n && n.slice().forEach(t => t(e))
			}
			const dirty_components = [],
				intros = {
					enabled: !1
				},
				binding_callbacks = [],
				render_callbacks = [],
				flush_callbacks = [],
				resolved_promise = Promise.resolve();
			let update_scheduled = !1;

			function schedule_update() {
				update_scheduled || (update_scheduled = !0, resolved_promise.then(flush))
			}

			function tick() {
				return schedule_update(), resolved_promise
			}

			function add_render_callback(t) {
				render_callbacks.push(t)
			}

			function add_flush_callback(t) {
				flush_callbacks.push(t)
			}
			let flushing = !1;
			const seen_callbacks = new Set;

			function flush() {
				if (!flushing) {
					flushing = !0;
					do {
						for (let t = 0; t < dirty_components.length; t += 1) {
							const e = dirty_components[t];
							set_current_component(e), update(e.$$)
						}
						for (set_current_component(null), dirty_components.length = 0; binding_callbacks.length;) binding_callbacks.pop()();
						for (let t = 0; t < render_callbacks.length; t += 1) {
							const e = render_callbacks[t];
							seen_callbacks.has(e) || (seen_callbacks.add(e), e())
						}
						render_callbacks.length = 0
					} while (dirty_components.length);
					for (; flush_callbacks.length;) flush_callbacks.pop()();
					update_scheduled = !1, flushing = !1, seen_callbacks.clear()
				}
			}

			function update(t) {
				if (null !== t.fragment) {
					t.update(), run_all(t.before_update);
					const e = t.dirty;
					t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(add_render_callback)
				}
			}
			let promise;

			function wait() {
				return promise || (promise = Promise.resolve()).then(() => {
					promise = null
				}), promise
			}

			function dispatch(t, e, n) {
				t.dispatchEvent(custom_event(`${e?"intro":"outro"}${n}`))
			}
			const outroing = new Set;
			let outros;

			function group_outros() {
				outros = {
					r: 0,
					c: [],
					p: outros
				}
			}

			function check_outros() {
				outros.r || run_all(outros.c), outros = outros.p
			}

			function transition_in(t, e) {
				t && t.i && (outroing.delete(t), t.i(e))
			}

			function transition_out(t, e, n, o) {
				if (t && t.o) {
					if (outroing.has(t)) return;
					outroing.add(t), outros.c.push(() => {
						outroing.delete(t), o && (n && t.d(1), o())
					}), t.o(e)
				}
			}
			const null_transition = {
				duration: 0
			};

			function create_in_transition(t, e, n) {
				let o, r, s = e(t, n),
					c = !1,
					i = 0;

				function a() {
					o && delete_rule(t, o)
				}

				function l() {
					const {
						delay: e = 0,
						duration: n = 300,
						easing: l = identity,
						tick: u = noop,
						css: _
					} = s || null_transition;
					_ && (o = create_rule(t, 0, 1, n, e, l, _, i++)), u(0, 1);
					const p = exports.now() + e,
						d = p + n;
					r && r.abort(), c = !0, add_render_callback(() => dispatch(t, !0, "start")), r = loop(e => {
						if (c) {
							if (e >= d) return u(1, 0), dispatch(t, !0, "end"), a(), c = !1;
							if (e >= p) {
								const t = l((e - p) / n);
								u(t, 1 - t)
							}
						}
						return c
					})
				}
				let u = !1;
				return {
					start() {
						u || (delete_rule(t), is_function(s) ? (s = s(), wait().then(l)) : l())
					},
					invalidate() {
						u = !1
					},
					end() {
						c && (a(), c = !1)
					}
				}
			}

			function create_out_transition(t, e, n) {
				let o, r = e(t, n),
					s = !0;
				const c = outros;

				function i() {
					const {
						delay: e = 0,
						duration: n = 300,
						easing: i = identity,
						tick: a = noop,
						css: l
					} = r || null_transition;
					l && (o = create_rule(t, 1, 0, n, e, i, l));
					const u = exports.now() + e,
						_ = u + n;
					add_render_callback(() => dispatch(t, !1, "start")), loop(e => {
						if (s) {
							if (e >= _) return a(0, 1), dispatch(t, !1, "end"), --c.r || run_all(c.c), !1;
							if (e >= u) {
								const t = i((e - u) / n);
								a(1 - t, t)
							}
						}
						return s
					})
				}
				return c.r += 1, is_function(r) ? wait().then(() => {
					r = r(), i()
				}) : i(), {
					end(e) {
						e && r.tick && r.tick(1, 0), s && (o && delete_rule(t, o), s = !1)
					}
				}
			}

			function create_bidirectional_transition(t, e, n, o) {
				let r = e(t, n),
					s = o ? 0 : 1,
					c = null,
					i = null,
					a = null;

				function l() {
					a && delete_rule(t, a)
				}

				function u(t, e) {
					const n = t.b - s;
					return e *= Math.abs(n), {
						a: s,
						b: t.b,
						d: n,
						duration: e,
						start: t.start,
						end: t.start + e,
						group: t.group
					}
				}

				function _(e) {
					const {
						delay: n = 0,
						duration: o = 300,
						easing: _ = identity,
						tick: p = noop,
						css: d
					} = r || null_transition, f = {
						start: exports.now() + n,
						b: e
					};
					e || (f.group = outros, outros.r += 1), c || i ? i = f : (d && (l(), a = create_rule(t, s, e, o, n, _, d)), e && p(0, 1), c = u(f, o), add_render_callback(() => dispatch(t, e, "start")), loop(e => {
						if (i && e > i.start && (c = u(i, o), i = null, dispatch(t, c.b, "start"), d && (l(), a = create_rule(t, s, c.b, c.duration, 0, _, r.css))), c)
							if (e >= c.end) p(s = c.b, 1 - s), dispatch(t, c.b, "end"), i || (c.b ? l() : --c.group.r || run_all(c.group.c)), c = null;
							else if (e >= c.start) {
							const t = e - c.start;
							s = c.a + c.d * _(t / c.duration), p(s, 1 - s)
						}
						return !(!c && !i)
					}))
				}
				return {
					run(t) {
						is_function(r) ? wait().then(() => {
							r = r(), _(t)
						}) : _(t)
					},
					end() {
						l(), c = i = null
					}
				}
			}

			function handle_promise(t, e) {
				const n = e.token = {};

				function o(t, o, r, s) {
					if (e.token !== n) return;
					e.resolved = s;
					let c = e.ctx;
					void 0 !== r && ((c = c.slice())[r] = s);
					const i = t && (e.current = t)(c);
					let a = !1;
					e.block && (e.blocks ? e.blocks.forEach((t, n) => {
						n !== o && t && (group_outros(), transition_out(t, 1, 1, () => {
							e.blocks[n] = null
						}), check_outros())
					}) : e.block.d(1), i.c(), transition_in(i, 1), i.m(e.mount(), e.anchor), a = !0), e.block = i, e.blocks && (e.blocks[o] = i), a && flush()
				}
				if (is_promise(t)) {
					const n = get_current_component();
					if (t.then(t => {
							set_current_component(n), o(e.then, 1, e.value, t), set_current_component(null)
						}, t => {
							if (set_current_component(n), o(e.catch, 2, e.error, t), set_current_component(null), !e.hasCatch) throw t
						}), e.current !== e.pending) return o(e.pending, 0), !0
				} else {
					if (e.current !== e.then) return o(e.then, 1, e.value, t), !0;
					e.resolved = t
				}
			}
			const globals = "undefined" != typeof window ? window : "undefined" != typeof globalThis ? globalThis : global;

			function destroy_block(t, e) {
				t.d(1), e.delete(t.key)
			}

			function outro_and_destroy_block(t, e) {
				transition_out(t, 1, 1, () => {
					e.delete(t.key)
				})
			}

			function fix_and_destroy_block(t, e) {
				t.f(), destroy_block(t, e)
			}

			function fix_and_outro_and_destroy_block(t, e) {
				t.f(), outro_and_destroy_block(t, e)
			}

			function update_keyed_each(t, e, n, o, r, s, c, i, a, l, u, _) {
				let p = t.length,
					d = s.length,
					f = p;
				const h = {};
				for (; f--;) h[t[f].key] = f;
				const m = [],
					b = new Map,
					x = new Map;
				for (f = d; f--;) {
					const t = _(r, s, f),
						i = n(t);
					let a = c.get(i);
					a ? o && a.p(t, e) : (a = l(i, t)).c(), b.set(i, m[f] = a), i in h && x.set(i, Math.abs(f - h[i]))
				}
				const g = new Set,
					v = new Set;

				function y(t) {
					transition_in(t, 1), t.m(i, u), c.set(t.key, t), u = t.first, d--
				}
				for (; p && d;) {
					const e = m[d - 1],
						n = t[p - 1],
						o = e.key,
						r = n.key;
					e === n ? (u = e.first, p--, d--) : b.has(r) ? !c.has(o) || g.has(o) ? y(e) : v.has(r) ? p-- : x.get(o) > x.get(r) ? (v.add(o), y(e)) : (g.add(r), p--) : (a(n, c), p--)
				}
				for (; p--;) {
					const e = t[p];
					b.has(e.key) || a(e, c)
				}
				for (; d;) y(m[d - 1]);
				return m
			}

			function validate_each_keys(t, e, n, o) {
				const r = new Set;
				for (let s = 0; s < e.length; s++) {
					const c = o(n(t, e, s));
					if (r.has(c)) throw new Error("Cannot have duplicate keys in a keyed each");
					r.add(c)
				}
			}

			function get_spread_update(t, e) {
				const n = {},
					o = {},
					r = {
						$$scope: 1
					};
				let s = t.length;
				for (; s--;) {
					const c = t[s],
						i = e[s];
					if (i) {
						for (const t in c) t in i || (o[t] = 1);
						for (const t in i) r[t] || (n[t] = i[t], r[t] = 1);
						t[s] = i
					} else
						for (const t in c) r[t] = 1
				}
				for (const t in o) t in n || (n[t] = void 0);
				return n
			}

			function get_spread_object(t) {
				return "object" == typeof t && null !== t ? t : {}
			}
			const boolean_attributes = new Set(["allowfullscreen", "allowpaymentrequest", "async", "autofocus", "autoplay", "checked", "controls", "default", "defer", "disabled", "formnovalidate", "hidden", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "selected"]),
				invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;

			function spread(t, e) {
				const n = Object.assign({}, ...t);
				e && (null == n.class ? n.class = e : n.class += " " + e);
				let o = "";
				return Object.keys(n).forEach(t => {
					if (invalid_attribute_name_character.test(t)) return;
					const e = n[t];
					!0 === e ? o += " " + t : boolean_attributes.has(t.toLowerCase()) ? e && (o += " " + t) : null != e && (o += ` ${t}="${String(e).replace(/"/g,"&#34;").replace(/'/g,"&#39;")}"`)
				}), o
			}
			const escaped = {
				'"': "&quot;",
				"'": "&#39;",
				"&": "&amp;",
				"<": "&lt;",
				">": "&gt;"
			};

			function escape(t) {
				return String(t).replace(/["'&<>]/g, t => escaped[t])
			}

			function each(t, e) {
				let n = "";
				for (let o = 0; o < t.length; o += 1) n += e(t[o], o);
				return n
			}
			const missing_component = {
				$$render: () => ""
			};

			function validate_component(t, e) {
				if (!t || !t.$$render) throw "svelte:component" === e && (e += " this={...}"), new Error(`<${e}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
				return t
			}

			function debug(t, e, n, o) {
				return console.log(`{@debug} ${t?t+" ":""}(${e}:${n})`), console.log(o), ""
			}
			let on_destroy;

			function create_ssr_component(t) {
				function e(e, n, o, r) {
					const s = exports.current_component;
					set_current_component({
						$$: {
							on_destroy: on_destroy,
							context: new Map(s ? s.$$.context : []),
							on_mount: [],
							before_update: [],
							after_update: [],
							callbacks: blank_object()
						}
					});
					const c = t(e, n, o, r);
					return set_current_component(s), c
				}
				return {
					render: (t = {}, n = {}) => {
						on_destroy = [];
						const o = {
								title: "",
								head: "",
								css: new Set
							},
							r = e(o, t, {}, n);
						return run_all(on_destroy), {
							html: r,
							css: {
								code: Array.from(o.css).map(t => t.code).join("\n"),
								map: null
							},
							head: o.title + o.head
						}
					},
					$$render: e
				}
			}

			function add_attribute(t, e, n) {
				return null == e || n && !e ? "" : ` ${t}${!0===e?"":`=${"string"==typeof e?JSON.stringify(escape(e)):`"${e}"`}`}`
			}

			function add_classes(t) {
				return t ? ` class="${t}"` : ""
			}

			function bind(t, e, n) {
				const o = t.$$.props[e];
				void 0 !== o && (t.$$.bound[o] = n, n(t.$$.ctx[o]))
			}

			function create_component(t) {
				t && t.c()
			}

			function claim_component(t, e) {
				t && t.l(e)
			}

			function mount_component(t, e, n) {
				const {
					fragment: o,
					on_mount: r,
					on_destroy: s,
					after_update: c
				} = t.$$;
				o && o.m(e, n), add_render_callback(() => {
					const e = r.map(run).filter(is_function);
					s ? s.push(...e) : run_all(e), t.$$.on_mount = []
				}), c.forEach(add_render_callback)
			}

			function destroy_component(t, e) {
				const n = t.$$;
				null !== n.fragment && (run_all(n.on_destroy), n.fragment && n.fragment.d(e), n.on_destroy = n.fragment = null, n.ctx = [])
			}

			function make_dirty(t, e) {
				-1 === t.$$.dirty[0] && (dirty_components.push(t), schedule_update(), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31
			}

			function init(t, e, n, o, r, s, c = [-1]) {
				const i = exports.current_component;
				set_current_component(t);
				const a = e.props || {},
					l = t.$$ = {
						fragment: null,
						ctx: null,
						props: s,
						update: noop,
						not_equal: r,
						bound: blank_object(),
						on_mount: [],
						on_destroy: [],
						before_update: [],
						after_update: [],
						context: new Map(i ? i.$$.context : []),
						callbacks: blank_object(),
						dirty: c,
						skip_bound: !1
					};
				let u = !1;
				if (l.ctx = n ? n(t, a, (e, n, ...o) => {
						const s = o.length ? o[0] : n;
						return l.ctx && r(l.ctx[e], l.ctx[e] = s) && (!l.skip_bound && l.bound[e] && l.bound[e](s), u && make_dirty(t, e)), n
					}) : [], l.update(), u = !0, run_all(l.before_update), l.fragment = !!o && o(l.ctx), e.target) {
					if (e.hydrate) {
						const t = children(e.target);
						l.fragment && l.fragment.l(t), t.forEach(detach)
					} else l.fragment && l.fragment.c();
					e.intro && transition_in(t.$$.fragment), mount_component(t, e.target, e.anchor), flush()
				}
				set_current_component(i)
			}
			"function" == typeof HTMLElement && (exports.SvelteElement = class extends HTMLElement {
				constructor() {
					super(), this.attachShadow({
						mode: "open"
					})
				}
				connectedCallback() {
					for (const t in this.$$.slotted) this.appendChild(this.$$.slotted[t])
				}
				attributeChangedCallback(t, e, n) {
					this[t] = n
				}
				$destroy() {
					destroy_component(this, 1), this.$destroy = noop
				}
				$on(t, e) {
					const n = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
					return n.push(e), () => {
						const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
					}
				}
				$set(t) {
					this.$$set && !is_empty(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1)
				}
			});
			class SvelteComponent {
				$destroy() {
					destroy_component(this, 1), this.$destroy = noop
				}
				$on(t, e) {
					const n = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
					return n.push(e), () => {
						const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
					}
				}
				$set(t) {
					this.$$set && !is_empty(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1)
				}
			}

			function dispatch_dev(t, e) {
				document.dispatchEvent(custom_event(t, Object.assign({
					version: "3.29.0"
				}, e)))
			}

			function append_dev(t, e) {
				dispatch_dev("SvelteDOMInsert", {
					target: t,
					node: e
				}), append(t, e)
			}

			function insert_dev(t, e, n) {
				dispatch_dev("SvelteDOMInsert", {
					target: t,
					node: e,
					anchor: n
				}), insert(t, e, n)
			}

			function detach_dev(t) {
				dispatch_dev("SvelteDOMRemove", {
					node: t
				}), detach(t)
			}

			function detach_between_dev(t, e) {
				for (; t.nextSibling && t.nextSibling !== e;) detach_dev(t.nextSibling)
			}

			function detach_before_dev(t) {
				for (; t.previousSibling;) detach_dev(t.previousSibling)
			}

			function detach_after_dev(t) {
				for (; t.nextSibling;) detach_dev(t.nextSibling)
			}

			function listen_dev(t, e, n, o, r, s) {
				const c = !0 === o ? ["capture"] : o ? Array.from(Object.keys(o)) : [];
				r && c.push("preventDefault"), s && c.push("stopPropagation"), dispatch_dev("SvelteDOMAddEventListener", {
					node: t,
					event: e,
					handler: n,
					modifiers: c
				});
				const i = listen(t, e, n, o);
				return () => {
					dispatch_dev("SvelteDOMRemoveEventListener", {
						node: t,
						event: e,
						handler: n,
						modifiers: c
					}), i()
				}
			}

			function attr_dev(t, e, n) {
				attr(t, e, n), null == n ? dispatch_dev("SvelteDOMRemoveAttribute", {
					node: t,
					attribute: e
				}) : dispatch_dev("SvelteDOMSetAttribute", {
					node: t,
					attribute: e,
					value: n
				})
			}

			function prop_dev(t, e, n) {
				t[e] = n, dispatch_dev("SvelteDOMSetProperty", {
					node: t,
					property: e,
					value: n
				})
			}

			function dataset_dev(t, e, n) {
				t.dataset[e] = n, dispatch_dev("SvelteDOMSetDataset", {
					node: t,
					property: e,
					value: n
				})
			}

			function set_data_dev(t, e) {
				e = "" + e, t.wholeText !== e && (dispatch_dev("SvelteDOMSetData", {
					node: t,
					data: e
				}), t.data = e)
			}

			function validate_each_argument(t) {
				if ("string" != typeof t && !(t && "object" == typeof t && "length" in t)) {
					let e = "{#each} only iterates over array-like objects.";
					throw "function" == typeof Symbol && t && Symbol.iterator in t && (e += " You can use a spread to convert this iterable into an array."), new Error(e)
				}
			}

			function validate_slots(t, e, n) {
				for (const o of Object.keys(e)) ~n.indexOf(o) || console.warn(`<${t}> received an unexpected slot "${o}".`)
			}
			class SvelteComponentDev extends SvelteComponent {
				constructor(t) {
					if (!t || !t.target && !t.$$inline) throw new Error("'target' is a required option");
					super()
				}
				$destroy() {
					super.$destroy(), this.$destroy = (() => {
						console.warn("Component was already destroyed")
					})
				}
				$capture_state() {}
				$inject_state() {}
			}

			function loop_guard(t) {
				const e = Date.now();
				return () => {
					if (Date.now() - e > t) throw new Error("Infinite loop detected")
				}
			}
			exports.HtmlTag = HtmlTag, exports.SvelteComponent = SvelteComponent, exports.SvelteComponentDev = SvelteComponentDev, exports.action_destroyer = action_destroyer, exports.add_attribute = add_attribute, exports.add_classes = add_classes, exports.add_flush_callback = add_flush_callback, exports.add_location = add_location, exports.add_render_callback = add_render_callback, exports.add_resize_listener = add_resize_listener, exports.add_transform = add_transform, exports.afterUpdate = afterUpdate, exports.append = append, exports.append_dev = append_dev, exports.assign = assign, exports.attr = attr, exports.attr_dev = attr_dev, exports.beforeUpdate = beforeUpdate, exports.bind = bind, exports.binding_callbacks = binding_callbacks, exports.blank_object = blank_object, exports.bubble = bubble, exports.check_outros = check_outros, exports.children = children, exports.claim_component = claim_component, exports.claim_element = claim_element, exports.claim_space = claim_space, exports.claim_text = claim_text, exports.clear_loops = clear_loops, exports.component_subscribe = component_subscribe, exports.compute_rest_props = compute_rest_props, exports.compute_slots = compute_slots, exports.createEventDispatcher = createEventDispatcher, exports.create_animation = create_animation, exports.create_bidirectional_transition = create_bidirectional_transition, exports.create_component = create_component, exports.create_in_transition = create_in_transition, exports.create_out_transition = create_out_transition, exports.create_slot = create_slot, exports.create_ssr_component = create_ssr_component, exports.custom_event = custom_event, exports.dataset_dev = dataset_dev, exports.debug = debug, exports.destroy_block = destroy_block, exports.destroy_component = destroy_component, exports.destroy_each = destroy_each, exports.detach = detach, exports.detach_after_dev = detach_after_dev, exports.detach_before_dev = detach_before_dev, exports.detach_between_dev = detach_between_dev, exports.detach_dev = detach_dev, exports.dirty_components = dirty_components, exports.dispatch_dev = dispatch_dev, exports.each = each, exports.element = element, exports.element_is = element_is, exports.empty = empty, exports.escape = escape, exports.escaped = escaped, exports.exclude_internal_props = exclude_internal_props, exports.fix_and_destroy_block = fix_and_destroy_block, exports.fix_and_outro_and_destroy_block = fix_and_outro_and_destroy_block, exports.fix_position = fix_position, exports.flush = flush, exports.getContext = getContext, exports.get_binding_group_value = get_binding_group_value, exports.get_current_component = get_current_component, exports.get_slot_changes = get_slot_changes, exports.get_slot_context = get_slot_context, exports.get_spread_object = get_spread_object, exports.get_spread_update = get_spread_update, exports.get_store_value = get_store_value, exports.globals = globals, exports.group_outros = group_outros, exports.handle_promise = handle_promise, exports.has_prop = has_prop, exports.identity = identity, exports.init = init, exports.insert = insert, exports.insert_dev = insert_dev, exports.intros = intros, exports.invalid_attribute_name_character = invalid_attribute_name_character, exports.is_client = is_client, exports.is_crossorigin = is_crossorigin, exports.is_empty = is_empty, exports.is_function = is_function, exports.is_promise = is_promise, exports.listen = listen, exports.listen_dev = listen_dev, exports.loop = loop, exports.loop_guard = loop_guard, exports.missing_component = missing_component, exports.mount_component = mount_component, exports.noop = noop, exports.not_equal = not_equal, exports.null_to_empty = null_to_empty, exports.object_without_properties = object_without_properties, exports.onDestroy = onDestroy, exports.onMount = onMount, exports.once = once, exports.outro_and_destroy_block = outro_and_destroy_block, exports.prevent_default = prevent_default, exports.prop_dev = prop_dev, exports.query_selector_all = query_selector_all, exports.run = run, exports.run_all = run_all, exports.safe_not_equal = safe_not_equal, exports.schedule_update = schedule_update, exports.select_multiple_value = select_multiple_value, exports.select_option = select_option, exports.select_options = select_options, exports.select_value = select_value, exports.self = self, exports.setContext = setContext, exports.set_attributes = set_attributes, exports.set_current_component = set_current_component, exports.set_custom_element_data = set_custom_element_data, exports.set_data = set_data, exports.set_data_dev = set_data_dev, exports.set_input_type = set_input_type, exports.set_input_value = set_input_value, exports.set_now = set_now, exports.set_raf = set_raf, exports.set_store_value = set_store_value, exports.set_style = set_style, exports.set_svg_attributes = set_svg_attributes, exports.space = space, exports.spread = spread, exports.stop_propagation = stop_propagation, exports.subscribe = subscribe, exports.svg_element = svg_element, exports.text = text, exports.tick = tick, exports.time_ranges_to_array = time_ranges_to_array, exports.to_number = to_number, exports.toggle_class = toggle_class, exports.transition_in = transition_in, exports.transition_out = transition_out, exports.update_keyed_each = update_keyed_each, exports.update_slot = update_slot, exports.validate_component = validate_component, exports.validate_each_argument = validate_each_argument, exports.validate_each_keys = validate_each_keys, exports.validate_slots = validate_slots, exports.validate_store = validate_store, exports.xlink_attr = xlink_attr;

		}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	}, {}],
	59: [function(require, module, exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", {
			value: !0
		});
		var internal = require("../internal");
		const subscriber_queue = [];

		function readable(e, n) {
			return {
				subscribe: writable(e, n).subscribe
			}
		}

		function writable(e, n = internal.noop) {
			let r;
			const t = [];

			function u(n) {
				if (internal.safe_not_equal(e, n) && (e = n, r)) {
					const n = !subscriber_queue.length;
					for (let n = 0; n < t.length; n += 1) {
						const r = t[n];
						r[1](), subscriber_queue.push(r, e)
					}
					if (n) {
						for (let e = 0; e < subscriber_queue.length; e += 2) subscriber_queue[e][0](subscriber_queue[e + 1]);
						subscriber_queue.length = 0
					}
				}
			}
			return {
				set: u,
				update: function(n) {
					u(n(e))
				},
				subscribe: function(i, s = internal.noop) {
					const l = [i, s];
					return t.push(l), 1 === t.length && (r = n(u) || internal.noop), i(e), () => {
						const e = t.indexOf(l); - 1 !== e && t.splice(e, 1), 0 === t.length && (r(), r = null)
					}
				}
			}
		}

		function derived(e, n, r) {
			const t = !Array.isArray(e),
				u = t ? [e] : e,
				i = n.length < 2;
			return readable(r, e => {
				let r = !1;
				const s = [];
				let l = 0,
					o = internal.noop;
				const a = () => {
						if (l) return;
						o();
						const r = n(t ? s[0] : s, e);
						i ? e(r) : o = internal.is_function(r) ? r : internal.noop
					},
					c = u.map((e, n) => internal.subscribe(e, e => {
						s[n] = e, l &= ~(1 << n), r && a()
					}, () => {
						l |= 1 << n
					}));
				return r = !0, a(),
					function() {
						internal.run_all(c), o()
					}
			})
		}
		Object.defineProperty(exports, "get", {
			enumerable: !0,
			get: function() {
				return internal.get_store_value
			}
		}), exports.derived = derived, exports.readable = readable, exports.writable = writable;

	}, {
		"../internal": 58
	}],
	60: [function(require, module, exports) {
		const Constants = {
			Effects: {
				FADEOUT: 0,
				FADEIN: 1,
				LIGHTNING: 2
			},
			Directions: {
				DOWN: 0,
				UP: 1,
				RIGHT: 2,
				LEFT: 3
			},
			Tiles: {
				SOLID: 0,
				EMPTY: 1,
				GRASS: 2,
				WATER: 3,
				SAND: 4,
				DIRT: 5,
				SNOW: 6
			},
			DisconnectEvents: [{
				key: "CLIENT_CLOSED",
				code: 1e3,
				title: "Disconnected",
				description: "",
				autoReload: !1,
				autoReconnect: !1
			}, {
				key: "GOING_AWAY",
				code: 1001,
				title: "Disconnected",
				description: "",
				autoReload: !1,
				autoReconnect: !1
			}, {
				key: "PROTOCOL_ERROR",
				code: 1002,
				title: "Protocol Error",
				description: "Please wait...",
				autoReload: !0,
				autoReconnect: !1
			}, {
				key: "CLIENT_DROPPED",
				code: 1006,
				title: "Connection Lost",
				description: "Please wait...",
				autoReload: !0,
				autoReconnect: !0
			}, {
				key: "RESTART",
				code: 1012,
				title: "Server Restarting",
				description: "Please wait...",
				autoReload: !0,
				autoReconnect: !1
			}, {
				key: "GENERIC",
				code: 4e3,
				title: "Disconnected",
				description: "",
				autoReload: !1,
				autoReconnect: !1
			}, {
				key: "VERSION_MISMATCH",
				code: 4001,
				title: "Outdated Version",
				description: "Updating. Please wait...",
				autoReload: !0,
				autoReconnect: !1
			}, {
				key: "BAD_AUTH",
				code: 4002,
				title: "Authentication Failure",
				description: "Please log in again",
				autoReload: !0,
				autoReconnect: !1
			}, {
				key: "DUP_CLIENT",
				code: 4003,
				title: "Duplicate Client",
				description: "It appears that you've connected from somewhere else",
				autoReload: !1,
				autoReconnect: !1
			}, {
				key: "KICK",
				code: 4004,
				title: "Kicked",
				description: "You have been kicked from the game",
				autoReload: !1,
				autoReconnect: !1
			}, {
				key: "BAN",
				code: 4005,
				title: "Banned",
				description: "You have been banned from the game",
				autoReload: !1,
				autoReconnect: !1
			}, {
				key: "SESSION_EXPIRED",
				code: 4006,
				title: "Session Expired",
				description: "Please log in again",
				autoReload: !0,
				autoReconnect: !1
			}, {
				key: "ZONE_TRANSITION_TIMEOUT",
				code: 4007,
				title: "Transition Timeout",
				description: "Error loading new zone",
				autoReload: !0,
				autoReconnect: !0
			}, {
				key: "OUT_OF_BOUNDS",
				code: 4008,
				title: "Out of bounds",
				description: "Somehow you left the map.",
				autoReload: !1,
				autoReconnect: !0
			}, {
				key: "LEAVING_PAGE",
				code: 4009,
				title: "Loading",
				description: "Please wait...",
				autoReload: !1,
				autoReconnect: !1
			}, {
				key: "SERVER_DIED",
				code: 4010,
				title: "Server Offline",
				description: "Please reload the page",
				autoReload: !1,
				autoReconnect: !1
			}]
		};
		Constants.DisconnectCodes = Constants.DisconnectEvents.reduce((e, t) => (e[t.key] = t.code, e), {});
		const DisconnectEventsLookup = Constants.DisconnectEvents.reduce((e, t) => (e.set(t.code, t), e), new Map);
		Constants.DisconnectLookup = (e => DisconnectEventsLookup.get(e)), module.exports = Constants;

	}, {}],
	61: [function(require, module, exports) {
		(function(Buffer) {
			const Pbf = require("pbf"),
				protos = require("./protos.js"),
				messages = [
					["trigger", protos.Trigger],
					["interact", protos.Interact],
					["session_init", protos.SessionInit],
					["ping", protos.Id],
					["pong", protos.Id],
					["form_submit", protos.FormSubmit],
					["zone_world_load", protos.ZoneWorldLoad],
					["zone_world_loaded", protos.ZoneWorldLoad],
					["zone_init", protos.ZoneInit],
					["zone_clock_sync", protos.ClockData],
					["trainer_join", protos.Trainer],
					["trainer_leave", protos.Id],
					["trainer_move", protos.TrainerMovement],
					["trainer_interact", protos.TrainerInteract],
					["trainer_entity_activate", protos.TrainerEntityActivate],
					["control_grant", protos.TrainerId],
					["control_revoke", null],
					["playerdata", protos.PlayerData],
					["resync_request", null],
					["wild_encounter", protos.Encounter],
					["wild_encounter_conf", null],
					["wild_encounter_reset", null],
					["wild_encounter_start", protos.Encounter],
					["spectate", protos.Spectate],
					["sys_message", protos.SysMessage]
				];

			function calcChecksum(e) {
				const o = e.length;
				let r = 92492822;
				for (let t = 0; t < o; t++) r += e[t] * (t + 1);
				return 4294967295 & r
			}
			const decoders = messages.reduce((e, o, r) => {
					const [t, n] = o;
					return e.set(r, e => {
						let o;
						if (n) {
							const r = new Pbf(e);
							o = n.read(r)
						}
						return {
							key: t,
							data: o
						}
					}), e
				}, new Map),
				emptyBuffer = Buffer.from([]),
				encoders = messages.reduce((e, o, r) => {
					const [t, n] = o;
					return e.set(t, e => {
						let o = emptyBuffer;
						if (n) {
							const r = new Pbf;
							n.write(e, r), o = r.finish()
						}
						return {
							idx: r,
							buffer: o
						}
					}), e
				}, new Map);

			function encode(e, o) {
				const r = encoders.get(e);
				if (!r) throw Error(`Cannot encode undefined message [${e}]`);
				const {
					idx: t,
					buffer: n
				} = r(o), s = calcChecksum(n) + t, c = new Pbf;
				return protos.Payload.write({
					idx: t,
					buffer: n,
					checksum: s
				}, c), c.finish()
			}

			function decode(e) {
				const o = new Pbf(e),
					{
						idx: r,
						buffer: t,
						checksum: n
					} = protos.Payload.read(o);
				if (n !== calcChecksum(t) + r) throw Error("Bad checksum");
				const s = decoders.get(r);
				if (!s) throw Error(`Cannot decode undefined message index [${r}]`);
				return s(t)
			}
			module.exports = {
				encode: encode,
				decode: decode
			};

		}).call(this, require("buffer").Buffer)
	}, {
		"./protos.js": 62,
		"buffer": 46,
		"pbf": 54
	}],
	62: [function(require, module, exports) {
		"use strict";
		var Payload = exports.Payload = {};
		Payload.read = function(e, r) {
			return e.readFields(Payload._readField, {
				idx: 0,
				buffer: null,
				checksum: 0
			}, r)
		}, Payload._readField = function(e, r, i) {
			1 === e ? r.idx = i.readVarint(!0) : 2 === e ? r.buffer = i.readBytes() : 3 === e && (r.checksum = i.readVarint(!0))
		}, Payload.write = function(e, r) {
			e.idx && r.writeVarintField(1, e.idx), e.buffer && r.writeBytesField(2, e.buffer), e.checksum && r.writeVarintField(3, e.checksum)
		};
		var PlayerData = exports.PlayerData = {};
		PlayerData.read = function(e, r) {
			return e.readFields(PlayerData._readField, {
				id: 0,
				username: "",
				clanId: 0,
				clanTag: "",
				clanName: "",
				betaFeatures: !1,
				isAdmin: !1,
				isPremium: !1,
				sidequestRegion: "",
				spectator: !1
			}, r)
		}, PlayerData._readField = function(e, r, i) {
			1 === e ? r.id = i.readVarint(!0) : 2 === e ? r.username = i.readString() : 3 === e ? r.clanId = i.readVarint(!0) : 4 === e ? r.clanTag = i.readString() : 5 === e ? r.clanName = i.readString() : 6 === e ? r.betaFeatures = i.readBoolean() : 7 === e ? r.isAdmin = i.readBoolean() : 8 === e ? r.isPremium = i.readBoolean() : 9 === e ? r.sidequestRegion = i.readString() : 10 === e && (r.spectator = i.readBoolean())
		}, PlayerData.write = function(e, r) {
			e.id && r.writeVarintField(1, e.id), e.username && r.writeStringField(2, e.username), e.clanId && r.writeVarintField(3, e.clanId), e.clanTag && r.writeStringField(4, e.clanTag), e.clanName && r.writeStringField(5, e.clanName), e.betaFeatures && r.writeBooleanField(6, e.betaFeatures), e.isAdmin && r.writeBooleanField(7, e.isAdmin), e.isPremium && r.writeBooleanField(8, e.isPremium), e.sidequestRegion && r.writeStringField(9, e.sidequestRegion), e.spectator && r.writeBooleanField(10, e.spectator)
		};
		var Trainer = exports.Trainer = {};
		Trainer.read = function(e, r) {
			return e.readFields(Trainer._readField, {
				id: 0,
				x: 0,
				y: 0,
				vx: 0,
				vy: 0,
				facingDirection: 0,
				spriteIdx: 0,
				playerData: null,
				maxSpeed: 0
			}, r)
		}, Trainer._readField = function(e, r, i) {
			1 === e ? r.id = i.readVarint(!0) : 2 === e ? r.x = i.readFloat() : 3 === e ? r.y = i.readFloat() : 4 === e ? r.vx = i.readFloat() : 5 === e ? r.vy = i.readFloat() : 6 === e ? r.facingDirection = i.readVarint(!0) : 7 === e ? r.spriteIdx = i.readVarint(!0) : 8 === e ? r.playerData = PlayerData.read(i, i.readVarint() + i.pos) : 9 === e && (r.maxSpeed = i.readFloat())
		}, Trainer.write = function(e, r) {
			e.id && r.writeVarintField(1, e.id), e.x && r.writeFloatField(2, e.x), e.y && r.writeFloatField(3, e.y), e.vx && r.writeFloatField(4, e.vx), e.vy && r.writeFloatField(5, e.vy), e.facingDirection && r.writeVarintField(6, e.facingDirection), e.spriteIdx && r.writeVarintField(7, e.spriteIdx), e.playerData && r.writeMessage(8, PlayerData.write, e.playerData), e.maxSpeed && r.writeFloatField(9, e.maxSpeed)
		};
		var TrainerMovement = exports.TrainerMovement = {};
		TrainerMovement.read = function(e, r) {
			return e.readFields(TrainerMovement._readField, {
				id: 0,
				x: 0,
				y: 0,
				vx: 0,
				vy: 0,
				facingDirection: 0
			}, r)
		}, TrainerMovement._readField = function(e, r, i) {
			1 === e ? r.id = i.readVarint(!0) : 2 === e ? r.x = i.readFloat() : 3 === e ? r.y = i.readFloat() : 4 === e ? r.vx = i.readFloat() : 5 === e ? r.vy = i.readFloat() : 6 === e && (r.facingDirection = i.readVarint(!0))
		}, TrainerMovement.write = function(e, r) {
			e.id && r.writeVarintField(1, e.id), e.x && r.writeFloatField(2, e.x), e.y && r.writeFloatField(3, e.y), e.vx && r.writeFloatField(4, e.vx), e.vy && r.writeFloatField(5, e.vy), e.facingDirection && r.writeVarintField(6, e.facingDirection)
		};
		var TrainerEntityActivate = exports.TrainerEntityActivate = {};
		TrainerEntityActivate.read = function(e, r) {
			return e.readFields(TrainerEntityActivate._readField, {
				id: 0,
				move: null,
				actionType: 0
			}, r)
		}, TrainerEntityActivate._readField = function(e, r, i) {
			1 === e ? r.id = i.readVarint(!0) : 2 === e ? r.move = TrainerMovement.read(i, i.readVarint() + i.pos) : 3 === e && (r.actionType = i.readVarint(!0))
		}, TrainerEntityActivate.write = function(e, r) {
			e.id && r.writeVarintField(1, e.id), e.move && r.writeMessage(2, TrainerMovement.write, e.move), e.actionType && r.writeVarintField(3, e.actionType)
		};
		var Pokemon = exports.Pokemon = {};
		Pokemon.read = function(e, r) {
			return e.readFields(Pokemon._readField, {
				name: "",
				yoffset: 0,
				class: "",
				type1: "",
				type2: "",
				rarity: "",
				generation: 0,
				sqRegion: ""
			}, r)
		}, Pokemon._readField = function(e, r, i) {
			1 === e ? r.name = i.readString() : 2 === e ? r.yoffset = i.readVarint(!0) : 3 === e ? r.class = i.readString() : 4 === e ? r.type1 = i.readString() : 5 === e ? r.type2 = i.readString() : 6 === e ? r.rarity = i.readString() : 7 === e ? r.generation = i.readVarint(!0) : 8 === e && (r.sqRegion = i.readString())
		}, Pokemon.write = function(e, r) {
			e.name && r.writeStringField(1, e.name), e.yoffset && r.writeVarintField(2, e.yoffset), e.class && r.writeStringField(3, e.class), e.type1 && r.writeStringField(4, e.type1), e.type2 && r.writeStringField(5, e.type2), e.rarity && r.writeStringField(6, e.rarity), e.generation && r.writeVarintField(7, e.generation), e.sqRegion && r.writeStringField(8, e.sqRegion)
		};
		var ClockData = exports.ClockData = {};
		ClockData.read = function(e, r) {
			return e.readFields(ClockData._readField, {
				time: 0,
				cycleDurationMs: 0
			}, r)
		}, ClockData._readField = function(e, r, i) {
			1 === e ? r.time = i.readVarint(!0) : 2 === e && (r.cycleDurationMs = i.readVarint(!0))
		}, ClockData.write = function(e, r) {
			e.time && r.writeVarintField(1, e.time), e.cycleDurationMs && r.writeVarintField(2, e.cycleDurationMs)
		};
		var FormInput = exports.FormInput = {};
		FormInput.read = function(e, r) {
			return e.readFields(FormInput._readField, {
				name: "",
				value: ""
			}, r)
		}, FormInput._readField = function(e, r, i) {
			1 === e ? r.name = i.readString() : 2 === e && (r.value = i.readString())
		}, FormInput.write = function(e, r) {
			e.name && r.writeStringField(1, e.name), e.value && r.writeStringField(2, e.value)
		};
		var FormSubmit = exports.FormSubmit = {};
		FormSubmit.read = function(e, r) {
			return e.readFields(FormSubmit._readField, {
				absolute: !1,
				action: "",
				method: "",
				inputs: [],
				sceneEnd: !1
			}, r)
		}, FormSubmit._readField = function(e, r, i) {
			1 === e ? r.absolute = i.readBoolean() : 2 === e ? r.action = i.readString() : 3 === e ? r.method = i.readString() : 4 === e ? r.inputs.push(FormInput.read(i, i.readVarint() + i.pos)) : 5 === e && (r.sceneEnd = i.readBoolean())
		}, FormSubmit.write = function(e, r) {
			if (e.absolute && r.writeBooleanField(1, e.absolute), e.action && r.writeStringField(2, e.action), e.method && r.writeStringField(3, e.method), e.inputs)
				for (var i = 0; i < e.inputs.length; i++) r.writeMessage(4, FormInput.write, e.inputs[i]);
			e.sceneEnd && r.writeBooleanField(5, e.sceneEnd)
		};
		var ZoneWorldLoad = exports.ZoneWorldLoad = {};
		ZoneWorldLoad.read = function(e, r) {
			return e.readFields(ZoneWorldLoad._readField, {
				key: ""
			}, r)
		}, ZoneWorldLoad._readField = function(e, r, i) {
			1 === e && (r.key = i.readString())
		}, ZoneWorldLoad.write = function(e, r) {
			e.key && r.writeStringField(1, e.key)
		};
		var Interact = exports.Interact = {};
		Interact.read = function(e, r) {
			return e.readFields(Interact._readField, {
				x: 0,
				y: 0,
				id: 0
			}, r)
		}, Interact._readField = function(e, r, i) {
			1 === e ? r.x = i.readFloat() : 2 === e ? r.y = i.readFloat() : 3 === e && (r.id = i.readVarint(!0))
		}, Interact.write = function(e, r) {
			e.x && r.writeFloatField(1, e.x), e.y && r.writeFloatField(2, e.y), e.id && r.writeVarintField(3, e.id)
		};
		var Id = exports.Id = {};
		Id.read = function(e, r) {
			return e.readFields(Id._readField, {
				id: 0
			}, r)
		}, Id._readField = function(e, r, i) {
			1 === e && (r.id = i.readVarint(!0))
		}, Id.write = function(e, r) {
			e.id && r.writeVarintField(1, e.id)
		};
		var Entity = exports.Entity = {};
		Entity.read = function(e, r) {
			return e.readFields(Entity._readField, {
				id: 0,
				x: 0,
				y: 0,
				type: "",
				visible: !1,
				state: 0
			}, r)
		}, Entity._readField = function(e, r, i) {
			1 === e ? r.id = i.readVarint(!0) : 2 === e ? r.x = i.readFloat() : 3 === e ? r.y = i.readFloat() : 4 === e ? r.type = i.readString() : 5 === e ? r.visible = i.readBoolean() : 6 === e && (r.state = i.readVarint(!0))
		}, Entity.write = function(e, r) {
			e.id && r.writeVarintField(1, e.id), e.x && r.writeFloatField(2, e.x), e.y && r.writeFloatField(3, e.y), e.type && r.writeStringField(4, e.type), e.visible && r.writeBooleanField(5, e.visible), e.state && r.writeVarintField(6, e.state)
		};
		var ZoneInit = exports.ZoneInit = {};
		ZoneInit.read = function(e, r) {
			return e.readFields(ZoneInit._readField, {
				key: "",
				trainers: [],
				entities: [],
				clock: null
			}, r)
		}, ZoneInit._readField = function(e, r, i) {
			1 === e ? r.key = i.readString() : 2 === e ? r.trainers.push(Trainer.read(i, i.readVarint() + i.pos)) : 3 === e ? r.entities.push(Entity.read(i, i.readVarint() + i.pos)) : 5 === e && (r.clock = ClockData.read(i, i.readVarint() + i.pos))
		}, ZoneInit.write = function(e, r) {
			if (e.key && r.writeStringField(1, e.key), e.trainers)
				for (var i = 0; i < e.trainers.length; i++) r.writeMessage(2, Trainer.write, e.trainers[i]);
			if (e.entities)
				for (i = 0; i < e.entities.length; i++) r.writeMessage(3, Entity.write, e.entities[i]);
			e.clock && r.writeMessage(5, ClockData.write, e.clock)
		};
		var TrainerJoin = exports.TrainerJoin = {};
		TrainerJoin.read = function(e, r) {
			return e.readFields(TrainerJoin._readField, {
				trainer: null,
				effect: 0
			}, r)
		}, TrainerJoin._readField = function(e, r, i) {
			1 === e ? r.trainer = Trainer.read(i, i.readVarint() + i.pos) : 2 === e && (r.effect = i.readVarint(!0))
		}, TrainerJoin.write = function(e, r) {
			e.trainer && r.writeMessage(1, Trainer.write, e.trainer), e.effect && r.writeVarintField(2, e.effect)
		};
		var TrainerId = exports.TrainerId = {};
		TrainerId.read = function(e, r) {
			return e.readFields(TrainerId._readField, {
				id: 0
			}, r)
		}, TrainerId._readField = function(e, r, i) {
			1 === e && (r.id = i.readVarint(!0))
		}, TrainerId.write = function(e, r) {
			e.id && r.writeVarintField(1, e.id)
		};
		var Encounter = exports.Encounter = {};
		Encounter.read = function(e, r) {
			return e.readFields(Encounter._readField, {
				id: "",
				pokemon: null,
				level: 0,
				prefix: "",
				gender: "",
				fullname: "",
				platform: 0,
				caught: 0,
				tilePos: null
			}, r)
		}, Encounter._readField = function(e, r, i) {
			1 === e ? r.id = i.readString() : 2 === e ? r.pokemon = Pokemon.read(i, i.readVarint() + i.pos) : 3 === e ? r.level = i.readVarint(!0) : 5 === e ? r.prefix = i.readString() : 6 === e ? r.gender = i.readString() : 7 === e ? r.fullname = i.readString() : 8 === e ? r.platform = i.readVarint(!0) : 9 === e ? r.caught = i.readVarint(!0) : 10 === e && (r.tilePos = Encounter.TilePos.read(i, i.readVarint() + i.pos))
		}, Encounter.write = function(e, r) {
			e.id && r.writeStringField(1, e.id), e.pokemon && r.writeMessage(2, Pokemon.write, e.pokemon), e.level && r.writeVarintField(3, e.level), e.prefix && r.writeStringField(5, e.prefix), e.gender && r.writeStringField(6, e.gender), e.fullname && r.writeStringField(7, e.fullname), e.platform && r.writeVarintField(8, e.platform), e.caught && r.writeVarintField(9, e.caught), e.tilePos && r.writeMessage(10, Encounter.TilePos.write, e.tilePos)
		}, Encounter.TilePos = {}, Encounter.TilePos.read = function(e, r) {
			return e.readFields(Encounter.TilePos._readField, {
				x: 0,
				y: 0
			}, r)
		}, Encounter.TilePos._readField = function(e, r, i) {
			1 === e ? r.x = i.readVarint(!0) : 2 === e && (r.y = i.readVarint(!0))
		}, Encounter.TilePos.write = function(e, r) {
			e.x && r.writeVarintField(1, e.x), e.y && r.writeVarintField(2, e.y)
		};
		var Spectate = exports.Spectate = {};
		Spectate.read = function(e, r) {
			return e.readFields(Spectate._readField, {
				x1: 0,
				y1: 0,
				x2: 0,
				y2: 0,
				secs: 0
			}, r)
		}, Spectate._readField = function(e, r, i) {
			1 === e ? r.x1 = i.readVarint(!0) : 2 === e ? r.y1 = i.readVarint(!0) : 3 === e ? r.x2 = i.readVarint(!0) : 4 === e ? r.y2 = i.readVarint(!0) : 5 === e && (r.secs = i.readVarint(!0))
		}, Spectate.write = function(e, r) {
			e.x1 && r.writeVarintField(1, e.x1), e.y1 && r.writeVarintField(2, e.y1), e.x2 && r.writeVarintField(3, e.x2), e.y2 && r.writeVarintField(4, e.y2), e.secs && r.writeVarintField(5, e.secs)
		};
		var TrainerInteract = exports.TrainerInteract = {};
		TrainerInteract.read = function(e, r) {
			return e.readFields(TrainerInteract._readField, {
				idTrainer: 0,
				idEntity: 0,
				action: 0
			}, r)
		}, TrainerInteract._readField = function(e, r, i) {
			1 === e ? r.idTrainer = i.readVarint(!0) : 2 === e ? r.idEntity = i.readVarint(!0) : 3 === e && (r.action = i.readVarint(!0))
		}, TrainerInteract.write = function(e, r) {
			e.idTrainer && r.writeVarintField(1, e.idTrainer), e.idEntity && r.writeVarintField(2, e.idEntity), e.action && r.writeVarintField(3, e.action)
		};
		var SysMessage = exports.SysMessage = {};
		SysMessage.read = function(e, r) {
			return e.readFields(SysMessage._readField, {
				message: ""
			}, r)
		}, SysMessage._readField = function(e, r, i) {
			1 === e && (r.message = i.readString())
		}, SysMessage.write = function(e, r) {
			e.message && r.writeStringField(1, e.message)
		};
		var Manifest = exports.Manifest = {};
		Manifest.read = function(e, r) {
			return e.readFields(Manifest._readField, {
				version: "",
				siteUrl: ""
			}, r)
		}, Manifest._readField = function(e, r, i) {
			1 === e ? r.version = i.readString() : 2 === e && (r.siteUrl = i.readString())
		}, Manifest.write = function(e, r) {
			e.version && r.writeStringField(1, e.version), e.siteUrl && r.writeStringField(2, e.siteUrl)
		};
		var SessionInit = exports.SessionInit = {};
		SessionInit.read = function(e, r) {
			return e.readFields(SessionInit._readField, {
				manifest: null,
				playerData: null
			}, r)
		}, SessionInit._readField = function(e, r, i) {
			1 === e ? r.manifest = Manifest.read(i, i.readVarint() + i.pos) : 2 === e && (r.playerData = PlayerData.read(i, i.readVarint() + i.pos))
		}, SessionInit.write = function(e, r) {
			e.manifest && r.writeMessage(1, Manifest.write, e.manifest), e.playerData && r.writeMessage(2, PlayerData.write, e.playerData)
		};

	}, {}]
}, {}, [27]);